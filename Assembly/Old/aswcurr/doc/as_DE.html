<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META NAME="Author" CONTENT="automatically generated by tex2html from doc_DE/as.tex">
<META NAME="Last-modified" CONTENT="Mon Sep 22 11:32:37 2025">
</HEAD>
<BODY>
<P>
<P>





















<P>
<P>
<DIV ALIGN=LEFT>
<BIG> Alfred Arnold</BIG><BR>



<P>
<BIG><BIG> Makroassembler AS</BIG></BIG> V1.42</BIG></BIG><BR>
<HR WIDTH="92%" ALIGN=LEFT><BR>
<P>
<BIG><BIG> Benutzeranleitung</BIG></BIG>



<P>
<BIG> Stand September 2025</BIG>
</DIV>
<P>
<P>












<P>
<EM> IBM, PPC403Gx, OS/2</EM> und<EM> PowerPC</EM> sind eingetragene
Warenzeichen der IBM Corporation.
<P>
<EM> Intel, MCS-48, MCS-51, MCS-251, MCS-96, MCS-196</EM> und<EM>
MCS-296</EM> sind eingetragene Warenzeichen der Intel Corp. .
<P>
<EM> Motorola</EM> und<EM> ColdFire</EM> sind eingetragene
Warenzeichen von Motorola Inc. .
<P>
<EM> MagniV</EM> ist ein eingetragenes Warenzeichen von Freescale
Semiconductor.
<P>
<EM> PicoBlaze</EM> ist ein eingetragenes Warenzeichen der Xilinx
Inc.
<P>
<EM> eZ80</EM> und<EM> Z80</EM> sind eingetragene Warenzeichen von
Zilog Inc.
<P>
<EM> UNIX</EM> ist ein eingetragenes Warenzeichen der Open Group.
<P>
<EM> Linux</EM> ist ein eingetragenes Warenzeichen von Linus
Thorvalds.
<P>
<EM> Microsoft, Windows</EM> und<EM> MS-DOS</EM> sind eingetragene
Warenzeichen der Microsoft Corporation.
<P>
Alle anderen Warenzeichen, die nicht ausdr&uuml;cklich in diesem
Abschnitt genannt wurden und in diesem Handbuch verwendet werden,
sind Eigentum der entsprechenden Eigent&uuml;mer.
<P>


















<P>
Dieses Dokument wurde mit dem LaTeX-Satzsystem unter dem
Betriebssystem Linux angefertigt und formatiert.
<P>
<P>
<P>
<P>
<H1>Inhalt</H1><P>
<P><H2><A HREF="#sect_1_">1. Allgemeines</A></H2>
<P><H3><A HREF="#sect_1_1_">1.1. Lizenzbedingungen</A></H3>
<P><H3><A HREF="#sect_1_2_">1.2. allgemeine F&auml;higkeiten des Assemblers</A></H3>
<P><H3><A HREF="#sect_1_3_">1.3. Unterst&uuml;tzte Plattformen</A></H3>
<P><H2><A HREF="#sect_2_">2. Benutzung des Assemblers</A></H2>
<P><H3><A HREF="#sect_2_1_">2.1. Hardware-Anforderungen</A></H3>
<P><H3><A HREF="#sect_2_2_">2.2. Lieferumfang</A></H3>
<P><H3><A HREF="#sect_2_3_">2.3. Installation</A></H3>
<P><H3><A HREF="#sect_2_4_">2.4. Aufruf, Parameter</A></H3>
<P><H3><A HREF="#sect_2_5_">2.5. Format der Eingabedateien</A></H3>
<P><H3><A HREF="#sect_2_6_">2.6. Format des Listings</A></H3>
<P><H3><A HREF="#sect_2_7_">2.7. Symbolkonventionen</A></H3>
<P><H3><A HREF="#sect_2_8_">2.8. Tempor&auml;re Symbole</A></H3>
<P><H4><A HREF="#sect_2_8_1_">2.8.1. Tempor&auml;re Symbole mit Namen</A></H4>
<P><H4><A HREF="#sect_2_8_2_">2.8.2. Zusammengesetzte tempor&auml;re Symbole</A></H4>
<P><H3><A HREF="#sect_2_9_">2.9. Formelausdr&uuml;cke</A></H3>
<P><H4><A HREF="#sect_2_9_1_">2.9.1. Integerkonstanten</A></H4>
<P><H4><A HREF="#sect_2_9_2_">2.9.2. Gleitkommakonstanten</A></H4>
<P><H4><A HREF="#sect_2_9_3_">2.9.3. Stringkonstanten</A></H4>
<P><H4><A HREF="#sect_2_9_4_">2.9.4. String- zu Integerwandlung und Zeichenkonstanten</A></H4>
<P><H4><A HREF="#sect_2_9_5_">2.9.5. Evaluierung</A></H4>
<P><H4><A HREF="#sect_2_9_6_">2.9.6. Operatoren</A></H4>
<P><H4><A HREF="#sect_2_9_7_">2.9.7. Funktionen</A></H4>
<P><H3><A HREF="#sect_2_10_">2.10. Vorw&auml;rtsreferenzen und andere Desaster</A></H3>
<P><H3><A HREF="#sect_2_11_">2.11. Registersymbole</A></H3>
<P><H3><A HREF="#sect_2_12_">2.12. Sharefile</A></H3>
<P><H3><A HREF="#sect_2_13_">2.13. Prozessor-Aliase</A></H3>
<P><H2><A HREF="#sect_3_">3. Pseudobefehle</A></H2>
<P><H3><A HREF="#sect_3_1_">3.1. Definitionen</A></H3>
<P><H4><A HREF="#sect_3_1_1_">3.1.1. SET, EQU und CONSTANT</A></H4>
<P><H4><A HREF="#sect_3_1_2_">3.1.2. SFR und SFRB</A></H4>
<P><H4><A HREF="#sect_3_1_3_">3.1.3. XSFR und YSFR</A></H4>
<P><H4><A HREF="#sect_3_1_4_">3.1.4. LABEL</A></H4>
<P><H4><A HREF="#sect_3_1_5_">3.1.5. BIT</A></H4>
<P><H4><A HREF="#sect_3_1_6_">3.1.6. DBIT</A></H4>
<P><H4><A HREF="#sect_3_1_7_">3.1.7. DEFBIT und DEFBITB</A></H4>
<P><H4><A HREF="#sect_3_1_8_">3.1.8. DEFBITFIELD</A></H4>
<P><H4><A HREF="#sect_3_1_9_">3.1.9. PORT</A></H4>
<P><H4><A HREF="#sect_3_1_10_">3.1.10. REG und NAMEREG</A></H4>
<P><H4><A HREF="#sect_3_1_11_">3.1.11. LIV und RIV</A></H4>
<P><H4><A HREF="#sect_3_1_12_">3.1.12. CHARSET</A></H4>
<P><H4><A HREF="#sect_3_1_13_">3.1.13. CODEPAGE</A></H4>
<P><H4><A HREF="#sect_3_1_14_">3.1.14. ENUM, NEXTENUM und ENUMCONF</A></H4>
<P><H4><A HREF="#sect_3_1_15_">3.1.15. PUSHV und POPV</A></H4>
<P><H3><A HREF="#sect_3_2_">3.2. Codebeeinflussung</A></H3>
<P><H4><A HREF="#sect_3_2_1_">3.2.1. ORG</A></H4>
<P><H4><A HREF="#sect_3_2_2_">3.2.2. RORG</A></H4>
<P><H4><A HREF="#sect_3_2_3_">3.2.3. CPU</A></H4>
<P><H4><A HREF="#sect_3_2_4_">3.2.4. SUPMODE, FPU, PMMU, CUSTOM</A></H4>
<P><H4><A HREF="#sect_3_2_5_">3.2.5. ACCMODE</A></H4>
<P><H4><A HREF="#sect_3_2_6_">3.2.6. CIS, EIS, FIS und FP11</A></H4>
<P><H4><A HREF="#sect_3_2_7_">3.2.7. FULLPMMU</A></H4>
<P><H4><A HREF="#sect_3_2_8_">3.2.8. PADDING</A></H4>
<P><H4><A HREF="#sect_3_2_9_">3.2.9. PACKING</A></H4>
<P><H4><A HREF="#sect_3_2_10_">3.2.10. MAXMODE</A></H4>
<P><H4><A HREF="#sect_3_2_11_">3.2.11. EXTMODE und LWORDMODE</A></H4>
<P><H4><A HREF="#sect_3_2_12_">3.2.12. SRCMODE</A></H4>
<P><H4><A HREF="#sect_3_2_13_">3.2.13. PLAINBASE</A></H4>
<P><H4><A HREF="#sect_3_2_14_">3.2.14. BIGENDIAN</A></H4>
<P><H4><A HREF="#sect_3_2_15_">3.2.15. WRAPMODE</A></H4>
<P><H4><A HREF="#sect_3_2_16_">3.2.16. PANEL</A></H4>
<P><H4><A HREF="#sect_3_2_17_">3.2.17. WARNRELATIVE</A></H4>
<P><H4><A HREF="#sect_3_2_18_">3.2.18. SEGMENT</A></H4>
<P><H4><A HREF="#sect_3_2_19_">3.2.19. PHASE und DEPHASE</A></H4>
<P><H4><A HREF="#sect_3_2_20_">3.2.20. SAVE und RESTORE</A></H4>
<P><H4><A HREF="#sect_3_2_21_">3.2.21. ASSUME</A></H4>
<P><H4><A HREF="#sect_3_2_22_">3.2.22. CKPT</A></H4>
<P><H4><A HREF="#sect_3_2_23_">3.2.23. EMULATED</A></H4>
<P><H4><A HREF="#sect_3_2_24_">3.2.24. Z80SYNTAX</A></H4>
<P><H4><A HREF="#sect_3_2_25_">3.2.25. EXPECT und ENDEXPECT</A></H4>
<P><H3><A HREF="#sect_3_3_">3.3. Datendefinitionen</A></H3>
<P><H4><A HREF="#sect_3_3_1_">3.3.1. DC[.size]</A></H4>
<P><H4><A HREF="#sect_3_3_2_">3.3.2. DS[.size]</A></H4>
<P><H4><A HREF="#sect_3_3_3_">3.3.3. BLKB, BLKW, BLKL, BLKD</A></H4>
<P><H4><A HREF="#sect_3_3_4_">3.3.4. DN,DB,DW,DD,DQ,DT &amp; DO</A></H4>
<P><H4><A HREF="#sect_3_3_5_">3.3.5. FLT2, FLT3, FLT4</A></H4>
<P><H4><A HREF="#sect_3_3_6_">3.3.6. x_FLOATING</A></H4>
<P><H4><A HREF="#sect_3_3_7_">3.3.7. DS, DS8</A></H4>
<P><H4><A HREF="#sect_3_3_8_">3.3.8. BLKx</A></H4>
<P><H4><A HREF="#sect_3_3_9_">3.3.9. BYT oder FCB</A></H4>
<P><H4><A HREF="#sect_3_3_10_">3.3.10. BYTE</A></H4>
<P><H4><A HREF="#sect_3_3_11_">3.3.11. DC8</A></H4>
<P><H4><A HREF="#sect_3_3_12_">3.3.12. ADR oder FDB</A></H4>
<P><H4><A HREF="#sect_3_3_13_">3.3.13. DDB</A></H4>
<P><H4><A HREF="#sect_3_3_14_">3.3.14. DCM</A></H4>
<P><H4><A HREF="#sect_3_3_15_">3.3.15. WORD</A></H4>
<P><H4><A HREF="#sect_3_3_16_">3.3.16. DW16</A></H4>
<P><H4><A HREF="#sect_3_3_17_">3.3.17. ACON</A></H4>
<P><H4><A HREF="#sect_3_3_18_">3.3.18. LONG</A></H4>
<P><H4><A HREF="#sect_3_3_19_">3.3.19. SINGLE, DOUBLE und EXTENDED</A></H4>
<P><H4><A HREF="#sect_3_3_20_">3.3.20. FLOAT und DOUBLE</A></H4>
<P><H4><A HREF="#sect_3_3_21_">3.3.21. SINGLE und DOUBLE</A></H4>
<P><H4><A HREF="#sect_3_3_22_">3.3.22. EFLOAT, BFLOAT, TFLOAT</A></H4>
<P><H4><A HREF="#sect_3_3_23_">3.3.23. Qxx und LQxx</A></H4>
<P><H4><A HREF="#sect_3_3_24_">3.3.24. DATA</A></H4>
<P><H4><A HREF="#sect_3_3_25_">3.3.25. ZERO</A></H4>
<P><H4><A HREF="#sect_3_3_26_">3.3.26. FB und FW</A></H4>
<P><H4><A HREF="#sect_3_3_27_">3.3.27. ASCII, ASCIC und ASCIZ</A></H4>
<P><H4><A HREF="#sect_3_3_28_">3.3.28. STRING und RSTRING</A></H4>
<P><H4><A HREF="#sect_3_3_29_">3.3.29. PACKED</A></H4>
<P><H4><A HREF="#sect_3_3_30_">3.3.30. RADIX50</A></H4>
<P><H4><A HREF="#sect_3_3_31_">3.3.31. FCC</A></H4>
<P><H4><A HREF="#sect_3_3_32_">3.3.32. TEXT</A></H4>
<P><H4><A HREF="#sect_3_3_33_">3.3.33. DFS oder RMB</A></H4>
<P><H4><A HREF="#sect_3_3_34_">3.3.34. BLOCK</A></H4>
<P><H4><A HREF="#sect_3_3_35_">3.3.35. SPACE</A></H4>
<P><H4><A HREF="#sect_3_3_36_">3.3.36. RES</A></H4>
<P><H4><A HREF="#sect_3_3_37_">3.3.37. BSS</A></H4>
<P><H4><A HREF="#sect_3_3_38_">3.3.38. DSB und DSW</A></H4>
<P><H4><A HREF="#sect_3_3_39_">3.3.39. DS16</A></H4>
<P><H4><A HREF="#sect_3_3_40_">3.3.40. ALIGN</A></H4>
<P><H4><A HREF="#sect_3_3_41_">3.3.41. LTORG</A></H4>
<P><H3><A HREF="#sect_3_4_">3.4. Makrobefehle</A></H3>
<P><H4><A HREF="#sect_3_4_1_">3.4.1. MACRO</A></H4>
<P><H4><A HREF="#sect_3_4_2_">3.4.2. IRP</A></H4>
<P><H4><A HREF="#sect_3_4_3_">3.4.3. IRPC</A></H4>
<P><H4><A HREF="#sect_3_4_4_">3.4.4. REPT</A></H4>
<P><H4><A HREF="#sect_3_4_5_">3.4.5. WHILE</A></H4>
<P><H4><A HREF="#sect_3_4_6_">3.4.6. EXITM</A></H4>
<P><H4><A HREF="#sect_3_4_7_">3.4.7. SHIFT</A></H4>
<P><H4><A HREF="#sect_3_4_8_">3.4.8. MAXNEST</A></H4>
<P><H4><A HREF="#sect_3_4_9_">3.4.9. FUNCTION</A></H4>
<P><H3><A HREF="#sect_3_5_">3.5. Strukturen</A></H3>
<P><H4><A HREF="#sect_3_5_1_">3.5.1. Definition</A></H4>
<P><H4><A HREF="#sect_3_5_2_">3.5.2. Nutzung</A></H4>
<P><H4><A HREF="#sect_3_5_3_">3.5.3. geschachtelte Strukturen</A></H4>
<P><H4><A HREF="#sect_3_5_4_">3.5.4. Unions</A></H4>
<P><H4><A HREF="#sect_3_5_5_">3.5.5. Namenlose Strukturen</A></H4>
<P><H4><A HREF="#sect_3_5_6_">3.5.6. Strukturen und Sektionen</A></H4>
<P><H4><A HREF="#sect_3_5_7_">3.5.7. Strukturen und Makros</A></H4>
<P><H3><A HREF="#sect_3_6_">3.6. bedingte Assemblierung</A></H3>
<P><H4><A HREF="#sect_3_6_1_">3.6.1. IF / ELSEIF / ENDIF</A></H4>
<P><H4><A HREF="#sect_3_6_2_">3.6.2. SWITCH / CASE / ELSECASE / ENDCASE</A></H4>
<P><H3><A HREF="#sect_3_7_">3.7. Listing-Steuerung</A></H3>
<P><H4><A HREF="#sect_3_7_1_">3.7.1. PAGE, PAGESIZE</A></H4>
<P><H4><A HREF="#sect_3_7_2_">3.7.2. NEWPAGE</A></H4>
<P><H4><A HREF="#sect_3_7_3_">3.7.3. MACEXP_DFT und MACEXP_OVR</A></H4>
<P><H4><A HREF="#sect_3_7_4_">3.7.4. LISTING</A></H4>
<P><H4><A HREF="#sect_3_7_5_">3.7.5. PRTINIT und PRTEXIT</A></H4>
<P><H4><A HREF="#sect_3_7_6_">3.7.6. TITLE</A></H4>
<P><H4><A HREF="#sect_3_7_7_">3.7.7. RADIX</A></H4>
<P><H4><A HREF="#sect_3_7_8_">3.7.8. OUTRADIX</A></H4>
<P><H3><A HREF="#sect_3_8_">3.8. lokale Symbole</A></H3>
<P><H4><A HREF="#sect_3_8_1_">3.8.1. Grunddefinition (SECTION/ENDSECTION)</A></H4>
<P><H4><A HREF="#sect_3_8_2_">3.8.2. Verschachtelung und Sichtbarkeitsregeln</A></H4>
<P><H4><A HREF="#sect_3_8_3_">3.8.3. PUBLIC und GLOBAL</A></H4>
<P><H4><A HREF="#sect_3_8_4_">3.8.4. FORWARD</A></H4>
<P><H4><A HREF="#sect_3_8_5_">3.8.5. Geschwindigkeitsaspekte</A></H4>
<P><H3><A HREF="#sect_3_9_">3.9. Diverses</A></H3>
<P><H4><A HREF="#sect_3_9_1_">3.9.1. SHARED</A></H4>
<P><H4><A HREF="#sect_3_9_2_">3.9.2. INCLUDE</A></H4>
<P><H4><A HREF="#sect_3_9_3_">3.9.3. BINCLUDE</A></H4>
<P><H4><A HREF="#sect_3_9_4_">3.9.4. MESSAGE, WARNING, ERROR und FATAL</A></H4>
<P><H4><A HREF="#sect_3_9_5_">3.9.5. READ</A></H4>
<P><H4><A HREF="#sect_3_9_6_">3.9.6. INTSYNTAX</A></H4>
<P><H4><A HREF="#sect_3_9_7_">3.9.7. RELAXED</A></H4>
<P><H4><A HREF="#sect_3_9_8_">3.9.8. COMPMODE</A></H4>
<P><H4><A HREF="#sect_3_9_9_">3.9.9. END</A></H4>
<P><H2><A HREF="#sect_4_">4. Prozessorspezifische Hinweise</A></H2>
<P><H3><A HREF="#sect_4_1_">4.1. 6811</A></H3>
<P><H3><A HREF="#sect_4_2_">4.2. PowerPC</A></H3>
<P><H3><A HREF="#sect_4_3_">4.3. PALM</A></H3>
<P><H3><A HREF="#sect_4_4_">4.4. DSP56xxx</A></H3>
<P><H3><A HREF="#sect_4_5_">4.5. H8/300</A></H3>
<P><H3><A HREF="#sect_4_6_">4.6. H8/500</A></H3>
<P><H3><A HREF="#sect_4_7_">4.7. SH7000/7600/7700</A></H3>
<P><H3><A HREF="#sect_4_8_">4.8. HMCS400</A></H3>
<P><H3><A HREF="#sect_4_9_">4.9. H16</A></H3>
<P><H3><A HREF="#sect_4_10_">4.10. OLMS-40</A></H3>
<P><H3><A HREF="#sect_4_11_">4.11. OLMS-50</A></H3>
<P><H3><A HREF="#sect_4_12_">4.12. MELPS-4500</A></H3>
<P><H3><A HREF="#sect_4_13_">4.13. 6502UNDOC</A></H3>
<P><H3><A HREF="#sect_4_14_">4.14. MELPS-740</A></H3>
<P><H3><A HREF="#sect_4_15_">4.15. MELPS-7700/65816</A></H3>
<P><H3><A HREF="#sect_4_16_">4.16. M16</A></H3>
<P><H3><A HREF="#sect_4_17_">4.17. CP-3F</A></H3>
<P><H3><A HREF="#sect_4_18_">4.18. 4004/4040</A></H3>
<P><H3><A HREF="#sect_4_19_">4.19. MCS-48</A></H3>
<P><H3><A HREF="#sect_4_20_">4.20. MCS-51</A></H3>
<P><H3><A HREF="#sect_4_21_">4.21. MCS-251</A></H3>
<P><H3><A HREF="#sect_4_22_">4.22. 8080/8085</A></H3>
<P><H3><A HREF="#sect_4_23_">4.23. 8085UNDOC</A></H3>
<P><H3><A HREF="#sect_4_24_">4.24. 8086..V35</A></H3>
<P><H3><A HREF="#sect_4_25_">4.25. 8X30x</A></H3>
<P><H3><A HREF="#sect_4_26_">4.26. XA</A></H3>
<P><H3><A HREF="#sect_4_27_">4.27. AVR</A></H3>
<P><H3><A HREF="#sect_4_28_">4.28. Z80, Z18, Z280, Z380</A></H3>
<P><H3><A HREF="#sect_4_29_">4.29. Z80UNDOC</A></H3>
<P><H3><A HREF="#sect_4_30_">4.30. GB_Z80 bzw. LR35902</A></H3>
<P><H3><A HREF="#sect_4_31_">4.31. Z380</A></H3>
<P><H3><A HREF="#sect_4_32_">4.32. Z8, Super8 und eZ8</A></H3>
<P><H3><A HREF="#sect_4_33_">4.33. Z8000</A></H3>
<P><H4><A HREF="#sect_4_33_1_">4.33.1. Bedingungen</A></H4>
<P><H4><A HREF="#sect_4_33_2_">4.33.2. Flags</A></H4>
<P><H4><A HREF="#sect_4_33_3_">4.33.3. Indirekte Adressierung</A></H4>
<P><H4><A HREF="#sect_4_33_4_">4.33.4. Direkte versus unmittelbare Adressierung</A></H4>
<P><H3><A HREF="#sect_4_34_">4.34. TLCS-900(L)</A></H3>
<P><H3><A HREF="#sect_4_35_">4.35. TLCS-90</A></H3>
<P><H3><A HREF="#sect_4_36_">4.36. TLCS-870</A></H3>
<P><H3><A HREF="#sect_4_37_">4.37. TLCS-47</A></H3>
<P><H3><A HREF="#sect_4_38_">4.38. TLCS-9000</A></H3>
<P><H3><A HREF="#sect_4_39_">4.39. TC9331</A></H3>
<P><H3><A HREF="#sect_4_40_">4.40. 29xxx</A></H3>
<P><H3><A HREF="#sect_4_41_">4.41. 80C16x</A></H3>
<P><H3><A HREF="#sect_4_42_">4.42. PIC16C5x/16C8x</A></H3>
<P><H3><A HREF="#sect_4_43_">4.43. PIC17C4x</A></H3>
<P><H3><A HREF="#sect_4_44_">4.44. SX20/28</A></H3>
<P><H3><A HREF="#sect_4_45_">4.45. ST6</A></H3>
<P><H3><A HREF="#sect_4_46_">4.46. ST7</A></H3>
<P><H3><A HREF="#sect_4_47_">4.47. ST9</A></H3>
<P><H3><A HREF="#sect_4_48_">4.48. 6804</A></H3>
<P><H3><A HREF="#sect_4_49_">4.49. TMS3201x</A></H3>
<P><H3><A HREF="#sect_4_50_">4.50. TMS320C2x</A></H3>
<P><H3><A HREF="#sect_4_51_">4.51. TMS320C3x/C4x</A></H3>
<P><H3><A HREF="#sect_4_52_">4.52. TMS9900</A></H3>
<P><H3><A HREF="#sect_4_53_">4.53. TMS70Cxx</A></H3>
<P><H3><A HREF="#sect_4_54_">4.54. TMS370xxx</A></H3>
<P><H3><A HREF="#sect_4_55_">4.55. MSP430(X)</A></H3>
<P><H3><A HREF="#sect_4_56_">4.56. TMS1000</A></H3>
<P><H3><A HREF="#sect_4_57_">4.57. COP8</A></H3>
<P><H3><A HREF="#sect_4_58_">4.58. SC/MP</A></H3>
<P><H3><A HREF="#sect_4_59_">4.59. SC144xxx</A></H3>
<P><H3><A HREF="#sect_4_60_">4.60. NS32xxx</A></H3>
<P><H3><A HREF="#sect_4_61_">4.61. uPD78(C)1x</A></H3>
<P><H3><A HREF="#sect_4_62_">4.62. 75K0</A></H3>
<P><H3><A HREF="#sect_4_63_">4.63. 78K0</A></H3>
<P><H3><A HREF="#sect_4_64_">4.64. 78K2/78K3/78K4</A></H3>
<P><H3><A HREF="#sect_4_65_">4.65. uPD772x</A></H3>
<P><H3><A HREF="#sect_4_66_">4.66. uCOM-43</A></H3>
<P><H3><A HREF="#sect_4_67_">4.67. F2MC16L</A></H3>
<P><H3><A HREF="#sect_4_68_">4.68. MN161x</A></H3>
<P><H3><A HREF="#sect_4_69_">4.69. CDP180x</A></H3>
<P><H3><A HREF="#sect_4_70_">4.70. KENBAK</A></H3>
<P><H3><A HREF="#sect_4_71_">4.71. HP Nanoprocessor</A></H3>
<P><H3><A HREF="#sect_4_72_">4.72. IM61x0</A></H3>
<P><H2><A HREF="#sect_5_">5. Dateiformate</A></H2>
<P><H3><A HREF="#sect_5_1_">5.1. Code-Dateien</A></H3>
<P><H3><A HREF="#sect_5_2_">5.2. Debug-Dateien</A></H3>
<P><H2><A HREF="#sect_6_">6. Hilfsprogramme</A></H2>
<P><H3><A HREF="#sect_6_1_">6.1. PLIST</A></H3>
<P><H3><A HREF="#sect_6_2_">6.2. BIND</A></H3>
<P><H3><A HREF="#sect_6_3_">6.3. P2HEX</A></H3>
<P><H3><A HREF="#sect_6_4_">6.4. P2BIN</A></H3>
<P><H3><A HREF="#sect_6_5_">6.5. AS2MSG</A></H3>
<P><H2><A HREF="#sect_A_">A. Fehlermeldungen von AS</A></H2>
<P><H2><A HREF="#sect_B_">B. E/A-Fehlermeldungen</A></H2>
<P><H2><A HREF="#sect_C_">C. Programmierbeispiele</A></H2>
<P><H3><A HREF="#sect_C_1_">C.1. 16-Bit-Befehle per Makro</A></H3>
<P><H2><A HREF="#sect_D_">D. H&auml;ufig gestellte Fragen</A></H2>
<P><H2><A HREF="#sect_E_">E. Pseudobefehle und Integer-Syntax, gesammelt</A></H2>
<P><H2><A HREF="#sect_F_">F. Vordefinierte Symbole</A></H2>
<P><H2><A HREF="#sect_G_">G. Mitgelieferte Includes</A></H2>
<P><H3><A HREF="#sect_G_1_">G.1. BITFUNCS.INC</A></H3>
<P><H3><A HREF="#sect_G_2_">G.2. CTYPE.INC</A></H3>
<P><H2><A HREF="#sect_H_">H. Danksagungen</A></H2>
<P><H2><A HREF="#sect_I_">I. &Auml;nderungen seit Version 1.3</A></H2>
<P><H2><A HREF="#sect_J_">J. Hinweise zum Quellcode von AS</A></H2>
<P><H3><A HREF="#sect_J_1_">J.1. Verwendete Sprache</A></H3>
<P><H3><A HREF="#sect_J_2_">J.2. Abfangen von Systemabh&auml;ngigkeiten</A></H3>
<P><H3><A HREF="#sect_J_3_">J.3. Systemunabh&auml;ngige Dateien</A></H3>
<P><H4><A HREF="#sect_J_3_1_">J.3.1. Von AS genutzte Module</A></H4>
<P><H4><A HREF="#sect_J_3_2_">J.3.2. Zus&auml;tzliche Module f&uuml;r die Hilfsprogramme</A></H4>
<P><H3><A HREF="#sect_J_4_">J.4. W&auml;hrend der Erzeugung von AS gebrauchte Module</A></H3>
<P><H3><A HREF="#sect_J_5_">J.5. Generierung der Nachrichtendateien</A></H3>
<P><H4><A HREF="#sect_J_5_1_">J.5.1. Format der Quelldateien</A></H4>
<P><H3><A HREF="#sect_J_6_">J.6. Dokumentationserzeugung</A></H3>
<P><H3><A HREF="#sect_J_7_">J.7. Testsuite</A></H3>
<P><H3><A HREF="#sect_J_8_">J.8. Einh&auml;ngen eines neuen Zielprozessors</A></H3>
<P><H3><A HREF="#sect_J_9_">J.9. Lokalisierung auf eine neue Sprache</A></H3>
<P><H1><A HREF="#sect_bib">Literaturverzeichnis
</A></H1>
<P><H1><A HREF="#sect_index">Index
</A></H1>
<P>

<H1><A NAME="sect_1_">1. Allgemeines</A></H1>
<P>
Diese Anleitung wendet sich an Programmierer, die bereits mit der
Programmierung in Assembler vertraut sind und sich dar&uuml;ber
informieren m&ouml;chten, wie man mit AS umgeht. Sie hat eher die
Form eines Referenz- und nicht Benutzerhandbuches. Als solches macht
sie weder den Versuch, die Sprache Assembler an sich zu
erkl&auml;ren, noch erl&auml;utert sie die Architektur bestimmter
Prozessoren. Im Literaturverzeichnis habe ich weiterf&uuml;hrende
Literatur aufgelistet, die bei der Implementation der einzelnen
Codegeneratoren ma&szlig;gebend war. Um Assembler von Grund auf zu
lernen, kenne ich kein Buch; ich habe es im wesentlichen im ,,Trial
and error''-Verfahren gelernt.
<P>

<H2><A NAME="sect_1_1_">1.1. Lizenzbedingungen</A></H2>
<A NAME="ref_SectLicense"></A>
<P>
Bevor es in medias res geht, erst einmal der unvermeidliche Prolog:
<P>
AS in der vorliegenden Version untersteht der GNU General Public
License (GPL); die Details dieser Lizenz k&ouml;nnen Sie in der
beiliegenden Datei COPYING nachlesen. Falls Sie diese nicht mit AS
erhalten haben, beschweren Sie sich bei demjenigen, von dem Sie AS
erhalten haben!
<P>
Kurz gesagt, beinhaltet die GPL folgende Punkte:
<UL>
<LI> Auf AS aufbauende Programme m&uuml;ssen ebenfalls der GPL
    unterstehen;</LI>
<LI> Weiterverbreitung ausdr&uuml;cklich erlaubt;</LI>
<LI> expliziter Haftungsausschlu&szlig; f&uuml;r durch die Anwendung
    dieses Programms entstehende Sch&auml;den.</LI>
</UL>
...aber f&uuml;r die Details bitte ich wirklich, in den Originaltext
der GPL zu schauen!
<P>
Um eine m&ouml;glichst schnelle Fehlerdiagnose und -korrektur zu
erm&ouml;glichen, bitte ich, Fehlerberichten folgende Angaben
beizuf&uuml;gen:
<UL>
<LI> Betriebssystem (DOS, Windows, Linux...) mit Version</LI>
<LI> benutzte Version von AS bzw. Datum des EXE-Files</LI>
<LI> bei selbst kompilierten Versionen: verwendeter Compiler und
    Version</LI>
<LI> m&ouml;glichst die Quelldatei, bei der der Fehler auftritt</LI>
</UL>
Zu erreichen bin ich folgenderma&szlig;en:
<UL>
<LI> per Post:
<DL COMPACT>
<DD>        Alfred Arnold</DD>
<DD>        Hirschgraben 29</DD>
<DD>        52062 Aachen</DD>
</DL>
 </LI>
<LI> per E-Mail:<TT> alfred@ccac.rwth-aachen.de</TT></LI>
</UL>
Wer mir pers&ouml;nlich Fragen stellen will (und in der N&auml;he von
Aachen wohnt), kann dies mit hoher Wahrscheinlichkeit donnerstags von
20.00 bis 21.00 Uhr im Computerclub an der RWTH Aachen
(Elisabethstra&szlig;e 16, erster Stock, rechter Flur).
<P>
Von Telefonanrufen bitte ich abzusehen. Erstens, weil sich die
komplizierten Zusammenh&auml;nge am Telefon nur &auml;u&szlig;erst
schwer er&ouml;rtern lassen, und zweitens ist die Telekom schon reich
genug...
<P>
Die neueste Version von AS (DPMI, Win32, C) findet sich auf folgendem
Server:
<PRE>

 http://john.ccac.rwth-aachen.de:8000/as

</PRE>
oder auch kurz
<PRE>

 http://www.alfsembler.de

</PRE>
<P>
Wer &uuml;ber keinen FTP-Zugang verf&uuml;gt, kann den Assembler auch
von mir anfordern. Ich werde aber nur Anfragen beantworten, die einen
CD-Rohling und einen passenden, frankierten R&uuml;ckumschlag
enthalten.<B> KEIN</B> Geld schicken!!!
<P>
So. Nach diesem unvermeidlichen Vorwort k&ouml;nnen wir wohl beruhigt
zur eigentlichen Anleitung schreiten:
<P>

<H2><A NAME="sect_1_2_">1.2. allgemeine F&auml;higkeiten des Assemblers</A></H2>
<P>
AS bietet im Gegensatz zu normalen Assemblern die M&ouml;glichkeit,
Code f&uuml;r v&ouml;llig verschiedene Prozessoren zu erzeugen.
Momentan sind folgende Prozessorfamilien implementiert:
<UL>
<LI> Motorola 68000..68040, 683xx, Coldfire inkl. Koprozessor und
    MMU</LI>
<LI> Motorola ColdFire</LI>
<LI> Motorola DSP5600x,DSP56300</LI>
<LI> Motorola/IBM MPC601/MPC505/PPC403/MPC821</LI>
<LI> IBM PALM</LI>
<LI> Motorola M-Core</LI>
<LI> Motorola 6800, 6801, 68(HC)11(K4) sowie Hitachi 6301</LI>
<LI> Motorola/Freescale 6805, 68HC(S)08</LI>
<LI> Motorola 6809 / Hitachi 6309</LI>
<LI> Motorola/Freescale 68HC12(X) inklusive XGATE</LI>
<LI> Freescale/NXP S12Z (''MagniV'')</LI>
<LI> Freescale 68RS08</LI>
<LI> Motorola 68HC16</LI>
<LI> Konami 052001</LI>
<LI> Hitachi H8/300(H)</LI>
<LI> Hitachi H8/500</LI>
<LI> Hitachi SH7000/7600/7700</LI>
<LI> Hitachi HMCS400</LI>
<LI> Hitachi H16</LI>
<LI> Rockwell 6502, 65(S)C02, Commodore 65CE02, WDC W65C02S, Rockwell
    65C19 und Hudson HuC6280</LI>
<LI> Rockwell PPS-4</LI>
<LI> CMD 65816</LI>
<LI> Mitsubishi MELPS-740</LI>
<LI> Mitsubishi MELPS-7700</LI>
<LI> Mitsubishi MELPS-4500</LI>
<LI> Mitsubishi M16</LI>
<LI> Mitsubishi M16C</LI>
<LI> DEC PDP-11</LI>
<LI> DEC VAX</LI>
<LI> Western Digital WD16</LI>
<LI> Intel 4004/4040</LI>
<LI> Intel MCS-48/41, einschlie&szlig;lich Siemens SAB80C382 und der
    OKI-Varianten</LI>
<LI> Intel MCS-51/251, Dallas DS80C390</LI>
<LI> Intel MCS-96/196(Nx)/296</LI>
<LI> Intel 8080/8085</LI>
<LI> Intel i960</LI>
<LI> Signetics 8X30x</LI>
<LI> Signetics 2650</LI>
<LI> Philips XA</LI>
<LI> Atmel (Mega-)AVR</LI>
<LI> AMD 29K</LI>
<LI> Siemens 80C166/167</LI>
<LI> Zilog Z80 (einschlie&szlig;lich undokumentierter Befehle), Z180,
    Z280, Z380, eZ80</LI>
<LI> Sharp LR35902 (,,Gameboy-Z80'')</LI>
<LI> Sharp SC61860</LI>
<LI> Sharp SC62015</LI>
<LI> Zilog Z8, Super8, Z8 Encore</LI>
<LI> Zilog Z8000</LI>
<LI> Xilinx KCPSM/KCPSM3 ('PicoBlaze')</LI>
<LI> LatticeMico8</LI>
<LI> Toshiba TLCS-900(L)</LI>
<LI> Toshiba TLCS-90</LI>
<LI> Toshiba TLCS-870(/C)</LI>
<LI> Toshiba TLCS-47</LI>
<LI> Toshiba TLCS-42</LI>
<LI> Toshiba TLCS-9000</LI>
<LI> Toshiba TC9331</LI>
<LI> Microchip PIC16C54..16C57</LI>
<LI> Microchip PIC16C84/PIC16C64</LI>
<LI> Microchip PIC17C42</LI>
<LI> Parallax SX20/SX28</LI>
<LI> SGS M380/GI LP8000</LI>
<LI> SGS-Thomson ST6</LI>
<LI> SGS-Thomson ST7/STM8</LI>
<LI> SGS-Thomson ST9</LI>
<LI> SGS-Thomson 6804</LI>
<LI> Texas Instruments TMS32010/32015</LI>
<LI> Texas Instruments TMS3202x</LI>
<LI> Texas Instruments TMS320C3x/TMS320C4x</LI>
<LI> Texas Instruments TMS320C20x/TMS320C5x</LI>
<LI> Texas Instruments TMS320C54x</LI>
<LI> Texas Instruments TMS320C6x</LI>
<LI> Texas Instruments TMS99xx/TMS99xxx</LI>
<LI> Texas Instruments TMS7000</LI>
<LI> Texas Instruments TMS1000</LI>
<LI> Texas Instruments TMS370xxx</LI>
<LI> Texas Instruments MSP430(X)</LI>
<LI> National Semiconductor IMP-16</LI>
<LI> National Semiconductor IPC-16 ('PACE'), INS8900</LI>
<LI> National Semiconductor SC/MP</LI>
<LI> National Semiconductor INS807x</LI>
<LI> National Semiconductor COP4</LI>
<LI> National Semiconductor COP8</LI>
<LI> National Semiconductor SC144xx</LI>
<LI> National Semiconductor NS32xxx</LI>
<LI> Olympia CP-3F (bzw. SGS M380, GI LP8000)</LI>
<LI> Fairchild ACE</LI>
<LI> Fairchild F8</LI>
<LI> NEC &micro;PD78(C)0x/&micro;PD78(C)1x</LI>
<LI> NEC &micro;COM-43/44/45</LI>
<LI> NEC &micro;PD75xx</LI>
<LI> NEC &micro;PD75xxx (alias 75K0)</LI>
<LI> NEC 78K0</LI>
<LI> NEC 78K2</LI>
<LI> NEC 78K3</LI>
<LI> NEC 78K4</LI>
<LI> NEC &micro;PD7720/7725</LI>
<LI> NEC &micro;PD77230</LI>
<LI> NEC V60</LI>
<LI> Fujitsu F&sup2;MC8L</LI>
<LI> Fujitsu F&sup2;MC16L</LI>
<LI> OKI OLMS-40</LI>
<LI> OKI OLMS-50</LI>
<LI> Panafacom MN1610/MN1613</LI>
<LI> Renesas RX</LI>
<LI> Padauk PMS/PMC/PFSxxx</LI>
<LI> Symbios Logic SYM53C8xx (ja, die kann man programmieren!)</LI>
<LI> Intersil CDP1802/1804/1805(A)</LI>
<LI> Intersil IM6100/6120</LI>
<LI> XMOS XS1</LI>
<LI> MIL STD 1750</LI>
<LI> KENBAK-1</LI>
<LI> GI CP-1600</LI>
<LI> HP Nano Processor</LI>
</UL>
in Arbeit / Planung / &Uuml;berlegung :
<UL>
<LI> ARM</LI>
<LI> Analog Devices ADSP21xx</LI>
<LI> DEC VAX</LI>
<LI> SGS-Thomson ST20</LI>
<LI> Texas Instruments TMS320C8x</LI>
<LI> Zilog eZ80</LI>
</UL>
ungeliebt, aber<I> doch</I> vorhanden :
<UL>
<LI> Intel 8086, 80186, NEC V30..V55 inkl. Koprozessor 8087</LI>
</UL>
Die Umschaltung des Codegenerators darf dabei auch mitten in der
Datei erfolgen, und das beliebig oft!
<P>
Der Grund f&uuml;r diese Flexibilit&auml;t ist, da&szlig; AS eine
Vorgeschichte hat, die auch in der Versionsnummer deutlich wird: AS
ist als Erweiterung eines Makroassemblers f&uuml;r die
68000er-Familie entstanden. Auf besonderen Wunsch habe ich den
urspr&uuml;nglichen Assembler um die F&auml;higkeit zur
&Uuml;bersetzung von 8051-Mnemonics erweitert, und auf dem Weg
(Abstieg?!) vom 68000 zum 8051 sind eine Reihe anderer fast nebenbei
abgefallen...die restlichen Prozessoren wurden allesamt auf
Benutzeranfrage hin integriert. Zumindest beim
prozessorunabh&auml;ngigen Kern kann man also getrost davon ausgehen,
da&szlig; er gut ausgetestet und von offensichtlichen Bugs frei ist.
Leider habe ich aber h&auml;ufig mangels passender Hardware nicht die
M&ouml;glichkeit, einen neuen Codegenerator praktisch zu testen, so
da&szlig; bei Neuerungen &Uuml;berraschungen nie ganz
auszuschlie&szlig;en sind. Das in Abschnitt <A
HREF="#ref_SectLicense">1.1</A> gesagte hat also schon seinen
Grund...
<P>
Diese Flexibilit&auml;t bedingt ein etwas exotisches Code-Format,
f&uuml;r dessen Bearbeitung ich einige Tools beigelegt habe. Deren
Beschreibung findet sich in Abschnitt <A HREF="#ref_ChapTools">6</A>.
<P>
AS ist ein Makroassembler, d.h. dem Programmierer ist die
M&ouml;glichkeit gegeben, sich mittels Makros neue ,,Befehle'' zu
definieren. Zus&auml;tzlich beherrscht er die bedingte Assemblierung.
Labels in Makror&uuml;mpfen werden automatisch als lokal betrachtet.
<P>
Symbole k&ouml;nnen f&uuml;r den Assembler sowohl Integer-, String-
als auch Gleitkommawerte haben. Diese werden --- wie
Zwischenergebnisse bei Formeln --- mit einer Breite von 32 Bit
f&uuml;r Integerwerte, 80/64 Bit f&uuml;r Gleitkommawerte und 255
Zeichen f&uuml;r Strings gespeichert. F&uuml;r eine Reihe von
Mikrokontrollern besteht die M&ouml;glichkeit, durch Segmentbildung
die Symbole bestimmten Klassen zuzuordnen. Dem Assembler kann man auf
diese Weise die --- begrenzte --- M&ouml;glichkeit geben, Zugriffe in
falsche Adre&szlig;r&auml;ume zu erkennen.
<P>
Der Assembler kennt keine expliziten Beschr&auml;nkungen bzgl.
Verschachtelungstiefe von Include-Dateien oder Makros, eine Grenze
bildet lediglich die durch den Hauptspeicher beschr&auml;nkte
Rekursionstiefe. Ebenso gibt es keine Grenze f&uuml;r die
Symboll&auml;nge, diese wird nur durch die maximale Zeilenl&auml;nge
begrenzt.
<P>
Ab Version 1.38 ist AS ein Mehrpass-Assembler. Dieser hochtrabende
Begriff bedeutet nicht mehr, als das die Anzahl der Durchg&auml;nge
durch die Quelltexte nicht mehr zwei sein mu&szlig;. Sind keine
Vorw&auml;rtsreferenzen im Quellcode enthalten, so kommt AS mit einem
Durchgang aus. Stellt sich dagegen im zweiten Durchgang heraus,
da&szlig; ein Befehl mit einer k&uuml;rzeren oder l&auml;ngeren
Kodierung benutzt werden mu&szlig;, so wird ein dritter (vierter,
f&uuml;nfter...) Durchgang eingelegt, um alle Symbolreferenzen
richtig zu stellen. Mehr steckt hinter dem Begriff ,,Multipass''
nicht...er wird im weiteren Verlauf dieser Anleitung deswegen auch
nicht mehr auftauchen.
<P>
Nach soviel Lobhudelei ein dicker Wermutstropfen: AS erzeugt keinen
linkf&auml;higen Code. Eine Erweiterung um einen Linker w&auml;re mit
erheblichem Aufwand verbunden und ist momentan nicht in Planung.
<P>
Wer einen Blick in die Quellen von AS werfen will, besorge sich
einfach die Unix-Version von AS, die als Quelltext zum Selber
&uuml;bersetzen kommt. Die Quellen sind mit Sicherheit nicht in einem
Format, da&szlig; das Verst&auml;ndnis m&ouml;glichst leicht macht -
an vielen Stellen schaut noch der originale Pascal-Quellcode heraus,
und ich teile einige h&auml;ufig vertretene Ansichten &uuml;ber
'guten' C-Stil nicht...
<P>

<H2><A NAME="sect_1_3_">1.3. Unterst&uuml;tzte Plattformen</A></H2>
<P>
Obwohl AS als ein reines DOS-Programm angefangen hat, stehen auch        
eine Reihe von Versionen zur Verf&uuml;gung, die etwas mehr als den
Real-Mode eines Intel-Prozessors ausnutzen k&ouml;nnen. Diese sind in
ihrer Benutzung soweit als m&ouml;glich kompatibel gehalten zur
DOS-Version, es ergeben sich nat&uuml;rlich bisweilen Unterschiede in
der Installation und der Einbindung in die jeweilige
Betriebssystemumgebung. Abschnitte in dieser Anleitung, die nur
f&uuml;r eine bestimmte Version von AS gelten, sind mit einer
entsprechenden Randbemerkung (an diesem Absatz f&uuml;r die
DOS-Version) gekennzeichnet. Im einzelnen existieren die folgenden,
weiteren Versionen (die als getrennte Pakete distributiert werden):
<P>
F&uuml;r den Fall, da&szlig; man bei der &Uuml;bersetzung                
gro&szlig;er, komplexer Programme unter DOS Speicherplatzprobleme
bekommt, existiert eine DOS-Version, die mittels eines DOS-Extenders
im Protected Mode abl&auml;uft und so das komplette Extended Memory
eines ATs nutzen kann. Die &Uuml;bersetzung wird durch den Extender
merklich langsamer, aber immerhin l&auml;uft es dann noch...
<P>
F&uuml;r Freunde von IBM's Betriebssystem OS/2 gibt es eine native       
OS/2-Version von AS. Seit 1.41r8 ist diese nur eine volle 32-bittige
OS/2-Anwendung, was nat&uuml;rlich zur Folge hat, da&szlig; OS/2 2.x
und ein 80386-Prozessor jetzt zwingend erforderlich sind.
<P>
Den reinen PC-Bereich verl&auml;&szlig;t man mit der C-Version von       
AS, die so gehalten wurde, da&szlig; sie auf einer m&ouml;glichst
gro&szlig;en Zahl von UNIX-artigen Systemen (dazu z&auml;hlt aber
auch OS/2 mit dem emx-Compiler) ohne gro&szlig;artige Verrenkungen
&uuml;bersetzbar ist. Im Gegensatz zu den vorherigen Versionen (die
auf den auf Anfrage erh&auml;ltlichen Pascal-Sourcen basieren) wird
die C-Version im Quellcode ausgeliefert, d.h. man mu&szlig; sich
mittels eines Compilers selbst die Binaries erzeugen. Dies ist aber
(f&uuml;r mich) der eindeutig einfachere Weg, als ein Dutzend
Binaries f&uuml;r Maschinen vorzukompilieren, auf die ich auch nicht
immer Zugriff habe...
<P>

<H1><A NAME="sect_2_">2. Benutzung des Assemblers</A></H1>
<P>
<BLOCKQUOTE>
<DIV ALIGN=LEFT>
    <I> Scotty: Captain, we din' can reference it!<BR>
    Kirk: Analysis, Mr. Spock?<BR>
    Spock: Captain, it doesn't appear in the symbol table.<BR>
    Kirk: Then it's of external origin?<BR>
    Spock: Affirmative.<BR>
    Kirk: Mr. Sulu, go to pass two.<BR>
    Sulu: Aye aye, sir, going to pass two.<BR>
    </I>
</DIV>
</BLOCKQUOTE>
<P>

<H2><A NAME="sect_2_1_">2.1. Hardware-Anforderungen</A></H2>
<P>
Je nach Version von AS variieren die Hardware-Anforderungen deutlich:
<P>
Die DOS-Version l&auml;uft prinzipiell auf allen IBM-kompatiblen PCs,    
angefangen vom PC/XT mit vierkommawenig Megaherz bis hin zum Pentium.
Wie bei vielen anderen Programmen aber auch, steigt der Lustgewinn
mit der Hardware-Ausstattung. So d&uuml;rfte ein XT-Benutzer ohne
Festplatte erhebliche Probleme haben, die &uuml;ber 500 Kbyte
gro&szlig;e Overlay-Datei von AS auf einer Diskette
unterzubringen...eine Festplatte sollte der PC also schon haben,
allein um vern&uuml;nftige Ladezeiten zu erreichen. Im
Hauptspeicherbedarf ist AS recht gen&uuml;gsam: Das Programm selber
belegt knapp 300 Kbyte Hauptspeicher, AS sollte also ab einer
Hauptspeichergr&ouml;&szlig;e von 512 Kbyte ausf&uuml;hrbar sein.
<P>
Die Version von AS f&uuml;r das DOS-Protected-Mode-Interface (DPMI)      
ben&ouml;tigt zum Ablaufen mindestens einen 80286-Prozessor und 1
Mbyte freies Extended Memory. Daher stellen 2 Mbyte Hauptspeicher das
absolute Minimum dar, wenn man im XMS sonst keine anderen Spielereien
(Platten-Cache, RAM-Disk, hochgeladenes DOS) installiert hat, sonst
entsprechend mehr. Falls man die DPMI-Version in einer DOS-Box von
OS/2 laufen l&auml;&szlig;t, so sollte DPMI auch in den
DOS-Einstellungen der Box erlaubt sein (Einstellung<TT> An</TT>
oder<TT> Auto</TT>) und der Box eine entsprechende Menge von
XMS-Speicher zugeordnet sein. Die virtuelle Speicherverwaltung von
OS/2 sorgt hier &uuml;brigens daf&uuml;r, da&szlig; man sich keine
Gedanken machen mu&szlig;, ob der eingestellte Speicher auch real
verf&uuml;gbar ist.
<P>
Die C-Version von AS wird im Quellcode ausgeliefert und erfordert        
damit ein Unix- oder OS/2-System mit einem C-Compiler. Der Compiler
mu&szlig; dem ANSI-Standard gen&uuml;gen (GNU-C erf&uuml;llt diese
Bedingung zum Beispiel). Ob Ihr UNIX-System bereits getestet und die
n&ouml;tigen Definitionen vorgenommen wurden, k&ouml;nnen Sie der<TT>
README</TT>-Datei entnehmen. Als zur Kompilation ben&ouml;tigten
Plattenplatz sollten Sie ca. 15 Mbyte veranschlagen; dieser Wert (und
der nach der &Uuml;bersetzung noch ben&ouml;tigte Platz f&uuml;r die
&uuml;bersetzten Programme) variiert allerdings stark von System zu
System, so da&szlig; man diesen Wert nur als Richtschnur betrachten
sollte.
<P>

<H2><A NAME="sect_2_2_">2.2. Lieferumfang</A></H2>
<P>
Prinzipiell erh&auml;lt man AS in einer von zwei Formen: Als<EM>
Bin&auml;rdistribution</EM> oder<EM> Quellcodedistribution</EM>. Im
Falle einer Bin&auml;rdistribution bekommt man AS mit den
zugeh&ouml;rigen Dienstprogrammen und Hilfsdateien fertig
&uuml;bersetzt, so da&szlig; man nach dem Auspacken des Archivs an
die gew&uuml;nschte Stelle direkt loslegen kann.
Bin&auml;rdistributionen werden f&uuml;r verbreitete Plattformen
gemacht, bei denen die Mehrzahl der Benutzer keinen Compiler hat oder
die &Uuml;bersetzung trickreich ist (im Moment sind dies DOS und
OS/2). Eine Quellcodedistribution enth&auml;lt im Gegensatz den
kompletten Satz an C-Quellen, um AS zu generieren; es ist letzten
Endes ein Schnappschu&szlig; des Quellenbaumes, an dem ich AS
weiterentwickele. Die Generierung von AS aus dem Quellcode und dessen
Struktur ist n&auml;her in Anhang <A HREF="#ref_ChapSource">J</A>
beschrieben, weshalb an dieser Stelle nur auf den Umfang und die
Installation einer Bin&auml;rdistribution beschrieben wird:
<P>
Das Archiv des Lieferumfangs gliedert sich in einige
Unterverzeichnisse, so da&szlig; man nach dem Auspacken sofort einen
Verzeichnisbaum erh&auml;lt. Die Verzeichnisse enthalten im
einzelnen:
<UL>
<LI> <TT> BIN</TT>: ausf&uuml;hrbare Programme, Text-Resourcen;</LI>
<LI> <TT> INCLUDE</TT>: Include-Dateien f&uuml;r Assemblerprogramme, z.B.
    Registerdefinitionen oder Standardmakros;</LI>
<LI> <TT> MAN</TT>: Kurzreferenzen f&uuml;r die Programme im
    Unix-Man-Format;</LI>
<LI> <TT> DOC</TT>: diese Dokumentation in verschiedenen Formaten;</LI>
<LI> <TT> LIB</TT>: vorgesehen f&uuml;r Initialisierungsdateien.</LI>
</UL>
Eine Auflistung der Dateien, die in jeder Bin&auml;rdistribution
enthalten sind, findet sich in Tabelle <A
HREF="#ref_TabCommonPackageList">2.0</A>. Falls eine der in diesen
(oder den folgenden) Tabellen aufgef&uuml;hrten Dateien fehlt, hat
jemand (im Zweifelsfalle ich) beim Kopieren geschlafen...
<P>
<CENTER>
<P><CENTER>Tabelle 2.1: Standardumfang einer Bin&auml;rdistribution<A
             NAME="ref_TabCommonPackageList"></A>
</CENTER><P>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datei</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis BIN</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>AS.EXE<BR>
PLIST.EXE<BR>
PBIND.EXE<BR>
P2HEX.EXE<BR>
P2BIN.EXE<BR>
AS.MSG<BR>
PLIST.MSG<BR>
PBIND.MSG<BR>
P2HEX.MSG<BR>
P2BIN.MSG<BR>
TOOLS.MSG<BR>
CMDARG.MSG<BR>
IOERRS.MSG</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Programmdatei Assembler<BR>
listet Inhalt von Codedateien auf<BR>
kopiert Codedateien zusammen<BR>
wandelt Code- in Hexdateien um<BR>
wandelt Code- in Bin&auml;rdateien um<BR>
Textresourcen zu AS *)<BR>
Textresourcen zu PLIST *)<BR>
Textresourcen zu PBIND *)<BR>
Textresourcen zu P2HEX *)<BR>
Textresourcen zu P2BIN *)<BR>
gemeinsame Textresourcen zu den Tools *)<BR>
gemeinsame Textresourcen zu allen Programmen *)<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=2 ALIGN=LEFT>*) nur DOS</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis DOC</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>AS_DE.DOC<BR>
AS_DE.HTML<BR>
AS_DE.TEX<BR>
AS_EN.DOC<BR>
AS_EN.HTML<BR>
AS_EN.TEX</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>deutsche Dokumentation, ASCII-Format<BR>
deutsche Dokumentation, HTML-Format<BR>
deutsche Dokumentation, LaTeX-Format<BR>
englische Dokumentation, ASCII-Format<BR>
englische Dokumentation, HTML-Format<BR>
englische Dokumentation, LaTeX-Format</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis INCLUDE</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>BCDIC.INC<BR>
BITFUNCS.INC<BR>
CTYPE.INC<BR>
<BR>
EBCDIC.INC<BR>
CP037.INC<BR>
CP5100.INC<BR>
CP5110.INC<BR>
80C50X.INC<BR>
80C552.INC<BR>
H8_3048.INC<BR>
KENBAK.INC<BR>
RADIX50.INC<BR>
REG166.INC<BR>
REG251.INC<BR>
REG29K.INC<BR>
REG53X.INC<BR>
REG6303.INC<BR>
REG683XX.INC<BR>
REG7000.INC<BR>
REG78310.INC<BR>
REG78K0.INC<BR>
REG96.INC<BR>
REGACE.INC<BR>
REGAVROLD.INC<BR>
REGAVR.INC<BR>
REGCOLD.INC<BR>
REGCOP8.INC<BR>
REGEZ80.INC<BR>
REGF8.INC<BR>
REGGP32.INC<BR>
REGH16.INC<BR>
REGHC12.INC<BR>
REGM16C.INC<BR>
REGMSP.INC<BR>
REGPDK.INC<BR>
REGS12Z.INC<BR>
REGST6.INC<BR>
REGST7.INC<BR>
REGSTM8.INC<BR>
REGST9.INC<BR>
REGZ280.INC<BR>
REGZ380.INC<BR>
STDDEF04.INC<BR>
STDDEF16.INC<BR>
<BR>
STDDEF17.INC<BR>
STDDEF18.INC<BR>
STDDEF2X.INC<BR>
STDDEF37.INC<BR>
STDDEF3X.INC<BR>
STDDEF4X.INC<BR>
STDDEF47.INC<BR>
STDDEF51.INC<BR>
<BR>
STDDEF56K.INC<BR>
STDDEF5X.INC<BR>
STDDEF60.INC<BR>
<BR>
STDDEF62.INC<BR>
STDDEF75.INC<BR>
STDDEF87.INC<BR>
STDDEF90.INC<BR>
STDDEF96.INC<BR>
STDDEFXA.INC<BR>
STDDEFZ8.INC<BR>
REGV60.INC<BR>
REGZ8.INC<BR>
REGSX20.INC<BR>
AVR/*.INC<BR>
<BR>
<BR>
COLDFIRE*.INC<BR>
<BR>
<BR>
EZ80*.INC<BR>
<BR>
<BR>
PDK*.INC<BR>
<BR>
<BR>
S12Z*.INC<BR>
<BR>
<BR>
ST6*.INC<BR>
<BR>
<BR>
ST7*.INC<BR>
<BR>
<BR>
STM8*.INC<BR>
<BR>
<BR>
Z8*.INC<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Definition BCDIC/Codepage 359<BR>
Funktionen zur Bitmanipulation<BR>
Funktionen zur Klassifizierung von<BR>
Zeichen<BR>
Inkludiert alle EBCDIC-Varianten<BR>
Definition EBCDIC (Codepage 037)<BR>
Definition Zeichensatz IBM 5100<BR>
Definition EBCDIC (IBM 5110)<BR>
Registeradressen SAB C50x<BR>
Registeradressen 80C552<BR>
Registeradressen H8/3048<BR>
Registeradressen Kenbak-1<BR>
Definition RADIX 50 Zeichensatz<BR>
Adressen &amp; Befehlsmakros 80C166/167<BR>
Adressen &amp; Bits 80C251<BR>
Peripherieadressen AMD 2924x<BR>
Registeradressen H8/53x<BR>
Registeradressen 6303<BR>
Registeradressen 68332/68340/68360<BR>
Registeradressen TMS70Cxx<BR>
Registeradressen &amp; Vektoren 78K3<BR>
Registeradressen 78K0<BR>
Registeradressen MCS-96<BR>
Registeradressen ACE<BR>
Register- &amp; Bitadressen AVR-Familie (veraltet)<BR>
Register- &amp; Bitadressen AVR-Familie (aktuell)<BR>
Registeradressen ColdFire<BR>
Registeradressen COP8<BR>
Registeradressen eZ80<BR>
Register- &amp; Speicheradressen F8<BR>
Registeradressen 68HC908GP32<BR>
Registeradressen H16<BR>
Registeradressen 68HC12<BR>
Registeradressen Mitsubishi M16C<BR>
Registeradressen TI MSP430<BR>
Register- &amp; Bitadressen PMC/PMS/PFSxxx<BR>
Register- &amp; Bitadressen S12Z-Familie<BR>
Register- &amp; Makrodefinitionen ST6 (aktuell)<BR>
Register- &amp; Makrodefinitionen ST7<BR>
Register- &amp; Makrodefinitionen STM8<BR>
Register- &amp; Makrodefinitionen ST9<BR>
Registeradressen Z280<BR>
Registeradressen Z380<BR>
Registeradressen 6804<BR>
Befehlsmakros und Registeradressen<BR>
PIC16C5x<BR>
Registeradressen PIC17C4x<BR>
Registeradressen PIC16C8x<BR>
Registeradressen TMS3202x<BR>
Register- &amp; Bitadressen TMS370xxx<BR>
Peripherieadressen TMS320C3x<BR>
Peripherieadressen TMS320C4x<BR>
Befehlsmakros TLCS-47<BR>
Definition von SFRs und Bits f&uuml;r<BR>
8051/8052/80515<BR>
Registeradressen DSP56000<BR>
Peripherieadressen TMS320C5x<BR>
Befehlsmakros &amp; Registeradressen<BR>
PowerPC<BR>
Registeradressen &amp; Makros ST6 (veraltet)<BR>
Registeradressen 75K0<BR>
Register- &amp; Speicheradressen TLCS-870<BR>
Register- &amp; Speicheradressen TLCS-90<BR>
Register- &amp; Speicheradressen TLCS-900<BR>
SFR-&amp; Bitadressen Philips XA<BR>
Registeradressen Z8-Familie (alt)<BR>
Registeradressen NEC V60<BR>
Registeradressen Z8-Familie (neu)<BR>
Register- &amp; Bitadressen Parallax SX20/28<BR>
Register- &amp; Bitadressen AVR-Familie<BR>
(nicht direkt benutzen, REGAVR.INC<BR>
inkludieren)<BR>
Register- &amp; Bitadressen ColdFire-Familie<BR>
(nicht direkt benutzen, REGCOLD.INC<BR>
inkludieren)<BR>
Register- &amp; Bitadressen eZ80-Familie<BR>
(nicht direkt benutzen, REGEZ80.INC<BR>
inkludieren)<BR>
Register- &amp; Bitadressen PMC/PMS/PFSxxx<BR>
(nicht direkt benutzen, REGPDK.INC<BR>
inkludieren)<BR>
Register- &amp; Bitadressen S12Z-Familie<BR>
(nicht direkt benutzen, REGS12Z.INC<BR>
inkludieren)<BR>
Register- &amp; Bitadressen ST6-Familie<BR>
(nicht direkt benutzen, REGST6.INC<BR>
inkludieren)<BR>
Register- &amp; Bitadressen ST7-Familie<BR>
(nicht direkt benutzen, REGST7.INC<BR>
inkludieren)<BR>
Register- &amp; Bitadressen STM8-Familie<BR>
(nicht direkt benutzen, REGSTM8.INC<BR>
inkludieren)<BR>
Register- &amp; Bitadressen Z8-Familie<BR>
(nicht direkt benutzen, REGZ8.INC<BR>
inkludieren)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis LIB</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis MAN</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>ASL.1<BR>
PLIST.1<BR>
PBIND.1<BR>
P2HEX.1<BR>
P2BIN.1</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Kurzanleitung zu AS<BR>
Kurzanleitung zu PLIST<BR>
Kurzanleitung zu PBIND<BR>
Kurzanleitung zu P2HEX<BR>
Kurzanleitung zu P2BIN</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>
Je nach Plattform kann eine Bin&auml;rdistribution aber noch weitere
Dateien enthalten, um einen Betrieb zu erm&ouml;glichen, wie es z.B.
bei DOS-Extendern der Fall ist. F&uuml;r die DOS-DPMI-Version ergeben    
sich die in Tabelle <A HREF="#ref_TabDPMIPackageList">2.1</A>
gelisteten Erg&auml;nzungen. Es spricht &uuml;brigens nichts dagegen,
als Hilfsprogramme die Versionen aus einer DOS-Distribution zu
verwenden, da diese einerseits ohne den Extender-Overhead deutlich
schneller ablaufen und andererseits den vom Extender bereitgestellten
erweiterten Speicher nicht ben&ouml;tigen.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datei</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis BIN</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>DPMI16BI.OVL<BR>
RTM.EXE</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>DPMI-Server f&uuml;r den Assembler<BR>
Laufzeit-Modul des Extenders</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.1: Zus&auml;tzliche Dateien in einer
             DPMI-Bin&auml;rdistribution<A
             NAME="ref_TabDPMIPackageList"></A>
</CENTER><P>

<P>
Eine OS/2-Bin&auml;rdistribution enth&auml;lt neben den Basisdateien     
eine Reihe von DLLs, die zur Laufzeitumgebung des verwendeten
emx-Compilers geh&ouml;ren (Tabelle <A
HREF="#ref_TabOS2PackageList">2.2</A>). Falls man diese DLLs (oder
neuere Versionen davon) bereits besitzt, kann man diese auch wieder
l&ouml;schen und seine eigenen benutzen.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datei</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis BIN</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>EMX.DLL<BR>
EMXIO.DLL<BR>
EMXLIBC.DLL<BR>
EMXWRAP.DLL</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Laufzeitbibliotheken f&uuml;r AS und<BR>
die Dienstprogramme<BR>
<BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.2: Zus&auml;tzliche Dateien in einer
             OS/2-Bin&auml;rdistribution<A
             NAME="ref_TabOS2PackageList"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_2_3_">2.3. Installation</A></H2>
<P>
Eine besondere Installation ist f&uuml;r die Nutzung einer               
Bin&auml;rdistribution nicht notwendig, es gen&uuml;gt, das Archiv an
passender Stelle auszupacken und dann noch einige Kleinigkeiten zu
erg&auml;nzen. Als Beispiel hier eine Installation, wie sie
vielleicht ein UNIX-Anh&auml;nger vornehmen w&uuml;rde:
<P>
Legen Sie ein Verzeichnis c:\as an (im folgenden nehme ich an,
da&szlig; Sie AS auf Laufwerk C installieren wollen), wechseln Sie in
dieses und entpacken Sie das Archiv unter Erhalt der Verzeichnisnamen
(bei Verwendung von PKUNZIP ist dazu die Kommandozeilenoption -d
erforderlich). Sie sollten jetzt folgenden Verzeichnisbaum haben:
<PRE>

c:\as
c:\as\bin
c:\as\include
c:\as\lib
c:\as\man
c:\as\doc

</PRE>
Erg&auml;nzen Sie jetzt die<TT> PATH</TT>-Anweisung in Ihrer<TT>
AUTOEXEC.BAT</TT> um das Verzeichnis c:\as\bin, so da&szlig; AS und
seine Hilfsprogramme vom System gefunden werden. In dem<TT>
lib</TT>-Verzeichnis erzeugen Sie mit einem beliebigen Texteditor
eine Datei<TT> AS.RC</TT> mit folgendem Inhalt:
<PRE>

-i c:\as\include

</PRE>
Diese sogenannte<EM> Key-Datei</EM> zeigt AS, in welchem Verzeichnis
er seine Include-Dateien suchen soll. Damit AS diese Key-Datei bei
Start auch beachtet, mu&szlig; noch folgende Anweisung in die<TT>
AUTOEXEC.BAT</TT>:
<PRE>

set ASCMD=@c:\as\lib\as.rc

</PRE>
Was Sie alles noch in der Key-Datei voreinstellen k&ouml;nnen, steht
im folgenden Abschnitt.
<P>
Die Installation der DPMI-Version sollte im Prinzip genauso verlaufen    
wie der reinen DOS-Version; wenn der Pfad das<TT>
bin</TT>-Verzeichnis enth&auml;lt, werden die Dateien des
DOS-Extenders automatisch gefunden und man sollte von dieser Mimik
(mit Ausnahme der l&auml;ngeren Anlaufzeit...) nichts mitbekommen.
Theoretisch ist es m&ouml;glich, da&szlig; Sie auf 80286-Rechnern
beim ersten Start mit einer Meldung der folgenden Form konfrontiert
werden:
<PRE>

  machine not in database (run DPMIINST)

</PRE>
Da das Tool DPMIINST bei neueren Versionen des DOS-Extenders von
Borland aber nicht mehr dabei ist, nehme ich einmal an, da&szlig;
diese Sache sich erledigt hat...falls doch nicht, bitte ich um
R&uuml;ckmeldung!
<P>
Die Installation der OS/2-Version kann in weiten Z&uuml;gen genauso      
ablaufen wie f&uuml;r die DOS-Version, nur da&szlig; dem System noch
die DLLs bekannt gemacht werden m&uuml;ssen. Wenn Sie den<TT>
LIBPATH</TT>-Eintrag in Ihrer<TT> CONFIG.SYS</TT> nicht erweitern
wollen, ist es nat&uuml;rlich auch m&ouml;glich, die DLLs in ein
Verzeichnis zu verschieben, das bereits dort aufgef&uuml;hrt ist.
<P>
Wie bereits erw&auml;hnt, beschr&auml;nkt sich die
Installationsbeschreibung hier nur auf Bin&auml;rdistributionen. Da
eine Installation unter Unix im Augenblick immer eine                    
Quellcodedistribution ist, geht der Verweis hier unisono in Anhang <A
HREF="#ref_ChapSource">J</A>.
<P>

<H2><A NAME="sect_2_4_">2.4. Aufruf, Parameter</A></H2>
<A NAME="ref_SectCallConvention"></A>
<P>
AS ist ein Kommandozeilen-gesteuertes Programm, d.h. alle Parameter
und Dateiangaben sind in der Kommandozeile anzugeben.
<P>
Zu AS geh&ouml;rt eine Reihe Reihe von Nachrichtendateien (erkennbar
an der Endung<TT> MSG</TT>, aus denen AS zur Laufzeit die f&uuml;r
die jeweilige Landessprache dynamisch nachl&auml;dt. AS sucht nach
diesen Dateien in den folgenden Verzeichnissen:
<UL>
<LI> im aktuellen Verzeichnis;</LI>
<LI> im Verzeichnis der EXE-Datei;</LI>
<LI> in dem in der Environment-Variablen<TT> AS_MSGPATH</TT> angegebenen
    Verzeichnis, oder alternativ in den in der<TT>
    PATH</TT>-Variablen gelisteten Verzeichnissen;</LI>
<LI> In dem Verzeichnis, das AS zur Kompilationszeit durch das Makro<TT>
    LIBDIR</TT> mitgegeben wurde.</LI>
</UL>
Diese Dateien werden von AS<EM> zwingend</EM> zum Betrieb
ben&ouml;tigt, d.h. findet AS diese Dateien nicht, bricht er an
dieser Stelle sofort ab.
<P>
Die Auswahl der Sprache (momentan Deutsch oder Englisch) orientiert
sich unter DOS und OS/2 an der<TT> COUNTRY</TT>-Einstellung in
der<TT> CONFIG.SYS</TT>, unter Unix an der<TT>
LANG</TT>-Environment-Variablen.
<P>
Um den Speicherbedarf von AS unter DOS &uuml;berhaupt befriedigen zu     
k&ouml;nnen, wurden die verschiedenen Codegeneratormodule in der
DOS-Version in einen Overlay verlegt, der Teil des EXE-Files ist.
Eine getrennte OVR-Datei wie bei fr&uuml;heren Versionen von AS
existiert also nicht mehr, AS versucht aber wie bisher auch
weiterhin, die durch das Overlaying entstehenden Verz&ouml;gerungen
durch Nutzung von eventuellem EMS- oder XMS-Speicher zu reduzieren.
Sollte diese Verwendung zu Problemen f&uuml;hren, so k&ouml;nnen Sie
die Verwendung von EMS bzw. XMS unterbinden, indem Sie einer
Environment-Variablen<TT> USEXMS</TT> bzw.<TT> USEEMS</TT> den
Wert<TT> n</TT> zuweisen. So kann man z.B. mit dem Befehl
<PRE>

   SET USEXMS=n

</PRE>
die Verwendung von Extended Memory verhindern.
<P>
Da AS alle Ein-und Ausgaben &uuml;ber das Betriebssystem abwickelt
(und daher unter DOS auch auf nicht ganz so kompatiblen PCs laufen
sollte) und eine rudiment&auml;re Bildschirmsteuerung ben&ouml;tigt,
gibt er w&auml;hrend der Assemblierung ANSI-Steuersequenzen aus.
Falls Sie in den Ausgaben von AS also seltsame Zeichen sehen sollten,    
fehlt offensichtlich in Ihrer CONFIG.SYS die Einbindung des
ANSI-Treibers (<TT>device=ansi.sys</TT>), die weitere Funktion von AS    
wird dadurch aber nicht beeinflu&szlig;t. Alternativ k&ouml;nnen Sie
aber auch die Ausgabe von ANSI-Sequenzen durch das Setzen der
Environment-Variablen<TT> USEANSI</TT> auf<TT> n</TT> ganz
unterdr&uuml;cken.
<P>
Der DOS-Extender der DPMI-Version l&auml;&szlig;t sich in seiner         
Speicherbelegung durch diverse Kommandozeilenoptionen beeinflussen.
Diese k&ouml;nnen Sie bei Bedarf der Datei DPMIUSER.DOC entnehmen.
Zus&auml;tzlich ist sie in der Lage, bei Bedarf den vorhandenen
Speicher durch eine Swap-Datei zu ,,erweitern''. Dazu belegt man eine
Environment-Variable<TT> ASXSWAP</TT> folgenderma&szlig;en:
<BLOCKQUOTE>
    <TT> SET ASXSWAP=&lt;Gr&ouml;&szlig;e&gt;[,Dateiname]</TT>
</BLOCKQUOTE>
Die Gr&ouml;&szlig;enangabe erfolgt in Megabytes und<B> mu&szlig;</B>
gemacht werden. Der Name der Datei ist dagegen optional; fehlt er, so
wird die Swap-Datei im aktuellen Verzeichnis unter dem Namen<TT>
ASX.TMP</TT> angelegt. In jedem Falle wird die Swap-Datei nach
Programmende wieder gel&ouml;scht.
<P>
Die Kommandozeilenparameter k&ouml;nnen grob in drei Klassen
eingeteilt werden: Schalter, Key-File-Referenzen (s.u.) und
Dateispezifikationen. Parameter dieser beiden Klassen k&ouml;nnen
beliebig gemischt in der Kommandozeile auftreten, AS wertet zuerst
alle Parameter aus und assembliert dann die angegebenen Dateien.
Daraus folgen zwei Dinge:
<UL>
<LI> Die angegebenen Schalter wirken auf alle angegebenen Quelldateien.
    Sollen mehrere Quelldateien mit unterschiedlich gesetzten
    Schaltern assembliert werden, so mu&szlig; dies in getrennten
    L&auml;ufen erfolgen.</LI>
<LI> Es k&ouml;nnen in einem Durchgang mehrere Dateien assembliert
    werden. Um der Sache die Krone aufzusetzen, d&uuml;rfen die
    Dateiangaben Jokerzeichen enthalten.</LI>
</UL>
Schalterparameter erkennt AS daran, da&szlig; sie durch einen
Schr&auml;gstrich (/) oder Bindestrich (-) eingeleitet werden. Es
gibt dabei sowohl Schalter, die nur aus einem Buchstaben bestehen,
als auch Schalter, die aus einem ganzen Wort bestehen. Immer wenn AS
einen Schalter nicht als ,,Wort-Schalter'' verstehen kann, so
versucht er, die Buchstaben des Wortes als einzelne Schalter zu
interpretieren. Wenn man also z.B.
<PRE>

 -queit

</PRE>
anstelle von
<PRE>

 -quiet

</PRE>
geschrieben h&auml;tte, w&uuml;rde AS die Buchstaben<TT> q, u, e,
i</TT> und<TT> t</TT> als einzelne Schalter auffassen.
Mehrbuchstabige Schalter unterscheiden sich weiterhin von
einbuchstabigen dadurch, da&szlig; AS bei ihnen beliebige
Gro&szlig;-und Kleinschreibungen akzeptiert, w&auml;hrend
einbuchstabige Schalter je nach Gro&szlig;- oder Kleinschreibung
unterschiedliche Bedeutung haben.
<P>
Momentan sind folgende Schalter definiert:<A
NAME="index_SHARED_1"></A>
<UL>
<LI> <TT>l</TT>: Assemblerlisting auf Konsole ausgeben. Falls mehrere
    Passes ausgef&uuml;hrt werden m&uuml;ssen, landen im Gegensatz
    zur n&auml;chsten Option die Listings aller Durchg&auml;nge auf
    der Ausgabe!</LI>
<LI> <TT>L</TT>: Assemblerlisting auf Datei schreiben. Die Listdatei
    erh&auml;lt dabei den gleichen Namen wie die Quelldatei,
    lediglich die Endung wird durch<TT> LST</TT> ersetzt, es sei
    denn...</LI>
<LI> <TT>OLIST</TT>: mit einem zus&auml;tzlichen Argument legt einen
    anderen Pfad bzw. Namen f&uuml;r die Listdatei fest. Falls
    mehrere Dateien assembliert werden, kann diese Option auch
    mehrfach gegeben werden.</LI>
<LI> <TT>listline-prefix</TT>: Mit dieser Option k&ouml;nnen die Daten
    bestimmt werden, die im Listing jeder Zeile vorangestellt werden.
    Der Aufbau des daf&uuml;r verwendeten Formatstrings ist in <A
    HREF="#ref_SectListing">2.6</A> beschrieben.</LI>
<LI> <TT> list-unknown-values</TT> bzw.<TT> no-list-unknown-values</TT>:
    Schaltet die Anzeige von im ersten Durchlauf unbekannten Werten
    als Fragezeichen an bzw. aus.</LI>
<LI> <A NAME="ref_radix"></A><TT>RADIX</TT>: Stellt das
    Default-Zahlensystem auf einen Wert zwischen 2 und 36, anstelle
    von 10. Dieser Wert kann durch die gleichnamige Anweisung im
    Programm &uuml;bersteuert werden.</LI>
<LI> <A NAME="ref_listradix"></A><TT>LISTRADIX</TT>:
    Defaultm&auml;&szlig;ig erfolgen alle Zahlenausgaben im Listing
    (Adressen, erzeugter Code, Symboltabelle) im Hexadezimalsystem.
    Mit diesem Schalter kann ein beliebiges anderes Zahlensystem im
    Bereich 2 bis 36 angegeben werden, z.B. '-listradix 8' f&uuml;r
    oktale Ausgaben. Wird der Zahlenwert mit f&uuml;hrender Null
    geschrieben (also z.B. 08 anstelle 8), wird der
    Programmz&auml;hler im Listing mit f&uuml;hrenden Nullen
    geschrieben.</LI>
<LI> <TT>SPLITBYTE [Zeichen]</TT>: Zahlen im Listing werden Byte-weise
    dargestellt, mit dem angegebenen Zeichen als Trenner. Ein Punkt
    wird als Trenner verwendet, wenn kein Zeichen angegeben wurde.
    Diese Option wird &uuml;blicherweise zusammen mit der<TT>
    LISTRADIX</TT>-Option verwendet; Listradix 8 zusammen mit einem
    Punkt als Trenner ergibt die sogenannte
    ''Split-Octal''-Darstellung.</LI>
<LI> <TT>o</TT>:Bestimmt einen neuen Namen f&uuml;r die von AS zu
    erzeugende Code-Datei. Wird diese Option mehrfach verwendet, so
    werden die angegebenen Namen nacheinander den zu assemblierenden
    Quelldateien zugeordnet; Negation (s.u.) dieser Option in
    Verbindung mit einem Namen l&ouml;scht den Namen aus der Liste;
    Negation ohne Namensangabe l&ouml;scht die komplette Liste.</LI>
<LI> <TT>SHAREOUT</TT>:dito, nur f&uuml;r eine eventuell zu erzeugende
    SHARE-Datei</LI>
<LI> <TT>c</TT>: SHARED-Variablen werden in einem Format abgelegt, das
    die Einbindung in eine C-Quelldatei erlaubt. Die Endung der Datei
    ist<TT> H</TT>.</LI>
<LI> <TT>p</TT>: SHARED-Variablen werden in einem Format abgelegt, das
    die Einbindung in den<TT> CONST</TT>-Block eines Pascal- oder
    Modula-Programms erlaubt. Die Endung der Datei ist<TT>
    INC</TT>.</LI>
<LI> <TT>a</TT>: SHARED-Variablen werden in einem Format abgelegt, das
    die Einbindung in eine Assembler-Quelldatei erlaubt. Die Endung
    der Datei ist<TT> INC</TT>.</LI>
</UL>
Zu Sinn und Funktion der SHARED-Symbole siehe Kapitel <A
HREF="#ref_ChapShareMain">2.12</A> bzw. <A
HREF="#ref_ChapShareOrder">3.9.1</A>.
<UL>
<LI> <TT>g [Format]</TT>: Mit diesem Schalter erzeugt AS zus&auml;tzlich
    eine Datei, die Debug-Informationen f&uuml;r dieses Programm
    enth&auml;lt. Als Format ist dabei entweder ein AS-eigenes Format
    (<TT> Format=MAP</TT>), eine NoICE-kompatible Kommandodatei (<TT>
    Format=NOICE</TT>) oder das Format der AVR-Tools (<TT>
    Format=ATMEL</TT>) erlaubt. Zu den im MAP-Format gespeicherten
    Informationen geh&ouml;rt zum einen die Symboltabelle, zum
    anderen eine Zuordnung von Quellzeilen zu Maschinenadressen. Eine
    genauere Beschreibung des benutzten MAP-Dateiformates findet sich
    in Abschnitt <A HREF="#ref_SectDebugFormat">5.2</A>. Die Endung
    der Datei ist<TT> MAP</TT>,<TT> NOI</TT> bzw.<TT> OBJ</TT>, je
    nach gew&auml;hltem Format. Wird keine explizite Formatangabe
    gemacht, wird das MAP-Format gew&auml;hlt.</LI>
<LI> <TT>noicemask [Wert]</TT>: Normalerweise listet AS in
    NoICE-Debuginfos nur Symbole aus dem CODE-Segment. Mit dieser
    Option und einem als Bitmaske zu verstehenden Wert lassen sich
    andere Symbole aus anderen Segmenten zuschalten. Die Zuordnung
    von Bits zu Segmenten kann Tabelle <A
    HREF="#ref_TabSegmentNums">5.1</A> entnommen werden.</LI>
<LI> <TT>w</TT>: Ausgabe von Warnungen unterdr&uuml;cken;</LI>
<LI> <TT>E [Datei]</TT>: Die von AS erzeugten Fehlermeldungen und
    Warnungen in eine Datei umleiten. Anstatt einer Datei k&ouml;nnen
    auch die 5 Standardhandles (STDIN..STDPRN) als !0 bis !4
    angegeben werden. Default ist !2, also STDERR. Wird die
    Dateiangabe weggelassen, so ist der Name der Fehlerdatei gleich
    dem der Quelldatei, nur mit der Endung<TT> LOG</TT>.</LI>
<LI> <TT>q</TT>: Dieser Schalter unterdr&uuml;ckt alle Meldungen von AS
    mit Ausnahme von Fehlermeldungen und vom Programm selber
    erzeugten Ausgaben. Die Assemblierzeit kann dadurch
    geringf&uuml;gig reduziert werden, und beim Aufruf aus einer
    Shell heraus kann man sich eine Umleitung ersparen. Der Nachteil
    ist, da&szlig; man u.U. einige Minuten ,,im Dunklen'' steht...
    Anstelle von 'q' darf auch 'quiet' geschrieben werden.</LI>
<LI> <TT>v</TT>: Dies fordert auf&uuml;hrliche Angaben an, also das
    Gegenteil zum Quiet-Modus. Die einzige Angabe, die momentat
    zus&auml;tzlich ausgegeben wird, ist die
    Versionsinformation.</LI>
<LI> <TT>version</TT>: Gibt Versionsinformationen aus und beendet
    sich.</LI>
<LI> <TT>h</TT>: Hexadezimalzahlen mit Klein- anstelle von
    Gro&szlig;buchstaben ausgeben. Diese Option ist in erster Linie
    eine Frage des pers&ouml;nlichen Geschmacks.</LI>
<LI> <TT>i &lt;Pfadliste&gt;</TT>: gibt eine Liste von Verzeichnissen an,
    in denen der Assembler automatisch nach Include-Dateien suchen
    soll, falls er diese nicht im aktuellen Verzeichnis findet. Die
    einzelnen Verzeichnisse m&uuml;ssen durch Semikolons getrennt
    werden.</LI>
<LI> <TT>u</TT>: eine Liste der in den Segmenten belegten Bereiche
    berechnen. Sie ist nur sinnvoll, falls ein Listing erzeugt wird.
    Diese Option ben&ouml;tigt erhebliche zus&auml;tzliche Speicher-
    und Rechenleistung, im Normalbetrieb sollte sie daher
    abgeschaltet sein. Da AS aber unabh&auml;ngig vom eingeschalteten
    Listing mit dieser Option auf &uuml;berlappende Speicherbelegung
    pr&uuml;ft, hat sie auch unabh&auml;ngig vom Listing einen
    gewissen Sinn...</LI>
<LI> <TT>C</TT>: erzeugt eine Liste mit Querverweisen. Aufgelistet wird,
    welche (globalen) Symbole in welchen Dateien in welchen Zeilen
    benutzt werden. Auch diese Liste wird nur generiert, falls ein
    Listing erzeugt wird und belegt w&auml;hrend der Assemblierung
    zus&auml;tzlichen Speicherplatz.</LI>
<LI> <TT>s</TT>: eine Liste aller Sektionen (s. Abschnitt <A
    HREF="#ref_ChapLocSyms">3.8</A>) ausgeben. Die Verschachtelung
    wird dabei durch Einr&uuml;ckungen angedeutet.</LI>
<LI> <TT>I</TT>: Analog zur Sektionsliste eine Liste aller bearbeiteten
    Include-Dateien ausgeben.</LI>
<LI> <TT>t &lt;Maske&gt;</TT>: Mit diesem Schalter lassen sich einzelne
    Komponenten des standardm&auml;&szlig;ig ausgegebenen
    Assembler-Listings ein-und ausblenden. Welcher Teil dabei welchem
    Bit zugeordnet ist, ist im &uuml;bern&auml;chsten Abschnitt, der
    genauer auf das Format des Assembler Listings eingeht,
    nachgelesen werden.</LI>
<LI> <TT>D &lt;Symbolliste&gt;</TT>: Symbole definieren. Die hinter
    dieser Option angegebenen, durch Kommas getrennten Symbole werden
    in der globalen Symboltabelle vor Beginn der Assemblierung
    abgelegt. Defaultm&auml;&szlig;ig werden diese Symbole als ganze
    Zahlen mit dem Wert TRUE abgelegt, mit einem nachgestellten
    Gleichheitszeichen kann aber auch eine andere Belegung
    gew&auml;hlt werden. Der dem Gleichheitszeichen folgende Ausdruck
    darf dabei auch Operatoren oder interne Funktionen beinhalten,
    jedoch<B> KEINE</B> anderen Symbole, selbst wenn diese schon
    davor in der Liste definiert sein sollten! Zusammen mit den
    Befehlen zur bedingten Assemblierung (siehe dort) k&ouml;nnen so
    per Kommandozeile aus einer Quelldatei unterschiedliche
    Programmversionen erzeugt werden.<B> ACHTUNG!</B> Wenn
    case-sensitiv gearbeitet werden soll, mu&szlig; dies in der
    Kommandozeile<EM> vor</EM> Symboldefinitionen angegeben werden,
    sonst werden Symbolnamen schon an dieser Stelle in
    Gro&szlig;buchstaben umgewandelt!</LI>
<LI> <TT>A</TT>: Die Liste globaler Symbole in einer anderen, kompakteren
    Form ablegen. Verwenden Sie diese Option, wenn der Assembler bei
    langen Symboltabellen mit einem Stapel&uuml;berlauf
    abst&uuml;rzt. Eventuell kann diese Option die
    Arbeitsgeschwindigkeit des Assemblers erh&ouml;hen, dies
    h&auml;ngt jedoch von den Quellen ab.</LI>
<LI> <TT>x</TT>: Legt die Ausf&uuml;hrlichkeitsstufe von Fehlermeldungen
    fest. Jedes Mal, wenn diese Option angegeben wird, wird die Stufe
    um eins erh&ouml;ht oder gesenkt. W&auml;hrend auf Stufe 0
    (Vorgabe) nur der Fehler selber ausgegeben wird, wird ab Stufe 1
    noch eine erweiterte Meldung ausgegeben, anhand der die
    Identifizierung des Fehlers erleichtert werden soll. Welche
    Fehlermeldungen welche Zusatzinformationen tragen k&ouml;nnen,
    steht in Anhang <A HREF="#ref_ChapErrMess">A</A> mit der Liste
    aller Fehlermeldungen. Auf Stufe 2 (Maximum) wird zus&auml;tzlich
    noch die betroffene Quellzeile mit ausgegeben.</LI>
<LI> <TT>n</TT>: Wird diese Option angegeben, so werden Fehlermeldungen
    nicht nur mit ihrem Klartext, sondern auch mit ihren im Anhang <A
    HREF="#ref_ChapErrMess">A</A> genannten internen Nummern
    ausgegeben. Diese Option ist prim&auml;r f&uuml;r Shells und
    Entwicklungsumgebungen gedacht, denen mit diesen Nummern die
    Identifizierung von Fehlern erleichtert werden soll.</LI>
<LI> <TT>U</TT>: Mit dieser Option schaltet man AS in den case-sensitiven
    Modus um, d.h. in Namen von Symbolen, Sektionen, Makros,
    Zeichentabellen und selbst definierte Funktionen werden Klein-
    und Gro&szlig;buchstaben unterschieden, was normalerweise nicht
    der Fall ist.</LI>
<LI> <TT>P</TT>: weist AS an, den von Makroprozessor und bedingter
    Assemblierung bearbeiteten Quelltext in einer Datei abzulegen.
    Dieser Datei fehlen zus&auml;tzlich Leer- und reine
    Kommentarzeilen. Die Endung der Datei ist<TT> I</TT>.</LI>
<LI> <TT>M</TT>: mit diesem Schalter erzeugt AS eine Datei, in der die
    Definitionen der Makros aus der Quelldatei abgespeichert werden,
    die die<TT> EXPORT</TT>-Option verwenden. Diese neue Datei hat
    den gleichen Namen wie die Quelldatei, lediglich die Endung wird
    in<TT> MAC</TT> ge&auml;ndert.</LI>
<LI> <TT>G</TT>: Dieser Schalter bestimmt, ob AS Code erzeugen soll oder
    nicht. Ist er ausgeschaltet, wird die Datei zwar assembliert,
    aber keine Code-Datei geschrieben. Dieser Schalter ist
    defaultm&auml;&szlig;ig aktiviert (logisch, sonst bek&auml;me man
    ja auch gar kein Code-File).</LI>
<LI> <TT>r [n]</TT>: Warnungen ausgeben, falls Situationen eintreten, die
    einen weiteren Pass erfordern. Diese Information kann genutzt
    werden, um die Anzahl der Durchl&auml;ufe zu verringern. Optional
    kann man die Nummer des Passes angeben, ab dem diese Warnungen
    erzeugt werden; ohne Angabe kommen die Warnungen ab dem ersten
    Pass. Machen Sie sich aber so oder so auf einen ziemlichen Haufen
    an Meldungen gefa&szlig;t!!</LI>
<LI> <TT>bigendian</TT>: Mit diesem Schalter schaltet man vom Beginn des
    Programms die Ablage von Werten im Speicher im Big Endian Modus
    ein, sofern die Zielarchitektur den gleichnamigen Pseudobefehl
    unterst&uuml;tzt (siehe Abschnitt <A
    HREF="#ref_SectBIGENDIAN">3.2.14</A>).</LI>
<LI> <TT>plainbase</TT>: Mit diesem Schalter erlaubt man vom Beginn des
    Programms an das Fortlassen eines leeren Indexarguments (siehe
    Abschnitt <A HREF="#ref_SectPLAINBASE">3.2.13</A>).</LI>
<LI> <TT>underscore-macroargs</TT>: Erlaubt die Verwendung von
    Unterstrichen in Namen von Makro-Argumenten (siehe <A
    HREF="#ref_SectMacros">3.4.1</A>).</LI>
<LI> <TT>relaxed</TT>: Mit diesem Schalter aktiviert man den
    RELAXED-Modus vom Beginn des Programms an, der ansonsten erst
    durch die gleichnamige Pseudoanweisung (siehe Abschnitt <A
    HREF="#ref_SectRELAXED">3.9.7</A>) eingeschaltet werden
    mu&szlig;.</LI>
<LI> <TT>intsyntax</TT>: Mit diesem Schalter kann man vom Beginn des
    Programms an die Liste der erlaubten Schreibweisen f&uuml;r
    Ganzzahl-Konstanten erweitern oder reduzieren, analog zur
    gleichnamigen Pseudoanweisung (siehe Abschnitt <A
    HREF="#ref_SectINTSYNTAX">3.9.6</A> f&uuml;r eine Liste erlauber
    Argumente).</LI>
<LI> <TT>supmode</TT>: Mit diesem Schalter erlaubt man vom Beginn des
    Programms an die Verwendung von Maschinenbefehlen, die nur im
    Supervisor-Modus des Prozessors verwendet werden d&uuml;rfen
    (siehe Abschnitt <A HREF="#ref_SectSUPMODE">3.2.4</A>).</LI>
<LI> <TT>Y</TT>: Mit diesem Schalter weist man AS an, alle
    Fehlermeldungen wegen zu langer Sprungdistanzen zu verwerfen,
    sobald die Notwendigkeit eines neuen Durchlaufs feststeht. In
    welchen (seltenen) Situationen dieser Schalter notwendig ist,
    kann man in Abschnitt <A HREF="#ref_ForwRefs">2.10</A>
    nachlesen.</LI>
<LI> <TT>cpu &lt;Name&gt;</TT>: Hiermit kann man man den Zielprozessor
    vorgeben, f&uuml;r den AS Code erzeugen soll, wenn die Quelldatei
    keinen<TT> CPU</TT>-Befehl enth&auml;lt. Falls das gew&auml;hlte
    Ziel CPU-Argumente unterst&uuml;tzt (siehe Abschnitt <A
    HREF="#ref_SectCPU">3.2.3</A>), k&ouml;nnen diese auch hier
    angegeben werden. Ein Aufruf mit ? oder<TT> list</TT> als
    Argument listet alle implementierten Zielprozessoren auf.</LI>
<LI> <TT>alias &lt;neu&gt;=&lt;alt&gt;</TT>:<BR>
    definiert den Prozessortyp<TT> &lt;neu&gt;</TT> als einen Alias
    f&uuml;r den Typen<TT> &lt;alt&gt;</TT>. Zu den Sinn und Zweck
    von Aliasen siehe Abschnitt <A
    HREF="#ref_SectAlias">2.13</A></LI>
<LI> <TT> gnuerrors</TT>: Meldungen &uuml;ber Fehler bzw. Warnungen und
    deren Position nicht im Standardformat von AS, sondern in einem
    dem GNU C-Compiler entlehnten Format anzeigen. Dies erleichtert
    die Integration von AS in f&uuml;r dieses Format ausgelegte
    Umgebungen, unterdr&uuml;ckt aber gleichzeitig die Anzeige der
    pr&auml;zisen Fehlerposition innerhalb Makror&uuml;mpfen!</LI>
<LI> <TT> maxerrors [n]</TT>: Weist den Assembler an, nach der gegebenen
    Anzahl von Fehlern die Assemblierung abzubrechen.</LI>
<LI> <TT> maxinclevel [n]</TT>: Weist den Assembler an, nach der
    gegebenen Include-Verschachtelungstiefe abzubrechen (Default ist
    200).</LI>
<LI> <TT> Werror</TT>: Weist den Assembler an, Warnungen als Fehler zu
    behandeln.</LI>
<LI> <TT> wrelative</TT> bzw.<TT> wno-relative</TT>: Weist den Assembler
    an, Warnungen auszugeben, falls ein relativer anstelle eines
    absoluten Sprungs m&ouml;glich ist (nur f&uuml;r
    Z80-Target).</LI>
<LI> <TT> wsign-extension</TT> bzw.<TT> wno-sign-extension</TT>: Weist
    den Assembler an, Warnungen &uuml;ber implizite
    Vorzeichen-Erweiterungen auszugeben (nur 68K, MOVEQ).</LI>
<LI> <TT>compmode</TT>: Dieser Schalter weist den Assembler an, im
    Default im Kompatibilit&auml;tsmodus zu arbeiten. Genauere
    Informationen zu diesem Modus finden sich im Abschnitt <A
    HREF="#ref_SectCompMode">3.9.8</A>.</LI>
<LI> <TT>packing</TT>: Dieser Schalter &uuml;bersteuert den Architektur-
    abh&auml;ngigen Default f&uuml;r die<TT> PACKING</TT>-Option
    (siehe Abschnitt <A HREF="#ref_SectPACKING">3.2.9</A>).</LI>
</UL>
Sofern Schalter keine Argumente ben&ouml;tigen und ihre
Zusammenziehung keinen mehrbuchstabigen Schalter ergibt, k&ouml;nnen
mehrere Schalter auch auf einen Rutsch angegeben werden, wie z.B im
folgenden Beispiel:
<PRE>

 asl test*.asm firstprog -cl /i c:\as\8051\include

</PRE>
Es werden alle Dateien TEST*.ASM sowie die Datei FIRSTPROG.ASM
assembliert, wobei f&uuml;r alle Dateien Listings auf der Konsole
ausgegeben und Sharefiles im C-Format erzeugt werden. Nach Includes
soll der Assembler zus&auml;tzlich im Verzeichnis  C:\AS\8051\INCLUDE
suchen.
<P>
Dieses Beispiel zeigt nebenbei, da&szlig; AS als Defaultendung
f&uuml;r Quelldateien<TT> ASM</TT> annimmt.
<P>
Etwas Vorsicht ist bei Schaltern angebracht, die ein optionales
Argument haben: Folgt auf einen solchen Schalter ohne Argument ein
Dateiname, so versucht AS, diesen als Argument zu verwerten, was
naturgem&auml;&szlig; schief geht:
<PRE>

 as -g test.asm

</PRE>
Die L&ouml;sung w&auml;re in diesem Fall, die<TT> -g</TT>-Option ans
Ende der Kommandozeile zu setzen oder ein explizites<TT>
MAP</TT>-Argument zu spezifizieren.
<P>
Neben der Angabe in der Kommandozeile k&ouml;nnen dauernd
ben&ouml;tigte Optionen in der Environment-Variablen ASCMD abgelegt
werden. Wer z.B. immer Listdateien haben m&ouml;chte und ein festes
Include-Verzeichnis hat, kann sich mit dem Befehl
<PRE>

 set ASCMD=-L -i c:\as\8051\include

</PRE>
eine Menge Tipparbeit ersparen. Da die Environment-Optionen vor der
Kommandozeile abgearbeitet werden, k&ouml;nnen Optionen in der
Kommandozeile widersprechende im Environment &uuml;bersteuern.
<P>
Bei sehr langen Pfaden kann es jedoch auch in der ASCMD-Variablen eng
werden. F&uuml;r solche F&auml;lle kann auf eine sogenannte<I>
Key</I>-Datei ausgewichen werden, in der die Optionen genauso wie in
der Kommandozeile oder ASCMD-Variablen abgelegt werden k&ouml;nnen,
nur da&szlig; diese Datei mehrere Zeilen mit jeweils maximal 255
Zeichen enthalten darf. Wichtig ist dabei, da&szlig; bei Optionen,
die ein Argument ben&ouml;tigen, sowohl Schalter als auch Argument
in<B> einer</B> Zeile stehen m&uuml;ssen. Der Name der Datei wird AS
dadurch mitgeteilt, da&szlig; er mit einem vorangestellten
Klammeraffen in der ASCMD-Variablen abgelegt wird, z.B.
<PRE>

 set ASCMD=@c:\as\as.key

</PRE>
Um Optionen in der ASCMD-Variablen (oder der Key-Datei) wieder
aufzuheben, kann die Option mit einem vorangestellten Pluszeichen
wieder aufgehoben werden. Soll in einem Einzelfall z.B. doch kein
Listing erzeugt werden, so kann es mit
<PRE>

 as +L &lt;Datei&gt;

</PRE>
wieder aufgehoben werden. Nat&uuml;rlich ist es nicht ganz logisch,
eine Option mit einem Pluszeichen zu negieren...UNIX soit qui mal y
pense.
<P>
Referenzen auf eine Key-Datei k&ouml;nnen nicht nur von der<TT>
ASCMD</TT>-Variablen aus erfolgen, sondern auch direkt von der
Kommandozeile aus, indem man analog zur<TT> ASCMD</TT>-Variablen dem
Dateinamen einen Klammeraffen voranstellt:
<PRE>

 as @&lt;Datei&gt; ....

</PRE>
Die in einem solchen Fall aus dem Key-File gelesenen Optionen werden
so eingearbeitet, als h&auml;tten sie anstelle dieser Referenz in der
Kommandozeile gestanden - es ist also<EM> nicht</EM> wie bei der<TT>
ASCMD</TT>-Variablen so, da&szlig; sie vor allen anderen
Kommandozeilenoptionen abgearbeitet werden w&uuml;rden.
<P>
Das Referenzieren eines Key-Files von einem Key-File selber ist nicht
erlaubt und wird von AS mit einer Fehlermeldung quittiert.
<P>
F&uuml;r den Fall, da&szlig; Sie AS von einem anderen Programm oder
einer Shell aufrufen wollen und diese Shell nur Klein- oder
Gro&szlig;buchstaben in der Kommandozeile &uuml;bergeben will,
existiert folgendes Workaround: Wird vor den Buchstaben der Option
eine Tilde gesetzt, so werden die folgenden Buchstaben immer als
Kleinbuchstaben interpretiert. Analog erzwingt ein Lattenzaun die
Interpretation als Gro&szlig;buchstaben. Es ergeben sich z.B.
folgende Transformationen:
<BLOCKQUOTE>
    <TT> /~I &#10230; /i<BR>
    -#u &#10230; -U</TT>
</BLOCKQUOTE>
<P>
Abh&auml;ngig vom Ablauf der Assemblierung endet der Assembler mit
folgenden Returncodes:
<DL COMPACT>
<DT>0<DD>fehlerfreier Ablauf, h&ouml;chstens Warnungen aufgetreten</DD>
<DT>1<DD>Der Assembler hat nur die Aufrufparameter ausgegeben und endete
    danach sofort.</DD>
<DT>2<DD>Es sind Fehler bei der Assemblierung aufgetreten, es wurde keine
    Code-Datei erzeugt.</DD>
<DT>3<DD>Es trat ein fataler Fehler w&auml;hrend des Ablaufes auf, der zum
    sofortigen Abbruch gef&uuml;hrt hat.</DD>
<DT>4<DD>Bereits w&auml;hrend des Starts des Assemblers ist ein Fehler
    aufgetreten. Dies kann ein Parameterfehler oder eine fehlerhafte
    Overlay-Datei sein.</DD>
<DT>255<DD>Bei der Initialisierung ist irgendein interner Fehler aufgetreten,
    der auf keinen Fall auftreten sollte...neu booten, noch einmal
    probieren, und bei Reproduzierbarkeit mit mir Verbindung
    aufnehmen!</DD>
</DL>
<P>
Zus&auml;tzlich endet jede Assemblierung einer Datei mit einer
kleinen Statistik, die Fehlerzahlen, Laufzeit, Anzahl der
Durchl&auml;ufe und freien Speicher ausgibt. Bei eingeschaltetem
Assembler-Listing wird diese Statistik zus&auml;tzlich auch in das
Listing geschrieben.
<P>
OS/2 erweitert wie Unix das Datensegment einer Anwendung erst dann,      
wenn sie wirklich mehr Speicher anfordert. Eine Angabe wie
<BLOCKQUOTE>
    <TT> 511 KByte verf&uuml;gbarer Restspeicher</TT>
</BLOCKQUOTE>
bedeutet also nicht einen nahenden Systemabsturz wegen
Speichermangel, sondern stellt nur den Abstand zu der Grenze dar, bei
der OS/2 einfach ein paar mehr Kohlen in den Ofen schaufelt...
<P>
Da es unter C auf verschiedenen Betriebssystemen keine kompatible        
M&ouml;glichkeit gibt, den noch verf&uuml;gbaren Speicher bzw. Stack
zu ermitteln, fehlen bei der C-Version diese beiden Angaben ganz.
<P>

<H2><A NAME="sect_2_5_">2.5. Format der Eingabedateien</A></H2>
<A NAME="ref_AttrTypes"></A>
<P>
Wie die meisten Assembler auch erwartet AS genau einen Befehl pro
Zeile (Leerzeilen sind nat&uuml;rlich auch zugelassen). Die Zeilen
d&uuml;rfen nicht l&auml;nger als 255 Zeichen werden, dar&uuml;ber
hinaus gehende Zeichen werden abgeschnitten.
<P>
Eine einzelne Zeile hat folgendes Format:
<PRE>

[Label[:]]&lt;Befehl&gt;[.Attribut] [Parameter[,Parameter..]] [;Kommentar]

</PRE>
Eine Zeile darf dabei auch &uuml;ber mehrere Zeilen in der Quelldatei
verteilt sein, Folgezeichen (\) verketten diese Teile dann zu einer
einzigen Zeile. Zu beachten ist allerdings, da&szlig; aufgrund der
internen Pufferstruktur die Gesamtzeile nicht 256 Zeichen
&uuml;berschreiten darf. Zeilenangaben in Fehlermeldungen beziehen
sich immer auf die letzte Zeile einer solchen zusammengesetzten
Zeile.
<P>
Der Doppelpunkt nach dem Label ist optional, falls das Label in der
ersten Spalte beginnt (woraus folgt, da&szlig; ein Befehl, sei es ein
Maschinen- oder Pseudobefehl niemals in Spalte 1 beginnen darf). Man
mu&szlig; ihn aber setzen, falls das Label nicht in der ersten Spalte
beginnt, damit AS es von einem Befehl unterscheiden kann. In
letzterem Fall mu&szlig; &uuml;brigens zwischen Doppelpunkt und dem
Befehl mindestens ein Leerzeichen stehen, falls der eingestellte
Zielprozessor zu denjenigen geh&ouml;rt, bei denen das Attribut auch
eine mit einem Doppelpunkt abgetrennte Formatangabe sein darf. Diese
Einschr&auml;nkung ist aus Eindeutigkeits-Gr&uuml;nden n&ouml;tig, da
sonst keine Unterscheidung zwischen Befehl mit Format und Label mit
Befehl m&ouml;glich w&auml;re.
<P>
Einige Signalprozessorreihen von Texas Instruments verwenden den
f&uuml;r das Label vorgesehenen Platz wahlweise auch f&uuml;r einen
Doppelstrich (||), der die parallele Ausf&uuml;hrung mit der
vorangehenden Instruktion anzeigt. Wenn diese beiden Instruktionen
auf Maschinenebene in einem einzigen Wort vereinigt werden (C3x/C4x),
macht ein zus&auml;tzliches Label vor der zweiten Anweisung
nat&uuml;rlich keinen Sinn und ist auch nicht vorgesehen. Anders
sieht es beim C6x mit seinen Instruktionspaketen variabler L&auml;nge
aus: Wer dort (unsch&ouml;nerweise...) mitten in ein Paket hinein
springen will, mu&szlig; das Label daf&uuml;r in eine Extrazeile
davor setzen (das gleiche gilt &uuml;brigens auch f&uuml;r
Bedingungen, die aber zusammen mit dem Doppelstrich in einer Zeile
stehen d&uuml;rfen).
<P>
Das Attribut wird von einer Reihe von Prozessoren benutzt, um
Spezialisierungen oder Kodierungsvarianten eines bestimmten Befehls
zu spezifizieren. Die bekannteste Nutzung des Attributs ist die
Angabe der Operandengr&ouml;&szlig;e, wie z. B. bei der 680x0-Familie
(Tabelle <A HREF="#ref_TabAttrs">2.3</A>).

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Attribut</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>arithmetisch-logischer Befehl</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Sprungbefehl</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>B<BR>
W<BR>
L<BR>
Q<BR>
C<BR>
S<BR>
D<BR>
X<BR>
P</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Byte (8 Bit)<BR>
Wort (16 Bit)<BR>
Langwort (32 Bit)<BR>
Vierfachwort (64 Bit)<BR>
Half Precision (16 Bit)<BR>
Single Precision (32 Bit)<BR>
Double Precision (64 Bit)<BR>
Extended Precision (80/96 Bit)<BR>
Dezimalgleitkomma (80/96 Bit)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>8-bit-displacement<BR>
16-Bit-Displacement<BR>
16-Bit-Displacement<BR>
---------<BR>
---------<BR>
8-Bit-Displacement<BR>
---------<BR>
32-Bit-Displacement<BR>
---------</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.3: Erlaubte Attribute (Beispiel 680x0)<A
             NAME="ref_TabAttrs"></A>
</CENTER><P>

<P>
Da sich diese Anleitung nicht gleichzeitig als Handbuch f&uuml;r die
von AS unterst&uuml;tzten Prozessorfamilien versteht, ist dies leider
auch nicht der richtige Platz, um hier alle m&ouml;glichen Attribute
f&uuml;r alle unterst&uuml;tzten Familien aufzuz&auml;hlen. Es sei
aber angemerkt, da&szlig; i.a. nicht alle Befehle alle Attribute
zulassen, andererseits das Fortlassen eines Attributs meist zur
Verwendung der f&uuml;r diese Familie ,,nat&uuml;rlichen''
Operandengr&ouml;&szlig;e f&uuml;hrt. Zum genaueren Studium greife
man auf ein Programmierhandbuch f&uuml;r die jeweilige Familie
zur&uuml;ck, z.B. in <A HREF="#cite_Williams">[1]</A> f&uuml;r die
68000er.
<P>
Bei TLCS-9000, H8/500 und M16(C) dient das Attribut sowohl der Angabe
der Operandengr&ouml;&szlig;e, falls diese nicht durch die Operanden
klar sein sollte, als auch der des zu verwendenden Befehlsformates.
Dieses mu&szlig; durch einen Doppelpunkt von der
Operandengr&ouml;&szlig;e getrennt werden, z.B. so:
<PRE>

    add.w:g   rw10,rw8

</PRE>
Was dieses Beispiel nicht zeigt, ist, da&szlig; die Formatangabe auch
ohne Operandengr&ouml;&szlig;e geschrieben werden darf. Steht
demgegen&uuml;ber eine Operandengr&ouml;&szlig;e ohne Formatangabe,
verwendet AS automatisch das k&uuml;rzeste Format. Die erlaubten
Befehlsformate und Operandengr&ouml;&szlig;en sind vom
Maschinenbefehl abh&auml;ngig und k&ouml;nnen z.B. <A
HREF="#cite_Tosh9000">[169]</A>, <A HREF="#cite_HitH8_5">[35]</A>, <A
HREF="#cite_MitM16">[66]</A> bzw. <A HREF="#cite_MitM16C">[67]</A>
entnommen werden.
<P>
Die Zahl der Befehlsparameter ist abh&auml;ngig vom Befehl und kann
prinzipiell zwischen 0 und 20 liegen. Die Trennung der Parameter
voneinander erfolgt ausschlie&szlig;lich durch Kommas (Ausnahme:
DSP56xxx, dessen parallele Datentransfers durch Leerzeichen getrennt
werden), wobei in Klammern oder Hochkommas eingeschlossene Kommas
nat&uuml;rlich nicht beachtet werden.
<P>
Anstelle eines Kommentars am Ende kann die Zeile auch nur aus einem
Kommentar bestehen, wenn er in der ersten Spalte beginnt.
<P>
Bei den Leerzeichen zur Trennung einzelnen Komponenten darf es sich
genauso gut um Tabulatoren handeln.
<P>

<H2><A NAME="sect_2_6_">2.6. Format des Listings</A></H2>
<A NAME="ref_SectListing"></A>
<P>
Das von AS bei Angabe der Kommandozeilenoptionen<TT> l</TT> oder<TT>
L</TT> erzeugte Listing l&auml;&szlig;t sich grob in folgende Teile
gliedern:
<OL>
<LI>Erg&auml;nzte Wiedergabe des assemblierten Quellcodes;</LI>
<LI>Symbolliste;</LI>
<LI>Makroliste;</LI>
<LI>Funktionsliste;</LI>
<LI>Belegungsliste;</LI>
<LI>Querverweisliste.</LI>
</OL>
Letztere beide werden nur erzeugt, wenn sie durch zus&auml;tzliche
Kommandozeilenoptionen angefordert wurden.
<P>
Im ersten Teil listet AS den kompletten Inhalt aller Quelldateien
inklusive des erzeugten Codes auf. Eine Zeile in diesem Listing hat
dabei folgende Form:
<PRE>

[&lt;n&gt;] &lt;Zeile&gt;/&lt;Adresse&gt; &lt;Code&gt; &lt;Quelle&gt;

</PRE>
Im Feld n zeigt AS die Include-Verschachtelungstiefe an. Die
Hauptdatei (die Datei, mit der die Assemblierung begann), hat dabei
die Tiefe 0, von dort aus eingebundene Dateien haben Tiefe 1 usw. Die
Tiefe 0 wird dabei nicht angezeigt: F&uuml;r Zeilen der Hauptdatei
wird dieses Feld durch eine passende Zahl von Leerzeichen ersetzt,
oder g&auml;nzlich fortgelassen, falls es bisher gar keine
Include-Anweisungen gegeben hat. Das 'Ged&auml;chtnis', ob es
Include-Anweisungen gegeben hat, und bis zu welcher Tiefe, reicht
&uuml;ber den einzelnen Pass hinaus. Auf diese Weise 'lernt' der
Assembler im ersten Pass die maximale Tiefe und kann in folgenden
Durchl&auml;ufen dieses Feld mit durchgehend gleicher Breite
ausgeben.
<P>
Im Feld<TT> Zeile</TT> wird die Zeilennummer bezogen auf die
jeweilige Datei ausgegeben. Die erste Zeile einer Datei hat dabei
Nummer 1. Die Adresse, an der der f&uuml;r diese Zeile erzeugte Code
abgelegt wurde, folgt hinter dem Schr&auml;gstrich im Feld<TT>
Adresse</TT>. Das daf&uuml;r verwendete Zahlensystem wird durch
den<TT> listradix</TT>-Schalter festgelegt (<A
HREF="#ref_listradix">2.4</A>), ebenso ob der Wert mit f&uuml;hrenden
Nullen angezeigt werden soll oder nicht. Das gerade aktuell
verwendete Target mit der Gr&ouml;&szlig;e seines Adre&szlig;raumes
bestimmt die Breite des Feldes: F&uuml;r einen Prozessor mit 64 KByte
Adre&szlig;raum sind nur 4 Hex-Stellen erforderlich, bei 4 GByte
dagegen acht.
<P>
Der erzeugte Code selber steht dahinter im Feld<TT> Code</TT>,
ebenfalls im durch den List-Radix gegebenen Zahlensystem. Je nach
Prozessortyp und aktuellem Segment bzw. Adre&szlig;raum k&ouml;nnen
die Werte dabei mit unterschiedlicher L&auml;nge formatiert sein. Das
k&ouml;nnen Bytes mit 8 Bits sein, aber auch Worte mit 16 oder 32
Bits, wenn der gerade genutzte Adre&szlig;raum nicht
Byte-adressierbar ist, oder die Instruktionsworte des Prozessors
l&auml;nger als 8 Bit sind. Dies ist z.B. beim 68000 oder der PDP-11
der Fall: Deren Adre&szlig;raum ist Byte-weise organisiert,
Instruktionsworte sind aber 16 Bit lang. Bei einigen wenigen Targets
sind auch L&auml;ngen m&ouml;glich, die nicht ein mehrfaches von 8
Bit betragen, zum Beispiel 12 Bit bei der PDP-8.
<P>
Bei Vorw&auml;rtsreferenzen gibt es im ersten Durchlauf die
Situation, dass der endg&uuml;ltige Code gar nicht angegeben werden
kann. AS macht dann eine Annahme f&uuml;r den Wert, der die weitere
Assemblierung nicht st&ouml;rt. Bei einer (zunehmenden) Zahl von
Targets werden diese Felder im Code auch explizit mit Fragezeichen
angezeigt. Die folgenden Targets unterst&uuml;tzen dies aktuell:
<UL>
<LI> 65xx/65XXX</LI>
<LI> 6800/6805/68HC08/6809/68HC11/68HC12</LI>
<LI> 8080/8085</LI>
<LI> (e)Z80/Z180/Z280/Z380</LI>
<LI> 8048</LI>
<LI> 8051/80251</LI>
<LI> 8096/80196/80296</LI>
<LI> 8086/V20...V55</LI>
<LI> AVR</LI>
<LI> TMS370xxx</LI>
</UL>
Falls die Fragezeichen beim Weiterverarbeiten des Listings
st&ouml;ren, k&auml;nn diese Funktion &uuml;ber den
Kommandozeilen-Schalter<TT> -no-list-unknown-values</TT> abgeschaltet
werden.
<P>
Sollte mehr Code erzeugt worden sein, als in das Feld
hineinpa&szlig;t, so werden im Anschlu&szlig; an die Zeile weitere
Zeilen erzeugt, in denen nur dieses Feld belegt ist.
<P>
Im Feld<TT> Quelle</TT> schlu&szlig;endlich wird die Zeile aus der
Quelldatei in ihrer Originalform ausgegeben.
<P>
Die Struktur der Daten vor der Quellcode-Zeile wird intern durch
einen Formatstring gesteuert, der &uuml;ber die
Kommandozeilen-Option<TT> -listline-prefix</TT> ge&auml;ndert werden
kann. Dieser darf folgende Platzhalter enthalten:
<UL>
<LI> <TT> %[c]i</TT>: Die aktuelle Include-Verschachtelungstiefe, mit
    optionaler Feldbreite. Ohne Feldbreite wird dies auf gar nichts
    oder eine passende Menge Leerzeichen expandiert, falls die Tiefe
    Null ist.</LI>
<LI> <TT> %[c]n</TT>: Die aktuelle Zeilennummer, mit einer optionalen
    Feldbreite, in der die Zeilennummer rechtsb&uuml;ndig ausgegeben
    wird. Der Default f&uuml;r die Feldbreite ist f&uuml;nf
    Zeichen.</LI>
<LI> <TT> %[c]a</TT>: Analog die aktuelle Speicheradresse, wobei der
    Default der Feldbreite der oben erw&auml;hnte,
    Target-abh&auml;ngige Wert ist.</LI>
</UL>
In allen drei F&auml;llen bedeutet eine f&uuml;hrende Null bei einer
Feldbreite, da&szlig; links mit Nullen anstelle von Leerzeichen
aufgef&uuml;llt werden soll. Der Default f&uuml;r diesen Formatstring
ist %i%n/%a. Um eine Ausgabe zu erhalten, wie sie Versionen von AS
vor 1.42 Build 249 erzeugten, kann als Formatstring %1i%5n/%8a
verwendet werden.
<P>
Die Symboltabelle ist so ausgelegt, da&szlig; sie nach
M&ouml;glichkeit immer in 80 Spalten dargestellt werden kann.
F&uuml;r Symbole ,,normaler L&auml;nge'' wird eine zweispaltige
Ausgabe gew&auml;hlt. Sollten einzelne Symbole mit ihrem Wert die
Grenze von 40 Spalten &uuml;berschreiten, werden sie in einer
einzelnen Zeile ausgegeben. Die Ausgabe erfolgt in alphabetischer
Reihenfolge. Symbole, die zwar definiert, aber nie benutzt wurden,
werden mit einem vorangestellten Stern (*) gekennzeichnet.
<P>
Die bisher genannten Teile sowie die Auflistung aller definierten
Makros / Funktionen lassen sich selektiv aus dem Gesamtlisting
ein-und ausblenden, und zwar mit dem bereits erw&auml;hnten<TT>
t</TT>-Kommandozeilenschalter. Intern existiert in AS ein Byte,
dessen Bits repr&auml;sentieren, welche Teile ausgegeben werden
sollen. Die Zuordnung von Bits zu den Teilen ist in Tabelle <A
HREF="#ref_TabTBits">2.4</A> aufgelistet.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bit</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Teil</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0<BR>
1<BR>
2<BR>
3<BR>
4<BR>
5<BR>
7</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Quelldatei(en)+erzeugter Code<BR>
Symboltabelle<BR>
Makroliste<BR>
Funktionsliste<BR>
Zeilennumerierung<BR>
Registersymboltabelle<BR>
Zeichentabellenliste</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.4: Zuordnung der Bits zu den Listingkomponenten<A
             NAME="ref_TabTBits"></A>
</CENTER><P>

Defaultm&auml;&szlig;ig sind alle Bits auf 1 gesetzt, bei Verwendung
des Schalters
<PRE>

-t &lt;Maske&gt;

</PRE>
werden die in &lt;Maske&gt; gesetzten Bits gel&ouml;scht, so
da&szlig; die entsprechenden Listing-Teile unterdr&uuml;ckt werden.
Analog lassen sich mit einem Pluszeichen einzelne Teile wieder
einschalten, falls man es in der<TT> ASCMD</TT>-Variablen
&uuml;bertrieben hat...will man z.B. nur die Symboltabelle haben, so
reicht
<PRE>

-t 2  .

</PRE>
In der Belegungsliste werden f&uuml;r jedes Segment einzeln die
belegten Bereiche hexadezimal ausgegeben. Handelt es sich bei einem
Bereich um eine einzige Adresse, wird nur diese ausgegeben, ansonsten
erste und letzte Adresse.
<P>
In der Querverweisliste wird f&uuml;r jedes definierte Symbol in
alphabetischer Reihenfolge eine Ausgabe folgender Form erzeugt:
<PRE>

Symbol &lt;Symbolname&gt; (=&lt;Wert&gt;,&lt;Datei&gt;/&lt;Zeile&gt;):
 Datei &lt;Datei 1&gt;:
 &lt;n1&gt;[(m1)]  ..... &lt;nk&gt;[(mk)]
 .
 .
 Datei &lt;Datei l&gt;:
 &lt;n1&gt;[(m1)]  ..... &lt;nk&gt;[(mk)]

</PRE>
F&uuml;r jedes Symbol wird aufgelistet, in welchen Dateien es in
welchen Zeilen angesprochen wurde. Sollte ein Symbol mehrmals in der
gleichen Zeile benutzt worden sein, so wird dies durch eine in
Klammern gesetzte Anzahl hinter der Zeilennummer angedeutet. Sollte
ein Symbol niemals benutzt worden sein, erscheint es auch nicht in
der Liste; entsprechend erscheint eine Datei auch &uuml;berhaupt
nicht in der Liste eines Symbols, falls es in der entsprechenden
Datei nicht referenziert wurde.
<P>
<B> ACHTUNG!</B> AS kann dieses Listing nur dann korrekt aufs Papier
bringen, wenn man ihm vorher die L&auml;nge und Breite des
Ausgabemediums mit Hilfe des<TT> PAGE</TT>-Befehls (siehe <A
HREF="#ref_SectPAGE">3.7.1</A>) mitgeteilt hat! Der voreingestellte
Default sind 60 Zeilen und eine unbegrenzte Zeilenbreite.
<P>

<H2><A NAME="sect_2_7_">2.7. Symbolkonventionen</A></H2>
<A NAME="ref_SectSymConv"></A>
<P>
Symbole d&uuml;rfen zwar (wie in der Einleitung bereits angedeutet)
bis zu 255 Zeichen lang werden und werden auch auf der ganzen
L&auml;nge unterschieden, die Symbolnamen m&uuml;ssen aber einigen
Konventionen gen&uuml;gen:
<P>
Symbolnamen d&uuml;rfen aus einer beliebigen Kombination von
Buchstaben, Ziffern, Unterstrichen und Punkten bestehen, wobei das
erste Zeichen keine Ziffer sein darf. Der Punkt wurde nur zugelassen,
um der MCS-51-Notation von Registerbits zu gen&uuml;gen, und sollte
m&ouml;glichst nicht in eigenen Symbolnamen verwendet werden. Zur
Segmentierung von Symbolnamen sollte auf jeden Fall der Unterstrich
und nicht der Punkt verwendet werden.
<P>
Defaultm&auml;&szlig;ig ist AS nicht case-sensitiv, es ist also egal,
ob man Gro&szlig;-oder Kleinbuchstaben verwendet. Mittels des
Kommandozeilenschalters<TT> U</TT> l&auml;&szlig;t sich AS jedoch in
einen Modus umschalten, in dem Gro&szlig;- und Kleinschreibung
unterschieden wird. Ob AS umgeschaltet wurde, kann mit dem
vordefinierten Symbol<TT> CASESENSITIVE</TT> ermittelt werden: TRUE
bedeutet Unterscheidung, FALSE keine.
<P>
Tabelle <A HREF="#ref_TabPredefined">2.5</A> zeigt die wichtigsten,
von AS vordefinierten Symbole.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> TRUE</TT><BR>
<TT> FALSE</TT><BR>
<TT> CONSTPI</TT><BR>
<TT> FLOATMAX</TT><BR>
<TT> VERSION</TT><BR>
<BR>
<TT> ARCHITECTURE</TT><BR>
<BR>
<TT> DATE</TT><BR>
<TT> TIME</TT><BR>
<TT> MOMCPU</TT><BR>
<TT> MOMCPUNAME</TT><BR>
<TT> MOMFILE</TT><BR>
<TT> MOMLINE</TT><BR>
<TT> MOMPASS</TT><BR>
<TT> MOMSECTION</TT><BR>
<BR>
<TT> MOMSEGMENT</TT><BR>
<BR>
 *, $, . bzw.<TT> PC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>logisch ,,wahr''<BR>
logisch ,,falsch''<BR>
Kreiszahl Pi (3.1415.....)<BR>
gr&ouml;&szlig;te darstellbare Gleitkommazahl<BR>
Version von AS in BCD-Kodierung,<BR>
z.B. 1331 hex f&uuml;r Version 1.33p1<BR>
Zielplattform, f&uuml;r die AS &uuml;bersetzt wurde,<BR>
in der Form Prozesor-Hersteller-Betriebssystem<BR>
Datum und<BR>
Zeitpunkt der Assemblierung (Beginn)<BR>
momentan gesetzte Ziel-CPU<BR>
dito, nur als voll ausgeschriebener String<BR>
augenblickliche Quelldatei<BR>
Zeilennummer in Quelldatei<BR>
Nummer das laufenden Durchgangs<BR>
Name der aktuellen Sektion oder<BR>
Leerstring<BR>
Name des mit<TT> SEGMENT</TT> gew&auml;hlten<BR>
Adre&szlig;raumes<BR>
mom. Programmz&auml;hler</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.5: Vordefinierte Symbole<A NAME="ref_TabPredefined"></A>
</CENTER><P>

<B> VORSICHT!</B> W&auml;hrend es im case-insensitiven Modus egal
ist, mit welcher Kombination von Gro&szlig;- und Kleinbuchstaben man
vordefinierte Symbole anspricht, mu&szlig; man sich im
case-sensitiven Modus exakt an die oben angegebene Schreibweise (nur
Gro&szlig;buchstaben) halten!
<P>
Zus&auml;tzlich definieren einige Pseudobefehle noch Symbole, die
eine Abfrage des damit momentan eingestellten Wertes
erm&ouml;glichen. Deren Beschreibung findet sich bei den
zugeh&ouml;rigen Befehlen.
<P>
Auf den meisten Plattformen ist der Name<TT> INF</TT> als Sonderwert
f&uuml;r Unendlich im Gleitkomma-Format reserviert und kann nicht
f&uuml;r eigene Symbole verwendet werden.
<P>
Ein etwas verstecktes (und mit Vorsicht zu nutzendes) Feature ist,
Symbolnamen aus String-Variablen zusammenzubauen, indem man den Namen
des Strings mit geschweiften Klammern in den Symbolnamen einbaut. So
kann man z.B. den Namen eines Symbols anhand des Wertes eines anderen
Symbols festlegen:
<PRE>

cnt		set	cnt+1
temp		equ	"\{CNT}"
		jnz	skip{temp}
		.
		.
skip{temp}:	nop

</PRE>
<B>ACHTUNG!</B> Der Programmierer ist selber daf&uuml;r
verantwortlich, da&szlig; sich dabei g&uuml;ltige Symbolnamen
ergeben!
<P>
Eine vollst&auml;ndige Auflistung aller von AS verwendeten
Symbolnamen findet sich in Anhang <A HREF="#ref_AppInternSyms">F</A>.
<P>
Neben seinem Wert besitzt auch jedes Symbol eine Markierung, zu
welchen<EM> Segment</EM> es geh&ouml;rt. In erster Linie wird eine
solche Unterscheidung bei Prozessoren ben&ouml;tigt, die mehrere
Adre&szlig;r&auml;ume besitzen. AS kann mit dieser Zusatzinformation
bei Zugriffen &uuml;ber ein Symbol warnen, wenn ein f&uuml;r diesen
Adre&szlig;raum ungeeigneter Befehl verwendet wird. Ein
Segmentattribut wird einem Symbol automatisch angeh&auml;ngt, wenn es
als Label oder mit einem Spezialbefehl (z.B.<TT> BIT</TT>) definiert
wird; ein mit dem ,,Universalbefehl''<TT> SET</TT> oder<TT> EQU</TT>
definiertes Symbol ist jedoch ,,typenlos'', d.h. seine Verwendung
wird niemals Warnungen ausl&ouml;sen. Das Segmentattribut eines
Symbols kann mit der eingebauten Funktion<TT> SYMTYPE</TT> abgefragt
werden, etwa so:
<PRE>

Label:
        .
        .
Attr    equ     symtype(Label)  ; ergibt 1

</PRE>
Den einzelnen Segmenttypen sind die in Tabelle <A
HREF="#ref_TabSegNums">2.6</A> aufgelisteten Nummern zugeordnet. Die
aus der Ordnung normaler Symbole etwas herausfallenden
Registersymbole sind n&auml;her in Abschnitt <A
HREF="#ref_SectRegSyms">2.11</A> erl&auml;utert. Mit einem
undefinierten Symbol als Argument liefert die<TT>
SYMTYPE</TT>-Funktion -1 als Ergebnis.
<P>
Ob ein Symbol definiert ist, kann mit den Funktionen<TT> DEFINED</TT>
bzw.<TT> SYMEXIST</TT> gepr&uuml;ft werden. Der Unterschied:<TT>
SYMEXIST</TT> liefert bei einer Vorw&auml;rtsdeklaration im ersten
Durchlauf ein 'false' und bei weiteren Durchl&auml;ufen ein 'true'.
Im Gegensatz dazu liefert<TT> DEFINED</TT> nur dann ein 'true', wenn
das Symbol im bis zu diesem Punkt assemblierten Code definiert wurde.
Bei Vorw&auml;rtsdeklarationen bleibt es also bei einem 'false',
unabh&auml;ngig vom Durchlauf.
<P>
<A NAME="ref_sect_symused"></A> Mittels der Funktion<TT> SYMUSED</TT>
kann abgefragt werden, ob ein Symbol bisher schon einmal verwendet
wurde. Dies schlie&szlig;t auch Bez&uuml;ge auf ein Symbol ein,
die<EM> vor</EM> seiner Definition erfolgen, falls eine der folgenden
Bedingungen erf&uuml;llt ist:
<UL>
<LI> Sowohl die Vorw&auml;rtsreferenz als auch die Definition erfolgen im
    globalen Symbol-Namensraum, d.h. au&szlig;erhalb von Sektionen
    oder expandierten Makro-Rmpfen.</LI>
<LI> Die Vorw&auml;rtsreferenz erfolgt in einer Sektion, aber
    au&szlig;erhalb eines expandierten Makro-Rumpfes, und die
    Definition erfolgt ebenfalls au&szlig;erhalb eines expandierten
    Makro-Rumpfes, in der selben Sektion, oder einer Eltern-Sektion
    dieser Sektion, oder global.</LI>
<LI> Die Vorw&auml;rtsreferenz erfolgt innerhalb eines expandierten
    Makro-Rumpfes, und die Definition im selben Makro-Rumpf.</LI>
</UL>
Falls ein Symbol auf Benutzung gepr&uuml;ft werden soll und es
Vorw&auml;rtsreferenzen gibt, die keine dieser drei Situationen
erf&uuml;llt, bleibt die M&ouml;glichkeit, ein Symbol vor der ersten
Vorw&auml;rtsreferenz mittels des<TT> FORWARD</TT>-Befehls
anzuk&uuml;ndigen. Es wird dann quasi ein 'Leereintrag' in der
Symboltabelle angelegt, an dem Vorw&auml;rtsreferenzen explizit
vermerkt werden k&ouml;nnen.
<P>
<TT> DEFINED</TT> akzeptiert nicht nur einen einfachen Symbolnamen,
sondern auch einen kompletten Formelausdruck. Der R&uuml;ckgabewert
ist in so einem Fall nur dann 'true', falls der Ausdruck keine
Symbole enth&auml;lt, die nach der im vorigen Absatz gegebenen
Erkl&auml;rung undefiniert sind.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Segment</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>R&uuml;ckgabewert</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>&lt;keines&gt;<BR>
CODE<BR>
DATA<BR>
IDATA<BR>
XDATA<BR>
YDATA<BR>
BITDATA<BR>
IO<BR>
REG<BR>
ROMDATA<BR>
EEDATA<BR>
&lt;Registersymbol&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>0<BR>
1<BR>
2<BR>
3<BR>
4<BR>
5<BR>
6<BR>
7<BR>
8<BR>
9<BR>
10<BR>
128</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.6: R&uuml;ckgabewerte der<TT> SYMTYPE</TT>-Funktion<A
             NAME="ref_TabSegNums"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_2_8_">2.8. Tempor&auml;re Symbole</A></H2>
<P>
Besonders bei Programmen mit vielen aufeinanderfolgenden Schleifen
oder IF-artigen Strukturen steht man immer wieder vor dem Problem,
sich st&auml;ndig neue Namen f&uuml;r Labels ausdenken zu
m&uuml;ssen. Dabei wei&szlig; man an sich genau, da&szlig; man dieses
Label nie wieder brauchen wird und am liebsten in irgendeiner Weise
'verwerfen' m&ouml;chte. Eine einfache L&ouml;sung, wenn man nicht
gleich den gro&szlig;en Hammer des Sektionskonzeptes (siehe Kapitel <A
HREF="#ref_ChapLocSyms">3.8</A>) schwingen m&ouml;chte, sind<EM>
tempor&auml;re</EM> Symbole, die solange ihre G&uuml;ltigkeit
behalten, bis ein neues, nicht-tempor&auml;res Symbol definiert wird.
Andere Assembler bieten einen &auml;hnlichen Mechanismus an, der dort
unter dem Stichwort 'lokale Symbole' l&auml;uft, zur besseren
Abgrenzung gegen das Sektionskonzept m&ouml;chte ich aber beim
Begriff 'tempor&auml;re Symbole' bleiben. AS kennt drei
unterschiedliche Typen von tempor&auml;ren Symbolen, um jedem
'Umsteiger' ein Konzept anzubieten, das den Umstieg so einfach wie
m&ouml;glich macht. Leider kocht quasi jeder Assembler bei diesem
Thema sein eigenes S&uuml;ppchen, so da&szlig; es nur in
Ausnahmef&auml;llen eine 1:1-L&ouml;sung f&uuml;r existierenden Code
geben wird:
<P>

<H3><A NAME="sect_2_8_1_">2.8.1. Tempor&auml;re Symbole mit Namen</A></H3>
<P>
Ein Symbol, dessen Name mit zwei Dollarzeichen beginnt (dies ist
weder f&uuml;r normale Symbole noch Konstanten zul&auml;ssig), ist
ein tempor&auml;res Symbol mit Namen. AS f&uuml;hrt intern einen
Z&auml;hler mit, der zu Beginn der Assemblierung auf Null gesetzt
wird und bei jeder Definition eines nicht-tempor&auml;ren Symbols
inkrementiert wird. Wird ein tempor&auml;res Symbol definiert oder
referenziert, so werden die beiden f&uuml;hrenden Dollarzeichen
gestrichen und der momentane Stand des Z&auml;hlers wird
angeh&auml;ngt. Auf diese Weise erh&auml;lt man mit jedem
nicht-tempor&auml;ren Symbol sozusagen die Symbolnamen zur&uuml;ck -
man kommt an die Symbole vor dieser Definition aber auch nicht mehr
heran! Tempor&auml;re Symbole bieten sich daher besonders f&uuml;r
den Einsatz in kleinen Anweisungsbl&ouml;cken an, typischerweise etwa
ein Dutzend Befehle, auf keinen Fall mehr als eine Bildschirmseite,
sonst kommt man leicht durcheinander...
<P>
Hier ein kleines Beispiel:
<PRE>

$$loop: nop
        dbra    d0,$$loop

split:

$$loop: nop
        dbra    d0,$$loop

</PRE>
W&auml;re das zwischen den Schleifen liegende nicht-tempor&auml;re
Label nicht vorhanden, g&auml;be es nat&uuml;rlich eine Fehlermeldung
wegen eines doppelt definierten Symbols.
<P>
<EM> Namenlose Tempor&auml;re Symbole</EM>
<P>
F&uuml;r all jene, denen tempor&auml;re Symbole mit Namen noch immer
zu kompliziert sind, gibt es eine noch einfachere Variante: Setzt man
als Label ein einfaches Plus- oder Minuszeichen, so werden diese in
die Namen<TT> __forwnn</TT> bzw.<TT> __backmm</TT> umgesetzt,
wobei<TT> nn</TT> bzw.<TT> mm</TT> von Null an laufende Z&auml;hler
sind. Referenziert werden diese Symbole &uuml;ber die Sonderwerte<TT>
- -- ---</TT> bzw.<TT> + ++ +++</TT>, womit sich die drei letzten
'Minussymbole' bzw die drei n&auml;chsten 'Plussymbole' referenzieren
lassen. Welche Variante man benutzt, h&auml;ngt also davon ab, ob man
ein Symbol vorw&auml;rts oder r&uuml;ckw&auml;rts referenzieren will.
<P>
Bei der<EM> Definition</EM> namenloser tempor&auml;rer Symbole gibt
es neben dem Plus- und Minuszeichen noch eine dritte Variante,
n&auml;mlich einen Schr&auml;gstrich (/). Ein so definiertes
tempor&auml;res Symbol kann gleicherma&szlig;en vorw&auml;rts wie
r&uuml;ckw&auml;rts referenziert werden; d. h. je nach Referenzierung
wird es wie ein Minus oder Plus behandelt.
<P>
Namenlose tempor&auml;re Symbole finden ihre Anwendung
&uuml;blicherweise in Konstruktionen, die auf eine Bildschirmseite
passen, wie das bedingte &Uuml;berspringen von ein paar
Maschinenbefehlen oder kleinen Schleifen - ansonsten w&uuml;rde die
Sache zu un&uuml;bersichtlich werden (das ist aber nur ein gut
gemeinter Rat...). Ein Beispiel daf&uuml;r ist das folgende
St&uuml;ck Code, zur Abwechslung mal als 65xx-Code:
<PRE>

        cpu     6502

-       ldx     #00
-       dex
        bne     -            ; springe zu 'dex'
        lda     RealSymbol
        beq     +            ; springe zu 'bne --'
        jsr     SomeRtn
        iny
+       bne     --           ; springe zu 'ldx #00'

SomeRtn:
        rts

RealSymbol:
        dfs     1

  	inc	ptr
   	bne 	+      	    ; springe zu 'tax'
   	inc 	ptr+1
+ 	tax

 	bpl 	++     	    ; springe zu 'dex'
   	beq 	+      	    ; springe vorwaerts zu 'rts'
   	lda 	#0
/  	rts            	    ; Schraegstrich = Wildcard
+ 	dex
   	beq 	-           ; springe rueckwaerts zu 'rts'

ptr:	dfs	2

</PRE>
<P>

<H3><A NAME="sect_2_8_2_">2.8.2. Zusammengesetzte tempor&auml;re Symbole</A></H3>
<P>
Dies ist vielleicht der Typ von tempor&auml;ren Symbolen, der dem
Konzept von lokalen Symbolen und Sektionen am n&auml;chsten kommt.
Wann immer der Name eines Symboles mit einem Punkt (.) anf&auml;ngt,
wird das Symbol nicht mit diesem Namen in der Symboltabelle abgelegt.
Stattdessen wird der Name des zuletzt definierten Symbols ohne
vorangestellten Punkt davor geh&auml;ngt. Auf diese Weise nehmen
Symbole, deren Name nicht mit einem Punkt anf&auml;ngt, quasi die
Rolle von 'Bereichsgrenzen' ein und Symbole, deren Name mit einem
Punkt anf&auml;ngt, k&ouml;nnen in jedem Bereich neu verwendet
werden. Sehen wir uns das folgende kurze Beispiel an:
<PRE>

proc1:                    ; nicht-temporaeres Symbol 'proc1'

.loop   moveq   #20,d0    ; definiert in Wirklichkeit 'proc1.loop'
        dbra    d0,.loop
        rts

proc2:                    ; nicht-temporaeres Symbol 'proc2'

.loop   moveq   #10,d1    ; definiert in Wirklichkeit 'proc2.loop'
        jsr     proc1
        dbra    d1,.loop
        rts

</PRE>
Man beachte, da&szlig; es weiterhin m&ouml;glich ist, auf alle
tempor&auml;ren Symbole zuzugreifen, auch wenn man sich nicht im
gleichen 'Bereich' befindet, indem man einfach den zusammengesetzten
Namen benutzt (wie z.B. 'proc2.loop' im voranstehenden Beispiel).
<P>
Zusammengesetzte Symbole lassen sich prinzipiell mit Sektionen
kombinieren und k&ouml;nnen so auch zu lokalen Symbolen werden. Man
beachte allerdings, da&szlig; das zuletzt definierte, nicht
tempor&auml;re Symbol nicht pro Sektion gespeichert wird, sondern
lediglich global. Das kann sich aber auch irgendwann einmal
&auml;ndern, man sollte sich also nicht auf das augenblickliche
Verhalten verlassen.
<P>

<H2><A NAME="sect_2_9_">2.9. Formelausdr&uuml;cke</A></H2>
<P>
An den meisten Stellen, an denen der Assembler Zahlenangaben
erwartet, k&ouml;nnen nicht nur einfache Symbole oder Konstanten
angegeben werden, sondern ganze Formelausdr&uuml;cke. Bei den
Komponenten der Formelausdr&uuml;cke kann es sich sowohl um ein
einzelnes Symbol als auch um eine Konstante handeln. Konstanten
d&uuml;rfen entweder Integer-, Gleitkomma-, oder Stringkonstanten
sein.
<P>

<H3><A NAME="sect_2_9_1_">2.9.1. Integerkonstanten</A></H3>
<A NAME="ref_SectIntConsts"></A>
<P>
Integerkonstanten bezeichnen ganze Zahlen. Sie werden als eine Folge
von Ziffern geschrieben. Dies kann in verschiedenen Zahlensystemen
erfolgen, deren Notation von verwendeten Zielprozessor abh&auml;ngt
(Tabelle <A HREF="#ref_TabSystems">2.7</A>).
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Intel-Modus</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Motorola-Modus</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>C-Modus</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>IBM-Modus</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dezimal<BR>
hexadezimal<BR>
<I> Kennung</I><BR>
<BR>
bin&auml;r<BR>
<I> Kennung</I><BR>
oktal<BR>
<I> Kennung</I><BR>
<BR>
ASCII<BR>
<I> Kennung</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>direkt<BR>
Suffix H<BR>
<TT> hexh</TT><BR>
<BR>
Suffix B<BR>
<TT> binb</TT><BR>
Suffix O oder Q<BR>
<TT> octo</TT><BR>
<TT> octq</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>direkt<BR>
Pr&auml;fix $<BR>
<TT> $hex</TT><BR>
<BR>
Pr&auml;fix %<BR>
<TT> %bin</TT><BR>
Pr&auml;fix @<BR>
<TT> @oct</TT><BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>direkt<BR>
Pr&auml;fix 0x<BR>
<TT> 0xhex</TT><BR>
<BR>
Pr&auml;fix 0b<BR>
<TT> 0bbin</TT><BR>
Pr&auml;fix 0<BR>
<TT> 0oct</TT><BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>direkt<BR>
X'..' oder H'..'<BR>
<TT> x'hex'</TT><BR>
<TT> h'hex'</TT><BR>
B'..'<BR>
<TT> b'bin'</TT><BR>
O'..'<BR>
<TT> o'oct'</TT><BR>
<BR>
A'..'<BR>
<TT> a'asc'</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.7: definierte Zahlensysteme und Schreibweisen<A
             NAME="ref_TabSystems"></A>
</CENTER><P>

Falls das Zahlensystem nicht explizit durch vor-oder nachgestellte
Zeichen vorgegeben wird, wird die Basis folgenderma&szlig;en
bestimmt:
<UL>
<LI> Falls ein<TT> RADIX</TT>-Befehl gegeben wurde, benutze die dadurch
    definierte Basis, ansonsten:</LI>
<LI> Falls ein<TT> -radix</TT> Kommandozeilenschalter gegeben wurde,
    benutze die dadurch definierte Basis, ansonsten:</LI>
<LI> Verwende das Dezimalsystem (Basis 10).</LI>
</UL>
Sowohl mit dem<TT> RADIX</TT>-Befehl als auch mit dem<TT>
-radix</TT>-Kommandozeilenschalter lassen sich auch
,,ungew&ouml;hnliche'' Zahlensysteme, d.h. andere als 2, 8, 10 oder
16 einstellen.
<P>
G&uuml;ltige Ziffern sind die Zahlen 0 bis 9 sowie die Buchstaben A
bis Z (Wert 10 bis 35) bis zur Basis des Zahlensystems minus eins.
Die ASCII- Darstellung f&auml;llt etwas aus diesem System heraus:
hier beschreibt der ASCII-Wert (bzw. der Code im aktuell
eingestellten Zeichensatz, siehe Abschnitt <A
HREF="#ref_SectCHARSET">3.1.12</A>) ein ganzes Byte. Solcherart
geschriebene Integer-Konstanten sind also letzten Endes identisch zu
Multi-Character-Konstanten. Die beiden Schreibweisen:
<PRE>

'ABCD'
A'ABCD'

</PRE>
sind also identisch, das vorangestellte 'A' ist eigentlich redundant.
Man kann diese Schreibweise aber f&uuml;r existierenden Code
erlauben, weil einige &auml;ltere Original-Assembler (z.B. Signetics
2650) diese Schreibweise unterst&uuml;tzen.
<P>
Multi-Character-Konstanten sind bei AS grunds&auml;tzlich immer
Big-Endian, d.h. 'ABCD' ergibt den Zahlenwert 0x41424344. Warum das
so ist? Naja, das erste AS-Target war der Motorola 68000, und es hat
sich nie jemand dar&uuml;ber beklagt...die einzige Ausnahme von
dieser Regel ist die PDP-11 (und der einen LSI-11 nutzende WD16):
zwecks besserer Kompatibilit&auml;t zum MACRO-11 von DEC sind solche
Konstanten ausnahmsweise Little-Endian, 'AB' ergibt also den
Zahlenwert 0x4241.
<P>
Die Verwendung von Buchstaben in Integerkonstanten bringt allerdings
auch einige Mehrdeutigkeiten mit sich, da Symbolnamen ja auch Ketten
aus Zahlen und Buchstaben sind: Ein Symbolname darf nicht mit einem
Zeichen von 0 bis 9 beginnen, was bedeutet, da&szlig; eine
Integerkonstante, die nicht durch ein anderes Sonderzeichen eindeutig
als solche erkennbar ist, niemals mit einem Buchstaben beginnen darf;
notfalls mu&szlig; man eine eigentlich &uuml;berfl&uuml;ssige Null
voranstellen. Der bekannteste Fall ist das Schreiben von
Hexadezimalkonstanten im Intel-Modus: Ist die vorderste Stelle
zwischen A und F, so hilft das hintangestellte H &uuml;berhaupt
nichts, es mu&szlig; noch eine Null davor (statt F0H also 0F0H). Die
Motorola-oder C-Syntax, die beide das Zahlensystem am Anfang einer
Integerkonstante kennzeichnen, kennen dieses Problem nicht.
<P>
Reichlich heimt&uuml;ckisch ist auch, da&szlig; bei immer
h&ouml;heren, mit<TT> RADIX</TT> eingestellten Zahlensystemen, die
bei Intel- und C-Syntax benutzten Buchstaben zur Zahlensystemkennung
immer weiter ,,aufgefressen'' werden; so kann man z.B. nach<TT> RADIX
16</TT> keine bin&auml;ren Konstanten mehr schreiben, und ab<TT>
RADIX 18</TT> in Intel-Syntax auch keine hexadezimalen Konstanten
mehr. Also<B> VORSICHT!</B>
<P>
Welche Syntax f&uuml;r welchen Zielprozessor im Default verwendet
wird, ist im Anhang <A HREF="#ref_SectPseudoInst">E</A> gesammelt.
Unabh&auml;ngig von diesem Default ist es m&ouml;glich, einzelne
Schreibweisen mit dem<TT> INTSYNTAX</TT>-Befehl (siehe Abschnitt <A
HREF="#ref_SectINTSYNTAX">3.9.6</A>) weg- oder dazuzuschalten. Die
unter<I> Ident</I> aufgef&uuml;hrten Namen, mit einem vorangestellten
Plus- oder Minuszeichen, dienen bei diesem Befehl als Argumente.
<P>
Eine Art ''Generalschalter' f&uuml;r Integer-Schreibweisen ist
der<TT> RELAXED</TT>-Befehl (siehe Abschnitt <A
HREF="#ref_SectRELAXED">3.9.7</A>): Unabh&auml;ngig vom Zielprozessor
k&ouml;nnen beliebige Schreibweisen verwendet werden kann (auf Kosten
der Kompatibilit&auml;t zu Standard-Assemblern).
<P>
Mit<TT> INTSYNTAX</TT> bzw.<TT> RELAXED</TT> er&ouml;ffnet sich
insbesondere die 'IBM-Schreibweise', wie man sie bei manchen
Fremdassemblern antrifft, f&uuml;r alle Ziele:
<P>
Bei dieser Schreibweise wird der eigentliche Wert in Hochkommas
geschrieben und das Zahlensystem ('x' oder 'h' f&uuml;r hexadezimal,
'o' f&uuml;r oktal und 'b' f&uuml;r bin&auml;r) direkt davor. Die
Integer-Konstante 305419896 kann damit also folgenderma&szlig;en
geschrieben werden:
<PRE>

 x'12345678'
 h'12345678'
 o'2215053170'
 b'00010010001101000101011001111000'

</PRE>
Als weitere Variante dieser Schreibweise erlauben einige wenige
Targets das Fortlassen des schlie&szlig;enden Hochkommas, zwecks
Kompatibilt&auml;t zu Code, der f&uuml;r andere Assembler geschrieben
wurde. F&uuml;r eigenen, neu erstellten Code wird von der Verwendung
abgeraten.
<P>

<H3><A NAME="sect_2_9_2_">2.9.2. Gleitkommakonstanten</A></H3>
<P>
Gleitkommazahlen werden in der &uuml;blichen halblogarithmischen
Schreibweise geschrieben, die in der allgemeinsten Form
<PRE>

 [-]&lt;Vorkommastellen&gt;[.Nachkommastellen][E[-]Exponent]

</PRE>
lautet.<B> ACHTUNG!</B> Der Assembler versucht eine Konstante zuerst
als Integerkonstante zu verstehen und macht erst dann einen Versuch
mit Gleitkomma, falls dies gescheitert ist. Will man aus
irgendwelchen Gr&uuml;nden die Auswertung als Gleitkommazahl
erzwingen, so kann man dies durch Dummy-Nachkommastellen erreichen,
z.B.<TT> 2.0</TT> anstelle<TT> 2</TT>.
<P>

<H3><A NAME="sect_2_9_3_">2.9.3. Stringkonstanten</A></H3>
<A NAME="ref_SectStringConsts"></A>
<P>
Stringkonstanten m&uuml;ssen in einfache oder doppelte Hochkommas
eingeschlossen werden. Um diese selber und andere Sonderzeichen ohne
Verrenkungen in String-Konstanten einbauen zu k&ouml;nnen, wurde ein
,,Escape-Mechanismus'' eingebaut, der C-Programmierer*innen bekannt
vorkommen d&uuml;rfte:
<P>
Schreibt man einen Backslash mit einer maximal dreiziffrigen Zahl im
String, so versteht der Assembler dies als Zeichen mit dem
entsprechenden dezimalen ASCII-Wert. Alternativ kann der Zahlenwert
auch hexadezimal oder oktal mit einem vorangestellten x oder einer
vorangestellten 0 geschrieben werden. F&uuml;r die hexadezimale
Schreibweise reduziert sich die Maximalanzahl von Stellen auf 2. So
kann man z.B. mit<TT>\3</TT> ein ETX-Zeichen definieren. Vorsicht
allerdings mit der Definition von NUL-Zeichen! Da die C-Version von      
AS momentan intern zur Speicherung von String-Symbolen C-Strings
benutzt (die durch NUL-Zeichen terminiert werden), sind NUL-Zeichen
in Strings momentan nicht portabel!
<P>
Einige besonders h&auml;ufig gebrauchte Steuerzeichen kann man auch
mit folgenden Abk&uuml;rzungen erreichen:
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> \b : Backspace</TD><TD NOWRAP> \a : Klingel</TD><TD NOWRAP> \e : Escape</TD></TR>
    <TR><TD NOWRAP> \t : Tabulator</TD><TD NOWRAP> \n : Zeilenvorschub</TD><TD NOWRAP> \r : Wagenr&uuml;cklauf</TD></TR>
    <TR><TD NOWRAP> \\ : Backslash</TD><TD NOWRAP> \' oder \h : Hochkomma</TD></TR>
    <TR><TD NOWRAP> \" oder \i : G&auml;nsef&uuml;&szlig;chen</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Die Kennbuchstaben d&uuml;rfen sowohl gro&szlig; als auch klein
geschrieben werden.
<P>
&Uuml;ber dieses Escape-Zeichen k&ouml;nnen sogar
Formelausdr&uuml;cke in den String eingebaut werden, wenn sie in
geschweifte Klammern eingefa&szlig;t werden: z.B. ergibt
<PRE>

    message "Wurzel aus 81 : \{sqrt(81)}"

</PRE>
die Ausgabe
<PRE>

    Wurzel aus 81 : 9

</PRE>
Der Assembler w&auml;hlt anhand des Formelergebnistyps die richtige
Ausgabeform, zu vermeiden sind lediglich weitere Stringkonstanten im
Ausdruck, da der Assembler bei der
Gro&szlig;-zu-Kleinbuchstabenumwandlung sonst durcheinander kommt.
Integer-Ausdr&uuml;cke werden defaultm&auml;&szlig;ig hexadezimal
ausgegeben, dies l&auml;&szlig;t sich jedoch mit dem<TT>
OUTRADIX</TT>-Befehl &auml;ndern.
<P>
Bis auf den Einbau von Formelausdr&uuml;cken ist dieser
Escape-Mechanismus auch in als ASCII definierten Integerkonstanten
zul&auml;ssig, z.B. so:
<PRE>

   move.b   #'\n',d0

</PRE>
Jedoch hat alles seine Grenzen, weil der dar&uuml;ber liegende
Splitter, der die Zeile in Opcode und Parameter zerlegt, nicht
wei&szlig;, womit er da eigentlich arbeitet, z.B. hier:
<PRE>

   move.l   #'\'abc',d0

</PRE>
Nach dem dritten Hochkomma findet er das Komma nicht mehr, weil er
vermutet, da&szlig; eine weitere Zeichenkonstante beginnt, und eine
Fehlermeldung &uuml;ber eine falsche Parameterzahl ist die Folge.
Abhilfe w&auml;re z.B., \h anstelle \' zu schreiben.
<P>

<H3><A NAME="sect_2_9_4_">2.9.4. String- zu Integerwandlung und Zeichenkonstanten</A></H3>
<P>
Fr&uuml;here Versionen von AS verfolgten eine strikte Trennung von
Strings und sogenannten ''Zeichenkonstanten'': Eine Zeichenkonstante
sieht auf den ersten Blick aus wie ein String, nur sind die Zeichen
in einfache Hochkommas statt doppelte eingeschlossen. Ein solches
Objekt hatte den Datentyp 'Integer', war also eine Zahl, deren Wert
durch den (ASCII-)Wert des jeweiligen Zeichens definiert war, und
wurde strikt von einer String-Konstante unterschieden:
<P>
<PRE>

   move.b   #65,d0
   move.b   #'A',d0      ; gleichwertig
   move.b   #"A",d0      ; nicht erlaubt in aelteren Versionen!

</PRE>
<P>
Diese Unterscheidung existiert<EM> nicht mehr</EM>, es ist also egal,
ob man einfache oder doppelte Hochkommas verwendet. Wird an einer
Stelle eine Zahl als Argument erwartet, und ein String verwendet, so
erfolgt die Umwandlung anhand der (ASCII-)Werte ''on-the-fly'' an
dieser Stelle. Im obigen Beispiel w&uuml;rden alle drei Anweisungen
den gleichen Maschinencode erzeugen.
<P>
Eine solche implizite Wandlung findet auch f&uuml;r aus mehreren
Zeichen bestehende Strings statt, die dann bisweilen als
''Mehrzeichenkonstanten'' bezeichnet werden:
<PRE>

'A'    == $41
"AB"   == $4142
'ABCD' == $41424344

</PRE>
Mehrzeichenkonstanten sind der einzige Fall, in denen die Verwendung
von einfachen oder doppelten Hochkommas noch einen Unterschied macht.
F&uuml;r viele Zielprozessoren sind Pseudobefehle zur Ablage von
Konstanten definiert, die als Argument verschiedene Datentypen
akzeptieren. Will man wirklich eine Zeichenkette haben, so mu&szlig;
man in diesem Fall weiterhin doppelte Hochkommas verwenden:
<PRE>

    dc.w    "ab"  ; legt zwei Worte (0x0041,0x0042) ab
    dc.w    'ab'  ; legt ein Wort (0x4142) ab

</PRE>
Wichtig: dies ist nicht erforderlich, wenn die Zeichenkette
l&auml;nger als die verwendete Operandegr&ouml;&szlig;e ist, in
diesem Beispiel also l&auml;nger als zwei Zeichen bzw. 16 Bit.
<P>

<H3><A NAME="sect_2_9_5_">2.9.5. Evaluierung</A></H3>
<P>
Die Berechnung von im Formelausdruck entstehenden Zwischenergebnissen
erfolgt immer mit der h&ouml;chsten auf dem Host-System
verf&uuml;gbaren Wortbreite. Bei Ganzzahlen sind dies 32 oder 64 Bit,
und bei Gleitkommazahlen ca. +/-1.8*10<SUP>308</SUP> (IEEE Double
Precision) oder ca. +/-1.1*10<SUP>4932</SUP> (IEEE Extended
Precision). Eine eventuelle Pr&uuml;fung auf
Wertebereichs&uuml;berschreitungen findet erst am Endergebnis statt.
<P>

<H3><A NAME="sect_2_9_6_">2.9.6. Operatoren</A></H3>
<P>
Der Assembler stellt zur Verkn&uuml;pfung die in Tabelle <A
HREF="#ref_TabOps">2.8</A> genannten Operanden zur Verf&uuml;gung.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Op.</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>#Ops.</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Int</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Float</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>String</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Register</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Rang</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>&lt;&gt;<BR>
!=<BR>
&gt;=<BR>
&lt;=<BR>
&lt;<BR>
&gt;<BR>
=<BR>
==<BR>
<BR>
!!<BR>
||<BR>
&amp;&amp;<BR>
  ~~ <BR>
<BR>
-<BR>
+<BR>
#<BR>
/<BR>
  * <BR>
  ^ <BR>
<BR>
!<BR>
|<BR>
&amp;<BR>
&gt;&lt;<BR>
&gt;&gt;<BR>
&lt;&lt;<BR>
  ~ </TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Ungleichheit<BR>
Alias f&uuml;r &lt;&gt;<BR>
gr&ouml;&szlig;er o. gleich<BR>
kleiner o. gleich<BR>
echt kleiner<BR>
echt gr&ouml;&szlig;er<BR>
Gleichheit<BR>
Alias f&uuml;r =<BR>
<BR>
log. XOR<BR>
log. OR<BR>
log. AND<BR>
log. NOT<BR>
<BR>
Differenz<BR>
Summe<BR>
Modulodivision<BR>
Quotient<BR>
Produkt<BR>
Potenz<BR>
<BR>
bin&auml;res XOR<BR>
bin&auml;res OR<BR>
bin&auml;res AND<BR>
Bitspiegelung<BR>
log. Rechtsschieben<BR>
log. Linksschieben<BR>
bin&auml;res NOT</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2<BR>
<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
<BR>
<BR>
2<BR>
2<BR>
2<BR>
1<BR>
<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
1</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>ja<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja*)<BR>
ja<BR>
ja<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>ja<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
<BR>
ja<BR>
ja<BR>
nein<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>ja<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
<BR>
nein<BR>
ja<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>ja<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>14<BR>
<BR>
14<BR>
14<BR>
14<BR>
14<BR>
14<BR>
<BR>
<BR>
13<BR>
12<BR>
11<BR>
2<BR>
<BR>
10<BR>
10<BR>
9<BR>
9<BR>
9<BR>
8<BR>
<BR>
7<BR>
6<BR>
5<BR>
4<BR>
3<BR>
3<BR>
1</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=8 ALIGN=CENTER>*) Rest wird verworfen</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.8: in AS definierte Operatoren<A NAME="ref_TabOps"></A>
</CENTER><P>

Unter ,,Rang'' ist dabei die Priorit&auml;t zu verstehen, die dieser
Operator bei der Teilung eines Ausdruckes in Unterausdr&uuml;cke hat,
der rangh&ouml;chste Operator wird also<I> zuletzt</I> ausgewertet.
Die Reihenfolge der Evaluierung l&auml;&szlig;t sich durch Klammerung
neu festlegen.
<P>
Die Vergleichsoperatoren liefern TRUE, falls die Bedingung zutrifft,
und FALSE falls nicht. Vergleiche betrachten Integerzahlen dabei als
32 oder 64 Bit breit (je nach Host-System) und vorzeichenbehaftet.
F&uuml;r die logischen Operatoren ist ein Ausdruck TRUE, falls er
ungleich 0 ist, ansonsten FALSE.
<P>
Grunds&auml;tzlich ist bei Operatoren mit zwei Argumenten nicht
definiert, in welcher Reihenfolge die Operanden bestimmt werden. Die
einzige Ausnahme von dieser Regel sind das logische AND und OR: Falls
das Ergebnis bereits durch den linken Operanden eindeutig bestimmt
ist, wird der rechte Operand nicht mehr ausgewertet,
<P>
Bei Vergleichen von Register-Symbolen sind zwei Details zu beachten.
Zum einen sind zwei Register-Symbole dann gleich, wenn sie auf das
gleiche Register verweisen. Da Register bei einigen Prozessoren
Alias-Namen haben, werden diese Aliase als gleich betrachtet. Zum
Beispiel ist das Register<TT> A7</TT> auf einem 68000 auch als<TT>
SP</TT> ansprechbar, und diese beiden Registersymbole sind gleich.
Zum anderen haben manche Prozessoren mehrere S&auml;tze von
Registern, auf einem 68040 zum Beispiel die normalen
(Integer-)Register und die FPU-Register. Zwischen zwei Registern aus
unterschiedlichen Gruppen l&auml;&szlig;t sich keine
kleiner/gr&ouml;&szlig;er-Beziehung angeben, die entsprechenden
Operatoren liefern immer ein FALSE zur&uuml;ck. Lediglich ein Test
auf Gleichheit oder Ungleichheit ergibt einen Sinn.
<P>
Die Bitspiegelung ist wohl etwas erkl&auml;rungsbed&uuml;rftig: Der
Operator spiegelt die untersten Bits im ersten Operanden,
l&auml;&szlig;t die dar&uuml;berliegenden Bits aber unver&auml;ndert.
Die Zahl der zu spiegelnden Bits ist der rechte Operand und darf
zwischen 1 und 32 liegen.
<P>
Eine keine Fu&szlig;angel beim bin&auml;ren Komplement: Da die
Berechnung grunds&auml;tzlich auf 32- oder 64-Bit-Ebene erfolgt,
ergibt seine Anwendung auf z.B. 8-Bit-Masken &uuml;blicherweise
Werte, die durch voranstehende Einsen nicht mehr im entferntesten in
8-Bit-Zahlen hineinpassen. Eine bin&auml;re UND-Verkn&uuml;pfung mit
einer passenden Maske ist daher unvermeidlich!
<P>

<H3><A NAME="sect_2_9_7_">2.9.7. Funktionen</A></H3>
<P>
Zus&auml;tzlich zu den Operatoren definiert AS noch eine Reihe in
erster Linie transzendenter Funktionen mit Gleitkomma-Argument, die
Tabellen <A HREF="#ref_TabFuncs1">2.8</A> und <A
HREF="#ref_TabFuncs2">2.8</A> auflisten.
<CENTER>
<P><CENTER>Tabelle 2.9: vordefinierte Funktionen in AS - Teil 1 (Integer- und
             Gleitkomma-Funktionen)<A NAME="ref_TabFuncs1"></A>
</CENTER><P>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Argument</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Ergebnis</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>SQRT<BR>
<BR>
SIN<BR>
COS<BR>
TAN<BR>
COT<BR>
<BR>
ASIN<BR>
ACOS<BR>
ATAN<BR>
ACOT<BR>
<BR>
EXP<BR>
ALOG<BR>
ALD<BR>
SINH<BR>
COSH<BR>
TANH<BR>
COTH<BR>
<BR>
LN<BR>
LOG<BR>
LD<BR>
ASINH<BR>
ACOSH<BR>
ATANH<BR>
ACOTH<BR>
<BR>
INT<BR>
<BR>
BITCNT<BR>
FIRSTBIT<BR>
LASTBIT<BR>
BITPOS</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Quadratwurzel<BR>
<BR>
Sinus<BR>
Kosinus<BR>
Tangens<BR>
Kotangens<BR>
<BR>
inverser Sinus<BR>
inverser Kosinus<BR>
inverser Tangens<BR>
inverser Kotangens<BR>
<BR>
Exponentialfunktion<BR>
10 hoch Argument<BR>
2 hoch Argument<BR>
hyp. Sinus<BR>
hyp. Kosinus<BR>
hyp. Tangens<BR>
hyp. Kotangens<BR>
<BR>
nat. Logarithmus<BR>
dek. Logarithmus<BR>
2er Logarithmus<BR>
inv. hyp. Sinus<BR>
inv. hyp. Kosinus<BR>
inv. hyp. Tangens<BR>
inv. hyp. Kotangens<BR>
<BR>
ganzzahliger Anteil<BR>
<BR>
bin&auml;re Quersumme<BR>
niedrigstes 1-Bit<BR>
h&ouml;chstes 1-Bit<BR>
einziges 1-Bit</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>arg &ge; 0<BR>
<BR>
arg in R<BR>
arg in R<BR>
arg &ne; (2*n+1)*(&pi;)/(2)<BR>
arg &ne; n*&pi;<BR>
<BR>
| arg | &le; 1<BR>
| arg | &le; 1<BR>
arg in R<BR>
arg in R<BR>
<BR>
arg in R<BR>
arg in R<BR>
arg in R<BR>
arg in R<BR>
arg in R<BR>
arg in R<BR>
arg &ne; 0<BR>
<BR>
arg &gt; 0<BR>
arg &gt; 0<BR>
arg &gt; 0<BR>
arg in R<BR>
arg &ge; 1<BR>
| arg | &lt; 1<BR>
| arg | &gt; 1<BR>
<BR>
arg in R<BR>
<BR>
Integer<BR>
Integer<BR>
Integer<BR>
Integer</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Gleitkomma<BR>
<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
<BR>
Integer<BR>
<BR>
Integer<BR>
Integer<BR>
Integer<BR>
Integer</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<CENTER>
<P><CENTER>Tabelle 2.9: vordefinierte Funktionen in AS - Teil 2 (Integer- und
             String-Funktionen)<A NAME="ref_TabFuncs2"></A>
</CENTER><P>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Argument</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Ergebnis</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>SGN<BR>
<BR>
ABS<BR>
<BR>
TOUPPER<BR>
TOLOWER<BR>
UPSTRING<BR>
<BR>
LOWSTRING<BR>
<BR>
STRLEN<BR>
<BR>
SUBSTR<BR>
<BR>
<BR>
CHARFROMSTR<BR>
<BR>
<BR>
STRSTR<BR>
<BR>
VAL<BR>
<BR>
EXPRTYPE<BR>
<BR>
<BR>
FSIZE</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Vorzeichen (0/1/-1)<BR>
<BR>
Betrag<BR>
<BR>
pass. Gro&szlig;buchstabe<BR>
pass. Kleinbuchstabe<BR>
wandelt alle Zeichen<BR>
in Gro&szlig;buchstaben<BR>
wandelt alle Zeichen<BR>
in Kleinbuchstaben<BR>
liefert L&auml;nge eines<BR>
Strings<BR>
extrahiert Teil eines<BR>
Strings<BR>
<BR>
extrahiert ein<BR>
Zeichen aus einem<BR>
String<BR>
sucht Teilstring in<BR>
einem String<BR>
evaluiert Stringin-<BR>
halt als Ausdruck<BR>
liefert Typ des<BR>
Arguments<BR>
<BR>
liefert Dateigr&ouml;&szlig;e</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer oder<BR>
Gleitkomma<BR>
Integer oder<BR>
Gleitkomma<BR>
Integer<BR>
Integer<BR>
String<BR>
<BR>
String<BR>
<BR>
String<BR>
<BR>
String,<BR>
Integer,<BR>
Integer<BR>
String,<BR>
Integer<BR>
<BR>
String,<BR>
String<BR>
String<BR>
<BR>
Integer,<BR>
Gleitkomma,<BR>
String<BR>
String</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
<BR>
Integer oder<BR>
Gleitkomma<BR>
Integer<BR>
Integer<BR>
String<BR>
<BR>
String<BR>
<BR>
Integer<BR>
<BR>
String<BR>
<BR>
<BR>
Integer<BR>
<BR>
<BR>
Integer<BR>
<BR>
abh. von<BR>
Argument<BR>
0<BR>
1<BR>
2<BR>
Integer</TD>
</TR>
</TABLE></CENTER>
</CENTER>
Die Funktionen<TT> FIRSTBIT</TT>,<TT> LASTBIT</TT> und<TT>
BITPOS</TT> liefern als Ergebnis -1, falls &uuml;berhaupt kein bzw.
nicht genau ein Bit gesetzt ist. Zus&auml;tzlich gibt<TT> BITPOS</TT>
in einem solchen Fall eine Fehlermeldung aus.
<P>
Die String-Funktion<TT> SUBSTR</TT> erwartet als ersten Parameter den
Quellstring, als zweiten die Startposition und als dritten die Anzahl
zu extrahierender Zeichen (eine 0 bedeutet, alle Zeichen bis zum Ende
zu extrahieren). Analog erwartet<TT> CHARFROMSTR</TT> den Quellstring
als erstes Argument und die Zeichenposition als zweites Argument.
Falls die angegebene Position gr&ouml;&szlig;er oder gleich der
L&auml;nge des Quellstrings ist, liefert<TT> SUBSTR</TT> einen
Leerstring, w&auml;hrend<TT> CHARFROMSTR</TT> eine -1 ergibt. Eine
Position kleiner Null wird von<TT> SUBSTR</TT> als Null behandelt,
w&auml;hrend<TT> CHARFROMSTR</TT> in diesem Fall ebenfalls eine -1
liefert.
<P>
Hier ein Beispiel, wie man die beiden Funktionen einsetzt, um einen
String im Speicher abzulegen, wobei das String-Ende durch ein
gesetztes MSB gekennzeichnet ist:
<P>
<PRE>

dbstr   macro   arg
        if      strlen(arg) &gt; 1
         db     substr(arg, 0, strlen(arg) - 1)
        endif
        if      strlen(arg) &gt; 0
         db     charfromstr(arg, strlen(arg) - 1) | 80h
        endif
        endm

</PRE>
<P>
<TT> STRSTR</TT> liefert das erste Auftreten des zweiten Strings im
ersten bzw. -1, falls das Suchmuster nicht gefunden wurde. Analog
zu<TT> SUBSTR</TT> und<TT> CHARFROMSTR</TT> hat das erste Zeichen den
Positionswert 0.
<P>
<TT> FSIZE</TT> liefert die Gr&ouml;&szlig;e einer Datei in Bytes.
Die Datei wird sowohl im aktuellen Verzeichnis gesucht, als auch
relativ zum Verzeichnis der gerade assemblierten Quelldatei. Im
Gegensatz zu<TT> INCLUDE</TT> und<TT> BINCLUDE</TT> wird jedoch nicht
im Include-Pfad gesucht!
<P>
Wenn eine Funktion auch Gleitkommaargumente erwartet, so soll dies
nicht bedeuten, da&szlig; man nicht z.B.
<PRE>

wur2   equ      sqrt(2)

</PRE>
schreiben d&uuml;rfte --- in solchen F&auml;llen findet automatisch
eine Typkonvertierung statt. Umgekehrt mu&szlig; allerdings die<TT>
INT</TT>-Funktion angewandt werden, um eine Gleitkommazahl ganz zu
bekommen. Bei der Benutzung dieser Funktion ist zu beachten,
da&szlig; sie als Ergebnis immer einen vorzeichenbehafteten Integer
liefert, sie hat also einen Wertebereich von ca. +/-2.0E9.
<P>
Schaltet man AS in den case-sensitiven Modus, so k&ouml;nnen im
Gegensatz zu vordefinierten Symbolen die vordefinierten Funktionen
weiterhin in beliebiger Schreibweise angesprochen werden. Bei selbst
definierten Funktionen (siehe Abschnitt <A
HREF="#ref_SectFUNCTION">3.4.9</A> wird allerdings unterschieden.
Dies hat zur Folge, da&szlig; z.B. bei der Definition einer
Funktion<TT> Sin</TT> man mit<TT> Sin</TT> diese Funktion auch
erreicht, mit allen anderen Schreibweisen jedoch die eingebaute
Funktion.
<P>
F&uuml;r die korrekte Umwandlung von Klein-zu Gro&szlig;buchstaben       
ist eine DOS-Version &ge; 3.30 erforderlich.
<P>
<P>

<H2><A NAME="sect_2_10_">2.10. Vorw&auml;rtsreferenzen und andere Desaster</A></H2>
<A NAME="ref_ForwRefs"></A>                                              
<P>
Dieser Abschnitt ist das Produkt eines gewissen Grolls auf die
(durchaus legale) Art und Weise, wie einige Leute programmieren, die
in Zusammenhang mit AS bisweilen das eine oder andere Problem
verursachen kann. Die Rede ist hier von sogenannten
,,Vorw&auml;rtsreferenzen''. Was unterscheidet eine
Vorw&auml;rtsreferenz von einer normalen Referenz? Dazu sehe man sich
folgendes Programmbeispiel an (man sehe mir bitte meine -- auch im
Rest dieser Anleitung anzutreffende -- 68000-Lastigkeit nach):
<PRE>

        move.l  #10,d0
loop:   move.l  (a1),d1
        beq     skip
        neg.l   d1
skip:   move.l  d1,(a1+)
        dbra    d0,loop

</PRE>
Denkt man sich den Scheifenrumpf mit dem Sprung weg, so bleibt ein
&auml;u&szlig;erst angenehm zu assemblierendes Programm &uuml;brig:
die einzige Referenz ist der R&uuml;cksprung zum Anfang des Rumpfes,
und da ein Assembler ein Programm von vorne nach hinten
durcharbeitet, hat er den Symbolwert bereits ermittelt, bevor er ihn
zum erstem Mal ben&ouml;tigt. Sofern man ein Programm hat, das nur
solche R&uuml;ckw&auml;rtsreferenzen besitzt, ist man in der
angenehmen Lage, nur einmal durch den Quellcode gehen zu m&uuml;ssen,
um den korrekten und optimalen Maschinencode zu finden. Einige
Hochsprachen wie Pascal mit ihrer strikten Regel, da&szlig; alles vor
der ersten Benutzung definiert sein mu&szlig;, nutzen genau diese
Eigenschaft aus, um den &Uuml;bersetzungsvorgang zu beschleunigen.
<P>
Leider ist die Sache im Falle von Assembler nicht so einfach, denn
man will ja bisweilen auch vorw&auml;rts im Code springen oder
mu&szlig; aus bestimmten Gr&uuml;nden Variablen Definitionen hinter
den Code verlegen. Dies ist im Beispiel der Fall f&uuml;r den
bedingten Sprung, mit dem ein anderer Befehl &uuml;bersprungen wird.
Wenn der Assembler im ersten Durchlauf auf den Sprungbefehl trifft,
so sieht er sich mit der Situation konfrontiert, entweder die
Teilfelder der Instruktion, die die Sprungadresse beinhalten, leer
zulassen, oder seitens des Formelparsers (der das Adre&szlig;argument
ja auswerten mu&szlig;) anstelle des korrekten, aber unbekannten
Wertes einen Wert anzubieten, der ,,niemandem wehtut''. Bei einem
einfachen Assembler, der nur eine Zielarchitektur kennt und bei dem
sich die betroffenen Befehle an einer Hand abz&auml;hlen lassen, wird
man sicher die erste Variante w&auml;hlen, bei AS mit seinen vielen
Dutzend Zielen w&auml;re die Zahl der Sonderabfragen aber extrem hoch
geworden, so da&szlig; nur der zweite Weg in Frage kam: Falls im
ersten Pass ein unbekanntes Symbol auftaucht, so liefert der
Formelparser den momentanen Stand des Programmz&auml;hlers als
Ergebnis zur&uuml;ck! Nur dieser Wert ist geeignet, relativen
Spr&uuml;ngen mit Sprungdistanzen unbekannter L&auml;nge eine Adresse
anzubieten, die nicht zu Fehlern f&uuml;hrt. Dies beantwortet auch
die bisweilen gestellte Frage, warum in einem Listing des ersten
Passes (dies bleibt z.B. stehen, wenn AS aufgrund anderer Fehler den
zweiten Pass erst gar nicht beginnt), z.T. falsche Adressen im
erzeugten Bin&auml;rcode gezeigt werden - dies sind noch nicht
aufgel&ouml;ste Vorw&auml;rtsreferenzen.
<P>
Das obige Beispiel offenbart allerdings noch eine weitere
Schwierigkeit von Vorw&auml;rtsreferenzen: Je nach Abstand von Quelle
und Ziel im Code kann der Sprungbefehl entweder lang oder kurz sein.
Diese Entscheidung &uuml;ber die Code-L&auml;nge - und damit auch die
Adressen folgender Labels - kann jedoch mangels genauer Kenntnis der
Zieladresse im ersten Pass nicht erfolgen. Sofern der Programmierer
nicht explizit kenntlich gemacht hat, ob der Sprung lang oder kurz
sein soll, behelfen sich reine 2-Pass-Assembler wie &auml;ltere
MASM-Versionen von Microsoft damit, im ersten Pass (nach diesem
m&uuml;ssen alle Adressen festliegen) Platz f&uuml;r die l&auml;ngste
Version zu reservieren und im zweiten Pass den
&uuml;bersch&uuml;ssigen Platz mit<TT> NOP</TT>s aufzuf&uuml;llen.
AS-Versionen bis 1.37 taten dieses ebenfalls, danach bin ich auf das
Multipass-Verfahren &uuml;bergegangen, das die strenge Einteilung in
zwei Passes aufhebt und beliebig viele Durchg&auml;nge erlaubt. Dazu
wird im ersten Pass der optimale Code mit den angenommenen
Symbolwerten erzeugt. Stellt AS fest, da&szlig; im zweiten Pass durch
Codel&auml;ngenver&auml;nderungen sich Werte von Symbolen
ge&auml;ndert haben, so wird einfach noch ein dritter Pass eingelegt,
und da durch die neuen Symbolwerte des zweiten Passes auch im dritten
Pass sich der Code wieder verk&uuml;rzen oder verl&auml;ngern kann,
ist ein weiterer Pass nicht unm&ouml;glich. Ich habe schon
8086-Programme erlebt, bei denen erst nach 12 Durchg&auml;ngen alles
stimmte. Leider erlaubt dieser Mechanismus nicht die Vorgabe einer
Maximalzahl von Durchl&auml;ufen, ich kann als Regel nur sagen,
da&szlig; die Anzahl von Durchl&auml;ufen sinkt, je mehr man davon
Gebrauch macht, Sprung- oder Adre&szlig;l&auml;ngen explizit
vorzugeben.
<P>
Speziell bei gro&szlig;en Programmen kann es zu einer interessanten
Situation kommen: Die Lage eines vorw&auml;rts gerichteten Sprunges
hat sich im zweiten Pass so weit gegen&uuml;ber dem ersten
verschoben, da&szlig; der jetzt noch benutzte Label-Wert aus dem
ersten Pass au&szlig;erhalb der erlaubten Sprungdistanz liegt. AS
ber&uuml;cksichtigt solche Situationen, indem er jegliche
Fehlermeldungen &uuml;ber zu weite Sprungdistanzen unterdr&uuml;ckt,
sobald er erkannt hat, da&szlig; er wegen sich &auml;ndernder
Symbolwerte ohnehin einen weiteren Durchlauf machen mu&szlig;. Dies
funktioniert zwar in 99% aller F&auml;lle, es gibt jedoch auch
Konstrukte, in denen der erste, derartig kritische Befehl bereits
auftaucht, bevor AS eine Chance hat, zu erkennen, da&szlig; ein neuer
Pass erforderlich ist. Das folgende Beispiel konstruiert eine solche
Situation mit Hilfe einer Vorw&auml;rtsreferenz (und war der
Anla&szlig; f&uuml;r die &Uuml;berschrift dieses Abschnitts...):
<PRE>

        cpu   6811

        org     $8000
        beq     skip
        rept    60
         ldd    Var
        endm
skip:   nop

Var     equ     $10

</PRE>
Aufgrund der Adre&szlig;lage nimmt AS im ersten Pass lange Adressen
f&uuml;r die<TT> LDD</TT>-Befehle an, was eine Code-L&auml;nge von
180 Bytes ergibt und im zweiten Pass (zum Zeitpunkt des<TT>
BEQ</TT>-Befehls ist noch der ,,falsche'' Wert von<TT> skip</TT>
aktuell, d.h. AS wei&szlig; zu diesem Zeitpunkt noch nicht, da&szlig;
der Code in Wirklichkeit nur 120 Bytes lang ist) gibt es eine
Fehlermeldung wegen einer &uuml;berschrittenen Sprungdistanz. Dieser
Fehler l&auml;&szlig;t sich auf drei Arten vermeiden:
<OL>
<LI>Weisen Sie AS explizit darauf hin, da&szlig; er f&uuml;r die<TT>
    LDD</TT>-Befehle kurze Adressen verwenden darf (<TT>ldd
    &lt;Var</TT>)</LI>
<LI>Entfernen Sie diese vermaledeite, verfluchte Vorw&auml;rtsreferenz
    und setzen Sie die<TT> EQU</TT>-Anweisung nach vorne, wo sie
    hingeh&ouml;rt (OK, ich beruhige mich ja schon wieder...)</LI>
<LI>F&uuml;r ganz Unentwegte: Benutzten Sie die<TT> -Y</TT>-Option, so
    da&szlig; AS die Fehlermeldung beim Erkennen der
    Adre&szlig;verschiebung nachtr&auml;glich verwirft. Nicht
    sch&ouml;n, aber...</LI>
</OL>
Noch ein Hinweis zum<TT> EQU</TT>-Befehl: Da AS nicht wissen kann, in
welchem Zusammenhang ein mit<TT> EQU</TT> definiertes Symbol
sp&auml;ter verwendet wird, wird ein<TT> EQU</TT> mit
Vorw&auml;rtsreferenzen im ersten Pass &uuml;berhaupt nicht
durchgef&uuml;hrt. Wird das mit<TT> EQU</TT> definierte Symbol also
im zweiten Pass vorw&auml;rts referenziert:
<PRE>

        move.l  #sym2,d0
sym2    equ     sym1+5
sym1    equ     0

</PRE>
so handelt man sich im zweiten Pass eine Fehlermeldung wegen eines
undefinierten Symbols ein...aber warum machen Leute eigentlich solche
Dinge ???
<P>
Zugegeben, das war ein ziemlich l&auml;nglicher Ausflug, aber es
mu&szlig;te einfach einmal sein. Was sollte man als Erkenntnis aus
diesem Abschnitt mitnehmen?
<OL>
<LI>AS versucht immer, den k&uuml;rzest m&ouml;glichen Code zu erzeugen.
    Dazu ben&ouml;tigt er eine endliche Zahl von Durchl&auml;ufen.
    Wenn man ihn nicht gerade knebelt, kennt AS keine
    R&uuml;cksichten...</LI>
<LI>Wenn sinnvoll und m&ouml;glich, Sprung- und Adre&szlig;l&auml;ngen
    explizit vorgeben. Man kann damit u.U. die Anzahl der
    Durchl&auml;ufe deutlich reduzieren.</LI>
<LI>Vorw&auml;rtsreferenzen auf das allern&ouml;tigste beschr&auml;nken.
    Man erleichtert sich und AS das Leben damit erheblich!</LI>
</OL>
<P>

<H2><A NAME="sect_2_11_">2.11. Registersymbole</A></H2>
<A NAME="ref_SectRegSyms"></A><A NAME="index_Registersymbole_1"></A>
<P>
<EM> G&uuml;ltigkeit: PowerPC, M-Core, XGate, 4004/4040,
MCS-48/(2)51, 8086, 80C16x, AVR, XS1, Z8, KCPSM, Mico8, MSP430(X),
ST9, M16, M16C, H8/300, H8/500, SH7x00, H16, i960, XA, 29K,
TLCS-9000, KENBAK, SC/MP</EM>
<P>
Manchmal ist es erw&uuml;nscht, nicht nur einer Speicheradresse oder
einer Konstanten, sondern auch einem Register einen symbolischen
Namen zuzuweisen, um seine Funktion in einem bestimmten
Programmabschnitt zu verdeutlichen. Dies ist bei Prozessoren, die die
Register schlicht als einen weiteren Adre&szlig;raum behandeln, recht
problemlos, da als Register damit auch Zahlenausdr&uuml;cke erlaubt
sind und man solche Symbole mit schlichten<TT> EQU</TT>s definieren
kann (z.B. bei MCS-96 oder TMS7000). Bei den allermeisten Prozessoren
jedoch sind Registernamen festgelegte Literale, und AS behandelt sie
beim Parsing aus Geschwindigkeitsgr&uuml;nden gesondert, so da&szlig;
auch ein getrennter Typ von Symbolen f&uuml;r solche Registersymbole
oder -aliase existiert. Registersymbole k&ouml;nnen wie
gew&ouml;hnliche Symbole mit<TT> EQU</TT> oder<TT> SET</TT> definiert
und umdefiniert werden, zudem existiert eine spezielle<TT>
REG</TT>-Anweisung, die explizit nur Symbole bzw. Ausdr&uuml;cke
dieses Typs akzeptiert.
<P>
Registersymbole unterliegen einer Reihe von Einschr&auml;nkungen: zum
einen ist die Menge der Literale beschr&auml;nkt und durch den
jeweiligen Zielprozessor vorgegeben, zum anderen kann man mit
Registersymbolen nicht rechnen. Etwas in dieser Form:
<PRE>

myreg   reg     r17         ; Definition Registersymbol
        addi    myreg+1,3   ; geht nicht!

</PRE>
ist also<EM> nicht</EM> zul&auml;ssig. Einfache Zuweisungen sind
dagegen auch &uuml;ber mehrere Stufen hinweg erlaubt:
<PRE>

myreg   reg     r17         ; Definition Registersymbol
myreg2  reg     myreg       ; myreg2 -&gt; r17

</PRE>
Des weiteren sind Vorw&auml;rtsreferenzen bei Registersymbolen noch
kritischer als bei anderen Typen von Symbolen. Ist ein Symbol nicht
definiert, so kann AS nur mutma&szlig;en, was f&uuml;r ein Typ von
Symbol es sein wird, und entscheidet sich in Zweifelsfall f&uuml;r
eine einfache Zahl, was bei den meisten Prozessoren einem Zugriff auf
eine absolute Adresse im Speicher gleichkommt. Nun sind bei den
meisten Prozessoren die Nutzungsm&ouml;glichkeiten f&uuml;r
Speicheradressen als Operand deutlich eingeschr&auml;nkter als
f&uuml;r Register. Je nach Situation erh&auml;lt man so eine
Fehlermeldung &uuml;ber einen nicht erlaubten Adressierungsmodus, und
es kommt zu keinem zweiten Pass...
<P>
Registersymbole sind analog zu normalen Symbolen lokal zu Sektionen,
und es ist auch durch Anh&auml;ngen eines in eckige Klammern
gesetzten Sektionsnamens m&ouml;glich, auf ein Registersymbol aus
einer bestimmten Sektion zuzugreifen.
<P>

<H2><A NAME="sect_2_12_">2.12. Sharefile</A></H2>
<A NAME="ref_ChapShareMain"></A><A NAME="index_SHARED_2"></A>
<P>
Diese Funktion ist ein Abfallprodukt aus den reinen
68000er-Vorg&auml;ngern von AS, da sie vielleicht doch der (die?!)
eine oder andere gebrauchen k&ouml;nnte, habe ich sie drin gelassen.
Grundproblem ist es, an bestimmte beim Assemblieren entstehende
Symbole heranzukommen, weil man evtl. mit diesen
Adre&szlig;informationen auf den Speicher des Zielsystems zugreifen
m&ouml;chte. Der Assembler erlaubt es, mit Hilfe des<TT>
SHARED</TT>-Pseudobefehles (siehe dort) Symbolwerte extern zur
Verf&uuml;gung zu stellen. Zu diesem Zweck erstellt der Assembler im
zweiten Pass eine Textdatei mit den gew&uuml;nschten Symbolen und
ihren Werten, die mittels Include in ein Hochsprachen-oder weiteres
Assemblerprogramm eingebunden werden k&ouml;nnen. Das Format der
Textdatei (C, Pascal oder Assembler) wird durch die
Kommandozeilenschalter<TT> p</TT>,<TT> c</TT> oder<TT> a</TT>
festgelegt.
<P>
<B> ACHTUNG!</B> Ist keiner dieser Schalter angegeben, so wird auch
keine Datei erzeugt, egal ob sich<TT> SHARED</TT>-Befehle im
Quelltext finden oder nicht!
<P>
AS pr&uuml;ft beim Anlegen der Share-Datei nicht, ob bereits eine
Datei gleichen Namens existiert, eine solche wird ggfs. einfach
&uuml;berschrieben. Eine Abfrage halte ich nicht f&uuml;r sinnvoll,
da AS dann bei jedem Lauf fragen w&uuml;rde, ob er die alte Version
der Share-Datei &uuml;berschreiben darf, und das w&auml;re doch sehr
l&auml;stig...
<P>

<H2><A NAME="sect_2_13_">2.13. Prozessor-Aliase</A></H2>
<A NAME="ref_SectAlias"></A>
<P>
Mit Varianten g&auml;ngiger Mikrocontroller-Familien ist es wie mit
Kaninchen: Sie vermehren sich schneller, als man mit der Versorgung
hinterher kommen kann. Im Zuge der Entwicklung von Prozessorkernen
als Bausteine f&uuml;r ASICs und von Controller-Familien mit vom
Kunden w&auml;hlbarer Peripherie wird die Zahl von
Controller-Varianten, die sich von einem bekannten Typ nur in einigen
Peripherie-Details unterscheiden, immer gr&ouml;&szlig;er. Die
Unterscheidung der einzelnen Typen ist aber trotz meist identischer
Prozessorkerns wichtig, um z.B. in den Include-Dateien den korrekten
Satz von Peripherieregistern einzublenden. Bisher habe ich mich zwar
immer bem&uuml;ht, die wichtigsten Vertreter einer Familie in AS
einzubauen (und werde das auch weiter tun), aber manchmal l&auml;uft
mir die Entwicklung einfach auf und davon...es mu&szlig;te also ein
Mechanismus her, mit dem man die Liste der unterscheidbaren
Prozessortypen selbst erweitern kann.
<P>
Das Ergebnis davon sind Prozessor-Aliasse: Mit der
Kommandozeilenoption<TT> alias</TT> kann man einen neuen Prozessortyp
definieren, der im Befehlssatz einem anderen, in AS fest eingebauten
Typ entspricht. Bei Benutzung dieses Typs im<TT> CPU</TT>-Befehl wird
sich AS also wie beim ,,Original'' verhalten, mit einem Unterschied:
Die Variablen<TT> MOMCPU</TT> bzw.<TT> MOMCPUNAME</TT> werden auf den
Namen des Alias gesetzt, wodurch der neue Name zur Unterscheidung
z.B. in Include-Dateien dienen kann.
<P>
Die Definition dieser Aliasse wurde aus zwei Gr&uuml;nden mit
Kommandozeilenoptionen anstatt Pseudobefehlen vorgenommen: zum einen
w&auml;re es ohnehin nicht m&ouml;glich gewesen, die Definition der
Aliasse zusammen mit den Registerdefinitionen in eine Include-Datei
zu legen, denn in einem Programm, das so eine Datei benutzen wollte,
m&uuml;&szlig;te sie ja sowohl vor als auch nach dem<TT>
CPU</TT>-Befehl in der Hauptdatei eingebunden werden - eine
Vorstellung, die irgendwo zwischen unelegant und unm&ouml;glich
liegt. Zum zweiten erm&ouml;glicht diese Implementierung, die
Definition der neuen Typen in eine Datei zu legen, die &uuml;ber
die<TT> ASCMD</TT>-Variable beim Start automatisch ausgef&uuml;hrt
wird, ohne das sich das Programm darum k&uuml;mmern m&uuml;&szlig;te.
<P>

<H1><A NAME="sect_3_">3. Pseudobefehle</A></H1>
<P>
Nicht f&uuml;r alle Prozessoren sind alle Pseudobefehle definiert.
Vor der Beschreibung eines Befehls ist deshalb jeweils vermerkt,
f&uuml;r welche Prozessortypen dieser Befehl erlaubt ist.
<P>

<H2><A NAME="sect_3_1_">3.1. Definitionen</A></H2>
<P>

<H3><A NAME="sect_3_1_1_">3.1.1. SET, EQU und CONSTANT</A></H3>
<A NAME="index_SET_1"></A><A NAME="index_EQU_1"></A><A
NAME="index_.SET_1"></A><A NAME="index_.EQU_1"></A><A
NAME="index_CONSTANT_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren,<TT> CONSTANT</TT> nur
KCPSM(3)</EM>
<P>
<TT> SET</TT> und<TT> EQU</TT> erlauben die Definition typenloser
Konstanten, d.h. sie werden keinem Segment zugeordnet und ihre
Verwendung erzeugt in keinem Fall eine Warnung wegen
Segment-Vermischung. W&auml;hrend<TT> EQU</TT> Konstanten definiert,
die nicht wieder (mit<TT> EQU</TT>) ge&auml;ndert werden k&ouml;nnen,
erlaubt<TT> SET</TT> die Definition von Variablen, die sich
w&auml;hrend des Assemblerlaufes ver&auml;ndern lassen. Dies ist
n&uuml;tzlich z.B. bei der Allokation von Resourcen &agrave; la
Interrupt-Vektoren, wie im folgenden Beispiel:
<PRE>

VecCnt  SET     0         ; irgendwo am Anfang
        ...
DefVec  MACRO   Name      ; einen neuen Vektor belegen
Name    EQU     VecCnt
VecCnt  SET     VecCnt+4
        ENDM
        ...
        DefVec  Vec1      ; ergibt Vec1=0
        DefVec  Vec2      ; ergibt Vec2=4

</PRE>
Intern werden Konstanten und Variablen identisch gespeichert, der
einzige Unterschied ist, da&szlig; sie als unver&auml;nderbar
markiert werden, wenn sie mit<TT> EQU</TT> definiert werden. Der
Versuch, eine Konstante mit<TT> SET</TT> zu ver&auml;ndern, gibt eine
Fehlermeldung.
<P>
Mit<TT> EQU/SET</TT> lassen sich Konstanten aller Typen definieren,
z.B.
<PRE>

IntZwei   EQU   2
FloatZwei EQU   2.0

</PRE>
Einige Prozessoren besitzen leider bereits selber einen<TT>
SET</TT>-Befehl. Bei diesen mu&szlig;<TT> EVAL</TT> anstelle von<TT>
SET</TT> verwendet werden, falls sich der Maschinenbefehl nicht durch
die andere Anzahl der Argumente erkennen l&auml;&szlig;t. Alternativ
ist es auch immer m&ouml;glich, durch einen vorangestellten Punkt
(<TT>.SET</TT> anstelle<TT> SET</TT>) explizit den Pseudobefehl
aufzurufen.
<P>
Anstelle von<TT> EQU</TT> darf auch<TT> .EQU</TT> oder einfach ein
Gleichheitszeichen geschrieben werden, analog kann man anstelle
von<TT> SET</TT> bzw.<TT> EVAL</TT> einfach<TT> :=</TT> schreiben.
Des weiteren existiert eine 'alternative' Syntax, bei der der
Synbolname nicht aus dem Feld f&uuml;r das Label genommen wird,
sondern das erste Argument ist. Wahlweise darf man also auch
schreiben:
<PRE>

          EQU   IntZwei,2
          EQU   FloatZwei,2.0

</PRE>
Das Feld f&uuml;r das Label mu&szlig; in diesem Fall leer bleiben.
<P>
Aus Kompatibilit&auml;tsgr&uuml;nden zum Originalassembler gibt es
f&uuml;r das KCPSM-Target auch den<TT> CONSTANT</TT>-Befehl, der im
Gegensatz zu<TT> EQU</TT> Namen und Wert immer als Argumente
erwartet, also z.B. so:
<PRE>

      CONSTANT  const1, 2

</PRE>
<TT> CONSTANT</TT> ist allerdings auf Integer-Konstanten
beschr&auml;nkt.
<P>
Defaultm&auml;&szlig;ig sind mit<TT> SET</TT> oder<TT> EQU</TT>
definierte Symbole typenlos, optional kann jedoch als zweites bzw.
drittes Argument ein Segmentname (<TT>CODE, DATA, IDATA, XDATA,
YDATA, BITDATA, IO oder REG</TT>) oder<TT> MOMSEGMENT</TT> f&uuml;r
das aktuell gesetzte Segment angegeben werden, um das Symbol einem
bestimmten Adre&szlig;raum zuordnen. AS ber&uuml;cksichtigt dabei
nicht, ob der benutzte Adre&szlig;raum bei dem aktuell gesetzten
Zielprozessor auch vorhanden ist!
<P>
Als kleines verstecktes Extra ist es m&ouml;glich, &uuml;ber<TT>
SET</TT> oder<TT> EQU</TT> den Programmz&auml;hler zu setzen, also
das zu machen, wozu man ansonsten<TT> ORG</TT> verwenden w&uuml;rde.
Dazu gibt man als Symbolnamen den Sonderwert an, mit dem sich auch
der aktuelle Programmz&auml;hler abfragen l&auml;&szlig;t, also je
nach gew&auml;hlter Zielarchitektur ein Stern, ein Dollarzeichen, ein
Punkt oder<TT> PC</TT>.
<P>
Falls die gew&auml;hlte Zielarchitektur ein Attribut an den Befehlen
zur Angabe der Operandengr&ouml;&szlig;e unterst&uuml;tzt (z.B.
680x0), so ist dieses ebenfalls bei<TT> SET</TT> und<TT> EQU</TT>
erlaubt. Das definierte Symbol wird dann mit dieser
Operandengr&ouml;&szlig;e in der Symboltabelle abgelegt. Deren
Verwendung bei Benutzung des Symbols ist architekturab&auml;ngig.
<P>

<H3><A NAME="sect_3_1_2_">3.1.2. SFR und SFRB</A></H3>
<A NAME="index_SFR_1"></A><A NAME="index_SFRB_1"></A>
<P>
<EM> G&uuml;ltigkeit: diverse, SFRB nur MCS-51</EM>
<P>
Diese Befehle funktionieren wie<TT> EQU</TT>, nur sind die damit
definierten Symbole dem direkt adressierbaren Datensegment
zugeordnet, d.h. sie dienen bevorzugt zur Definition von (wie der
Name ahnen l&auml;&szlig;t) im Daten- bzw. I/O-Bereich eingeblendeten
Hardwareregistern. Der dabei zugelassene Wertebereich ist identisch
mit dem bei<TT> ORG</TT> f&uuml;r das<TT> DATA</TT> bzw.<TT>
IO</TT>-Segment zugelassenen (s. Abschnitt <A
HREF="#ref_SectORG">3.2.1</A>).<TT> SFR</TT> und<TT> SFRB</TT>
unterscheiden sich darin, da&szlig;<TT> SFRB</TT> das Register als
bitadressierbar kennzeichnet, weshalb AS zus&auml;tzlich 8 Symbole
erzeugt, die dem Bitsegment zugeordnet werden und die Namen<TT>
xx.0</TT> bis<TT> xx.7</TT> tragen, z.B.
<PRE>

PSW     SFR     0d0h   ; ergibt PSW = D0H (Datensegment)

PSW     SFRB    0d0h   ; zusaetzlich PSW.0 = D0H (Bit)
                       ; bis PSW.7 = D7H (Bit)

</PRE>
Da beim 80C251 grunds&auml;tzlich alle SFRs ohne zus&auml;tzliche
Bit-Symbole bitadressierbar sind, ist der<TT> SFRB</TT>-Befehl
f&uuml;r ihn auch nicht mehr definiert; die Bits<TT> PSW.0</TT>
bis<TT> PSW.7</TT> sind automatisch vorhanden.
<P>
AS &uuml;berpr&uuml;ft bei der Definition eines bitadressierbaren
Registers mit<TT> SFRB</TT>, ob die Speicherstelle &uuml;berhaupt
bitadressierbar ist (Bereich 20h..3fh bzw. 80h, 88h, 90h,
98h...0f8h). Ist sie es nicht, so wird eine Warnung ausgegeben; die
dann erzeugten Bit-Symbole sind undefiniert.
<P>

<H3><A NAME="sect_3_1_3_">3.1.3. XSFR und YSFR</A></H3>
<A NAME="index_XSFR_1"></A><A NAME="index_YSFR_1"></A>
<P>
<EM> G&uuml;ltigkeit: DSP56xxx</EM>
<P>
Auch der DSP56000 hat einige Peripherieregister memory-mapped im
Speicher liegen, die Sache wird jedoch dadurch komplizierter,
da&szlig; es zwei Datenbereiche gibt, den X-und Y-Bereich. Diese
Architektur erlaubt einerseits zwar einen h&ouml;heren
Parallelit&auml;tsgrad, zwingt jedoch andererseits dazu, den
normalen<TT> SFR</TT>-Befehl in die beiden oben genannten Varianten
aufzuspalten. Sie verhalten sich identisch zu<TT> SFR</TT>, nur
da&szlig;<TT> XSFR</TT> ein Symbol im X-Adre&szlig;raum definiert
und<TT> YSFR</TT> entsprechend eines im Y-Adre&szlig;raum. Der
erlaubte Wertebereich ist 0..$ffff.
<P>

<H3><A NAME="sect_3_1_4_">3.1.4. LABEL</A></H3>
<A NAME="index_LABEL_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Die Funktion des<TT> LABEL</TT>-Befehls ist identisch zu<TT>
EQU</TT>, nur wird das Symbol nicht typenlos, sondern erh&auml;lt das
Attribut ,,Code''.<TT> LABEL</TT> wird genau f&uuml;r einen Zweck
ben&ouml;tigt: Labels in Makros sind normalerweise lokal, also nicht
au&szlig;erhalb des Makros zugreifbar. Mit einem<TT> EQU</TT>-Befehl
kann man sich zwar aus der Aff&auml;re ziehen, die Formulierung
<PRE>

&lt;Name&gt;   label    $

</PRE>
erzeugt aber ein Symbol mit korrekten Attributen.
<P>

<H3><A NAME="sect_3_1_5_">3.1.5. BIT</A></H3>
<A NAME="index_BIT_1"></A>
<P>
<EM> G&uuml;ltigkeit: MCS-(2)51, XA, 80C166, 75K0, STM8, ST9, AVR,
S12Z, SX20/28, H16, H8/300, H8/500, KENBAK, Padauk</EM>
<P>
<TT> BIT</TT> dient dazu, ein einzelnes Bit einer Speicherstelle mit
einem symbolischen Namen gleichzusetzen. Da die Art und Weise, wie
verschiedene Prozessoren Bitverarbeitung und -adressierung betreiben,
stark variiert, verh&auml;lt sich auch dieser Befehl je nach
Zielplattform anders:
<P>
F&uuml;r die MCS/51-Familie, die einen eigenen Adre&szlig;raum
f&uuml;r Bitoperanden besitzt, ist die Funktion von<TT> BIT</TT> ganz
analog zu<TT> SFR</TT>, d.h. es wird einfach ein Integer-Symbol mit
dem angegebenen Wert und dem Segment BDATA erzeugt. F&uuml;r alle
anderen Prozessoren wird die Bitadressierung dagegen zweidimensional
mit Adresse und Bitstelle vorgenommen. In diesem Fall verpackt AS
beide Teile in einer vom jeweiligen Prozessor abh&auml;ngigen Weise
in ein Integer-Symbol und dr&ouml;selt dieses bei der Benutzung
wieder in die beiden Teile auseinander. Letzterer Fall trifft auch
schon f&uuml;r den 80C251 zu: W&auml;hrend zum Beispiel der Befehl
<PRE>

Mein_Carry	bit	PSW.7

</PRE>
auf einem 8051 noch dem Symbol<TT> Mein_Carry</TT> den Wert 0d7h
zuweisen w&uuml;rde, w&uuml;rde auf einem 80C251 dagegen ein Wert von
070000d0h generiert werden, d.h. die Adresse steht in Bit 0..7 sowie
die Bitstelle in Bit 24..26. Dieses Verfahren entspricht dem, das
auch beim DBIT- Befehl des TMS370 angewendet wird und funktioniert
sinngem&auml;&szlig; so auch beim 80C166, nur da&szlig; dort
Bitstellen von 0 bis 15 reichen d&uuml;rfen:
<PRE>

MSB     BIT     r5.15

</PRE>
Beim Philips XA findet sich in Bit 0..9 die Bitadresse, wie sie auch
in die Maschinenbefehle eingesetzt wird, f&uuml;r Bits aus den
RAM-Speicher wird in Bit 16..23 die 64K-Bank eingesetzt.
<P>
Noch etwas weiter geht der<TT> BIT</TT>-Befehl bei der 75K0-Familie:
Da dort Bitadressierungen nicht nur absolute Basisadressen verwenden
d&uuml;rfen, sind sogar Ausdr&uuml;cke wie
<PRE>

bit1    BIT     @h+5.2

</PRE>
erlaubt.
<P>
Beim ST9 ist es hingegen m&ouml;glich, Bits auch invertiert
anzusprechen, was beim<TT> BIT</TT>-Befehl auch ber&uuml;cksichtigt
wird:
<PRE>

invbit  BIT     r6.!3

</PRE>
N&auml;heres zum<TT> BIT</TT>-Befehl beim ST9 findet sich bei den
prozessorspezifischen Hinweisen.
<P>
Im Falle des H16 sind die Argumente f&uuml;r Speicheradresse und
Bitposition vertauscht. Dies wurde getan, um die Syntax zur
Definition von Bit identisch zu den Maschinenbefehlen zu machen, die
einzelne Bits manipulieren.
<P>

<H3><A NAME="sect_3_1_6_">3.1.6. DBIT</A></H3>
<A NAME="index_DBIT_1"></A>
<P>
<EM> G&uuml;ltigkeit: TMS 370xxx</EM>
<P>
Die TMS370-Reihe hat zwar kein explizites Bit-Segment, jedoch
k&ouml;nnen einzelne Bits als Symbol durch diesen Befehl simuliert
werden.<TT> DBIT</TT> ben&ouml;tigt zwei Operanden, n&auml;mlich
einmal die Adresse der Speicherstelle, in der das Bit liegt, sowie
die genaue Position des Bits im Byte. So definiert man z.B. mit
<PRE>

INT3            EQU     P019
INT3_ENABLE     DBIT    0,INT3

</PRE>
das Bit, welches Interrupts von Anschlu&szlig; INT3 freigibt. So
definierte Bits k&ouml;nnen dann von den Befehlen<TT> SBIT0, SBIT1,
CMPBIT, JBIT0</TT> und<TT> JBIT</TT> genutzt werden.
<P>

<H3><A NAME="sect_3_1_7_">3.1.7. DEFBIT und DEFBITB</A></H3>
<A NAME="index_DEFBIT_1"></A><A NAME="index_DEFBITB_1"></A>
<P>

<H4>S12Z</H4>
<P>
Der Prozessorkern der S12Z-Familie verf&uuml;gt &uuml;ber Befehle,
mit denen sich einzelne Bits in Register oder Speicherzellen
manipulieren lassen. Um Bits im I/O-Bereich des Prozessors (erste 4
KByte des Adre&szlig;raumes) bequem ansprechen zu k&ouml;nnen, kann
man einem einzelnen Bit, definiert durch Speicheradresse und
Bitposition, einen symbolischen Namen geben:
<PRE>

&lt;Name&gt;         defbit[.Size]   &lt;Adresse&gt;,&lt;Position&gt;

</PRE>
Die<TT> Adresse</TT> mu&szlig; in den ersten 4 KByte liegen, als
Operandengr&ouml;&szlig;e sind 8, 16 oder 32 Bit
(<TT>Size</TT>=b/w/l) zugelassen. Dementsprechend darf<TT>
Position</TT> maximal 7, 15 oder 31 sein. Falls keine
Opoerandengr&ouml;&szlig;e angegeben wird, werden 8 Bit (.b)
angenommen. Ein solcherma&szlig;en definiertes Bit kann als Argument
f&uuml;r die Befehle<TT> BCLR, BSET, BTGL, BRSET</TT> und<TT>
BRCLR</TT> verwendet werden:
<PRE>

mybit   defbit.b  $200,4
        bclr.b    $200,#4
        bclr      mybit

</PRE>
Die beiden Aufrufe von<TT> bclr</TT> in diesem Beispiel erzeugen
identischen Code. Da ein solcherma&szlig;en definiertes Bit seine
Operandengr&ouml;&szlig;e ''kennt'', kann diese bei der Benutzung
fortgelassen werden.
<P>
Bit-Definitionen innerhalb einer Struktur, die sich auf ein Element
einer Struktur beziehen, sind ebenfalls m&ouml;glich:
<PRE>

mystruct struct    dots
reg      ds.w      1
flag     defbit    reg,4
         ends

         org       $100
data     mystruct

         bset      data.flag  ; entspricht bset.w $100,#4

</PRE>
<P>

<H4>Super8</H4>
<P>
Im Gegensatz zum ''klassischen'' Z8 verf&uuml;gt der Super8-Kern
&uuml;ber Befehle, mit denen sich Bits in allgemeinen oder
Arbeitsregistern bearbeiten lassen. Dabei ist jedoch zu beachten,
da&szlig; einige davon nur auf Bits arbeiten, die Teil eines der 16
Arbeitsregister sind. Mit der<TT> DEFBIT</TT>-Anweisung lassen sich
Bits beider Sorten definieren:
<PRE>

workbit	defbit	r3,#4
slow	defbit	emt,#6

</PRE>
Derart definierte Bits lassen sich dann bei den Befehlen wie ein
P&auml;rchen aus Register und Bitposition einsetzen:
<PRE>

	ldb	r3,emt,#6
	ldb	r3,slo		; gleich bedeutend

	bitc	r3,#4
	bitc	workbit		; gleich bedeutend

</PRE>
<P>

<H4>Z8000</H4>
<P>
Der Z8000 verf&uuml;gt zwar &uuml;ber Befehle zum Setzen und
R&uuml;cksetzen von Bits, diese k&ouml;nnen jedoch nur auf Adressen
im Speicher- und nicht im I/O-Adre&szlig;raum wirken. Aus diesem
Grund lassen sich mit<TT> DEFBIT</TT> bzw.<TT> DEFBITB</TT> auch nur
Bit-Objekte im Speicher-Adre&szlig;raum definieren. Die
Unterscheidung der Operandengr&ouml;&szlig;e ist wichtig, weil der
Z8000 ein Big-Endian-Prozessor ist: Bit<EM> n</EM> eines 16-Bit-Worts
bei Adresse<EM> m</EM> entspr&auml;che Bit<EM> n</EM> eines
8-Bit-Byte bei Adresse<EM> m+1</EM>.
<P>

<H4>&micro;PD7807...&micro;PD7809</H4>
<P>
Die ersten 16 Byte der Working Area und Sonderregister mit einer
Adresse kleiner 16 sind bitadressierbar.
<P>

<H3><A NAME="sect_3_1_8_">3.1.8. DEFBITFIELD</A></H3>
<A NAME="index_DEFBITFIELD_1"></A>
<P>
<EM> G&uuml;ltigkeit: S12Z</EM>
<P>
Der Prozessorkern der S12Z-Familie kann nicht nur mit einzelnen Bits
umgehen, sondern auch zusammenh&auml;ngende Felder von Bits in einem
8/16/24/32-Bit-Wert extrahieren oder schreiben. Analog zu<TT>
DEFBIT</TT> l&auml;&szlig;t sich auch ein Bitfeld symbolisch
definieren:
<PRE>

&lt;Name&gt;         defbitfield[.Size]   &lt;Adresse&gt;,&lt;Breite&gt;:&lt;Position&gt;

</PRE>
Im Gegensatz zu einzelnen Bits sind hier auch 24 Bits (.p) als
Operandengr&ouml;&szlig;e zugelassen, der Wertebereich von<TT>
Position</TT> und<TT> Breite</TT> ist dementsprechend von 0 bis 23
bzw. 1 bis 24. Auch hier ist es wieder zul&auml;ssig, Bitfelder als
Teil von Strukturen zu definieren:
<PRE>

mystruct struct      dots
reg      ds.w        1
clksel   defbitfield reg,4:8
         ends

         org       $100
data     mystruct

         bfext     d2,data.clksel ; fetch $100.w bits 4..11
                                  ; to D2 bits 0..7
         bfins     data.clksel,d2 ; insert D2 bits 0..7 into
                                  ; $100.w bits 4..11

</PRE>
Die interne Darstellung von Bits, die mit<TT> DEFBIT</TT> definiert
wurden, ist gleich der von Bitfeldern der Breite eins. Ein symbolisch
definiertes einzelnes Bit kann also auch als Argument f&uuml;r<TT>
BFINS</TT> und<TT> BFEXT</TT> verwendet werden.
<P>

<H3><A NAME="sect_3_1_9_">3.1.9. PORT</A></H3>
<A NAME="index_PORT_1"></A>
<P>
<EM> G&uuml;ltigkeit: PALM, 8008/8080/8085/8086, XA, Z80, Z8000,
320C2x/5x, TLCS-42/47, AVR, F8, IMP-16</EM>
<P>
<TT> PORT</TT> arbeitet analog zu<TT> SFR</TT>, nur wird das Symbol
dem I/O-Adre&szlig;bereich zugeordnet. Erlaubte Werte sind 0..7 beim
3201x und 8008, 0..15 beim 320C2x und PALM, 0..65535 beim 8086, Z8000
und 320C5x, 0..63 beim AVR und 0..255 beim Rest.
<P>
Beispiel: eine PIO 8255 liege auf Adresse 20H:
<PRE>

PIO_Port_A PORT 20h
PIO_Port_B PORT PIO_Port_A+1
PIO_Port_C PORT PIO_Port_A+2
PIO_Ctrl   PORT PIO_Port_A+3

</PRE>
<P>

<H3><A NAME="sect_3_1_10_">3.1.10. REG und NAMEREG</A></H3>
<A NAME="index_REG_1"></A><A NAME="index_NAMEREG_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0, AVR, M*Core, ST9, 80C16x, Z8000,
KCPSM,<BR>
PDP-11, WD16<BR>
(<TT>NAMEREG</TT> nur f&uuml;r KCPSM(3)), LatticeMico8,
MSP430(X)</EM>
<P>
Obwohl immer mit gleicher Syntax, hat diese Anweisung von Prozessor
zu Prozessor eine leicht abweichende Bedeutung: Falls der
Zielprozessor f&uuml;r Register einen eigenen Adre&szlig;raum
verwendet, so hat<TT> REG</TT> die Wirkung eines simplen<TT>
EQU</TT>s f&uuml;r eben diesen Adre&szlig;raum (z.B. beim ST9).
F&uuml;r alle anderen Prozessoren definiert<TT> REG</TT>
Registersymbole, deren Funktion in Abschnitt <A
HREF="#ref_SectRegSyms">2.11</A> beschrieben sind.
<P>
<TT> NAMEREG</TT> existiert aus Kompatibilit&auml;tsgr&uuml;nden zum
Originalassembler f&uuml;r den KCPSM. Es hat die gleiche Funktion,
lediglich werden sowohl Register- als auch symbolischer Name als
Argumente angegeben, z.B. so:
<PRE>

     NAMEREG  s08, treg

</PRE>
<P>
Auf der PDP-11 darf<TT> REG</TT> zus&auml;tzlich ohne Namen im
Label-Feld benutzt werden. Es wird dann als einziges Argument
entweder<TT> ON</TT> oder<TT> OFF</TT> erwartet, und damit werden die
eingebauten Register-Aliase (<TT>Rn</TT> =<TT> %n</TT>,<TT> SP</TT>
=<TT> R6</TT>,<TT> PC</TT> =<TT> R7</TT>) ein- und ausgeschaltet. Sie
sind im Default verf&uuml;gbar, und sollten nur abgeschaltet werden,
wenn sie mit eigenen Symbolnamen in einem Programm kollidieren. Die
augenblickliche Einstellung l&auml;&szlig;t sich aus dem Symbol<TT>
DEFAULT_REGSYMS</TT> lesen.
<P>

<H3><A NAME="sect_3_1_11_">3.1.11. LIV und RIV</A></H3>
<A NAME="index_LIV_1"></A><A NAME="index_RIV_1"></A>
<P>
<EM> G&uuml;ltigkeit: 8X30x</EM>
<P>
<TT> LIV</TT> und<TT> RIV</TT> dienen dazu, sogenannte IV-Bus-Objekte
zu definieren. Bei diesen handelt es sich um Bitgruppen in peripheren
Speicherzellen mit einer L&auml;nge von 1..8 Bit, die fortan
symbolisch angesprochen werden k&ouml;nnen, so da&szlig; man bei den
entsprechenden Befehlen nicht mehr Adresse, L&auml;nge und Position
separat angeben mu&szlig;. Da die 8X30x-Prozessoren zwei periphere
Adre&szlig;r&auml;ume besitzen (einen ,,linken'' und einen
,,rechten'', sind auch zwei separate Befehle definiert. Die Parameter
dieser Befehle sind allerdings identisch: es m&uuml;ssen drei
Parameter sein, die Adresse, Startposition und L&auml;nge angeben.
Weitere Hinweise zur Benutzung von Busobjekten finden sich in
Abschnitt <A HREF="#ref_8X30xSpec">4.25</A>.
<P>

<H3><A NAME="sect_3_1_12_">3.1.12. CHARSET</A></H3>
<A NAME="ref_SectCHARSET"></A><A NAME="index_CHARSET_1"></A><A
NAME="index_CODEPAGE\_VAL_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Einplatinen-Systeme, zumal wenn sie LCDs ansteuern, benutzen
h&auml;ufig einen anderen Zeichensatz als ASCII, und da&szlig; die
Umlautkodierung mit der im PC &uuml;bereinstimmt, d&uuml;rfte wohl
reiner Zufall sein. Und dann gibt es auch (historische) Systeme, die
z.B. eine EBCDIC-Variante verwenden...um nun aber keine
fehlertr&auml;chtigen Umkodierungen im Code per Hand vornehmen zu
m&uuml;ssen, enth&auml;lt der Assembler eine Umsetzungstabelle
f&uuml;r Zeichen, die jedem (ASCII-)zeichen im Quellcode ein
Zielzeichen zuordnet. Zur Modifikation dieser Tabelle (die initial
1:1 &uuml;bersetzt), dient der Befehl<TT> CHARSET</TT>.<TT>
CHARSET</TT> kann mit verschiedenen Parameterzahlen und -typen
aufgerufen werden:
<P>
Ein
<BLOCKQUOTE>
    <TT> CHARSET</TT>
</BLOCKQUOTE>
ohne jegliche Argumente setzt die &Uuml;bersetzungstabelle auf den
1:1-Default wieder zur&uuml;ck.
<P>
Wird nur ein Argument gegeben, mu&szlig; es sich dabei um einen
String-Ausdruck handeln, der von AS als Dateiname interpretiert wird:
<PRE>

        CHARSET  "mapping.bin"

</PRE>
Aus dieser Datei liest AS dann die ersten 256 Bytes aus und kopiert
sie in die &Uuml;bersetzungstabelle. Hiermit lassen sich also
komplexere, extern erzeugte Tabellen mit einer Anweisung laden.
<P>
In allen anderen Varianten wird ein einzelner Eintrag oder ein ganzer
Bereich von Eintr&auml;gen in der Tabelle modifiziert. Mit zwei
(Integer-)Argumenten kann ein einzelner Eintrag neu gesetzt werden.
Ein
<BLOCKQUOTE>
    <TT> CHARSET '&auml;',128</TT>
</BLOCKQUOTE>
bedeutet zum Beispiel, da&szlig; das Zielsystem das &auml; mit der
Zahl 128 kodiert. Es ist auch m&ouml;glich zu definieren, da&szlig;
ein bestimmtes Zeichen &uuml;berhaupt nicht dargestellt werden kann.
Daf&uuml;r l&auml;&szlig;t man das zweite Argument leer:
<BLOCKQUOTE>
    <TT> CHARSET '[',</TT>
</BLOCKQUOTE>
Soll fortan das ,,gel&ouml;schte'' Zeichen irgendwo in einem String
im Speicher abgelegt werden, f&uuml;hrt dies zu einer Fehlermeldung.
<P>
Anstelle eines einzelnen Zeichens kann auch ein ganzer Bereich
umgemappt werden. Das erste und zweite Argument geben den Bereich der
Zeichen an, das dritte das Mapping des ersten Zeichens. Falls z.B.
das Zielsystem keine Kleinbuchstaben unterst&uuml;tzt, k&ouml;nnen
mit
<PRE>

        CHARSET 'a','z','A'

</PRE>
alle Kleinbuchstaben auf die passenden Gro&szlig;buchstaben
automatisch umgesetzt werden. Und auch ein Bereich von Zeichen kann
als ,,nicht verf&uuml;gbar'' markiert werden:
<PRE>

        CHARSET 'a','z',

</PRE>
verbietet die Verwendung von Kleinbuchstabem.
<P>
In der letzten Variante (wieder mit nur zwei Argumenten) folgt nach
dem Startindex ein String, der das Mapping ab dem Start-Zeichen
auflistet. Das Umlegen von Klein- auf Gro&szlig;buchstaben
k&ouml;nnte man also auch so formulieren:
<PRE>

        CHARSET 'a',"ABCDEFGHIJKLMNOPQRSTUVWXYZ"

</PRE>
<P>
<B> ACHTUNG!</B> Das durch<TT> CHARSET</TT> definierte Mapping greift
nicht nur beim Ablegen von Strings im Speicher, es greift auch bei
Multi-Character-Konstanten, also als ,,ASCII'' formulierten
Integer-Konstanten. Dies bedeutet, da&szlig; eine bereits
modifizierte Umsetzungstabelle in den obigen Beispielen zu anderen
Ergebnissen f&uuml;hren kann!
<P>
Mit der eingebauten Funktion<TT> CODEPAGE_VAL</TT> kann die
&Uuml;bersetzung eines einzelnen Zeichens abgefragt werden. F&uuml;r
nicht gemappte Zeichen liefert die Funktion eine -1 zur&uuml;ck.
<P>

<H3><A NAME="sect_3_1_13_">3.1.13. CODEPAGE</A></H3>
<A NAME="index_CODEPAGE_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit der<TT> CHARSET</TT>-Anweisung hat man zwar beliebige Freiheiten
in der Zeichenzuordnung zwischen Entwicklungs- und Zielplattform,
wenn auf der Zielplattform jedoch verschiedene Zeichens&auml;tze
existieren, kann das Umschalten zwischen diesen jedoch zu einer
umst&auml;ndlichen Orgie von<TT> CHARSET</TT>-Kommandos werden. Mit
der<TT> CODEPAGE</TT>-Anweisung kann man jedoch mehrere
Zeichentabellen vorhalten und zwischen diesen mit einem Befehl
umschalten. Als Parameter erwartet<TT> CODEPAGE</TT> ein oder zwei
Namen: zum einen den Namen der fortan zu benutzenden Tabelle, zum
anderen optional den Namen der Tabelle, die die initiale Belegung der
Tabelle vorgibt (dieser Parameter hat somit auch nur eine Bedeutung
beim ersten Umschalten auf eine Tabelle, bei der AS sie automatisch
anlegt). Fehlt der zweite Parameter, so ist die initiale Belegung der
neuen Tabelle gleich der vorher aktiven Tabelle. Alle folgenden<TT>
CHARSET</TT>-Anweisungen ver&auml;ndern<EM> nur</EM> die momentan
aktive Tabelle.
<P>
Zu Beginn eines Durchlaufes wird von AS automatisch eine einzelne
Zeichentabelle mit dem Namen<TT> STANDARD</TT> erzeugt und 1:1
vorbelegt. Verwendet man keine<TT> CODEPAGE</TT>-Anweisungen, so
beziehen sich alle mit<TT> CHARSET</TT> gemachten Einstellungen auf
diese Tabelle.
<P>

<H3><A NAME="sect_3_1_14_">3.1.14. ENUM, NEXTENUM und ENUMCONF</A></H3>
<A NAME="index_ENUM_1"></A><A NAME="index_NEXTENUM_1"></A><A
NAME="index_ENUMCONF_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> ENUM</TT> dient analog zu dem entsprechenden Befehl in C dazu,
Aufz&auml;hlungstypen zu definieren, d.h. eine Reihe von
Integer-Konstanten, denen fortlaufende Werte (von 0 an beginnend)
zugewiesen werden. Als Parameter werden dabei die Namen der zu
definierenden Symbole angegeben, wie in dem folgenden Beispiel:
<BLOCKQUOTE>
    <TT> ENUM SymA,SymB,SymC</TT>
</BLOCKQUOTE>
Dieser Befehl weist den Symbolen<TT> SymA</TT>,<TT> SymB</TT> und<TT>
SymC</TT> die Werte 0, 1 und 2 zu.
<P>
M&ouml;chte man eine Aufz&auml;hlung &uuml;ber mehrere Zeilen
verteilen, so verwendet man ab der zweiten Zeile den Befehle<TT>
NEXTENUM</TT> anstelle von<TT> ENUM</TT>. Der interne Z&auml;hler,
der den Symbolen der Aufz&auml;hlung fortlaufende Werte zuweist, wird
dann nicht wieder auf Null zur&uuml;ck gesetzt, wie in dem folgenden
Fall:
<PRE>

        ENUM     Januar=1,Februar,Maerz,April,Mai,Juni
        NEXTENUM Juli,August,September,Oktober
        NEXTENUM November,Dezember

</PRE>
An diesem Beispiel sieht man auch, da&szlig; man einzelnen Symbolen
explizit Werte anstelle des aktuellen Z&auml;hlerstandes zuweisen
kann. Der interne Z&auml;hler wird anhand dieses Wertes auch
aktualisiert.
<P>
Die Definition von Symbolen mit<TT> ENUM</TT> gleicht einer
Definition mit<TT> EQU</TT>, d.h. es ist nicht m&ouml;glich, einem
Symbol einen neuen Wert zuzuweisen.
<P>
Die<TT> ENUMCONF</TT>-Anweisung erlaubt das Verhalten von<TT>
ENUM</TT> zu beeinflussen.<TT> ENUMCONF</TT> akzeptiert ein oder zwei
Argumente, wobei das erste Argument immer der Wert ist, um den der
interne Z&auml;hler pro Symbol in einer Aufz&auml;hlung
hochgez&auml;hlt wird. Mit einem
<PRE>

      ENUMCONF 2

</PRE>
werden den Symbolen also zum Beispiel die Werte 0,2,4,6... anstelle
0,1,2,3... zugewiesen.
<P>
Das zweite (optionale) Argument von<TT> ENUMCONF</TT> bestimmt,
welchen Adre&szlig;raum die Symbole zugeordnet werden. Per Default
sind mit<TT> ENUM</TT> definierte Symbole typenlos, man kann aber zum
Beispiel mit einem
<PRE>

      ENUMCONF 1,CODE

</PRE>
bestimmen, da&szlig; sie im Instruktions-Adre&szlig;raum liegen
sollen. Die Namen der Adre&szlig;r&auml;ume sind die gleichen wie
beim<TT> SEGMENT</TT>-Befehl (<A HREF="#ref_SEGMENT">3.2.18</A>),
zus&auml;tzlich ist als Argument ein<TT> NOTHING</TT> erlaubt, um
wieder typenlose Symbole zu erzeugen.
<P>

<H3><A NAME="sect_3_1_15_">3.1.15. PUSHV und POPV</A></H3>
<A NAME="index_PUSHV_1"></A><A NAME="index_POPV_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit<TT> PUSHV</TT> und<TT> POPV</TT> ist es m&ouml;glich, den Wert
von (nicht Makro-lokalen) Symbolen tempor&auml;r zu speichern und zu
einem sp&auml;teren Zeitpunkt wiederherzustellen. Die Speicherung
erfolgt auf<EM> Stacks</EM>, d.h. Last-In-First-Out-Speichern. Ein
Stack hat einen Namen, der den allgemeinen Symbolkonventionen
gen&uuml;gen mu&szlig;, und existiert so lange, wie er mindestens ein
Element enth&auml;lt: Ein bisher nicht existierender Stack wird
bei<TT> PUSHV</TT> automatisch angelegt, ein durch<TT> POPV</TT> leer
werdender Stack wird automatisch wieder aufgel&ouml;st. Der Name des
Stacks, auf den Symbole abgelegt und von dem sie wieder abgeholt
werden sollen, ist der erste Parameter von<TT> PUSHV</TT> bzw.<TT>
POPV</TT>, danach folgt eine beliebige Menge von Symbolen als weitere
Parameter. Alle in der Liste aufgef&uuml;hrten Symbole m&uuml;ssen
bereits existieren, es ist also<EM> nicht</EM> m&ouml;glich, mit
einem<TT> POPV</TT>-Befehl implizit neue Symbole zu definieren.
<P>
Stacks stellen eine globale Ressource dar, d.h. ihre Namen sind nicht
lokal zu Sektionen.
<P>
Wichtig ist, da&szlig; die Variablenliste<EM> immer</EM> von links
nach rechts abgearbeitet wird. Wer also mehrere Variablen mit<TT>
POPV</TT> von einem Stack herunter holen will, mu&szlig; diese in
genau umgekehrter Reihenfolge zum entsprechenden<TT> PUSHV</TT>
angeben!
<P>
Der Name des Stacks kann auch weggelassen werden, etwa so:
<PRE>

        pushv   ,var1,var2,var3
        .
        .
        popv    ,var3,var2,var1

</PRE>
AS verwendet dann einen internen, vordefinierten Default-Stack.
<P>
Nach Ende eines Durchlaufes &uuml;berpr&uuml;ft AS, ob noch Stacks
existieren, die nicht leer sind, und gibt deren Namen sowie
,,F&uuml;llstand'' aus. Mit diesen Warnungen kann man herausfinden,
ob an irgendeiner Stelle die<TT> PUSHV</TT>'s und<TT> POPV</TT>'s
nicht paarig sind. Es ist jedoch in keinem Fall m&ouml;glich,
Symbolwerte in einem Stack &uuml;ber mehrere Durchl&auml;ufe
hinwegzuretten: Zu Beginn eines Durchlaufes werden alle Stacks
geleert!
<P>

<H2><A NAME="sect_3_2_">3.2. Codebeeinflussung</A></H2>
<P>

<H3><A NAME="sect_3_2_1_">3.2.1. ORG</A></H3>
<A NAME="ref_SectORG"></A><A NAME="index_ORG_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> ORG</TT> erlaubt es, den Assembler-internen
Adre&szlig;z&auml;hler mit einem neuen Wert zu besetzen. Der
Wertebereich ist vom momentan gew&auml;hlten Segment und vom
Prozessortyp abh&auml;ngig (Tabelle <A HREF="#ref_TabORG">3.1</A>).
Die untere Grenze ist dabei immer 0; die obere Grenze der angegebene
Wert minus eins.
<P>
Falls in einer Familie verschiedene Varianten unterschiedlich
gro&szlig;e Adre&szlig;r&auml;ume haben, ist jeweils der maximale
Raum aufgef&uuml;hrt.
<P>
ORG wird in erster Linie ben&ouml;tigt, um dem Code eine neue
Startadresse zu geben und damit verschiedene, nicht
zusammenh&auml;ngende Codest&uuml;cke in einer Quelldatei
unterzubringen. Sofern nicht in einem Feld explizit anders angegeben,
ist die vorgegebene Startadresse in einem Segment (d.h. die ohne<TT>
ORG</TT> angenommene) immer 0.
<P>
<B> WICHTIG:</B> Falls auch mit dem<TT> PHASE</TT>-Befehl gearbeitet
wird, mu&szlig; ber&uuml;cksichtigt werden, da&szlig; das Argument
von<TT> ORG</TT> immer die<EM> Ladeadresse</EM> des Codes ist, nicht
die<EM> Ausf&uuml;hrungsadresse</EM>. Ausdr&uuml;cke, die sich mit
dem $- oder *-Symbol auf den aktuellen Programmz&auml;hler beziehen,
liefern aber die<EM> Ausf&uuml;hrungsadresse</EM> des Codes und
f&uuml;hren als Argument von<TT> ORG</TT> nicht zum gew&uuml;nschten
Ergebnis. In solchen F&auml;llen ist die<TT> RORG</TT>-Anweisung (<A
HREF="#ref_SectRORG">3.2.2</A>) das Mittel der Wahl.
<P>
<P><CENTER>Tabelle 3.1: Adre&szlig;bereiche f&uuml;r<TT> ORG</TT>
</CENTER><P>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Ziel</SMALL></SMALL><BR>
</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> CODE</SMALL></SMALL><BR>
</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> DATA</SMALL></SMALL><BR>
</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> I-</SMALL></SMALL><BR>
<SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> X-</SMALL></SMALL><BR>
<SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> Y-</SMALL></SMALL><BR>
<SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> BIT-</SMALL></SMALL><BR>
<SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IO</SMALL></SMALL><BR>
</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> REG</SMALL></SMALL><BR>
</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> ROM-</SMALL></SMALL><BR>
<SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> EE-</SMALL></SMALL><BR>
<SMALL><SMALL> DATA</SMALL></SMALL></TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL>68xxx/</SMALL></SMALL><BR>
<SMALL><SMALL> MCF</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> DSP56000</SMALL></SMALL><BR>
<SMALL><SMALL> DSP56300</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K/<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K/<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K/<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PowerPC</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PALM</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> M*Core</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6800,6301,</SMALL></SMALL><BR>
<SMALL><SMALL> 6811</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6805/</SMALL></SMALL><BR>
<SMALL><SMALL> HC08</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K/<BR>
64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6809,</SMALL></SMALL><BR>
<SMALL><SMALL> 6309,</SMALL></SMALL><BR>
<SMALL><SMALL> 052001</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68HC12,</SMALL></SMALL><BR>
<SMALL><SMALL> 68HC12X,</SMALL></SMALL><BR>
<SMALL><SMALL> XGATE</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> S12Z</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68HC16</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68RS08</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> H8/300</SMALL></SMALL><BR>
<SMALL><SMALL> H8/300H</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> H8/500</SMALL></SMALL><BR>
<SMALL><SMALL> (Min)</SMALL></SMALL><BR>
<SMALL><SMALL> H8/500</SMALL></SMALL><BR>
<SMALL><SMALL> (Max)</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> SH7000/</SMALL></SMALL><BR>
<SMALL><SMALL> 7600/7700</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> HD614023</SMALL></SMALL><BR>
<SMALL><SMALL> HD614043</SMALL></SMALL><BR>
<SMALL><SMALL> HD614081</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
4K<BR>
8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>160<BR>
256<BR>
512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16<BR>
16<BR>
16</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> HD641016</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6502,</SMALL></SMALL><BR>
<SMALL><SMALL> MELPS-</SMALL></SMALL><BR>
<SMALL><SMALL> 740</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> HUC6280</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 65816,</SMALL></SMALL><BR>
<SMALL><SMALL> MELPS-</SMALL></SMALL><BR>
<SMALL><SMALL> 7700</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>PPS-4</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MELPS-</SMALL></SMALL><BR>
<SMALL><SMALL> 4500</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>416<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> M16</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> M16C</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PDP-11</SMALL></SMALL><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
256K<BR>
4M<SUP>10</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> VAX</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> WD16</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 4004</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 8008</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MCS-48,</SMALL></SMALL><BR>
<SMALL><SMALL> MCS-41</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1/2/4/<BR>
6/8K<SUP>6</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<SUP>8</SUP><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MCS-51</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<SUP>1</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 80C390</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<SUP>1</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MCS-251</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MCS-96</SMALL></SMALL><BR>
<SMALL><SMALL> 196(N)/</SMALL></SMALL><BR>
<SMALL><SMALL> 296</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 8080,</SMALL></SMALL><BR>
<SMALL><SMALL> 8085</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 80x86,</SMALL></SMALL><BR>
<SMALL><SMALL> V20..55</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68xx0</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 8X30x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 2650</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> XA</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<SUP>3</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> AVR</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>128K<SUP>6</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32K<SUP>6</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K<SUP>7</SUP></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 29XXX</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 80C166,</SMALL></SMALL><BR>
<SMALL><SMALL> 80C167</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256K<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> GBZ80</SMALL></SMALL><BR>
<SMALL><SMALL> Z80,</SMALL></SMALL><BR>
<SMALL><SMALL> Z180,</SMALL></SMALL><BR>
<SMALL><SMALL> Z280,</SMALL></SMALL><BR>
<SMALL><SMALL> eZ80,</SMALL></SMALL><BR>
<SMALL><SMALL> Z380</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
64K<BR>
512K<SUP>2</SUP><BR>
16M<SUP>2</SUP><BR>
16M<BR>
4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
<BR>
---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
<BR>
---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
<BR>
---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
<BR>
---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
<BR>
---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>----<BR>
256<BR>
256<BR>
256<BR>
64K<BR>
4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
<BR>
---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
<BR>
---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---<BR>
---<BR>
---<BR>
---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Z8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> eZ8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Z8001,</SMALL></SMALL><BR>
<SMALL><SMALL> Z8003</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Z8002,</SMALL></SMALL><BR>
<SMALL><SMALL> Z8004</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> KCPSM</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> KCPSM3</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Mico8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4096</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-</SMALL></SMALL><BR>
<SMALL><SMALL> 900(L)</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-90</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-</SMALL></SMALL><BR>
<SMALL><SMALL> 870(/C)</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-42</SMALL></SMALL><BR>
<SMALL><SMALL> TLCS-42</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512,<BR>
1024</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>3,<BR>
6</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-47</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-</SMALL></SMALL><BR>
<SMALL><SMALL> 9000</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TC9331</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>320</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PIC</SMALL></SMALL><BR>
<SMALL><SMALL> 16C5x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PIC</SMALL></SMALL><BR>
<SMALL><SMALL> 16C5x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PIC</SMALL></SMALL><BR>
<SMALL><SMALL> 16C64,</SMALL></SMALL><BR>
<SMALL><SMALL> 16C86</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
8K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
512<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
256<SUP>6</SUP><BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PIC</SMALL></SMALL><BR>
<SMALL><SMALL> 17C42</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> SX20</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> ST6</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> ST7</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> STM8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> ST9</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6804</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 32010</SMALL></SMALL><BR>
<SMALL><SMALL> 32015</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K<BR>
4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>144<BR>
256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8<BR>
8</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 320C2x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 320C3x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 320C40</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 320C44</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 320C5x/</SMALL></SMALL><BR>
<SMALL><SMALL> 320C20x/</SMALL></SMALL><BR>
<SMALL><SMALL> 320C54x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TMS</SMALL></SMALL><BR>
<SMALL><SMALL> 9900</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TMS</SMALL></SMALL><BR>
<SMALL><SMALL> 70Cxx</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 370xxx</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSP430</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TMS1000</SMALL></SMALL><BR>
<SMALL><SMALL> TMS1200</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TMS1100</SMALL></SMALL><BR>
<SMALL><SMALL> TMS1300</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>128<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> IMP-16</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>128</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> IPC-16</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> SC/MP</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 807x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> COP4</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> COP8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> SC144xx</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> NS16008/</SMALL></SMALL><BR>
<SMALL><SMALL> NS32008/</SMALL></SMALL><BR>
<SMALL><SMALL> NS08032/</SMALL></SMALL><BR>
<SMALL><SMALL> NS16032/</SMALL></SMALL><BR>
<SMALL><SMALL> NS32016/</SMALL></SMALL><BR>
<SMALL><SMALL> NS32032/</SMALL></SMALL><BR>
<SMALL><SMALL> NS32CG16</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> NS32332/</SMALL></SMALL><BR>
<SMALL><SMALL> NS32532</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> ACE</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K<SUP>4</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> CP-3F/</SMALL></SMALL><BR>
<SMALL><SMALL> M380/</SMALL></SMALL><BR>
<SMALL><SMALL> LP8000</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>48<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> F3850</SMALL></SMALL><BR>
<SMALL><SMALL> F8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64<BR>
64</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> &micro;PD</SMALL></SMALL><BR>
<SMALL><SMALL> 78(C)xx</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> &micro;PD</SMALL></SMALL><BR>
<SMALL><SMALL> 550</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>640<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> &micro;PD</SMALL></SMALL><BR>
<SMALL><SMALL> 554, 652</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1000<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> &micro;PD</SMALL></SMALL><BR>
<SMALL><SMALL> 547, 552</SMALL></SMALL><BR>
<SMALL><SMALL> 651</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1000<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> &micro;PD</SMALL></SMALL><BR>
<SMALL><SMALL> 546, 553</SMALL></SMALL><BR>
<SMALL><SMALL> 556, 557</SMALL></SMALL><BR>
<SMALL><SMALL> 650</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2000<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>96<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 7566</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 7508</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 75K0</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 78K0</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 78K2</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 78K3</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 78K4</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<SUP>5</SUP></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 7720</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>128<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 7725</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1024<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 77230</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 70616</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 53C8XX</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> F<SUP>2</SUP></SMALL></SMALL>MC8L</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> F<SUP>2</SUP></SMALL></SMALL>MC16L</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSM5840</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>128</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSM5842</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>768</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSM58421</SMALL></SMALL><BR>
<SMALL><SMALL> MSM58422</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1.5K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>40<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSM5847</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1.5K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>96</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSM5054</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>62</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSM5055</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1.75K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>96</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSM5056</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1.75K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>90</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSM6051</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2.5K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>119</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MN1610</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MN1613</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PMCxxx/</SMALL></SMALL><BR>
<SMALL><SMALL> PMSxxx/</SMALL></SMALL><BR>
<SMALL><SMALL> PFSxxx</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1..<BR>
4K<SUP>9</SUP><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64..<BR>
256<SUP>9</SUP><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32..<BR>
128<SUP>9</SUP><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 180x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> XS1</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 1750</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> KENBAK</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> CP1600</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> NANO</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> IM6100</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> IM6120</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> RX...</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> SC61860</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> SC62015</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>1</SUP> Initialwert 80h.<BR>
Da der 8051 kein RAM jenseits 80h hat, mu&szlig; der Initialwert f&uuml;r den 8051<BR>
als Zielprozessor auf jeden Fall mit<TT> ORG</TT> angepa&szlig;t werden.</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>2</SUP> Da Z180 und Z280 weiterhin logisch nur 64K ansprechen k&ouml;nnen, ist der<BR>
ganze Adre&szlig;raum nur mittels<TT> PHASE</TT>-Anweisungen oder passenden<TT> ASSUME</TT>-<BR>
Werten f&uuml;r die MMU-Register erreichbar.</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>3</SUP> Initialwert 400h.</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>4</SUP> Initialwert 800h bzw. 0C00h</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>5</SUP> Bereich f&uuml;r Programmcode auf 1 MByte begrenzt</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>6</SUP> Gr&ouml;&szlig;e ist vom Zielprozessor abh&auml;ngig</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>7</SUP> Gr&ouml;&szlig;e und Verf&uuml;gbarkeit sind vom Zielprozessor abh&auml;ngig</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>8</SUP> Nur auf Varianten mit<TT> MOVX</TT>-Anweisung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>9</SUP> typabh&auml;ngig</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=11 ALIGN=LEFT><SUP>10</SUP> modellabh&auml;ngig</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><A NAME="ref_TabORG"></A></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
</TR>
</TABLE></CENTER>
<P>

<H3><A NAME="sect_3_2_2_">3.2.2. RORG</A></H3>
<A NAME="ref_SectRORG"></A><A NAME="index_RORG_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> RORG</TT> setzt wie<TT> ORG</TT> den Programmz&auml;hler neu,
erwartet als Argument allerdings keine absolute Adresse, sondern
einen relativen Wert (positiv oder negativ), der zum
Programmz&auml;hler addiert wird. Eine Anwendungsm&ouml;glichkeit ist
das Freilassen einer bestimmten Menge von Adre&szlig;raum, oder die
Anwendung in Code-Teilen, die an mehreren Stellen (z.B. via Makros
oder Includes) eingebunden werden und lageunabh&auml;ngig arbeiten
sollen. Eine weitere Anwendungsm&ouml;glichkeit ergibt sich in Code,
der eine Ausf&uuml;hrungsadresse unterschiedlich zur Ladeadresse hat
(d.h. es wird mit der<TT> PHASE</TT>-Anweisung gearbeitet). Es gibt
kein Symbol, &uuml;ber das man in so einer Situation auf die
aktuelle<EM> Ladeadresse</EM> zugreifen kann, aber mittels<TT>
RORG</TT> kann man sich indirekt darauf beziehen.
<P>

<H3><A NAME="sect_3_2_3_">3.2.3. CPU</A></H3>
<A NAME="ref_SectCPU"></A><A NAME="index_CPU_1"></A>
<P>
<P>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit diesem Befehl wird festgelegt, f&uuml;r welchen Prozessor im
weiteren Code erzeugt werden soll. Die Befehle der anderen
Prozessorfamilien sind dann nicht greifbar und erzeugen eine
Fehlermeldung!
<P>
Die Prozessoren k&ouml;nnen grob in Familien unterschieden werden, in
den Familien dienen unterschiedliche Typen noch einmal zur
Feinunterscheidung:
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> a)</TD><TD NOWRAP> 68008 &rarr; 68000 &rarr; 68010 &rarr; 68012 &rarr;</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MCF5202 &rarr; MCF5204 &rarr; MCF5206 &rarr; MCF5208&rarr;</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MCF52274 &rarr; MCF52277 &rarr; MCF5307 &rarr; MCF5329 &rarr; MCF5373 &rarr;</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MCF5407 &rarr; MCF5470 &rarr; MCF5471 &rarr; MCF5472 &rarr; MCF5473 &rarr;</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MCF5474 &rarr; MCF5475 &rarr; MCF51QM &rarr;</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 68332 &rarr; 68340 &rarr; 68360 &rarr;</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 68020 &rarr; 68030 &rarr; 68040</TD></TR>
</TABLE></BLOCKQUOTE>
In dieser Familie liegen die Unterschiede in hinzukommenden Befehlen
und Adressierungsarten (ab 68020). Eine kleine Ausnahme stellt der
Schritt zum 68030 dar, dem 2 Befehle fehlen:<TT> CALLM</TT> und<TT>
RTM</TT>. Die drei Vertreter der 683xx-Familie haben den gleichen
Prozessorkern (eine leicht abgemagerte 68020-CPU), jedoch v&ouml;llig
unterschiedliche Peripherie. MCF5xxx repr&auml;sentiert verschiedene
ColdFire-Varianten von Motorola/Freescale/NXP, zum 680x0 bin&auml;r
abw&auml;rtskompatible RISC-Prozesoren. Beim 68040 kommen die
zus&auml;tzlichen Steuerregister (via<TT> MOVEC</TT> erreichbar)
f&uuml;r On-Chip-MMU und Caches sowie einige Systembefehle f&uuml;r
selbige hinzu.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> b)</TD><TD NOWRAP> 56000 &#10230; 56002 &#10230; 56300</TD></TR>
</TABLE></BLOCKQUOTE>
W&auml;hrend der 56002 nur Befehle zum Inkrementieren und
Dekrementieren der Akkus erg&auml;nzt, ist der 56300-Kern schon fast
ein neuer Prozessor: Er vergr&ouml;&szlig;ert alle
Adre&szlig;r&auml;ume von 64K-W&ouml;rtern auf 16M und verdoppelt
fast die Anzahl der Befehle.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> c)</TD><TD NOWRAP> PPC403 &rarr; PPC403GC &rarr; MPC505 &rarr; MPC601 &rarr; MPC821 &rarr; RS6000</TD></TR>
</TABLE></BLOCKQUOTE>
Der PCC403 ist eine abgespeckte Version der PowerPC-Linie ohne
Gleitkommaeinheit, demzufolge sind s&auml;mtliche Gleitkommabefehle
bei ihm gesperrt; daf&uuml;r sind einige Mikrocontroller-spezifische
Befehle enthalten, die er als einziges Mitglied in dieser Familie
kennt. Die GC-Variante des PPC403 hat zus&auml;tzlich eine MMU und
deshalb einige Befehle zu deren Steuerung mehr. Der MPC505 (eine
Mikrokontroller-Variante mit FPU) unterscheidet sich solange vom
601er nur in den Peripherieregistern, wie ich es nicht besser
wei&szlig; - <A HREF="#cite_Mot505">[82]</A> h&auml;lt sich da noch
etwas bedeckt... Die RS6000-Reihe kennt noch einige Befehle mehr (die
auf vielen 601er-Systemen emuliert werden, um vollst&auml;ndige
Kompatibilit&auml;t herzustellen), au&szlig;erdem verwendet IBM z.T.
andere Mnemonics f&uuml;r diese reinen Workstation-Prozessoren, als
Remineszenz an die 370er-Gro&szlig;rechner...
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> d)</TD><TD NOWRAP> IBM5100, IBM5110, IBM5120</TD></TR>
</TABLE></BLOCKQUOTE>
Diese drei Typen referenzieren aktuell alle auf den gleichen (PALM-)
Prozessorkern.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> e)</TD><TD NOWRAP> MCORE</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> f)</TD><TD NOWRAP> XGATE</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> g)</TD><TD NOWRAP> 6800 &rarr; 6801 &rarr; 6301 &rarr; 6811</TD></TR>
</TABLE></BLOCKQUOTE>
W&auml;hrend der 6301 nur einige neue Befehle definiert (und der 6301
noch ein paar mehr), bietet der 6811 neben weiteren Befehlen ein
zweites Indexregister Y zur Adressierung.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> h)</TD><TD NOWRAP> 6809/6809UNDOC/6309 und 6805/68HC08/68HCS08</TD></TR>
</TABLE></BLOCKQUOTE>
Diese Prozessoren sind zwar teilweise Quellcode-kompatibel zu den
anderen 68xx-ern, haben aber ein anderes Bin&auml;rcode-Format und
einen deutlich eingeschr&auml;nkteren (6805) bzw. erweiterten (6809)
Befehlssatz. Der 6309 ist eine CMOS-Version des 6809, die zwar
offiziell nur kompatibel zum 6809 ist, inoffiziell aber mehr Register
und deutlich mehr Befehle besitzt (siehe <A
HREF="#cite_Kaku">[56]</A>). 6809UNDOC schaltet die
undokumentierte<TT> HCF</TT>-Instruktion frei.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> i)</TD><TD NOWRAP> 68HC12 &#10230; 68HC12X</TD></TR>
</TABLE></BLOCKQUOTE>
Der 12X-Kern bietet eine Reihe neuer Befehle, bzw. bestehende Befehle
wurden um neue Adressierungsarten erg&auml;nzt.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> j)</TD><TD NOWRAP> S912ZVC19F0MKH, S912ZVC19F0MLF,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVCA19F0MKH, S912ZVCA19F0MLF,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVCA19F0WKH, S912ZVH128F2CLQ,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVH128F2CLL, S912ZVH64F2CLQ,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVHY64F1CLQ, S912ZVHY32F1CLQ,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVHY64F1CLL, S912ZVHY32F1CLL,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVHL64F1CLQ, S912ZVHL32F1CLQ,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVHL64F1CLL, S912ZVHL32F1CLL,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVFP64F1CLQ, S912ZVFP64F1CLL,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVH128F2VLQ, S912ZVH128F2VLL,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVH64F2VLQ, S912ZVHY64F1VLQ,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVHY32F1VLQ, S912ZVHY64F1VL,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> S912ZVHY32F1VLL, S912ZVHL64F1VLQ</TD></TR>
</TABLE></BLOCKQUOTE>
Alle Derivate beinhalten den gleichen Prozessorkern und den gleichen
Befehlssatz, lediglich die on-Chip-Peripherie und die Menge
eingebauten Speichers (RAM, Flash-ROM, EEPROM) variieren.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> k)</TD><TD NOWRAP> 68HC16</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> l)</TD><TD NOWRAP> 052001</TD></TR>
</TABLE></BLOCKQUOTE>
Dieser Baustein ist eine Eigenentwicklung von Konami und in
Architektur und Befehlssatz an den Motorola 6809 angelehnt. Er ist
jedoch nicht bin&auml;rkompatibel und stellt auch nicht alle Befehle
und Adressierungsarten des Vorbilds zur Verf&uuml;gung.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> m)</TD><TD NOWRAP> HD6413308 &#10230; HD6413309</TD></TR>
</TABLE></BLOCKQUOTE>
Diese beiden Namen repr&auml;sentieren die 300er und 300H-Varianten
der H8-Familie; die H-Version besitzt dabei einen gr&ouml;&szlig;eren
Adre&szlig;raum (16 Mbyte statt 64Kbyte), doppelt so breite Register
(32 Bit) und kennt einige zus&auml;tzliche Befehle und
Adressierungsarten. Trotzdem ist sie bin&auml;r
aufw&auml;rtskompatibel.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> n)</TD><TD NOWRAP> HD6475328 &#10230; HD6475348 &#10230; HD6475368 &#10230; HD6475388</TD></TR>
</TABLE></BLOCKQUOTE>
Diese Prozessoren besitzen alle den gleichen CPU-Kern; Die
unterschiedlichen Typen dienen lediglich der Einbindung des korrekten
Registersatzes in der Datei<TT> REG53X.INC</TT>.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> o)</TD><TD NOWRAP> SH7000 &#10230; SH7600 &#10230; SH7700</TD></TR>
</TABLE></BLOCKQUOTE>
Der Prozessorkern des 7600ers bietet eine Handvoll Befehle mehr, die
L&uuml;cken im Befehlssatz des 7000ers schlie&szlig;en
(verz&ouml;gerte, bedingte sowie relative und indirekte Spr&uuml;nge,
Multiplikationen mit 32-Bit-Operanden sowie
Multiplizier/Addier-Befehle). Die 7700er-Reihe (auch als SH3
gel&auml;ufig) bietet weiterhin eine zweite Registerbank, bessere
Schiebebefehle sowie Befehle zur Cache-Steuerung.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> p)</TD><TD NOWRAP> HD614023 &#10230; HD614043 &#10230; HD614081</TD></TR>
</TABLE></BLOCKQUOTE>
Diese drei Varianten der HMCS400-Serie unterscheiden sich in der
Gr&ouml;&szlig;e des internen ROM- und RAM-Speichers.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> q)</TD><TD NOWRAP> HD641016</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist aktuell das einzige Target mit H16-Kern.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> r)</TD><TD NOWRAP> 6502 &rarr; 65(S)C02 &rarr; 65CE02 / W65C02S</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 65C19 / MELPS740 / HUC6280 / 6502UNDOC</TD></TR>
</TABLE></BLOCKQUOTE>
Die CMOS-Version definiert einige zus&auml;tzliche Befehle,
au&szlig;erdem sind bei einigen Befehlen Adressierungsarten
hinzugekommen, die beim 6502 nicht m&ouml;glich waren. Der W65SC02
erg&auml;nzt den 65C02-Befehlssatz um zwei Befehle, mit denen die
Low-Power-Modi der CPU feiner eingestellt werden k&ouml;nnen. Dem
65SC02 fehlen die Bitmanipulationsbefehle des 65C02. Der 65CE02
erg&auml;nzt Sprungbefehle mit 16-Bit-Displacement, ein Z-Register,
einen 16-bittigen Stack-Pointer, eine Reihe neuer Befehle und eine
programmierbare Base-Page.
<P>
Der 65C19 ist<EM> nicht</EM> bin&auml;r aufw&auml;rtskompatibel zum
originalen 6502! Einige Adressierungsarten wurden durch andere
ersetzt. Des weiteren enth&auml;lt dieser Prozessor
Befehlssatz-Erweiterungen, die die Implementierung digitaler
Signalverarbeitung erleichtern.
<P>
Die Mitsubishi-Mikrokontroller dagegen erweitern den 6502-Befehlssatz
in erster Linie um Bitoperationen und
Multiplikations-/Divisionsbefehle. Bis auf den unbedingten Sprung und
Befehle zur Inkrementierung/Dekremetierung des Akkumulators sind die
Erweiterungen disjunkt.
<P>
Das herausstechendste Merkmal des HuC 6280 ist der gr&ouml;&szlig;ere
Adre&szlig;raum von 2 MByte anstelle 64 KByte, der durch eingebaute
Bankregister erreicht wird. Des weiteren existieren einige
Sonderbefehle zur Kommunikation mit dem Videoprozessor (dieser Chip
wurde in Videospielen eingesetzt) und zum Kopieren von
Speicherbereichen.
<P>
Mit dem Prozessortyp 6502UNDOC sind die ,,undokumentierten''
6502-Befehle erreichbar, d.h. die Operationen, die sich bei der
Verwendung nicht als Befehle definierter Bitkombinationen im Opcode
ergeben. Die von AS unterst&uuml;tzten Varianten sind im Kapitel mit
den prozessorspezifischen Hinweisen beschrieben.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> s)</TD><TD NOWRAP> MELPS7700, 65816</TD></TR>
</TABLE></BLOCKQUOTE>
Neben einer ,,16-Bit-Version'' des 6502-Befehlssatzes bieten diese
Prozessoren einige Befehlserweiterungen. Diese sind aber
gr&ouml;&szlig;erenteils disjunkt, da sie sich an ihren jeweiligen
8-bittigen Vorbildern (65C02 bzw. MELPS-740) orientieren. Z.T.~werden
auch andere Mnemonics f&uuml;r gleiche Befehle verwendet.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> t)</TD><TD NOWRAP> PPS-4</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> u)</TD><TD NOWRAP> MELPS4500</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> v)</TD><TD NOWRAP> M16</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> w)</TD><TD NOWRAP> M16C</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> x)</TD><TD NOWRAP> PDP-11/03, PDP-11/04, PDP-11/05, PDP-11/10,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> PDP-11/15, PDP-11/20, PDP-11/23, PDP-11/24,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> PDP-11/34, PDP-11/35, PDP-11/40, PDP-11/44,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> PDP-11/45, PDP-11/50, MicroPDP-11/53,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> PDP-11/55, PDP-11/60, PDP-11/70,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MicroPDP-11/73, MicroPDP-11/83, PDP-11/84,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MicroPDP-11/93, PDP-11/94, T-11</TD></TR>
</TABLE></BLOCKQUOTE>
Die Modelle der PDP-11-Serien unterscheiden sich im Befehlssatz
(sowohl dem eingebauten als auch den verf&uuml;gbaren Erweiterungen)
als auch im verf&uuml;gbaren Adre&szlig;raum (64, 256 oder 4096
KByte).
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> y)</TD><TD NOWRAP> WD16</TD></TR>
</TABLE></BLOCKQUOTE>
Der WD16 benutzt den gleichen Prozessor wie der LSI-11, lediglich mit
anderem Mikrocode. Demensprechend sind Registersatz und
Adressierungsarten zur PDP-11 identisch, der Befehlsumfang ist aber
leicht unterschiedlich und auf der PDP-11 in gleicher Form vorhandene
Maschinenbefehle haben durchg&auml;ngig andere Kodierungen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> z)</TD><TD NOWRAP> MICROVAX-I, MICROVAX-II,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> VAX-11/725, VAX-11/730, VAX-11/750,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> VAX-11/780, VAX-11/782, VAX-11/785,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> VAX-8200, VAX-8300, VAX-8500, VAX-8600</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> VAX-8650, VAX-8800</TD></TR>
</TABLE></BLOCKQUOTE>
Alle Implementierungen der VAX-Architektur unterst&uuml;tzen den
gleichen Kern-Befehlssatz. Einige Erweiterungen, wie z.B. Befehle zur
Verarbeitung von Strings, gepackten Dezimalzahlen oder bestimmten
Gleitkommaformaten, sind nicht immer in Hardware implementiert.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> aa)</TD><TD NOWRAP> CP-3F, LP8000, M380</TD></TR>
</TABLE></BLOCKQUOTE>
Das Prozessorelement des Chipsatzes ist von AEG/Olympia, GI und
SGS-Ates unter den jeweiligen Namen vertrieben worden. Im Befehlssatz
und den Adre&szlig;r&auml;umen bestehen keine Unterschiede.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ab)</TD><TD NOWRAP> 4004 &rarr; 4040</TD></TR>
</TABLE></BLOCKQUOTE>
Der 4040 besitzt gegen&uuml;ber seinem Vorg&auml;nger ein gutes
Dutzend zus&auml;tzlicher Maschineninstruktionen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ac)</TD><TD NOWRAP> 8008 &rarr; 8008NEW</TD></TR>
</TABLE></BLOCKQUOTE>
Intel hat 1975 die Mnemonics des 8008 umdefiniert, die zweite
Variante spiegelt diesen neuen Befehlssatz wieder. Eine gleichzeitige
Unterst&uuml;tzung beider Varianten war nicht m&ouml;glich, da
teilweise &Uuml;berschneidungen vorliegen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ad)</TD><TD NOWRAP> 8021, 8022,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 8401, 8411, 8421, 8461,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 8039, (MSM)80C39, 8048, (MSM)80C48, 8041, 8042,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 80C382</TD></TR>
</TABLE></BLOCKQUOTE>
Bei den ROM-losen Versionen 8039 und 80C39 sind die Befehle verboten,
die den BUS (Port 0) ansprechen. Der 8021 und 8022 sind
Sonderversionen mit stark abgemagertem Befehlssatz, wof&uuml;r der
8022 zwei A/D-Wandler und die dazugeh&ouml;rigen Steuerbefehle
enth&auml;lt. MAB8401 bis 8461 sind von Philips entwickelte Derivate,
die in ihrem Befehssatz irgendwo zwischen dem 8021/8022 und einem
'vollst&auml;ndigen'' 8048 stehen. Daf&uuml;r verf&uuml;gen sie
&uuml;ber serielle Ports und je nach Variante bis zu 8 KByte
Programmspeicher.
<P>
Die CMOS-Versionen lassen sich mit dem<TT> IDL</TT>- bzw.<TT>
HALT</TT>-Befehl in einen Ruhezustand niedriger Stromaufnahme
&uuml;berf&uuml;hren. Der 8041 und 8042 haben einige Zusatzbefehle
zur Steuerung der Busschnittstelle, daf&uuml;r fehlen aber einige
andere Befehle. Beim 8041, 8042, 84x1, 8021 und 8022 ist der
Programmadre&szlig;raum nicht extern erweiterbar, weshalb AS das
Codesegment bei diesen Prozessoren auf die Gr&ouml;&szlig;e des
internen ROM beschr&auml;nkt. Der (SAB)80C382 ist eine von Siemens
speziell f&uuml;r Telefone entwickelte Variante, die ebenfalls
einen<TT> HALT</TT>-Befehl kennt sowie<TT> DJNZ</TT> und<TT> DEC</TT>
auch mit indirekter Adressierung erlaubt. Im Gegenzug wurden einige
Befehle des 'normalen' 8048 entfernt. Die OKI-Varienaten (MSM...)
unterst&uuml;tzen ebenfalls<TT> DJNZ</TT> und<TT> DEC</TT> mit
indirekter Adressierung, sowie eine erweiterte Steuerung der
Power-Down-Modi, ohne den Basis-MCS-48-Befehlssatz zu beschneiden.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ae)</TD><TD NOWRAP> 87C750 &rarr; 8051, 8052, 80C320, 80C501, 80C502,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 80C504, 80515, und 80517</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; 80C390</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; 80C251</TD></TR>
</TABLE></BLOCKQUOTE>
Der 87C750 kann nur max. 2 Kbyte Programmspeicher adressieren,
weshalb die<TT> LCALL</TT>- und<TT> LJMP</TT>-Befehle bei ihm fehlen.
Zwischen den acht mittleren Prozessoren nimmt AS selber
&uuml;berhaupt keine Unterscheidung vor, sondern verwaltet den
Unterschied lediglich in der Variablen<TT> MOMCPU</TT> (s.u.), die
man mit<TT> IF</TT>-Befehlen abfragen kann. Eine Ausnahme stellt
lediglich der 80C504, der in seiner momentanen Form noch einen
Maskenfehler zeigt, wenn eine<TT> AJMP</TT>- oder<TT>
ACALL</TT>-Anweisung auf der vorletzten Adresse einer 2K-Seite steht.
AS benutzt in einem solchen Fall automatisch lange Sprungbefehle bzw.
gibt eine Fehlermeldung aus. Der 80C251 hingegen stellt einen
drastischen Fortschritt in Richtung 16/32 Bit, gr&ouml;&szlig;erer
Adre&szlig;r&auml;ume und orthogonalerem Befehlssatz dar. Den 80C390
k&ouml;nnte man vielleicht als die 'kleine L&ouml;sung' bezeichnen:
Dallas Semiconductor hat den Befehlssatz und die Architektur nur so
weit ver&auml;ndert, wie es f&uuml;r die 16 MByte gro&szlig;en
Adre&szlig;r&auml;ume notwendig war.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> af)</TD><TD NOWRAP> 8096 &rarr; 80196 &rarr; 80196N &rarr; 80296</TD></TR>
</TABLE></BLOCKQUOTE>
Neben einem anderen Satz von SFRs (die &uuml;brigens von Unterversion
zu Unterversion stark differieren) kennt der 80196 eine Reihe von
zus&auml;tzlichen Befehlen und kennt einen ,,Windowing''-Mechanismus,
um das gr&ouml;&szlig;ere interne RAM anzusprechen. Die
80196N-Familie wiederum erweitert den Adre&szlig;raum auf 16 Mbyte
und f&uuml;hrt eine Reihe von Befehlen ein, mit denen man auf
Adressen jenseits 64 Kbyte zugreifen kann. Der 80296 erweitert den
CPU-Kern um Befehle zur Signalverarbeitung und ein zweites
Windowing-Register, verzichtet jedoch auf den<EM> Peripheral
Transaction Server</EM> (PTS) und verliert damit wieder zwei
Maschinenbefehle.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ag)</TD><TD NOWRAP> 8080 &rarr; V30EMU &rarr; 8085 &rarr; 8085UNDOC</TD></TR>
</TABLE></BLOCKQUOTE>
Der 8085 kennt zus&auml;tzlich die Befehle<TT> RIM</TT> und<TT>
SIM</TT> zum Steuern der Interruptmaske und der zwei I/O-Pins. Der
Typ<TT> 8085UNDOC</TT> schaltet zus&auml;tzliche, nicht von Intel
dokumentierte Befehle ein. Diese Befehle sind in Abschnitt <A
HREF="#ref_8085Spec">4.23</A> dokumentiert.
<P>
<TT> V30EMU</TT> als Ziel schaltet gegen&uuml;ber einem 8080 die
Befehle<TT> RETEM</TT> und<EM> CALLN</EM> frei, mit denen die
8080-Emulation auf einem V20/V30/V40/V50 verlassen bzw. unterbrochen
werden kann.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ah)</TD><TD NOWRAP> 8088,8086</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; 80188,80186</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; V20,V30,V40,V50</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; V33,V53</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; V25,V35</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; V55</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; V55SC</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; V55PI</TD></TR>
</TABLE></BLOCKQUOTE>
Prozessoren in der gleichen Zeile verf&uuml;gen &uuml;ber den
gleichen CPU-Kern und damit den gleichen Befehlssatz. Von Zeile zu
Zeile kommen neue Befehle hinzu, wobei die NEC-CPUs ausgehend vom
'V20-Basisbefehlssatz' jeweils &uuml;ber unterschiedliche
Erweiterungen verf&uuml;gen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ai)</TD><TD NOWRAP> 80960</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> aj)</TD><TD NOWRAP> 8X300 &rarr; 8X305</TD></TR>
</TABLE></BLOCKQUOTE>
Der 8X305 besitzt eine Reihe zus&auml;tzlicher Arbeitsregister, die
dem 8X300 fehlen und kann mit diesen auch zus&auml;tzliche
Operationen ausf&uuml;hren, wie das direkte Schreiben von
8-Bit-Werten auf Peripherieadressen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ak)</TD><TD NOWRAP> XAG1, XAG2, XAG3</TD></TR>
</TABLE></BLOCKQUOTE>
Diese Prozessoren unterscheiden sich nur in der Gr&ouml;&szlig;e des
eingebauten ROMs, die in<TT> STDDEFXA.INC</TT> definiert ist.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> al)</TD><TD NOWRAP> AT90S1200, AT90S2313, AT90S2323, AT90S233, AT90S2343,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> AT90S4414, AT90S4433, AT90S4434, AT90S8515,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> AT90C8534, AT90S8535, ATTINY4, ATTINY5, ATTINY9,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY10, ATTINY11, ATTINY12, ATTINY13, ATTINY13A,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY15, ATTINY20, ATTINY24(A), ATTINY25,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY26, ATTINY28, ATTINY40, ATTINY44(A),</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY45, ATTINY48, ATTINY84(A), ATTINY85,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY87, ATTINY88, ATTINY102, ATTINY104,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY167, ATTINY261, ATTINY261A, ATTINY43U,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY441, ATTINY461, ATTINY461A, ATTINY828,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY841, ATTINY861, ATTINY861A, ATTINY1634,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATTINY2313, ATTINY2313A, ATTINY4313, ATMEGA48,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA8, ATMEGA8515, ATMEGA8535, ATMEGA88,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA8U2, ATMEGA16U2, ATMEGA32U2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA16U4, ATMEGA32U4, ATMEGA32U6, AT90USB646,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> AT90USB647, AT90USB1286, AT90USB1287, AT43USB355,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA16, ATMEGA161, ATMEGA162, ATMEGA163,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA164, ATMEGA165, ATMEGA168, ATMEGA169,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA32, ATMEGA323, ATMEGA324, ATMEGA325,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA3250, ATMEGA328, ATMEGA329, ATMEGA3290,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA406, ATMEGA64, ATMEGA640, ATMEGA644,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA644RFR2, ATMEGA645, ATMEGA6450,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA649, ATMEGA6490, ATMEGA103, ATMEGA128,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA1280, ATMEGA1281, ATMEGA1284,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ATMEGA1284RFR2, ATMEGA2560, ATMEGA2561</TD></TR>
</TABLE></BLOCKQUOTE>
Die verschiedenen AVR-Varianten unterscheiden sich in erster Linie in
der Gr&ouml;&szlig;e des On-Chip-Speichers (Flash, SRAM, EEPROM) und
der integrierten Peripherie (GPIO, Timer, UART, A/D-Wandler,...). Die
ATmegas bringen im Vergleich zu den AT90...-Vorg&auml;ngern auch neue
Maschinenbefehle mit, den ATtinys fehlen wiederum die
Multiplikationsbefehle.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> am)</TD><TD NOWRAP> AM29245 &rarr; AM29243 &rarr; AM29240 &rarr; AM29000</TD></TR>
</TABLE></BLOCKQUOTE>
Je weiter man sich in der Liste nach rechts bewegt, desto weniger
Befehle m&uuml;ssen in Software emuliert werden. W&auml;hrend z.B.
der 29245 noch nicht einmal einen Hardware-Multiplizierer besitzt,
fehlen den beiden Vertretern in der Mitte nur die Gleitkommabefehle.
Der 29000 dient dabei als ,,generischer'' Typ, der alle Befehle in
Hardware versteht.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> an)</TD><TD NOWRAP> 80C166 &#10230; 80C167,80C165,80C163</TD></TR>
</TABLE></BLOCKQUOTE>
80C167 und 80C165/163 haben anstelle 256 Kbyte max. 16 Mbyte
Adre&szlig;raum, au&szlig;erdem kennen sie einige zus&auml;tzliche
Befehle f&uuml;r erweiterte Adressierungsmodi sowie atomare
Befehlssequenzen. Untereinander unterscheiden sich diese Prozessoren
der ,,zweiten Generation'' nur in der eingebauten Peripherie.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ao)</TD><TD NOWRAP> LR35902/GBZ80 &rarr; Z80 &rarr; Z80UNDOC</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; Z180</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; eZ80190, eZ80L92, eZ80F91,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> eZ80F92, eZ80F93,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; Z280</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; Z380</TD></TR>
</TABLE></BLOCKQUOTE>
W&auml;hrend f&uuml;r den Z180 nur die zus&auml;tzlichen Befehle
definiert sind (d.h. die Z180-MMU findet noch keine
Ber&uuml;cksichtigung), besitzt der Z380 32-Bit-Register, einen
linearen 4Gbyte-Adre&szlig;raum sowie neben einer Reihe von
Befehlserweiterungen, die den Befehlssatz deutlich orthogonaler
machen, neue Adressierungsmodi (Ansprechen der
Indexregisterh&auml;lften, Stack-relativ). Zu einem kleinen Teil
existieren diese Erweiterungen aber auch schon beim Z80 als
undokumentierte Befehle, die mit der Variante<TT> Z80UNDOC</TT>
zugeschaltet werden k&ouml;nnen. Eine Liste mit den zus&auml;tzlichen
Befehlen findet sich im Kapitel mit den prozessorspezifischen
Hinweisen.
<P>
Der im Gameboy verbaute Prozessor (offizielle Bezeichnung LR35902,
umgangssprachlich auch als ,,Gameboy-Z80'' bezeichnet) ist eine
Mischung aus Z80 und 8080. Ihm fehlen die IX/IY-Register, der
I/O-Adre&szlig;raum, die zweite Registerbank sowie eine Reihe von
16-Bit-Befehlen.
<P>
Die Zilog eZ80 Varianten erweitern die Z80 Architektur um einem 16
MByte gro&szlig;en Adre&szlig;raum, 24 Bit breite Register sowie eine
begrenzte Zahl neuer Befehle. Einige Varianten enthalten ein
I-Register, das nur 8 Bit breit ist. Dem eZ80190 fehlen
zus&auml;tzlich einige String-I/O Befehle. Ansonsten liegen die
Unterschiede nur in der Menge des eingebauten Speichers sowie der
integrierten Peripherie.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ap)</TD><TD NOWRAP> Z8601, Z8603, Z86C03, Z86E03, Z86C06, Z86E06,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z86C08, Z86C21, Z86E21, Z86C30, Z86C31, Z86C32 Z86C40</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; Z88C00, Z88C01</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> &rarr; eZ8, Z8F0113, Z8F011A, Z8F0123, Z8F012A,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F0130, Z8F0131, Z8F0213, Z8F021A, Z8F0223, Z8F022A,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F0230, Z8F0231, Z8F0411, Z8F0412, Z8F0413, Z8F041A,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F0421, Z8F0422, Z8F0423, Z8F042A, Z8F0430, Z8F0431,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F0811, Z8F0812, Z8F0813, Z8F081A, Z8F0821, Z8F0822,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F0823, Z8F082A, Z8F0830, Z8F0831, Z8F0880, Z8F1232,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F1233, Z8F1621, Z8F1622, Z8F1680, Z8F1681, Z8F1682,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F2421, Z8F2422, Z8F2480, Z8F3221, Z8F3222, Z8F3281,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F3282, Z8F4821, Z8F4822, Z8F4823, Z8F6081, Z8F6082,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> Z8F6421, Z8F6422, Z8F6423, Z8F6481, Z8F6482</TD></TR>
</TABLE></BLOCKQUOTE>
Die Varianten mit Z8-Kern unterscheiden sich nur in Speicherausbau
und Peripherie, d.h. die Wahl hat auf den unterst&uuml;tzten
Befehlssatz keinen Effekt. Deutlich anders sind jedoch die Super8-
und eZ8-Varianten, jeweils mit (in unterschiedliche Richtungen) stark
erweiterten Befehlss&auml;tzen, die auch auf Quellcode-Ebene nur
g&ouml;&szlig;tenteils aufw&auml;rts-kompatibel sind.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> aq)</TD><TD NOWRAP> Z8001, Z8002, Z8003, Z8004</TD></TR>
</TABLE></BLOCKQUOTE>
&Uuml;ber die Wahl des Prozessors wird die Betriebsart (segmentiert
f&uuml;r Z8001 und Z8003, nicht segmentiert f&uuml;r Z8002 und Z8004)
bestimmt. Eine Unterscheidung zwischen dem Z8001/8002 einerseits und
Z8003/8004 andererseits findet aktuell nicht statt.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ar)</TD><TD NOWRAP> KCPSM, KCPSM3</TD></TR>
</TABLE></BLOCKQUOTE>
Bei beiden Prozessorkernen handelt es sich um keine
eigenst&auml;ndigen Bausteine, sondern Logik-Kerne f&uuml;r
Gate-Arrays der Firma Xilinx. Die 3er-Variante bietet einen
gr&ouml;&szlig;eren Adre&szlig;raum sowie einige zus&auml;tzliche
Instruktionen. Es ist zu beachten, da&szlig; sie nicht bin&auml;r
aufw&auml;rtskompatibel ist!
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> as)</TD><TD NOWRAP> MICO8_05, MICO8_V3, MICO8_V31</TD></TR>
</TABLE></BLOCKQUOTE>
Leider hat Lattice die Maschinencodes des Mico8 mehrfach
ge&auml;ndert, so da&szlig; verschiedene Targets notwendig wurden, um
auch alte Designs weiter zu unterst&uuml;tzen. Die erste Variante
entspricht der Variante, wie sie im 2005er-Manual beschrieben wurde,
die beiden anderen die Versionen 3.0 bzw. 3.1.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> at)</TD><TD NOWRAP> 96C141, 93C141</TD></TR>
</TABLE></BLOCKQUOTE>
Diese beiden Prozessoren repr&auml;sentieren die beiden Varianten der
Prozessorfamilie: TLCS-900 und TLCS-900L. Die Unterschiede dieser
beiden Varianten werden in Abschnitt <A
HREF="#ref_TLCS900Spec">4.34</A> genauer beleuchtet.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> au)</TD><TD NOWRAP> 90C141</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> av)</TD><TD NOWRAP> 87C00, 87C20, 87C40, 87C70</TD></TR>
</TABLE></BLOCKQUOTE>
Die Prozessoren der TLCS-870-Reihe haben zwar den identischen
CPU-Kern, je nach Variante aber eine unterschiedliche
Peripherieausstattung. Zum Teil liegen Register gleichen Namens auf
unterschiedlichen Adressen. Die Datei STDDEF87.INC benutzt analog zur
MCS-51-Familie die hier m&ouml;gliche Unterscheidung, um automatisch
den korrekten Symbolsatz bereitzustellen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> aw)</TD><TD NOWRAP> TLCS-870/C</TD></TR>
</TABLE></BLOCKQUOTE>
Momentan ist nur der Prozessorkern der TLCS-870/C-Familie
implementiert.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ax)</TD><TD NOWRAP> 47C00 &rarr; 470C00 &rarr; 470AC00</TD></TR>
</TABLE></BLOCKQUOTE>
Diese drei Varianten der TLCS-47-Familie haben unterschiedlich
gro&szlig;e RAM-und ROM-Adre&szlig;bereiche, wodurch jeweils einige
Befehle zur Bankumschaltung hinzukommen oder wegfallen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ay)</TD><TD NOWRAP> 4240P, 4250N, 4260P, 4270N</TD></TR>
    <TR><TD NOWRAP> 42C00Y, 42C40P, 42C50N, 42C60P, 42C70N</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Die CMOS-Varianten verf&uuml;gen &uuml;ber zwei zus&auml;tzliche
Befehle. Ansonsten unterscheiden die Varianten sich in der Anzahl der
I/O-Ports und der Gr&ouml;&szlig;e des Prorammspeichers.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> az)</TD><TD NOWRAP> 97C241</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ba)</TD><TD NOWRAP> TC9331</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bb)</TD><TD NOWRAP> 16C54 &rarr; 16C55 &rarr; 16C56 &rarr; 16C57</TD></TR>
</TABLE></BLOCKQUOTE>
Diese Prozessoren unterscheiden sich durch den verf&uuml;gbaren
Adre&szlig;raum im Programmspeicher, d.h. durch die Adresse, ab der
der AS &Uuml;berl&auml;ufe anmeckert.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bc)</TD><TD NOWRAP> 16C64, 16C84</TD></TR>
</TABLE></BLOCKQUOTE>
Analog zur MCS-51-Familie findet hier keine Unterscheidung im
Codegenerator statt, die unterschiedlichen Nummern dienen lediglich
der Einblendung der korrekten SFRs in STDDEF18.INC.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bd)</TD><TD NOWRAP> 17C42</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> be)</TD><TD NOWRAP> SX20, SX28</TD></TR>
</TABLE></BLOCKQUOTE>
Der SX20 steckt in einem kleineren Geh&auml;use, weshalb der Port C
fehlt.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bf)</TD><TD NOWRAP> ST6200, ST6201, ST6203, ST6208, ST6209,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST6210, ST6215, ST6218, ST6220, ST6225,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST6228, ST6230, ST6232, ST6235, ST6240,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST6242, ST6245, ST6246, ST6252, ST6253,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST6255, ST6260, ST6262, ST6263, ST6265,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST6280, ST6285</TD></TR>
</TABLE></BLOCKQUOTE>
Die einzelnen ST6-Varianten differieren in der Menge der
On-Chip-Peripherie und dem eingebauten Speicher.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bg)</TD><TD NOWRAP> ST7</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST72251G1, ST72251G2, ST72311J2, ST72311J4,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST72321BR6, ST72321BR7, ST72321BR9, ST72325S4,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST72325S6, ST72325J7, ST72325R9, ST72324J6,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST72324K6, ST72324J4, ST72324K4, ST72324J2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST72324JK21, ST72325S4, ST72325J7, ST72325R9,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST72521BR6, ST72521BM9, ST7232AK1, ST7232AK2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7232AJ1, ST7232AJ2, ST72361AR4, ST72361AR6,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST72361AR7, ST72361AR9, ST7FOXK1, ST7FOXK2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7LITES2Y0, ST7LITES5Y0, ST7LITE02Y0,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7LITE05Y0, ST7LITE09Y0</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7LITE10F1, ST7LITE15F1, ST7LITE19F1,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7LITE10BF0, ST7LITE15BF0, ST7LITE15BF1,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7LITE19BF0, ST7LITE19BF1,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7LITE20F2, ST7LITE25F2, ST7LITE29F2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7LITE30F2, ST7LITE35F2, ST7LITE39F2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7LITE49K2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7MC1K2, ST7MC1K4, ST7MC2N6, ST7MC2S4,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7MC2S6, ST7MC2S7, ST7MC2S9, ST7MC2R6,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> ST7MC2R7, ST7MC2R9, ST7MC2M9,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S001J3, STM8S003F3, STM8S003K3, STM8S005C6,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S005K6, STM8S007C8, STM8S103F2, STM8S103F3,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S103K3, STM8S105C4, STM8S105C6, STM8S105K4,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S105K6, STM8S105S4, STM8S105S6, STM8S207MB,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S207M8, STM8S207RB, STM8S207R8, STM8S207R6,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S207CB, STM8S207C8, STM8S207C6, STM8S207SB,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S207S8, STM8S207S6, STM8S207K8, STM8S207K6,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S208MB, STM8S208RB, STM8S208R8, STM8S208R6,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S208CB, STM8S208C8, STM8S208C6, STM8S208SB,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8S208S8, STM8S208S6, STM8S903K3, STM8S903F3,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L050J3, STM8L051F3, STM8L052C6, STM8L052R8,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L001J3, STM8L101F1, STM8L101F2, STM8L101G2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L101F3, STM8L101G3, STM8L101K3, STM8L151C2,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L151K2, STM8L151G2, STM8L151F2, STM8L151C3,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L151K3, STM8L151G3, STM8L151F3, STM8L151C4,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L151C6, STM8L151K4, STM8L151K6, STM8L151G4,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L151G6, STM8L152C4, STM8L152C6, STM8L152K4,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L152K6, STM8L151R6, STM8L151C8, STM8L151M8,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L151R8, STM8L152R6, STM8L152C8, STM8L152K8,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8L152M8, STM8L152R8, STM8L162M8, STM8L162R8,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AF6366, STM8AF6388, STM8AF6213, STM8AF6223,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AF6226, STM8AF6246, STM8AF6248, STM8AF6266,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AF6268, STM8AF6269, STM8AF6286, STM8AF6288,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AF6289, STM8AF628A, STM8AF62A6, STM8AF62A8,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AF62A9, STM8AF62AA, STM8AF5268, STM8AF5269,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AF5286, STM8AF5288, STM8AF5289, STM8AF528A,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AF52A6, STM8AF52A8, STM8AF52A9, STM8AF52AA,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AL3136, STM8AL3138, STM8AL3146, STM8AL3148,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AL3166, STM8AL3168, STM8AL3L46, STM8AL3L48,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AL3L66, STM8AL3L68, STM8AL3188, STM8AL3189,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8AL318A, STM8AL3L88, STM8AL3L89, STM8AL3L8A,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8TL52F4, STM8TL52G4, STM8TL53C4, STM8TL53F4,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> STM8TL53G4</TD></TR>
</TABLE></BLOCKQUOTE>
Der STM8-Kern erweitert den Adre&szlig;raum auf bis zu 16 MByte und
f&uuml;hrt eine ganze Reihe neuer Befehle ein. Obwohl viele Befehle
den gleichen Maschinencode wie beim ST7 haben, ist er nicht
bin&auml;r aufw&auml;rtskompatibel.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bh)</TD><TD NOWRAP> ST9020, ST9030, ST9040, ST9050</TD></TR>
</TABLE></BLOCKQUOTE>
Diese 4 Namen vetreten die vier ,,Unterfamilien'' der ST9-Familie,
die sich durch eine unterschiedliche Ausstattung mit
On-Chip-Peripherie auszeichnen. Im Prozessorkern sind sie identisch,
so da&szlig; diese Unterscheidung wieder nur in der Include-Datei mit
den Peripherieadressen zum Zuge kommt.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bi)</TD><TD NOWRAP> 6804</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bj)</TD><TD NOWRAP> 32010 &rarr; 32015</TD></TR>
</TABLE></BLOCKQUOTE>
Der TMS32010 besitzt nur 144 Byte internes RAM, weshalb AS Adressen
im Datensegment auf eben diesen Bereich begrenzt. F&uuml;r den 32015
gilt diese Beschr&auml;nkung nicht, es kann der volle Bereich von
0--255 angesprochen werden.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bk)</TD><TD NOWRAP> 320C25 &rarr; 320C26 &rarr; 320C28</TD></TR>
</TABLE></BLOCKQUOTE>
Diese Prozessoren unterscheiden sich nur leicht in der
On-Chip-Peripherie sowie den Konfigurationsbefehlen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bl)</TD><TD NOWRAP> 320C30, 320C31 &rarr; 320C40, 320C44</TD></TR>
</TABLE></BLOCKQUOTE>
Der 320C31 ist eine etwas ,,abgespeckte'' Version des 320C30 mit dem
gleichen Befehlssatz, jedoch weniger Peripherie. In STDDEF3X.INC wird
diese Unterscheidung ausgenutzt. Die C4x-Varianten sind
Quellcode-aufw&auml;rtskompatibel, unterscheiden sich im
Maschinencode einiger Befehle jedoch subtil. Auch hier ist ist der
C44 eine abgespeckte Version des C40, mit weniger Peripherie und
kleinerem Adre&szlig;raum.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bm)</TD><TD NOWRAP> 320C203 &rarr; 320C50, 320C51, 320C53</TD></TR>
</TABLE></BLOCKQUOTE>
Ersterer ist der generelle Repr&auml;sentant f&uuml;r die
C20x-Signalprozessorfamilie, die eine Untermenge des
C5x-Befehlssatzes implementieren. Die Unterscheidung zwischen den
verschiedenen C5x-Prozessoren wird von AS momentan nicht ausgenutzt.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bn)</TD><TD NOWRAP> 320C541</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist momentan der Repr&auml;sentant f&uuml;r die
TMS320C54x-Familie...
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bo)</TD><TD NOWRAP> TI990/4, TI990/10, TI990/12</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> TMS9900, TMS9940, TMS9995, TMS99105, TMS99110</TD></TR>
</TABLE></BLOCKQUOTE>
Die TMS99xx/99xxx-Prozessoren sind im Prinzip
Single-Chip-Implementierungen der TI990-Minicomputer, einige
TI990-Modelle basieren auch auf einem solchen Prozessor anstatt einer
diskret aufgebauten CPU. Die einzelnen Modelle unterscheiden sich im
Befehlssatz (der TI990/12 hat den gr&ouml;&szlig;ten), und dem
Vorhandensein eines privilegierten Modus.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bp)</TD><TD NOWRAP> TMS70C00, TMS70C20, TMS70C40,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> TMS70CT20, TMS70CT40,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> TMS70C02, TMS70C42, TMS70C82,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> TMS70C08, TMS70C48</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Alle Mitglieder dieser Familie haben den gleichen CPU-Kern,
unterscheiden sich im Befehlssatz also nicht. Die Unterschiede finden
sich nur in der Datei REG7000.INC, in der Speicherbereiche und
Peripherieadressen definiert werden. Die in einer Zeile stehenden
Typen besitzen jeweils gleiche Peripherie und gleiche interne
RAM-Menge, unterscheiden sich also nur in der Menge eingebauten ROMs.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bq)</TD><TD NOWRAP> 370C010, 370C020, 370C030, 370C040 und 370C050</TD></TR>
</TABLE></BLOCKQUOTE>
Analog zur MCS-51-Familie werden die unterschiedlichen Typen nur zur
Unterscheidung der Peripherie in STDDEF37.INC genutzt, der
Befehlssatz ist identisch.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> br)</TD><TD NOWRAP> MSP430 &rarr; MSP430X</TD></TR>
</TABLE></BLOCKQUOTE>
Die X-Variante des CPU-Kerns erweitert den Adre&szlig;raum von 64
KiByte auf 1 MiByte und erweitert den Befehlssatz, um Instruktionen
mehrfach ausf&uuml;hren zu k&ouml;nnen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bs)</TD><TD NOWRAP> TMS1000, TMS1100, TMS1200, TMS1300</TD></TR>
</TABLE></BLOCKQUOTE>
F&uuml;r TMS1000 und TMS1200 sind jeweils 1 KByte ROM und 64 Nibbles
RAM vorgesehen, f&uuml;r TMS1100 und TMS1300 jeweils das doppelte.
Des weiteren hat TI f&uuml;r TMS1100 und TMS1300 einen deutlich
anderen Default-Befehlssatz vorgesehen (AS kennt nur die Default-
Befehlss&auml;tze!).
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bt)</TD><TD NOWRAP> IMP-16C/200, IMP-16C/300, IMP-16P/200, IMP-16P/300, IMP-16L</TD></TR>
</TABLE></BLOCKQUOTE>
Beim IMP-16L sind einige zus&auml;tzliche Bits im Statusregister
sowie weitere Sprungbedingungen definiert. Den erweiterten
Befehlssatz unterst&uuml;tzt er ebenso wie die 300er-Varianten.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bu)</TD><TD NOWRAP> IPC-16, INS8900</TD></TR>
</TABLE></BLOCKQUOTE>
Der INS8900 ist lediglich eine Re-Implementierung des PACE in einem
modernerem NMOS-Fertigungsprozess; es bestehen keine Unterschiede im
Befehlssatz.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bv)</TD><TD NOWRAP> SC/MP</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bw)</TD><TD NOWRAP> 8070</TD></TR>
</TABLE></BLOCKQUOTE>
Dieser Prozessor repr&auml;sentiert die gesamte 807x-Familie (die
mindestens aus den 8070, 8072 und 8073 besteht), der jedoch ein
einheitlicher CPU-Kern gemeinsam ist.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bx)</TD><TD NOWRAP> COP87L84</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist das momentan einzige unterst&uuml;tzte Mitglied der
COP8-Familie von National Semiconductor. Mir ist bekannt, da&szlig;
die Familie wesentlich gr&ouml;&szlig;er ist und auch Vertreter mit
unterschiedlich gro&szlig;em Befehlssatz existieren, die nach Bedarf
hinzukommen werden. Es ist eben ein Anfang, und die Dokumentation von
National ist ziemlich umfangreich...
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> by)</TD><TD NOWRAP> COP410 &rarr; COP420 &rarr; COP440 &rarr; COP444</TD></TR>
</TABLE></BLOCKQUOTE>
Die COP42x-Derivate bieten einige weitere Befehle, des weiteren
wurden Befehlen in ihrem Wertebereich erweitert.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bz)</TD><TD NOWRAP> SC14400, SC14401, SC14402, SC14404, SC14405,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> SC14420, SC14421, SC14422, SC14424</TD></TR>
</TABLE></BLOCKQUOTE>
Diese Gruppe von DECT-Controller unterscheidet sich in ihrem
Befehlsumfang, da jeweils unterschiedliche B-Feld Datenformate
unterst&uuml;tzt werden und deren Architektur im Laufe der Zeit
optimiert wurde.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ca)</TD><TD NOWRAP> NS16008, NS32008, NS08032, NS16032, NS32016, NS32032,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> NS32332, NS32CG16, NS32532</TD></TR>
</TABLE></BLOCKQUOTE>
National hat in den ersten Jahren die CPUs der ersten Generation
mehrfach umbenannt, hinter NS16008/NS32008/NS08032 bzw.
NS16032/NS32016 versteckt sich der gleiche Baustein. NS32332 und
NS32532 unterst&uuml;tzen eine Adre&szlig;raum von 4 GByte statt 16
MByte, und der NS32CG16 ist eine Embedded-Variante mit Zusatzbefehlen
f&uuml;r Bitblock-Transfers.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cb)</TD><TD NOWRAP> ACE1101, ACE1202</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cc)</TD><TD NOWRAP> F3850, MK3850,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MK3870, MK3870/10, MK3870/12, "MK3870/20, MK3870/22,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MK3870/30, MK3870/32, MK3870/40, MK3870/42,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MK3872, MK3873, MK3873/10, MK3873/12, MK3873/20, MK3873/22,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MK3874, MK3875, MK3875/22, MK3875/42, MK3876, MK38P70/02,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MK38C70, MK38C70/10,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MK38C70/20, MK97400, MK97410, MK97500, MK97501, MK97503</TD></TR>
</TABLE></BLOCKQUOTE>
Die gro&szlig;e Menge an Varianten ergibt sich zum Teil daraus,
da&szlig; Mostek Anfang der 80er-Jahre diversen Varianten neue Namen
gegeben hat. Am neuen Benamungsschema kann man am Suffix die Menge
internen ROMs (0 bis 4 f&uuml;r 0..4 KByte) bzw. die Menge des
eingebauten Executable RAM (0 oder 2 f&uuml;r 0 oder 64 Byte)
ablesen. 3850 und MK975xx unterst&uuml;tzen einen 64 KByte
gro&szlig;en Adre&szlig;raum, beim Rest ist er 4 KByte gro&szlig;.
P-Varianten haben einen Piggyback-Sockel f&uuml;r ein EPROM,
C-Varianten sind in CMOS ausgef&uuml;hrt und kennen zwei neue
Maschinenbefehle (HET und HAL). Der MK3873 enth&auml;lt als
,,Spezialit&auml;t'' eine eingebaute serielle Schnittstelle, der
MK3875 bietet einen zweiten Betriebsspannungsanschlu&szlig;, um den
internen RAM-Inhalt im Standby halten zu k&ouml;nnen.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cd)</TD><TD NOWRAP> 7800, 7801, 7802</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 78C05, 78C06</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 7807, 7808, 7809</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 7810 &rarr; 78C10, 78C11, 78C12, 78C14, 78C17, 78C18</TD></TR>
</TABLE></BLOCKQUOTE>
&micro;PD7800 bis &micro;PD7802 repr&auml;sentieren die ''erste
Generation'' der uCOM87-Familie von NEC. &micro;PD78C05 und
&micro;PD78C06 sind davon abgespeckte Versionen, die nur eine
Untermenge des Befehlssatzes unterst&uuml;tzen. 7807 bis 7809 stellen
die uCOM87-Serie dar, die um weitere Befehle und erg&auml;nzt wurde.
Alle &micro;PD781x-Varianten geh&ouml;ren zur uCOM87AD-Serie, die
dar&uuml;ber hinaus um einen A/D-Wandler erg&auml;nzt wurde,
daf&uuml;r wurden die Befehle zur Verarbeitung von Bits wieder
entfernt.<B> ACHTUNG!</B> Der Befehlssatz ist generell nur teilweise
bin&auml;r aufw&auml;rtskompatibel! Die NMOS-Version &micro;PD7810
besitzt keinen STOP-Modus; der entsprechende Befehl sowie das
ZCM-Register fehlen demzufolge.<B> VORSICHT!</B> NMOS- und
CMOS-Version differieren zum Teil in den Reset-Werten einiger
Register!
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ce)</TD><TD NOWRAP> uPD550, uPD554, uPD652,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> uPD547, uPD552, uPD651,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> uPD546, uPD553, uPD556, uPD557, uPD650</TD></TR>
</TABLE></BLOCKQUOTE>
Die drei Gruppen vom Controllers geh&ouml;ren jeweils zur
&micro;COM-45-, &micro;COM-44- und &micro;COM-43-Familie. Die ersten
beiden Familien implementieren eine Untermenge des
&micro;COM-43-Befehlssatzes. Ansonsten unterscheiden die Varianten
sich in der Menge des integrierten ROM- und RAM-Speichers.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cf)</TD><TD NOWRAP> 7566 &harr; 7508</TD></TR>
</TABLE></BLOCKQUOTE>
Es existieren in der &micro;PD75xx-Familie zwei verschiedene
CPU-Kerne: Der 7566 repr&auml;sentiert den 'instruction set B', der
deutlich weniger Befehle, einige Register weniger und kleinere
Adre&szlig;r&auml;ume erlaubt. Der 7508 repr&auml;sentiert den
'vollen' Befehlssatz A.<B> VORSICHT!</B> Beide
Maschinen-Befehlss&auml;tze sind nicht 100%-ig bin&auml;rkompatibel!
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cg)</TD><TD NOWRAP> 75402,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75004, 75006, 75008,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75268,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75304, 75306, 75308, 75312, 75316,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75328,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75104, 75106, 75108, 75112, 75116,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75206, 75208, 75212, 75216,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75512, 75516</TD></TR>
</TABLE></BLOCKQUOTE>
Dieses ,,F&uuml;llhorn'' an Prozessoren unterscheidet sich innerhalb
einer Gruppe nur durch die RAM- und ROM-Gr&ouml;&szlig;e; die Gruppen
untereinander unterscheiden sich einmal durch ihre on-chip-Peripherie
und zum anderen durch die M&auml;chtigkeit des Befehlssatzes.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ch)</TD><TD NOWRAP> 78070</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist das einzige, mir momentan vertraute Mitglied der
78K0-Familie von NEC. Es gelten &auml;hnliche Aussagen wie zur
COP8-Familie!
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ci)</TD><TD NOWRAP> 78214</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist momentan der Repr&auml;sentant der 78K2-Familie von NEC.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cj)</TD><TD NOWRAP> 78310</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist momentan der Repr&auml;sentant der 78K3-Familie von NEC.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ck)</TD><TD NOWRAP> 784026</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist momentan der Repr&auml;sentant der 78K4-Familie von NEC.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cl)</TD><TD NOWRAP> 7720 &rarr; 7725</TD></TR>
</TABLE></BLOCKQUOTE>
Der &micro;PD7725 bietet im Vergleich zu seinem Vorg&auml;nger
gr&ouml;&szlig;ere Adre&szlig;r&auml;ume und einige zus&auml;tzliche
Befehle.<B> VORSICHT!</B> Die Prozessoren sind nicht zueinander
bin&auml;rkompatibel!
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cm)</TD><TD NOWRAP> 77230</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cn)</TD><TD NOWRAP> 70616</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist momentan der Repr&auml;sentant der V60-Familie von NEC.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> co)</TD><TD NOWRAP> SYM53C810, SYM53C860, SYM53C815, SYM53C825,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> SYM53C875, SYM53C895</TD></TR>
</TABLE></BLOCKQUOTE>
Die einfacheren Mitglieder dieser Familie von SCSI-Prozessoren
besitzen einige Befehlsvarianten nicht, au&szlig;erdem unterscheiden
sie sich in ihrem Satz interner Register.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cp)</TD><TD NOWRAP> MB89190</TD></TR>
</TABLE></BLOCKQUOTE>
Dieser Prozessortyp repr&auml;sentiert die F<SUP>2</SUP>MC8L-Serie
von Fujitsu...
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cq)</TD><TD NOWRAP> MB9500</TD></TR>
</TABLE></BLOCKQUOTE>
...so wie dieser es momentan f&uuml;r die 16-Bit-Varianten von
Fujitsu tut!
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cr)</TD><TD NOWRAP> MSM5840, MSM5842, MSM58421, MSM58422, MSM5847</TD></TR>
</TABLE></BLOCKQUOTE>
Diese Varianten der OLMS-40-Familie unterscheiden sich im Befehlssatz
sowie im internen Programm- und Datenspeicher.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cs)</TD><TD NOWRAP> MSM5054, MSM5055, MSM5056, MSM6051, MSM6052</TD></TR>
</TABLE></BLOCKQUOTE>
Gleiches wie bei der OLMS-40-Familie: Unterschiede im Befehlssatz
sowie im internen Programm- und Datenspeicher.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ct)</TD><TD NOWRAP> MN1610[ALT] &rarr; MN1613[ALT]</TD></TR>
</TABLE></BLOCKQUOTE>
Zus&auml;tzlich zu den Funktionen seines Vorg&auml;ngers bietet der
MN1613 einen gr&ouml;&szlig;eren Adre&szlig;raum, eine
Floating-Point-Einheit sowie eine ganze Reihe neuer Befehle.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cu)</TD><TD NOWRAP> RXV1, RX110, RX111, RX113, RX130, RX210,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> RX21A, RX220, RX610, RX621, RX62N, RX630,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> RX631 &#10230;</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> RXV2, RX140, RX230, RX231, RX64M,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> RX651 &#10230;</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> RXV3, RX660, RX671, RX72M, RX72N</TD></TR>
</TABLE></BLOCKQUOTE>
Die Controller der RX-Serie k&ouml;nnen grob in drei Gruppen bzw.
Generationen eingeteilt werden, wobei von Generation zu Generation
(RXv1, RXv2, RXv3) jeweils neue Instruktionen hinzu gekommen sind.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cv)</TD><TD NOWRAP> PMC150, PMS150, PFS154, PMC131, PMS130, PMS131</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> PMS132, PMS132B, PMS152, PMS154B, PMS154C, PFS173</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> PMS133, PMS134, DF69, MCS11, PMC232, PMC234, PMC251</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> PMC271,PMC884, PMS232, PMS234, PMS271</TD></TR>
</TABLE></BLOCKQUOTE>
Die Padauk-Controller unterscheiden sich allesamt in der
Gr&ouml;&szlig;e des internen (ROM/RAM)-Speichers, der Art des
internen ROMs (l&ouml;schbar oder OTP), der eingebauten Peripherie
sowie in Umfang und Kodierung des Befehlssatzes.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cw)</TD><TD NOWRAP> 1802 &rarr; 1804, 1805, 1806 &rarr; 1804A, 1805A 1806A</TD></TR>
</TABLE></BLOCKQUOTE>
1804, 1805 und 1806 haben gegen&uuml;ber dem 'Original' 1802 einen
leicht erweiterten Befehlssatz sowie on-chip-RAM und einen
integrierten Timer. Die A-Versionen erweitern den Befehlssatz um<TT>
DSAV</TT>,<TT> DBNZ</TT>, sowie um Befehle f&uuml;r Addition und
Subtraktion im BCD-Format.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cx)</TD><TD NOWRAP> XS1</TD></TR>
</TABLE></BLOCKQUOTE>
Dieser Typ repr&auml;sentiert die XCore-''Familie''.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cy)</TD><TD NOWRAP> 1750</TD></TR>
</TABLE></BLOCKQUOTE>
MIL STD 1750 ist ein Standard, also gibt es auch nur eine
(Standard-)Variante...
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> cz)</TD><TD NOWRAP> KENBAK</TD></TR>
</TABLE></BLOCKQUOTE>
Es hat nie einen KENBAK-2 gegeben...
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> da)</TD><TD NOWRAP> CP-1600</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> db)</TD><TD NOWRAP> HPNANO</TD></TR>
</TABLE></BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> dc)</TD><TD NOWRAP> 6100 &rarr; 6120</TD></TR>
</TABLE></BLOCKQUOTE>
Der IM6120 unterst&uuml;tzt einen gr&ouml;&szlig;eren Adre&szlig;raum
(32K anstelle 4K) sowie zus&auml;tzliche Maschinenbefehle.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> dd)</TD><TD NOWRAP> SC61860</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist der in den meisten Sharp Pocket Computern
(PC-12xx...PC-15xx) verbaute Prozessor.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> de)</TD><TD NOWRAP> SC62015</TD></TR>
</TABLE></BLOCKQUOTE>
Dies ist der im Sharp PC-E500 verbaute Prozessor.
<P>
Ein spezielles, bisher hier nicht aufgelistetes Target ist NONE. Es
ist als Default eingestellt, wenn kein Target per<TT> -cpu</TT>
Argument auf der Kommandozeile vorgegeben wurde, und auch bisher
keine<TT> CPU</TT>-Anweisung assembliert wurde.
Target-unabh&auml;ngige Pseudo-Befehle sind in diesem Zustand weiter
m&ouml;glich, aber es kann kein Code erzeugt werden, weder durch
Maschinenbefehle noch durch Datenablage. Prinzipiell ist es auch
m&ouml;glich, dieses Target per<TT> -cpu</TT> oder<TT> CPU</TT>
auszuw&auml;hlen, aber der praktische Nutzen davon ist nat&uuml;rlich
beschr&auml;nkt.
<P>
Beim CPU-Befehl mu&szlig; der Prozessortyp als einfaches Literal
angegeben werden, eine Berechnung &agrave; la
<PRE>

        CPU     68010+10

</PRE>
ist also nicht zul&auml;ssig. G&uuml;ltige Aufrufe sind z.B.
<PRE>

        CPU     8051

</PRE>
oder
<PRE>

        CPU     6800

</PRE>
Egal, welcher Prozessortyp gerade eingestellt ist, in der
Integervariablen MOMCPU wird der momentane Status als Hexadezimalzahl
abgelegt. F&uuml;r den 68010 ist z.B.<TT> MOMCPU=$68010</TT>,
f&uuml;r den 80C48<TT> MOMCPU=80C48H</TT>. Da man Buchstaben
au&szlig;er A..F nicht als Hexziffer interpretieren kann, mu&szlig;
man sich diese bei der Hex-Darstellung des Prozessors wegdenken.
F&uuml;r den Z80 ist z.B.<TT> MOMCPU=80H</TT>.
<P>
Dieses Feature kann man vorteilhaft einsetzen, um je nach
Prozessortyp unterschiedlichen Code zu erzeugen. Der 68000 z.B. kennt
noch keinen Befehl f&uuml;r den Unterprogrammr&uuml;cksprung mit
Stapelkorrektur. Mit der Variablen<TT> MOMCPU</TT> kann man ein Makro
definieren, das je nach Prozessortyp den richtigen Befehl benutzt
oder ihn emuliert:
<PRE>

myrtd   MACRO   disp
        IF      MOMCPU$&lt;$68010   ; auf 68008 und
         MOVE.L (sp),disp(sp)    ; 68000 emulieren
         LEA    disp(sp),sp
         RTS
        ELSEIF
         RTD    #disp            ; ab 68010 direkt
        ENDIF                    ; benutzen
        ENDM

        CPU     68010
        MYRTD   12               ; ergibt RTD #12

        CPU     68000
        MYRTD   12               ; ergibt MOVE.. /
                                 ; LEA.. / RTS

</PRE>
Da nicht alle Prozessornamen nur aus Ziffern und Buchstaben zwischen
A und F bestehen, wird zus&auml;tzlich der volle Name in der
String-Variablen<TT> MOMCPUNAME</TT> abgelegt.
<P>
Implizit schaltet der Assembler mit dem<TT> CPU</TT>-Befehl das
aktuelle Segment wieder auf Code zur&uuml;ck, da dies das einzige
Segment ist, das alle Prozessoren definieren.
<P>
Eine wichtige &Auml;nderung: Das Default-Target ist nicht mehr der
68008. Falls kein<TT> -cpu</TT> Kommandozeilen-Argument gegeben
wurde, dann ist bis zur ersten<TT> CPU</TT>-Anweisung das reservierte
Target<TT> NONE</TT> gesetzt. Vom Target unabh&auml;ngig
verf&uuml;gbare Pseudo-Anweisungen sind in dieser Situation weiterhin
erlaubt, zum Beispiel um Konstanten oder Makros zu definieren. Es ist
aber nicht m&ouml;glich, irgendwelchen Code zu definieren, weder
&uuml;ber Maschinenbefehle, noch durch Ablegen von Daten im Speicher.
<P>
F&uuml;r einige Ziele sind Optionen bzw. Varianten definiert, die so
grundlegend sind, da&szlig; sie direkt zusammen mit dem<TT>
CPU</TT>-Befehl gew&auml;hlt werden m&uuml;ssen. Solche Optionen
h&auml;ngt man direkt an das Argument mit Doppelpunkten an, und sie
haben die Form von Variablenzuweisungen:
<PRE>

  CPU &lt;CPU-Name&gt;:&lt;var1&gt;=&lt;wert1&gt;:&lt;var2&gt;=&lt;wert2&gt;:...

</PRE>
Ob das jeweilige Ziel solche Optionen unterst&uuml;tzt, und wenn ja
welche, wird im jeweils zugeh&ouml;rigen Unterkapitel mit
prozessorspezifischen Hinweisen beschrieben.
<P>

<H3><A NAME="sect_3_2_4_">3.2.4. SUPMODE, FPU, PMMU, CUSTOM</A></H3>
<A NAME="index_SUPMODE_1"></A><A NAME="index_FPU_1"></A><A
NAME="index_PMMU_1"></A><A NAME="index_CUSTOM_1"></A><A
NAME="ref_SectSUPMODE"></A>
<P>
<EM>
<UL>
<LI> G&uuml;ltigkeit SUPMODE: 680x0, NS32xxx, PDP-11, i960, TLCS-900,
    SH7000, i960, 29K, Z280, XA, PowerPC, M*CORE, V60 und
    TMS9900</LI>
<LI> G&uuml;ltigkeit FPU: 680x0, NS32xxx, 80x86</LI>
<LI> G&uuml;ltigkeit PMMU: 680x0, NS32xxx</LI>
<LI> G&uuml;ltigkeit CUSTOM: NS32xxx</LI>
</UL>
</EM>
<P>
Mit diesen Schaltern kann bestimmt werden, auf welche Teile des
Befehlssatzes verzichtet werden soll, weil die daf&uuml;r
n&ouml;tigen Vorbedingungen im folgenden Codest&uuml;ck nicht gegeben
sind. Als Parameter f&uuml;r diese Befehle darf entweder<TT> ON</TT>
oder<TT> OFF</TT> gegeben werden, der momentan gesetzte Zustand kann
aus einer Variablen ausgelesen werden, die entweder TRUE oder FALSE
ist. Die Befehle bedeuten im einzelnen folgendes:
<UL>
<LI> <TT>SUPMODE</TT>: erlaubt bzw. sperrt Befehle, f&uuml;r deren
    Ausf&uuml;hrung der Prozessor im Supervisorstatus sein mu&szlig;.
    Die Statusvariable hei&szlig;t<TT> INSUPMODE</TT>.</LI>
<LI> <TT>FPU</TT>: erlaubt bzw. sperrt die Befehle des numerischen
    Koprozessors 8087, NS32081/32381 bzw. 68881/68882. Die
    Statusvariable hei&szlig;t<TT> FPUAVAIL</TT>. F&uuml;r NS32xxx
    als Ziel darf neben einem einfachen<TT> ON</TT> oder<TT> OFF</TT>
    auch der FPU-Typ (<TT>NS32081</TT>,<TT> NS32181</TT>,<TT>
    NS32381</TT> oder<TT> NS32580</TT>) angegeben werden, um die
    erweiterten Register und Befehle freizugeben oder zu
    verbieten.</LI>
<LI> <TT>PMMU</TT>: erlaubt bzw. sperrt die Befehle der
    Speicherverwaltungseinheit 68851 bzw. der im 68030 eingebauten
    MMU.<B> ACHTUNG!</B> Die 68030-MMU erlaubt nur eine relativ
    kleine Untermenge der 68851-Befehle, dies wird &uuml;ber den<TT>
    FULLPMMU</TT>-Befehl gesteuert. Die Statusvariable
    hei&szlig;t<TT> PMMUAVAIL</TT>. F&uuml;r NS32xxx als Ziel darf
    neben einem einfachen<TT> ON</TT> oder<TT> OFF</TT> auch der
    MMU-Typ (<TT>NS32082</TT>,<TT> NS32382</TT> oder<TT>
    NS32532</TT>) angegeben werden, um den jeweiligen
    MUU-Registersatz freizugeben.</LI>
<LI> <TT>CUSTOM</TT>: erlaubt bzw. sperrt die f&uuml;r benutzerdefinierte
    Slave-Prozessoren vorgesehenen Befehle.</LI>
</UL>
Benutzung von auf diese Weise gesperrten Befehlen erzeugt bei<TT>
SUPMODE</TT> eine Warnung, bei<TT> PMMU</TT> und<TT> FPU</TT> eine
echte Fehlermeldung.
<P>

<H3><A NAME="sect_3_2_5_">3.2.5. ACCMODE</A></H3>
<A NAME="index_ACCMODE_1"></A>
<P>
<EM>
<UL>
<LI> G&uuml;ltigkeit: VAX</LI>
</UL>
</EM>
<P>
Die VAX kennt nicht nur einen Supervisor- un User-Mode, sonder vier
derartige Privilegstufen. Mit absteigenden Rechten heissen diese
Zugriffs-Modi Kernel, Executive, Supervisor und User. Mit dem<TT>
ACCMODE</TT>-Befehl teilt man dem Assembler mit, in welchen Modus der
folgende Code ausgef&uuml;hrt wird. Je nach Modus sind nicht alle
Maschinenbefehle erlaubt. Als Argument sind entweder die genannten
Namen der vier Modi zul&auml;ssig, oder eine Zahl von Null
(Kernel-Modus) bis Drei (User-Modus). Im Default wird der User-Modus
angenommen, und die aktuelle Einstellung (als Zahlenwert) l&auml;sst
sich aus dem Symbol gleichen Namens lesen.
<P>

<H3><A NAME="sect_3_2_6_">3.2.6. CIS, EIS, FIS und FP11</A></H3>
<A NAME="index_CIS_1"></A><A NAME="index_EIS_1"></A><A
NAME="index_FIS_1"></A><A NAME="index_FP11_1"></A>
<P>
<EM>
<UL>
<LI> G&uuml;ltigkeit: PDP-11</LI>
</UL>
</EM>
<P>
Mit diesen Anweisungen schaltet man die Verf&uuml;gbarkeit bestimmter
PDP-11-Befehlssatzerweiterungen ein oder aus. Voraussetzung f&uuml;r
die Verf&uuml;gbarkeit einer dieser Anweisungen ist, da&szlig; die
fraglichen Befehle nicht bereits im Basis-Befehlssatz enthalten sind,
und da&szlig; eine entsprechende Aufr&uuml;stm&ouml;glichkeit
bestanden hat. Im einzelnen:
<UL>
<LI> <TT> CIS</TT>: ,,Commercial Instruction Set'', d.h. Befehle zur
    Verarbeitung gepackter und nicht gepackter BCD-Zahlen mit
    variabler L&auml;nge. Diese waren auf dem LSI-11 sowie der
    PDP-11/44 als Option verf&uuml;gbar.</LI>
<LI> <TT> EIS</TT>: Die Befehle<TT> MUL, DIV, ASH</TT> und<TT> ASHC</TT>,
    die auf fr&uuml;hen bzw. einfachen PDP-11-Systemen nicht Teil des
    Basisbefehlssatzes waren. Auf dem LSI-11 bzw. der PDP-11/35 und
    PDP-11/40 waren sie per Option nachr&uuml;stbar.</LI>
<LI> <TT> FIS</TT>: Stack-orientierte Befehle, die die Grundrechenarten
    f&uuml;r Gleitkommazahlen im F-Format (32 Bit) implementieren.
    Auf dem LSI-11 bzw. der PDP-11/35 und PDP-11/40 waren sie per
    Option nachr&uuml;stbar.</LI>
<LI> <TT> FP11</TT>: Volle Gleitkomma-Unterst&uuml;tzung mit separaten
    FPU-Registern im F- und D-Format (32/64 Bit).</LI>
</UL>
<P>

<H3><A NAME="sect_3_2_7_">3.2.7. FULLPMMU</A></H3>
<A NAME="index_FULLPMMU_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0</EM>
<P>
Motorola hat zwar ab dem 68030 die PMMU in den Prozessor integriert,
diese aber nur mit einer Funktionsuntermenge der externen PMMU 68851
ausgestattet. AS sperrt bei aktiviertem PMMU-Befehlssatz (s.o.)
deshalb alle fehlenden Befehle, wenn als Zielprozessor 68030 oder
h&ouml;her eingestellt wurde. Nun kann es aber sein, da&szlig; in
einem System mit 68030-Prozessor die interne MMU abgeschaltet wurde
und der Prozessor mit einer externen 68851 betrieben wird. Mit<TT>
FULLPMMU ON</TT> kann man AS dann mitteilen, da&szlig; der
vollst&auml;ndige MMU-Befehlssatz zugelassen ist. Umgekehrt kann man,
wenn man portablen Code erzeugen will, alle zus&auml;tzlichen Befehle
trotz 68020-Zielplattform mit<TT> FULLPMMU OFF</TT> abschalten. Die
Umschaltung darf beliebig oft erfolgen, die momentane Einstellung
kann aus einem gleichnamigen Symbol ausgelesen werden.<B>
ACHTUNG!</B> Der<TT> CPU</TT>-Befehl besetzt f&uuml;r 680x0-Argumente
implizit diese Einstellung vor!<TT> FULLPMMU</TT> mu&szlig; also auf
jeden Fall nach dem<TT> CPU</TT>-Befehl kommen!
<P>

<H3><A NAME="sect_3_2_8_">3.2.8. PADDING</A></H3>
<A NAME="index_PADDING_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0, 68xx, M*Core, XA, H8, SH7000,
TMS9900,<BR>
MSP430(X), ST7/STM8, AVR (nur wenn die Granularit&auml;t des
Code-Segments 8 Bit ist)</EM>
<P>
Diverse Prozessorfamilien verlangen, da&szlig; Objekte von mehr als
einem Byte L&auml;nge auf einer geraden Adresse liegen m&uuml;ssen.
Neben Datenobjekten schlie&szlig;t dies auch Instruktionsworte selber
ein - auf einem 68000 l&ouml;sen Wortzugriffe auf eine ungerade
Adresse zum Beispiel eine Exception aus, andere Prozessoren wie die
H8-Familie setzen das unterste Adre&szlig;bit bei einem Wortzugriff
einfach hart auf Null.
<P>
Mit dem<TT> PADDING</TT>-Befehl kann man einen Mechanismus
aktivieren, mit dem der Assembler versucht, solches 'Misalignment'
nach M&ouml;glichkeit zu verhindern. Steht die Situation an,
da&szlig; ein Instruktionswort, oder auch z.B. mit<TT> DC</TT>
angelegte Daten von 16 Bit oder mehr auf einer ungeraden Adresse
landen w&uuml;rden, dann wird automatisch ein F&uuml;llbyte davor
eingef&uuml;gt. Im Listing wird dieses F&uuml;llbyte in einer
separaten Zeile mit dem Hinweis
<PRE>

&lt;padding&gt;

</PRE>
ausgewiesen.
<P>
Steht in der Quellzeile ein Label, so verweist dieses Label weiterhin
auf den von dieser Zeile erzeugten Code, also auf die Adresse
unmittelbar nach dem F&uuml;llbyte. Das gleiche gilt auch f&uuml;r
ein Label in einer separaten Zeile unmittelbar davor, sofern diese
Zeile<EM> alleine</EM> das Label und selber keine Anweisung
enth&auml;lt. Im folgenden Beispiel:
<PRE>

       padding  on
       org      $1000

       dc.b     1
adr1:  nop

       dc.b     1
adr2:
       nop

       dc.b     1
adr3:  equ      *
       nop

</PRE>
w&uuml;rden die Labels<TT> adr1</TT> und<TT> adr2</TT> die (durch ein
F&uuml;llbyte auf einen geraden Wert aufgerundete) Adresse der
jeweiligen<TT> NOP</TT>- Instruktion beinhalten,<TT> adr3</TT>
w&uuml;rde jedoch auf das F&uuml;llbyte<EM> vor</EM> der dritten<TT>
NOP</TT>-Instruktion zeigen.
<P>
Als Argument zu<TT> PADDING</TT> ist analog zu den vorherigen
Befehlen<TT> ON</TT> oder<TT> OFF</TT> erlaubt, und die
augenblickliche Einstellung kann aus dem gleichnamigen Symbol
ausgelesen werden. Defaultm&auml;&szlig;ig ist<TT> PADDING</TT> nur
f&uuml;r die 680x0-Familie eingeschaltet, f&uuml;r alle anderen
werden erst nach Umschaltung Padding-Bytes eingef&uuml;gt.
<P>

<H3><A NAME="sect_3_2_9_">3.2.9. PACKING</A></H3>
<A NAME="index_PACKING_1"></A><A NAME="ref_SectPACKING"></A>
<P>
<EM> G&uuml;ltigkeit: 56000, AVR, TMS3203x/4x, TMS3206x, MN1610,<BR>
CP1600, &micro;PD7720/7725, &micro;PD77230</EM>
<P>
<TT> PACKING</TT> ist in gewisser Weise &auml;hnlich zu<TT>
PADDING</TT>, es arbeitet nur gewisserma&szlig;en anders herum:
w&auml;hrend<TT> PADDING</TT> die abgelegten Daten erg&auml;nzt, um
komplette Worte und damit ein Alignment zu erhalten, quetscht<TT>
PACKING</TT> mehrere Werte in ein einzelnes Wort. Dies macht im
Code-Segment des AVR Sinn, weil dort mit einem Spezialbefehl (<TT>
LPM</TT>) auf einzelne Bytes in den 16-Bit-Worten zugegriffen werden
kann. Ist diese Option eingeschaltet (Argument<TT> ON</TT>), so
werden immer zwei Byte-Werte bei<TT> DATA</TT> in ein Wort gepackt,
analog zu den einzelnen Zeichen von String-Argumenten. Der
Wertebereich der Integer-Argumente reduziert sich dann nat&uuml;rlich
auf -128...+255. Ist diese Option dagegen ausgeschaltet,
(Argument<TT> OFF</TT>), so bekommt jedes Integer-Argument sein
eigenes Wort und darf auch Werte von -32768...+65535 annehmen.
<P>
Diese Unterscheidung betrifft nur Integer-Argumente von<TT>
DATA</TT>, Strings werden immer gepackt. Zu beachten ist weiterhin,
da&szlig; dieses Packen nur innerhalb der Argumente eines<TT>
DATA</TT>-Befehls funktionieren kann, wer also mehrere<TT>
DATA</TT>-Befehle hintereinander hat, f&auml;ngt sich bei ungeraden
Argumentzahlen trotzdem halbvolle W&ouml;rter ein!
<P>

<H3><A NAME="sect_3_2_10_">3.2.10. MAXMODE</A></H3>
<A NAME="index_MAXMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: TLCS-900, H8</EM>
<P>
Die Prozessoren der TLCS-900-Reihe k&ouml;nnen in 2 Betriebsarten
arbeiten, dem Minimum-und Maximum-Modus. Je nach momentaner
Betriebsart gelten f&uuml;r den Betrieb und den Assembler etwas
andere Eckwerte. Mit diesem Befehl und den Parametern<TT> ON</TT>
oder<TT> OFF</TT> teilt man AS mit, da&szlig; der folgende Code im
Maximum- oder Minimum-Modus abl&auml;uft. Die momentane Einstellung
kann aus der Variablen<TT> INMAXMODE</TT> ausgelesen werden.
Voreinstellung ist<TT> OFF</TT>, d.h. Minimum-Modus.
<P>
Analog dazu teilt man im H8-Modus AS mit diesem Befehl mit, ob mit
einem 64K- oder 16Mbyte-Adre&szlig;raum gearbeitet wird. F&uuml;r den
einfachen 300er ist diese Einstellung immer<TT> OFF</TT> und kann
nicht ver&auml;ndert werden.
<P>

<H3><A NAME="sect_3_2_11_">3.2.11. EXTMODE und LWORDMODE</A></H3>
<A NAME="index_EXTMODE_1"></A><A NAME="index_LWORDMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: Z380</EM>
<P>
Der Z380 kann in insgesamt 4 Betriebsarten arbeiten, die sich durch
die Einstellung von 2 Flags ergeben: Das XM-Flag bestimmt, ob der
Prozessor mit einem 64 Kbyte oder 4 Gbyte gro&szlig;en
Adre&szlig;raum arbeiten soll und kann nur gesetzt werden (nach einem
Reset steht es Z80-kompatibel auf 0). Demgegen&uuml;ber legt das
LW-Flag fest, ob Wort-Befehle mit einer Wortl&auml;nge von 16 oder 32
Bit arbeiten sollen. Die Stellung dieser beiden Flags
beeinflu&szlig;t Wertebereichseinschr&auml;nkungen von Konstanten
oder Adressen, weshalb man AS &uuml;ber diese beiden Befehle deren
Stellung mitteilen mu&szlig;. Als Default nimmt AS an, da&szlig;
beide Flags auf 0 stehen, die momentane Einstellung (<TT>ON</TT>
oder<TT> OFF</TT>) kann aus den vordefinierten Variablen<TT>
INEXTMODE</TT> bzw.<TT> INLWORDMODE</TT> ausgelesen werden.
<P>

<H3><A NAME="sect_3_2_12_">3.2.12. SRCMODE</A></H3>
<A NAME="index_SRCMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: MCS-251</EM>
<P>
Intel hat den Befehlssatz der 8051er beim 80C251 deutlich erweitert,
hatte aber leider nur noch einen einzigen freien Opcode f&uuml;r
diese Befehle frei. Damit der Prozessor nicht auf alle Ewigkeit durch
einen Pr&auml;fix behindert bleibt, hat Intel zwei Betriebsarten
vorgesehen: Den Bin&auml;r- und den Quellmodus. Im Bin&auml;rmodus
ist der Prozessor voll 8051-kompatibel, alle erweiterten Befehle
ben&ouml;tigen den noch freien Opcode als Pr&auml;fix. Im Quellmodus
tauschen diese neuen Befehle ihre Position in der Code-Tabelle mit
den entsprechenden 8051-Instruktionen, welche dann wiederum mit einem
Pr&auml;fix versehen werden m&uuml;ssen. Damit AS wei&szlig;, wann er
Pr&auml;fixe setzen mu&szlig; und wann nicht, mu&szlig; man ihm mit
diesem Befehl mitteilen, ob der Prozessor im Quellmodus (<TT>ON</TT>)
oder Bin&auml;rmodus (<TT>OFF</TT>) betrieben wird. Die momentane
Einstellung kann man aus der Variablen<TT> INSRCMODE</TT> auslesen.
Der Default ist<TT> OFF</TT>.
<P>

<H3><A NAME="sect_3_2_13_">3.2.13. PLAINBASE</A></H3>
<A NAME="index_PLAINBASE_1"></A><A NAME="ref_SectPLAINBASE"></A>
<P>
<EM> G&uuml;ltigkeit: 6809</EM>
<P>
Historisch erlaubt AS, bei indizierten Adressierungsausdr&uuml;cken
ein leeres, erstes Argument wegzulassen. Ein
<PRE>

  lda  x

</PRE>
zum Beispiel war also &auml;quivalent zu
<PRE>

  lda  ,x

</PRE>
Obwohl als Feature gedacht, wurde dies jedoch gelegentlich eher als
Bug angesehen. Deshalb darf ein leeres Index-Argument nicht mehr
weggelassen werden bzw. wird mit einer Fehlermeldung &uuml;ber eine
falsche Anzahl Argumente quittiert. Falls die Funktion gew&uuml;nscht
ist bzw. f&uuml;r existierenden Code gebraucht wird, kann sie mit
einem
<PRE>

  plainbase on

</PRE>
wieder eingeschaltet werden. Die aktuelle Einstellung kann aus dem
gleichnamigen Symbol ausgelesen werden.
<P>

<H3><A NAME="sect_3_2_14_">3.2.14. BIGENDIAN</A></H3>
<A NAME="index_ENDIAN_1"></A><A NAME="index_BIGENDIAN_1"></A><A
NAME="ref_SectBIGENDIAN"></A>
<P>
<EM> G&uuml;ltigkeit: MCS-51/251, PowerPC, SC/MP, 2650, NS32000</EM>
<P>
Bei den Prozessoren der 8051-Serie ist Intel seinen eigenen
Prinzipien untreu geworden: Der Prozessor verwendet entgegen
jeglicher Tradition eine Big-Endian-Orientierung von Mehrbytewerten!
W&auml;hrend dies bei den MCS-51-Prozessoren noch nicht
gro&szlig;artig auffiel, da der Prozessor ohnehin nur 8-bittig auf
Speicherzellen zugreifen konnte, man sich die Byte-Anordnung bei
eigenen Datenstrukturen also aussuchen konnte, ist dies beim MCS-251
nicht mehr so, er kann auch ganze (Lang-)Worte aus dem Speicher lesen
und erwartet dabei das MSB zuerst. Da dies nicht der bisherigen
Arbeitsweise von AS bei der Konstantenablage entspricht, kann man nun
mit diesem Befehl umschalten, ob die Befehle<TT> DB, DW, DD, DQ,
DT</TT> und<TT> DO</TT> mit Big- oder Little-Endian-Orientierung
arbeiten sollen. Mit<TT> BIGENDIAN OFF</TT> (Voreinstellung) wird wie
bei &auml;lteren AS-Versionen zuerst das niederwertigste Byte
abgelegt, mit<TT> BIGENDIAN ON</TT> wird die MCS-251-kompatible
Variante benutzt. Nat&uuml;rlich kann man diese Einstellung beliebig
oft im Code &auml;ndern; die momentane Einstellung kann aus dem
gleichnamigen Symbol ausgelesen werden.
<P>
F&uuml;r Renesas RX ist die Endianess ebenfalls umschaltbar, aus
Kompatibilit&auml;t zum Original-Assembler hei&szlig;t der Befehl
hier jedoch<TT> ENDIAN</TT> und akzeptiert ein<TT> LITTLE</TT>
oder<TT> BIG</TT> als Argument.
<P>

<H3><A NAME="sect_3_2_15_">3.2.15. WRAPMODE</A></H3>
<A NAME="index_WRAPMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: Atmel AVR</EM>
<P>
Ist dieser Schalter auf<TT> ON</TT> gesetzt, so veranla&szlig;t man
AS dazu, anzunehmen, der Programmz&auml;hler des Prozessors habe
nicht die volle, durch die Architektur gegebene L&auml;nge von 16
Bits, sondern nur eine L&auml;nge, die es gerade eben erlaubt, das
interne ROM zu adressieren. Im Falle des AT90S8515 sind dies z.B. 12
Bit, entsprechend 4 KWorten oder 8 KBytes. Damit werden relative
Spr&uuml;nge vom Anfang des ROMs zum Ende und umgekehrt m&ouml;glich,
die bei strenger Arithmetik einen out-of-branch ergeben w&uuml;rden,
hier jedoch funktionieren, weil die &Uuml;bertragsbits bei der
Zieladressenberechnung 'unter den Tisch' fallen. Vergewissern Sie
sich genau, ob die von Ihnen eingesetzte Prozessorvariante so
arbeitet, bevor Sie diese Option einschalten! Im Falle des oben
erw&auml;hnten AT90S8515 ist diese Option sogar zwingend n&ouml;tig,
um &uuml;berhaupt quer durch den ganzen Adre&szlig;raum springen zu
k&ouml;nnen...
<P>
Defaultm&auml;&szlig;ig steht dieser Schalter auf<TT> OFF</TT>, der
momentane Stand l&auml;&szlig;t sich aus einem gleichnamigen Symbol
auslesen.
<P>

<H3><A NAME="sect_3_2_16_">3.2.16. PANEL</A></H3>
<A NAME="index_PANEL_1"></A>
<P>
<EM> G&uuml;ltigkeit: IM61x0</EM>
<P>
Mit diesem Schalter teilt man dem Assembler mit, ob der folgende Code
mit gesetztem oder gel&ouml;schtem<EM> Control Panel Flip-Flop</EM>
ausgef&uuml;hrt wird. Eine Reihe von<TT> IOT</TT>-Instruktionen sind
nur bei einer bestimmten Stellung des Flip-Flops zul&auml;ssig. Ihre
Verwendung im anderen Modus wird vom Assembler mit einer
Fehlermeldung quittiert.
<P>
Die aktuelle Einstellung kann aus dem Symbol<TT> INPANEL</TT> gelesen
werden.
<P>

<H3><A NAME="sect_3_2_17_">3.2.17. WARNRELATIVE</A></H3>
<P>
<EM> G&uuml;ltigkeit: Zx80</EM>
<P>
Mit diesem Schalter teilt man dem Assembler mit, ob eine Warnung
erfolgen soll, falls ein relativer anstelle eines absoluten Sprungs
m&ouml;glich gewesen w&auml;re. Der Default ist OFF bzw. das, was auf
der Kommandozeile durch die Argumente<TT> -wrelative</TT> bzw.<TT>
-wno-relative</TT> vorgegeben wurde.
<P>
Die aktuelle Einstellung kann aus dem gleichnamigen Symbol gelesen
werden.
<P>

<H3><A NAME="sect_3_2_18_">3.2.18. SEGMENT</A></H3>
<A NAME="index_SEGMENT_1"></A><A NAME="ref_SEGMENT"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Bestimmte Mikrokontroller und Signalprozessoren kennen mehrere
Adre&szlig;bereiche, die nicht miteinander mischbar sind und jeweils
auch verschiedene Befehle zur Ansprache ben&ouml;tigen. Um auch diese
verwalten zu k&ouml;nnen, stellt der Assembler mehrere
Programmz&auml;hler zur Verf&uuml;gung, zwischen denen mit dem<TT>
SEGMENT</TT>-Befehl hin-und hergeschaltet werden kann. Dies erlaubt
es, sowohl in mit<TT> INCLUDE</TT> eingebundenen Unterprogrammen als
auch im Hauptprogramm ben&ouml;tigte Daten an der Stelle zu
definieren, an denen sie benutzt werden. Im einzelnen werden folgende
Segmente mit folgenden Namen verwaltet:
<UL>
<LI> <TT>CODE</TT>: Programcode;</LI>
<LI> <TT>DATA</TT>: direkt adressierbare Daten (dazu rechnen auch
    SFRs);</LI>
<LI> <TT>XDATA</TT>: im extern angeschlossenen RAM liegende Daten oder
    X-Adre&szlig;raum beim DSP56xxx oder ROM-Daten beim
    &micro;PD772x;</LI>
<LI> <TT>YDATA</TT>: Y-Adre&szlig;raum beim DSP56xxx;</LI>
<LI> <TT>IDATA</TT>: indirekt adressierbare (interne) Daten;</LI>
<LI> <TT>BITDATA</TT>: der Teil des 8051-internen RAMs, der bitweise
    adressierbar ist;</LI>
<LI> <TT>IO</TT>: I/O-Adre&szlig;bereich;</LI>
<LI> <TT>REG</TT>: Registerbank des ST9;</LI>
<LI> <TT>ROMDATA</TT>: Konstanten-ROM der NEC-Signalprozessoren;</LI>
<LI> <TT>EEDATA</TT>: eingebautes EEPROM.</LI>
</UL>
Zu Adre&szlig;bereich und Initialwerten der Segmente siehe Abschnitt
<A HREF="#ref_SectORG">3.2.1</A>. (<TT>ORG</TT>). Je nach
Prozessorfamilie sind auch nicht alle Segmenttypen erlaubt.
<P>
Das Bitsegment wird so verwaltet, als ob es ein Bytesegment
w&auml;re, d.h. die Adressen inkrementieren um 1 pro Bit.
<P>
Labels, die in einem Segment eines bestimmten Typs definiert werden,
erhalten diesen Typ als Attribut. Damit hat der Assembler eine
begrenzte Pr&uuml;fm&ouml;glichkeit, ob mit den falschen Befehlen auf
Symbole in einem Segment zugegriffen wird. In solchen F&auml;llen
wird der Assembler eine Warnung ausgeben.
<P>
Beispiel:
<PRE>

        CPU     8051    ; MCS-51-Code

        SEGMENT code    ; Testcodeblock

        SETB    flag    ; keine Warnung
        SETB    var     ; Warnung : falsches Segment

        SEGMENT data

var     DB      ?

        SEGMENT bitdata

flag    DB      ?

</PRE>
<P>

<H3><A NAME="sect_3_2_19_">3.2.19. PHASE und DEPHASE</A></H3>
<A NAME="index_PHASE_1"></A><A NAME="index_DEPHASE_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
In manchen Anwendungen (speziell Z80-Systeme) mu&szlig; Code vor der
Benutzung in einen anderen Adre&szlig;bereich verschoben werden. Da
der Assembler davon aber nichts wei&szlig;, w&uuml;rde er alle Labels
in dem zu verschiebenden Teil auf die Ladeadressen ausrichten. Der
Programmierer m&uuml;&szlig;te Spr&uuml;nge innerhalb dieses
Bereiches entweder lageunabh&auml;ngig kodieren oder die Verschiebung
bei jedem Symbol ,,zu Fu&szlig;'' addieren. Ersteres ist bei manchen
Prozessoren gar nicht m&ouml;glich, letzteres sehr
fehleranf&auml;llig.
<P>
Mit dem Befehlen<TT> PHASE</TT> und<TT> DEPHASE</TT> ist es
m&ouml;glich, dem Assembler mitzuteilen, auf welcher Adresse der Code
im Zielsystem effektiv ablaufen wird:
<PRE>

        PHASE   &lt;Adresse&gt;

</PRE>
informiert den Assembler davon, da&szlig; der folgende Code auf der
spezifizierten Adresse ablaufen soll. Der Assembler berechnet
daraufhin die Differenz zum echten Programmz&auml;hler und addiert
diese Differenz bei folgenden Operationen dazu:
<UL>
<LI> Adre&szlig;angabe im Listing</LI>
<LI> Ablage von Labelwerten</LI>
<LI> Programmz&auml;hlerreferenzen in relativen Spr&uuml;ngen und
    Adre&szlig;ausdr&uuml;cken</LI>
<LI> Abfrage des Programmz&auml;hlers mit den Symbolen * bzw. $</LI>
</UL>
Diese ,,Verschiebung'' wird mit dem Befehl
<PRE>

        DEPHASE

</PRE>
wieder auf den vor der zugeh&ouml;rigen<TT> PHASE</TT>-Anweisung
zur&uuml;ck ge&auml;ndert.<TT> PHASE</TT> und<TT> DEPHASE</TT>
k&ouml;nnen also auf diese Weise geschachtelt verwendet werden.
<P>
Obwohl dieses Befehlspaar vornehmlich in Codesegmenten Sinn macht,
verwaltet der Assembler f&uuml;r alle definierten Segmente
Phasenwerte.
<P>

<H3><A NAME="sect_3_2_20_">3.2.20. SAVE und RESTORE</A></H3>
<A NAME="index_SAVE_1"></A><A NAME="index_RESTORE_1"></A><A
NAME="index_.SAVE_1"></A><A NAME="index_.RESTORE_1"></A><A
NAME="index_SAVEENV_1"></A><A NAME="index_RESTOREENV_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit dem Befehl<TT> SAVE</TT> legt der Assembler den Inhalt folgender
Variablen auf einen internen Stapel:
<UL>
<LI> momentan gew&auml;hlter Prozessortyp (mit<TT> CPU</TT>
    gesetzt);</LI>
<LI> momentan aktiver Speicherbereich (mit<TT> SEGMENT</TT>
    gesetzt);</LI>
<LI> Flag, ob Listing ein- oder ausgeschaltet ist (mit<TT> LISTING</TT>
    gesetzt);</LI>
<LI> Flags, zu welchem Teil Expansionen folgender Makos im Listing
    ausgegeben werden sollen (mit<TT> MACEXP_DFT/MACEXP_OVR</TT>
    gesetzt).</LI>
<LI> momentan aktive Zeichen&uuml;bersetzungstabelle (mit<TT>
    CODEPAGE</TT> gesetzt).</LI>
</UL>
Mit dem Gegenst&uuml;ck<TT> RESTORE</TT> wird entsprechend der
zuletzt gesicherte Zustand von diesem Stapel wieder heruntergeladen.
Diese beiden Befehle sind in erster Linie f&uuml;r Include-Dateien
definiert worden, um in diesen Dateien die obigen Variablen beliebig
ver&auml;ndern zu k&ouml;nnen, ohne ihren originalen Inhalt zu
verlieren. So kann es z.B. sinnvoll sein, in Include-Dateien mit
eigenen, ausgetesteten Unterprogrammen die Listingerzeugung
auszuschalten:
<PRE>

        SAVE            ; alten Zustand retten
        LISTING OFF     ; Papier sparen
        ..              ; der eigentliche Code
        RESTORE         ; wiederherstellen

</PRE>
Gegen&uuml;ber einem einfachen<TT> LISTING OFF..ON</TT>-P&auml;rchen
wird hier auch dann der korrekte Zustand wieder hergestellt, wenn die
Listingerzeugung bereits vorher ausgeschaltet war.
<P>
Der Assembler &uuml;berpr&uuml;ft, ob die Zahl von<TT>
SAVE</TT>-und<TT> RESTORE</TT>-Befehlen &uuml;bereinstimmt und
liefert in folgenden F&auml;llen Fehlermeldungen:
<UL>
<LI> <TT>RESTORE</TT> und der interne Stapel ist leer;</LI>
<LI> nach Ende eines Passes ist der Stapel nicht leer.</LI>
</UL>
Falls das aktuell benutzte Target bereits einen Maschinenbefehl
namens<TT> SAVE</TT> bzw.<TT> RESTORE</TT> hat, kann die
Funktionalit&auml;t &uuml;ber<TT> SAVEENV</TT> bzw.<TT>
RESTOREENV</TT> erreicht werden. Wahlweise ist es auch immer
m&ouml;glich, explizit die Pseudobefehle durch voran gestellte Punkte
(<TT>.SAVE</TT> bzw.<TT> .RESTORE</TT>) aufzurufen.
<P>

<H3><A NAME="sect_3_2_21_">3.2.21. ASSUME</A></H3>
<A NAME="index_ASSUME_1"></A>
<P>
<EM> G&uuml;ltigkeit: diverse</EM>
<P>
Mit diesem Befehl kann man AS den aktuellen Stand bestimmter Register
mitteilen, deren Inhalt sich nicht mit einem einfachen<TT> ON</TT>
oder<TT> OFF</TT> beschreiben l&auml;&szlig;t. Typischerweise sind
dies Register, die die Adressierungseinheiten beeinflussen und deren
Werte AS wissen mu&szlig;, um korrekte Adressierungen zu erzeugen.
Wichtig ist, da&szlig; man AS mit ASSUME diese Werte nur mitteilt, es
wird<EM> kein</EM> Maschinencode erzeugt, der diese Werte in die
entsprechenden Register l&auml;dt!
<P>
Ein mit<TT> ASSUME</TT> definierter Wert l&auml;&szlig;t sich mit der
eingebauten Funktion<TT> ASSUMEDVAL</TT> wieder abfragen oder in
Ausdr&uuml;cke einbauen. Dies gilt f&uuml;r alle im folgenden
gelisteten Architekturen mit Ausnahme des 8086.
<P>

<H4>65CE02</H4>
<P>
Der 65CE02 besitzt ein Register 'B', mit dem die 'Base-Page'
festgelegt wird. Im Gegensatz zum 'einfachen' 6502 l&auml;&szlig;t
sich damit die Speicherseite, die mit kurzen (8-bittigen) Adressen
ansprechbar ist, frei im 64K-Adre'sraum hin- und herschieben. Nach
einem Reset steht dieses Register auf Null, der 65CE02 verh&auml;lt
sich also wie sein Vorbild. Dies ist auch die Default-Annahme des
Assemblers. Mittels eines<TT> ASSUME B:xx</TT> kann man ihm den
aktuellen Wert mitteilen, und f&uuml;r Adressen in dieser Seite
werden dann automatisch kurze Adressierungsarten benutzt.
<P>

<H4>6809</H4>
<P>
Im Gegensatz zu seinen ,,Vorg&auml;ngern'' wie 6800 und 6502 kann
beim 6809 die Lage der direct page, d.h. des Adressbereiches, der mit
ein Byte langen Adressen erreichbar ist, frei bestimmt werden. Dazu
dient das sog. ,,Direct Page Register'' (<TT>DPR</TT>), das die
Seitennummer festlegt. Ihm mu&szlig; man mittels<TT> ASSUME</TT>
einen passenden Wert zuweisen, wenn man einen anderen Wert als die
Vorgabe von 0 in DPR schreibt, sonst werden Adressen falscher
L&auml;nge erzeugt...
<P>

<H4>68HC11K4</H4>
<P>
Auch beim HC11 kamen die Entwickler letzen Endes nicht um eine Form
von Banking herum, um mit 16 Adre&szlig;leitungen mehr als 64 Kbyte
anzusprechen. Die Register<TT> MMSIZ</TT>,<TT> MMWBR</TT>,<TT>
MM1CR</TT> und<TT> MM2CR</TT> legen fest, ob und wie die beiden
zus&auml;tzlichen 512K-Bereiche in den Adre&szlig;raum der CPU
eingeblendet werden sollen. Initial nimmt AS den Reset-Zustand dieser
Register an, d.h. alle mit $00 belegt und das Windowing ist
abgeschaltet.
<P>
Weiterhin kann man die Werte der Register<TT> CONFIG</TT>,<TT>
INIT</TT> und<TT> INIT2</TT> festlegen. Aus diesen kann der Assembler
die Lage der CPU-internen Register sowie des CPU-internen RAM/EEPROM
bestimmen. Deren Mapping hat eine h&ouml;here Priorit&auml;t als die
per Windowing eingeblendeten Speicherbereiche.
<P>

<H4>68HC12X</H4>
<P>
Wie die Variante ohne anh&auml;ngendes 'X' kennt auch der HC12X eine
kurze direkte Adressierungsart, die hier jedoch auch andere
Adre&szlig;bereiche als die ersten 256 Byte erreichen kann. &Uuml;ber
das<TT> DIRECT</TT>-Register kann die 256-Byte-Seite vorgegeben
werden, die mit dieser kurzen Adressierungsart angesprochen wird.
Mittels<TT> ASSUME</TT> wird AS der momentane Stand dieses Registers
mitgeteilt, so da&szlig; bei absoluten Adressen automatisch die
effizienteste Adressierungsart gew&auml;hlt werden kann. Default ist
0, was auch dem Reset-Zustand entspricht.
<P>

<H4>68HC16</H4>
<P>
Um mit seinen nur 16 Bit breiten Adre&szlig;operanden einen 1 Mbyte
gro&szlig;en Adre&szlig;raum ansprechen zu k&ouml;nnen, bedient sich
der 68HC16 einer Reihe von Bank-Registern, die die fehlenden oberen
vier Adre&szlig;bits nachliefern. Davon ist das<TT> EK</TT>-Register
f&uuml;r absolute Datenzugriffe (nicht Spr&uuml;nge!) zust&auml;ndig.
AS &uuml;berpr&uuml;ft bei jeder absoluten Adressierung, ob die
oberen vier Bits der Adresse mit dem &uuml;ber<TT> ASSUME</TT>
spezifizierten Wert &uuml;bereinstimmen. Differieren die Werte, gibt
AS eine Warnung aus. Der Vorgabewert f&uuml;r<TT> EK</TT> ist 0.
<P>

<H4>H8/500</H4>
<P>
Im Maximum-Modus wird der erweiterte Adre&szlig;raum dieser
Prozessorreihe durch eine Reihe von Bank-Registern adressiert. Diese
tragen die Namen DP (Register 0..3, absolute Adressen), EP (Register
4/5) und TP (Stack). Den momentanen Wert von DP ben&ouml;tigt AS, um
zu &uuml;berpr&uuml;fen, ob absolute Adressen in der momentan
adressierbaren Bank liegen; die beiden anderen Register werden nur
f&uuml;r indirekte Adressierungen benutzt und entziehen sich daher
der Kontrolle; ob man ihre Werte angibt oder nicht, ist daher
Geschmackssache. Wichtig ist dagegen wieder das BR-Register, das
angibt, auf welchen 256-Byte-Bereich mit kurzen Adressen zugegriffen
werden kann. Allen Registern ist gemeinsam, da&szlig; AS<EM>
keine</EM> Initialwerte f&uuml;r sie annimmt, da sie nach einem
Prozessor-Reset undefiniert sind; wer absolut adressieren will,
mu&szlig; daher auf jeden Fall DR und DP belegen!
<P>

<H4>MELPS740</H4>
<P>
Die Mikrokontroller dieser Reihe kennen f&uuml;r den<TT>
JSR</TT>-Befehl eine besondere Adressierungsart ,,special page'', mit
deren Hilfe man Spr&uuml;nge in die oberste Seite des internen ROMs
k&uuml;rzer kodieren kann. Diese ist nat&uuml;rlich vom jeweiligen
Chip abh&auml;ngig, und es gibt mehr Chips, als es mit dem<TT>
CPU</TT>-Befehl sinnvoll w&auml;re, zu kodieren...also mu&szlig;<TT>
ASSUME</TT> herhalten, um die Lage dieser Seite vorzugeben, z.B.
<PRE>

        ASSUME SP:$1f ,

</PRE>
falls das interne ROM 8K gro&szlig; ist.
<P>

<H4>MELPS7700/65816</H4>
<P>
Diese Prozessoren beinhalten eine Reihe von Registern, deren Inhalt
AS kennen mu&szlig;, um den korrekten Code zu erzeugen. Es handelt
sich um folgende Register:
<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Wertebereich</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Default</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>DT/DBR<BR>
PG/PBR<BR>
DPR<BR>
X<BR>
M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Datenbank<BR>
Code-Bank<BR>
direkt adr. Seite<BR>
Indexregisterbreite<BR>
Akkumulatorbreite</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0-$ff<BR>
0-$ff<BR>
0-$ffff<BR>
0 oder 1<BR>
0 oder 1</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0<BR>
0<BR>
0<BR>
0<BR>
0</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>
Um mich nicht in endlose Wiederholungen zu ergehen, verweise ich
f&uuml;r die Benutzung dieser Werte auf Kapitel <A
HREF="#ref_MELPS7700Spec">4.15</A>. Die Handhabung erfolgt ansonsten
genauso wie beim 8086, d.h. es k&ouml;nnen auch hier mehrere Werte
auf einmal gesetzt werden und es wird<B> kein</B> Code erzeugt, der
die Register mit den Werten besetzt. Dies bleibt wieder einzig und
allein dem Programmierer &uuml;berlassen!
<P>

<H4>MCS-196/296</H4>
<P>
Alle Prozessoren der MCS-96-Familie besitzen ab dem 80196 ein
Register<TT> WSR</TT>, mit dessen Hilfe Speicherbereiche aus dem
erweiterten internen RAM oder dem SFR-Bereich in Bereiche des
Registerfiles eingeblendet werden und so mit kurzen Adressen
angesprochen werden k&ouml;nnen. Teilt man AS mit Hilfe des<TT>
ASSUME</TT>-Befehls mit, welchen Wert das WSR-Register hat, so stellt
er bei absoluten Adressen automatisch fest, ob sie durch das
Windowing mit 1-Byte-Adressen erreicht werden k&ouml;nnen; umgekehrt
werden auch f&uuml;r durch das Windowing &uuml;berdeckte Register
automatisch lange Adressen erzeugt. Der 80296 besitzt ein
zus&auml;tzliches, zweites Register<TT> WSR1</TT>, um zwei
unterschiedliche Speicherbereiche gleichzeitig in das Registerfile
einblenden zu k&ouml;nnen. Sollte es m&ouml;glich sein, eine
Speicherzelle &uuml;ber beide Bereiche zu adressieren, so w&auml;hlt
AS immer den Weg &uuml;ber<TT> WSR</TT>!
<P>
Bei indirekter Adressierung k&ouml;nnen Displacements wahlweise kurz
(8 Bit, -128 bis +127) oder lang (16 Bit) sein. Der Assembler
w&auml;hlt automatisch anhand des Displacements die
k&uuml;rzestm&ouml;gliche Kodierung. Es ist aber m&ouml;glich, durch
ein vorangestelltes Gr&ouml;&szlig;er-Zeichen (&gt;) eine
16-Bit-Kodierung des Displacements zu erzwingen. Gleiches gilt
f&uuml;r absolute Adressen im Bereich 0ff80h...0ffffh, die mit einem
kurzen Offset relativ zum "Nullregister" adressiert werden
k&ouml;nnen.
<P>

<H4>8086</H4>
<P>
Der 8086 kann Daten aus allen Segmenten in einem Befehl adressieren,
ben&ouml;tigt jedoch sog. ,,Segment-Pr&auml;fixe'', wenn ein anderes
Segmentregister als DS verwendet werden soll. Zus&auml;tzlich kann es
sein, da&szlig; das DS-Register auf ein anderes Segment verstellt
ist, um z.B. &uuml;ber l&auml;ngere Strecken nur Daten im Codesegment
zu adressieren. Da AS aber keine Sinnanalyse des Codes vornimmt,
mu&szlig; ihm &uuml;ber diesen Befehl mitgeteilt werden, auf welche
Segmente die Segmentregister momentan zeigen, z.B.
<PRE>

   ASSUME  CS:CODE, DS:DATA    .

</PRE>
Allen vier Segmenten des 8086 (SS,DS,CS,ES) k&ouml;nnen auf diese
Weise Annahmen zugewiesen werden. Dieser Befehl erzeugt jedoch<B>
keinen</B> Code, um die Werte auch wirklich in die Segmentregister zu
laden, dies mu&szlig; vom Programm getan werden.
<P>
Die Benutzung diese Befehls hat zum einen die Folge, da&szlig; AS bei
sporadischen Zugriffen ins Codesegment automatisch Pr&auml;fixe
voranstellen kann, andererseits da&szlig; man AS mitteilen kann,
da&szlig; das DS-Register verstellt wurde und man sich im folgenden
explizite<TT> CS:</TT>-Anweisungen sparen kann.
<P>
G&uuml;ltige Argumente hinter dem Doppelpunkt sind<TT> CODE,
DATA</TT> und<TT> NOTHING</TT>. Letzterer Wert dient dazu, AS
mitzuteilen, da&szlig; das Segmentregister keinen f&uuml;r AS
verwendbaren Wert enth&auml;lt. Vorinitialisiert sind folgende<TT>
ASSUME</TT>s :
<PRE>

  CS:CODE, DS:DATA, ES:NOTHING, SS:NOTHING

</PRE>
<P>

<H4>Z180</H4>
<P>
Der Z180 besitzt eine eingebaute MMU, die den ,,logischen
Adre&szlig;raum'' des CPU-Kerns von 64 KByte auf einen physischen
Adre&szlig;raum von 512 KByte &uuml;bersetzt. Das genaue Mapping wird
durch die drei Register<TT> CBAR</TT>,<TT> CBR</TT> und<TT> BBR</TT>
gesteuert. &Auml;hnlich wie beim 68HC11K4 nimmt AS automatische
Umrechnungen von physischen auf logische Adressen vor, und zwar
sowohl f&uuml;r absolute Adressen als auch Quelle und Ziel von
relativen Spr&uuml;ngen. Es ist ebenfalls m&ouml;glich, auf die
Mapping-Tabellen &uuml;ber die Funktionen<TT> phys2cpu()</TT> und<TT>
cpu2phys()</TT> zuzugreifen.
<P>

<H4>Z280</H4>
<P>
Beim Z280 kann man &uuml;ber das I-Bit im Trap Control Register
festlegen, ob I/O-Zugriffe im User-Modus erlaubt sein sollen oder
nicht. Teilt man AS &uuml;ber ein
<PRE>

   assume i:1

</PRE>
mit, dass sie verboten sind, dann wird eine entsprechende Warnung
ausgegeben, falls I/O-Befehle im User-Modus verwendet werden.
<P>
Des weiteren enth&auml;lt der Z280 eine MMU, um den logischen
64K-Adre&szlig;raum der CPU auf die physikalisch adressierbaren 16
MByte abzubilden. Ihre Funktion wird zum einen &uuml;ber das MMU
Master Control Register (<TT> MMUMCR</TT>) gesteuert, zum anderen
&uuml;ber 32 Page Descriptor Register ((<TT> UPD0...UPD15</TT>,<TT>
SPD0...SPD15</TT>). Die aktuellen Werte aller Register k&ouml;nnen AS
via<TT> ASSUME</TT>-Anweisungen mitgeteilt werden.
<P>
F&uuml;r die Berechnung des aktuellen Mappings werden die folgenden
Bits des<TT> MMUMCR</TT> beachtet:
<UL>
<LI> Bit 15 (UTE): MMU im User-Modus einschalten</LI>
<LI> Bit 14 (UPD): Programm/Data-Separation im User-Modus
    einschalten</LI>
<LI> Bit 11 (STE): MMU im System-Modus einschalten</LI>
<LI> Bit 10 (SPD): Programm/Data-Separation im System-Modus
    einschalten</LI>
</UL>
<P>
Die folgenden Bits von<TT> UPDn/SPDn</TT> werden beachtet:
<UL>
<LI> Bit 3 (V): Seite g&uuml;ltig/aktiv</LI>
<LI> Bit 15...4 bzw. 15...5: Seitenadresse, also Bits 23...12 bzw.
    23...13 der Startadresse im physischen Adressraum.</LI>
</UL>
<P>
Abh&auml;ngig von den Registerwerten kann die Adress&uuml;bersetzung
im System- und/oder User-Modus aktiv sein (STE und/oder UTE gesetzt),
oder &uuml;berhaupt nicht (sowohl STE als auch UTE nicht gesetzt).
Die aktuelle Einstellung von<TT> SUPMODE</TT> hat deshalb auch einen
Einflu&szlig; auf das aktuelle Mapping. Falls es eingeschaltet ist,
kann es f&uuml;r Code- und Datenzugriffe gleich oder unterschiedlich
sein (UPD/SPD nicht gesetzt oder gesetzt).
<P>

<H4>eZ80</H4>
<P>
Der eZ80 kann in zwei Modi operieren:
<UL>
<LI> Im Z80 Modus sind die Register BC, DE, HL, IX, IY und SP 16 bit
    breit, und nur die 64K-Speicherseite, die durch das
    MBASE-Register definiert ist, kann adressiert werden. Bei
    Befehlen, die eine absolute Adresse oder einen nicht-8-Bit Wert
    als Argument beinhalten, werden zwei Bytes geladen.</LI>
<LI> Im ADL Modus sind die Register BC, DE, HL, IX, IY und SP 24 Bit
    breit, und der komplette 16 MByte Adressraum kann angesprochen
    werden. Bei Befehlen, die eine absolute Adresse oder einen
    nicht-8-Bit Wert als Argument beinhalten, werden drei Bytes
    geladen.</LI>
</UL>
Da die Bin&auml;rkodierung und Adre&szlig;bereichspr&uuml;fung von
diesem Modus abh&auml;ngt, mu&szlig; der Assembler wissen, welcher
Modus gerade verwendet wird. Indem man<TT> ADL</TT> mittels<TT>
ASSUME</TT> entweder auf 0 oder 1 setzt, teilt man dem Assembler den
Default-Modus mit, d.h. den Modus ohne Verwendung expliziter Suffixe
an einem Befehl. Des weiteren kann dem Assembler der aktuelle Wert
von MBASE (0 bis 0ff hex) mitgeteilt werden. Die Default-Annahme
f&uuml;r beide Werte ist 0, &auml;hnlich den Werten nach einem
Hardware-Reset.
<P>

<H4>XA</H4>
<P>
Die XA-Familie besitzt einen Datenadre&szlig;raum von 16 Mbyte, ein
Proze&szlig; kann jedoch nur immer innerhalb einer 64K-Seite
adressieren, die durch das DS-Register vorgegeben wird. AS mu&szlig;
man den momentanen Wert dieses Registers vorgeben, damit er Zugriffe
auf absolute Adressen &uuml;berpr&uuml;fen kann.
<P>

<H4>29K</H4>
<P>
Die Prozessoren der 29K-Familie besitzen ein Register<TT> RBP</TT>,
mit dessen Hilfe B&auml;nke von 16 Registern vor der Benutzung im
User-Modus gesch&uuml;tzt werden k&ouml;nnen. Dazu kann man ein
entsprechendes Bit in diesem Register setzen. Mit<TT> ASSUME</TT>
kann man AS nun mitteilen, welchen Wert RBP gerade hat. Auf diese
Weise kann AS warnen, falls versucht wird, im User-Modus auf
gesch&uuml;tzte Register zuzugreifen.
<P>

<H4>80C166/167</H4>
<P>
Obwohl keines der Register im 80C166/167 breiter als 16 Bit ist,
besitzt dieser Prozessor 18/24 Adre&szlig;leitungen, kann also bis zu
256 Kbyte/16 Mbyte adressieren. Um diesen Widerspruch unter einen Hut
zu bekommen, verwendet er nicht die von Intel her bekannte (...und
ber&uuml;chtigte) Segmentierung oder hat unflexible
Bankregister...nein, er macht Paging! Dazu wird der ,,logische''
Adre&szlig;raum von 64 Kbyte in 4 Seiten zu 16 Kbyte eingeteilt, und
f&uuml;r jede Seite existiert ein Seitenregister (bezeichnet als<TT>
DPP0...DPP3</TT>), das bestimmt, welche der physikalischen 16/1024
Seiten dort eingeblendet wird. AS versucht nun, den Adre&szlig;raum
grunds&auml;tzlich mit 256 Kbyte/16 Mbyte aus der Sicht des
Programmierers zu verwalten, d.h. bei absoluten Zugriffen ermittelt
AS die physikalische Seite und schaut in der mit<TT> ASSUME</TT>
eingestellten Seitenverteilung nach, wie die Bits 14 und 15 der
logischen Adresse gesetzt werden m&uuml;ssen. Pa&szlig;t kein
Seitenregister, so wird eine Warnung ausgegeben.
Defaultm&auml;&szlig;ig nimmt AS an, da&szlig; die vier Register
linear die ersten 64 Kbyte abbilden, etwa in der folgenden Form:
<PRE>

        ASSUME  DPP0:0,DPP1:1,DPP2:2,DPP3:3

</PRE>
Der 80C167 kennt noch einige Befehle, die die Seitenregister in ihrer
Funktion &uuml;bersteuern k&ouml;nnen. Wie diese Befehle die
Adre&szlig;generierung beeinflussen, ist im Kapitel mit den
prozessorspezifischen Hinweisen beschrieben.
<P>
Einige Maschineninstruktionen kennen ein verk&uuml;rzte Kodierung,
wenn das Argument in einem bestimmten Wertebereich liegt:
<UL>
<LI> MOV Rn,#&lt;0..15&gt;</LI>
<LI> ADD/ADDC/SUB/SUBC/CMP/XOR/AND/OR Rn, #&lt;0..7&gt;</LI>
<LI> LOOP Rn,#&lt;0..15&gt;</LI>
</UL>
Der Assembler verwendet im Default automatisch die k&uuml;rzere
Kodierung wenn m&ouml;glich. Falls man die l&auml;ngere erzwingen
m&ouml;chte, schreibt man analog zum 65xx/68xx ein
Gr&ouml;&szlig;erzeichen vor den Operanden (hinter das Doppelkreuz!).
Umgekehrt kann man auch ein Kleinerzeichen schreiben, wenn man die
kurze Kodierung erzwingen will. Falls der Operand nicht im erlaubten
Wertebereich liegt, gibt es eine Fehlermeldung. Singem&auml;&szlig;
das gleiche gilt f&uuml;r Spr&uuml;nge, die mit kurzem Displacement
oder langem, absolutem Argument kodiert werden k&ouml;nnen.
<P>

<H4>TLCS-47</H4>
<P>
Der von der Architektur her vorgegebene Datenadre&szlig;raum dieser
Prozessoren (egal ob man direkt oder &uuml;ber das HL-Register
adressiert) betr&auml;gt lediglich 256 Nibbles. Da die ,,besseren''
Familienmitglieder aber bis zu 1024 Nibbles RAM on chip haben, war
Toshiba gezwungen, einen Bankingmechanismus &uuml;ber das
DMB-Register einzuf&uuml;hren. AS verwaltet das Datensegment als
einen durchgehenden Adre&szlig;raum und pr&uuml;ft bei jeder direkten
Adressierung, ob die Adresse in der momentan aktiven Bank liegt. Die
von AS momentan angenommene Bank kann mittels
<PRE>

        ASSUME  DMB:&lt;0..3&gt;

</PRE>
festgelegt werden. Der Default ist 0.
<P>

<H4>IPC-16/INS8900</H4>
<A NAME="ref_PACEAssume"></A>
<P>
Der Prozessor verf&uuml;gt &uuml;ber einen Eingangs-Pin namens<TT>
BPS</TT>, mit dem man w&auml;hlen kann, welcher Adre&szlig;bereich
direkt adressierbar sein soll: entweder die untersten 256 Worte des
Speichers, oder die jeweils obersten und untersten 128 Worte. Der
Default is ersteres, mit einem<TT> ASSUME BPS:1</TT> schaltet man auf
die zweite Variante um.
<P>

<H4>ST6</H4>
<A NAME="ref_ST6Assume"></A>
<P>
Die Mikrokontroller der ST6-Reihe sind in der Lage, einen Teil (64
Byte) des Codebereiches in den Datenbereich einzublenden, z.B. um
Konstanten aus dem ROM zu laden. Dies bedeutet aber auch, da&szlig;
zu einem Zeitpunkt immer nur ein Teil des ROMs adressiert werden
kann. Welcher Teil dies ist, wird durch ein bestimmtes Register
bestimmt. Dem Inhalt dieses Registers kann AS zwar nicht direkt
kontrollieren, man kann ihm aber mit diesem Befehl mitteilen, wenn
man dem Register einen neuen Wert zugewiesen hat. AS kann dann
pr&uuml;fen und ggfs. warnen, falls auf Adressen im Codesegment
zugegriffen wird, die nicht im ,,angek&uuml;ndigten'' Fenster liegt.
Hat die Variable<TT> VARI</TT> z.B. den Wert 456h, so setzt
<PRE>

        ASSUME  ROMBASE:VARI&gt;&gt;6

</PRE>
die AS-interne Variable auf 11h, und ein Zugriff auf<TT> VARI</TT>
erzeugt einen Zugriff auf die Adresse 56h im Datensegment.
<P>
Anstelle eines Symbols kann auch schlicht<TT> NOTHING</TT> angegeben
werden, z.B. wenn das Bank-Register tempor&auml;r als Speicherzelle
benutzt wird. Dieser Wert ist auch die Voreinstellung.
<P>
Der Programmz&auml;hler dieser Mikrokontroller ist lediglich 12 Bit
breit. Das bedeutet f&uuml;r Varianten mit mehr als 4 KByte
Programmspeicher, da&szlig; man sich eine Art von Banking einfallen
lassen mu&szlig;te. Dazu werden Adre&szlig;raum und Programmspeicher
in 2 KByte-Seite eingeteilt. Seite 1 des Adre&szlig;raumes greift
immer auf Seite 1 des Programmspeichers zu. &Uuml;ber das bei diesen
Varianten vorhandene<TT> PRPR</TT>-Register kann der Programmierer
bestimmen, welche Seite des Programmspeichers &uuml;ber die Adressen
000h bis 7ffh zugegriffen wird. AS betrachtet den Adre&szlig;raum in
erster N&auml;herung als linear und von der Gr&ouml;&szlig;e des
Programmspeichers. Erfolgt ein Sprung von Seite 1 aus auf eine
Adresse au&szlig;erhalb dieser Seite, wird gepr&uuml;ft, ob deren
Adresse mit dem aktuell angenommenen Wert des<TT> PRPR</TT>-Registers
identisch ist. Erfolgt ein Sprung von einer anderen Seite aus auf
eine Adresse au&szlig;erhalb Seite 1, wird gepr&uuml;ft, ob die
Zieladresse innerhalb der gleichen Seite liegt.<B> WICHTIG</B>: Da
der Programmz&auml;hler nur 12 Bit breit ist, ist es nicht
m&ouml;glich, ohne einen Umweg &uuml;ber Seite 1 von einer Seite in
eine andere zu springen - Mit einem Umsetzen des<TT>
PRPR</TT>-Registers au&szlig;erhalb von Seite 1 w&uuml;rde man sich
seinen eigenen Code unter den F&uuml;&szlig;en wegziehen.
<P>

<H4>ST9</H4>
<P>
Die ST9-Familie verwendet zur Adressierung von Code- und Datenbereich
exakt die gleichen Befehle. Welcher Adre&szlig;raum dabei jeweils
angesprochen wird, h&auml;ngt vom Stand des DP-Flags im Flag-Register
ab. Damit AS bei absoluten Zugriffen &uuml;berpr&uuml;fen kann, ob
man mit Symbolen aus dem korrekten Adre&szlig;raum arbeitet (das
funktioniert nat&uuml;rlich<EM> nur</EM> bei absoluten Zugriffen!),
mu&szlig; man ihm per<TT> ASSUME</TT> mitteilen, ob das DP-Flag
momentan auf 0 (Code) oder 1 (Daten) steht. Der Initialwert dieser
Annahme ist 0.
<P>

<H4>uPD78(C)1x</H4>
<P>
Diese Prozessoren besitzen ein Register (V), mit dessen Hilfe die
,,Zeropage'', d.h. die Lage der mit nur einem Byte adressierbaren
Speicherzellen sich in Seitengrenzen im Speicher frei verschieben
l&auml;&szlig;t. Da man aber aus Bequemlichkeitsgr&uuml;nden nicht
mit Ausdr&uuml;cken wie
<PRE>

        inrw    Lo(Zaehler)

</PRE>
arbeiten will, &uuml;bernimmt AS diese Arbeit, allerdings nur unter
der Voraussetzung, da&szlig; man ihm &uuml;ber einen<TT>
ASSUME</TT>-Befehl den Inhalt des V-Registers mitteilt. Wird ein
Befehl mit Kurzadressierung benutzt, so wird &uuml;berpr&uuml;ft, ob
die obere H&auml;lfte des Adre&szlig;ausdrucks mit dem angenommenen
Inhalt &uuml;bereinstimmt. Stimmt sie nicht, so erfolgt eine Warnung.
<P>

<H4>78K2</H4>
<P>
78K2 ist eine 8/16-Bit-Architektur, die nachtr&auml;glich durch
Banking auf einen (Daten-)Adre&szlig;raum von einem MByte erweitert
wurde. Das Banking wird mit den Registern PM6 (Normalfall) bzw. P6
(alternativer Fall mit vorangestelltem &amp;) realisiert, die die
fehlenden oberen vier Bits nachliefern. Zumindest bei absoluten
Adressen kann AS &uuml;berpr&uuml;fen, ob die gerade angesprochene,
lineare 20-bittige Adresse innerhalb des gegebenen 64K-Fensters
liegt.
<P>

<H4>78K3</H4>
<P>
Prozessoren mit 78K3-Kern besitzen Registerb&auml;nke mit insgesamt
16 Registern, die man &uuml;ber ihre Nummern ansprechen kann
(<TT>R0</TT> bis<TT> R15</TT>) oder ihre symbolischen Namen
(<TT>X=R0, A=R1, C=R2, B=R3, VPL=R8, VPH=R9, UPL=R10, UPH=R11, E=R12,
D=R13, L=R14, H=R15</TT>). Der Prozessorkern besitzt ein
Register-Auswahlbit (<TT>RSS</TT>), mit dem man das Mapping von A/X
und B/C von R0..R3 auf R4..R7 umschaltet. Dies ist in erste Linie
f&uuml;r Befehle wichtig, die implizit eines dieser Register benutzen
(d.h. bei denen die Registernummer nicht im Maschinenbefehl kodiert
ist). Man kann dem Assembler aber auch &uuml;ber ein
<P>
<PRE>

  assume rss:1

</PRE>
<P>
mitteilen, da&szlig; die folgenden Befehle mit diesem ge&auml;nderten
Mapping arbeiten. Der Assembler wird f&uuml;r Befehle, in denen die
Registernummer explizit kodiert ist, dann auch die alternativen
Registernummern einsetzen. Umgekehrt wird dann z.B. auch<TT> R5</TT>
statt<TT> R1</TT> im Quellcode wie<TT> A</TT> behandelt.
<P>

<H4>78K4</H4>
<P>
78K4 war als 'Upgrade-Pfad' vom 78K3 konzipiert, deshalb besitzt
dessen Prozessorkern auch ein RSS-Bit, mit dem man das Mapping der
Register AX und BC umschalten kann (auch wenn NEC von dessen
Verwendung in neuem Code abr&auml;t).
<P>
Neben vielen neuen Befehlen und Adressierungsarten ist die
wesentliche Erweiterung der gr&ouml;&szlig;ere Adre"raum von 16
MByte, von dem allerdings nur das erste MByte f&uuml;r Programmcode
genutzt werden kann. Das CPU-interne RAM sowie die Special Function
Register k&ouml;nnen wahlweise am oberen Ende des ersten MByte oder
der ersten 64 KByte Seite liegen. Dies teilt man dem Prozessor durch
den<TT> LOCATION</TT>-Befehl mit, der als Argument wahlweise eine 0
oder 15 akzeptiert. Parallel damit schaltet der Prozessor auch die
Adre&szlig;bereiche um, die mit kurzen (8-Bit) Adressen erreicht
werden k&ouml;nnen. Parallel dazu mu&szlig; man dem Assembler
mittels<TT> ASSUME LOCATION:..</TT> ebenfalls dieser Wert mitgeteilt
werden, damit er kurze Adressen in den dazu passenden Bereichen
erzeugt. Der Assembler nimmt f&uuml;r LOCATION einen Default von Null
an.
<P>

<H4>320C3x/C4x</H4>
<P>
Da alle Instruktionsworte dieser Prozessorfamilie nur 32 Bit lang
sind, und von diesen 32 Bit nur 16 Bit f&uuml;r absolute Adressen
vorgesehen wurden, m&uuml;ssen die fehlenden oberen 8/16 Bit aus dem
DP-Register erg&auml;nzt werden. Bei Adressierungen kann man aber
trotzdem die volle 24/32-Bit-Adresse angeben, AS pr&uuml;ft dann, ob
die oberen 8/16 Bit mit dem angenommenen Inhalt von DP
&uuml;bereinstimmen. Gegen&uuml;ber dem<TT> LDP</TT>-Befehl
weicht<TT> ASSUME</TT> darin ab, da&szlig; man hier nicht eine
beliebige Adresse aus der Speicherbank angeben kann, das Herausziehen
der oberen Bits mu&szlig; man also ,,zu Fu&szlig;'' machen, z.B. so:
<PRE>

        ldp     @adr
        assume  dp:adr&gt;&gt;16
        .
        .
        .
        ldi     @adr,r2

</PRE>
<P>

<H4>75K0</H4>
<P>
Da selbst mit Hilfe von Doppelregistern (8 Bit) nicht der komplette
Adre&szlig;raum von 12 Bit zu erreichen ist, mu&szlig;te NEC (wie
andere auch...) auf Banking zur&uuml;ck greifen: Die oberen 4
Adre&szlig;bits werden aus dem<TT> MBS</TT>-Register geholt (welchem
demzufolge mit<TT> ASSUME</TT> Werte zwischen 0 und 15 zugeordnet
werden k&ouml;nnen), das aber nur beachtet wird, falls das<TT>
MBE</TT>-Flag auf 1 gesetzt wurde. Steht es (wie die Vorgabe ist) auf
0, so kann man die obersten und untersten 128 Nibbles des
Adre&szlig;raumes ohne Bankumschaltung erreichen. Da der 75402
weder<TT> MBE</TT>-Flag noch<TT> MBS</TT>-Register kennt, ist
f&uuml;r ihn der<TT> ASSUME</TT>-Befehl nicht definiert; Die
Initialwerte von<TT> MBE</TT> und<TT> MBS</TT> lassen sich daher
nicht &auml;ndern.
<P>

<H4>F&sup2;MC16L</H4>
<P>
Wie viele andere Mikrokontroller auch, leidet diese Familie etwas
unter der Knauserei seiner Entwickler: einem 24 Bit breiten
Adre&szlig;raum stehen 16 Bit breite Adre&szlig;register etwas
unterbemittelt gegen&uuml;ber. Also mu&szlig;ten wieder mal
Bank-Register her. Im einzelnen sind dies PCB f&uuml;r den
Programmcode, DTB f&uuml;r alle Datenzugriffe, ADB f&uuml;r indirekte
Zugriffe &uuml;ber RW2/RW6 und SSB/USB f&uuml;r die Stacks. Sie
k&ouml;nnen alle Werte zwischen 0 und 255 annehmen.
Defaultm&auml;&szlig;ig stehen alle Annahmen von AS auf 0, mit
Ausnahme von 0ffh f&uuml;r PCB.
<P>
Des weiteren existiert das DPR-Register, das angibt, welche Seite
innerhalb der durch DTB gegebenen 64K-Bank mit 8-Bit-Adressen
erreicht werden kann. Der Default f&uuml;r DPR ist 1, zusammen mit
dem Default f&uuml;r DTB ergibt dies also eine Default-Seite bei
0001xxh.
<P>

<H4>MN1613</H4>
<P>
Beim MN1613 wurde eine Architektur mit 16-Bit-Adressen
nachtr&auml;glich erweitert, Dies wird durch einen Satz vier Bit
breiter ,,Segment-Register'' (CSBR, SSBR, TSR0 und TSR1) erreicht,
deren Wert (um 14 Bit nach links geschoben) zu den 16-Bit- Adressen
hinzu addiert wird. Ein Proze&szlig; kann auf diese Weise immer ein
64 KWorte gro&szlig;es Fenster im 256 KWorte gro&szlig;en
Adre&szlig;raum adressieren. Der Assembler benutzt die per<TT>
ASSUME</TT> mitgeteilten Werte, um zu warnen, wenn eine absolute
Adresse innerhalb des 256K-Adre&szlig;raums mit den aktuellen Werten
nicht adressierbar ist, und rechnet ansonsten den korrekten
16-bittigen Offset aus. Bei indirekter Adressierung ist so eine
Pr&uuml;fung (naturgem&auml;&szlig;) nicht m&ouml;glich.
<P>

<H4>IM61x0</H4>
<P>
Diese Mikroprozessoren implementieren den Befehlssatz einer PDP/8 und
unterst&uuml;tzen grunds&auml;tzlich einen Adre&szlig;raum von 4
Kiloworten. Durch Banking kann dieser auf acht ,,Felder'' von 4
Kiloworten erweitert werden. Adressierung von Daten und Spr&uuml;nge
sind prinzipiell nur im gleichen Feld m&ouml;glich, mit einer
Ausnahme: &uuml;ber das IB-Register sind Spr&uuml;nge in ein anderes
4K-Feld m&ouml;glich. Dieses gibt die oberen Bits der insgesamt 15
Bit langen Zieladresse vor, falls IB per<TT> ASSUME</TT> auf einen
Wert ungleich<TT> NOTHING</TT> gesetzt ist.
<P>

<H3><A NAME="sect_3_2_22_">3.2.22. CKPT</A></H3>
<A NAME="index_CKPT_1"></A>
<P>
<EM> G&uuml;ltigkeit: TI990/12</EM>
<P>
Typ 12-Instruktionen erfordern f&uuml;r ihre Ausf&uuml;hrung ein
sogenanntes<EM> Checkpoint Register</EM>. Dieses Register kann
entweder explizit als viertes Argument angegeben werden, oder es wird
mit dieser Anweisung ein Default f&uuml;r allen folgenden Code
festgelegt. Wenn weder eine<TT> CKPT</TT>-Anweisung noch ein
explizites Register angegeben wurde, wird eine Fehlermeldung
ausgegeben. Der Default von keinem Default-Register kann
wiederhergestellt werden, indem man die<TT> CKPT</TT>-Anweisung
mit<TT> NOTHING</TT> als Argument aufruft.
<P>

<H3><A NAME="sect_3_2_23_">3.2.23. EMULATED</A></H3>
<A NAME="index_EMULATED_1"></A>
<P>
<EM> G&uuml;ltigkeit: 29K</EM>
<P>
AMD hat die Ausnahmebehandlung f&uuml;r undefinierte Befehle bei der
29000-Serie so definiert, da&szlig; f&uuml;r jeden einzelnen Befehl
ein Exception-Vektor zur Verf&uuml;gung steht. Dies legt es nahe,
durch gezielte Software-Emulationen den Befehlssatz eines kleineren
Mitgliedes dieser Familie zu erweitern. Damit nun aber AS diese
zus&auml;tzlichen Befehle nicht als Fehler anmeckert, erlaubt es
der<TT> EMULATED</TT>-Befehl, AS mitzuteilen, da&szlig; bestimmte
Befehle doch erlaubt sind. Die Pr&uuml;fung, ob der momentan gesetzte
Prozessor diesen Befehl beherrscht, wird dann &uuml;bergangen. Hat
man z.B. f&uuml;r einen Prozessor ohne Gleitkommaeinheit ein Modul
geschrieben, das aber nur mit 32-Bit-IEEE-Zahlen umgehen kann, so
schreibt man
<PRE>

        EMULATED FADD,FSUB,FMUL,FDIV
        EMULATED FEQ,FGE,FGT,SQRT,CLASS

</PRE>
<P>
<TT> BRANCHEXT</TT> mit<TT> ON</TT> oder<TT> OFF</TT> als Argument
legt fest, ob AS kurze, nur mit einem 8-Bit-Displacement
verf&uuml;gbare Spr&uuml;nge automatisch ,,verl&auml;ngern'' soll,
indem z.B. aus einem einfachen
<PRE>

        bne     target

</PRE>
automatisch eine l&auml;ngere Sequenz mit gleicher Funktion wird,
falls das Sprungziel zu weit von momentanen Programmz&auml;hler
entfernt ist. F&uuml;r<TT> bne</TT> w&auml;re dies z.B. die Sequenz
<PRE>

        beq     skip
        jmp     target
skip:

</PRE>
Falls f&uuml;r eine Anweisung aber kein passendes ,,Gegenteil''
existiert, kann die Sequenz auch l&auml;nger werden, z.B.
f&uuml;r<TT> jbc</TT>:
<PRE>

        jbc     dobr
        bra     skip
dobr:   jmp     target
skip:

</PRE>
Durch dieses Feature gibt es bei Spr&uuml;ngen keine eineindeutige
Zuordnung von Maschinen- und Assemblercode mehr, und bei
Vorw&auml;rtsreferenzen handelt man sich m&ouml;glicherweise
zus&auml;tzliche Passes ein. Man sollte dieses Feature daher mit
Vorsicht einsetzen!
<P>

<H3><A NAME="sect_3_2_24_">3.2.24. Z80SYNTAX</A></H3>
<A NAME="index_Z80SYNTAX_1"></A>
<P>
<EM> G&uuml;ltigkeit: 8008, 8080/8085, &micro;PD78xx</EM>
<P>
Mit<TT> ON</TT> als Argument kann man Assmebler-Befehle wahlweise
auch in der Form schreiben, wie sie Zilog f&uuml;r den Z80 definiert
hat. Zum Beispiel benutzt man einfach nur noch<TT> LD</TT> mit sich
selbst erkl&auml;renden Operanden, wo man in der originalen Syntax
(bzw. neueren 8008-Syntax) je nach Operanden<TT> MVI, LXI, MOV, STA,
LDA, SHLD, LHLD, LDAX, STAX</TT> oder<TT> SPHL</TT> schreiben
mu&szlig;.
<P>
Weil einige Mnemonics in der originalen und Z80-Syntax
unterschiedliche Bedeutung haben, kann man nicht zu 100% im
'Z80-Stil' programmieren. Alternativ schaltet man f&uuml;r 8080/8085
mit einem<TT> EXCLUSIVE</TT> als Argument die originale Syntax ganz
ab. Details zu dieser Betriebsart kann man im Abschnitt <A
HREF="#ref_8080Spec">4.22</A> nachlesen.
<P>
Ein eingebautes Symbol mit gleichem Namen gestattet es, die aktuelle
Betriebsart auszulesen. Es gilt<TT> 0=OFF</TT>,<TT> 1=ON</TT> und<TT>
2=EXCLUSIVE</TT>.
<P>

<H3><A NAME="sect_3_2_25_">3.2.25. EXPECT und ENDEXPECT</A></H3>
<A NAME="index_EXPECT_1"></A><A NAME="index_ENDEXPECT_1"></A>
<P>
Mit diesen beiden Befehlen rahmt man ein St&uuml;ck Quellcode ein, in
dem ein oder mehrere Fehler<EM> erwartet</EM> werden. Treten die
&uuml;ber ihre Nummern (siehe Kapitel <A
HREF="#ref_ChapErrMess">A</A>) identifizierten Fehler oder Warnungen
auf, werden sie unterdr&uuml;ckt, und die Assemblierung l&auml;uft
ohne Fehler durch - nat&uuml;rlich ohne an dieser Stelle Code zu
erzeugen. Erwartete, aber nicht aufgetretene Fehler oder Warnungen
l&ouml;sen ihrerseits jedoch eine Fehlermeldung von<TT>
ENDEXPECT</TT> aus. Der Haupt-Anwendungszweck dieser Befehle findet
sich in den Selbst-Tests im tests/-Unterverzeichnis. Z.B. kann man so
testen, ob Wertebereiche korrekt gepr&uuml;ft werden:
<PRE>

       cpu      68000
       expect   1320     ; immediate-Shift nur 1..8
       lsl.l    #10,d0
       endexpect

</PRE>
<P>

<H2><A NAME="sect_3_3_">3.3. Datendefinitionen</A></H2>
<P>
Die hier beschriebenen Befehle &uuml;berschneiden sich teilweise in
ihrer Funktionalit&auml;t, jedoch definiert jede Prozessorfamilie
andere Namen f&uuml;r die gleiche Funktion. Um mit den
Standardassemblern konform zu bleiben, wurde diese Form der
Implementierung gew&auml;hlt.
<P>
Sofern nicht ausdr&uuml;cklich anders erw&auml;hnt, kann bei allen
Befehlen zur Datenablage (nicht bei denen zur Speicherreservierung!)
eine beliebige Zahl von Parametern angegeben werden, die der Reihe
nach abgearbeitet werden.
<P>

<H3><A NAME="sect_3_3_1_">3.3.1. DC[.size]</A></H3>
<A NAME="index_DC_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0, M*Core, 68xx, H8, SH7x00, DSP56xxx,<BR>
XA, ST7/STM8, MN161x, IM61x0, CP-3F, SC61860</EM>
<P>
Dieser Befehl legt eine oder mehrere Konstanten des beim durch das
Attribut bestimmten Typs im Speicher ab. Die Attribute entsprechen
den in Abschnitt <A HREF="#ref_AttrTypes">2.5</A> definierten,
zus&auml;tzlich ist f&uuml;r Byte-Konstanten die M&ouml;glichkeit
vorhanden, Stringausdr&uuml;cke im Speicher abzulegen, wie z.B.
<PRE>

String  dc.b    "Hello world!\0"

</PRE>
Die Parameterzahl darf zwischen 1 und 20 liegen, zus&auml;tzlich darf
jedem Parameter ein in eckigen Klammern eingeschlossener
Wiederholungsfaktor vorausgehen, z.B. kann man mit
<PRE>

        dc.b    [(*+255)&$ffffff00-*]0

</PRE>
den Bereich bis zur n&auml;chsten Seitengrenze mit Nullen
f&uuml;llen.<B> Vorsicht!</B> Mit dieser Funktion kann man sehr
leicht die Grenze von 1 Kbyte erzeugten Codes pro Zeile Quellcode
&uuml;berschreiten!
<P>
Sollte die Byte-Summe ungerade sein, so kann vom Assembler
automatisch ein weiteres Byte angef&uuml;gt werden, um die
Wortausrichtung von Daten zu erhalten. Dieses Verhalten kann mit
dem<TT> PADDING</TT>-Befehl ein- und ausgeschaltet werden.
<P>
Mit diesem Befehl abgelegte Dezimalgleitkommazahlen (<TT>DC.P</TT>
...) k&ouml;nnen zwar den ganzen Bereich der extended precision
&uuml;berstreichen, zu beachten ist dabei allerdings, da&szlig; die
von Motorola verf&uuml;gbaren Koprozessoren 68881/68882 beim Einlesen
solcher Konstanten die Tausenderstelle des Exponenten ignorieren!
<P>
Default-Attribut ist<TT> W</TT>, also 16-Bit-Integerzahlen.
<P>
Beim DSP56xxx ist der Datentyp auf Integerzahlen festgelegt (ein
Attribut ist deshalb weder n&ouml;tig noch erlaubt), die im Bereich
-8M..16M-1 liegen d&uuml;rfen. Stringkonstanten sind ebenfalls
erlaubt, wobei jeweils drei Zeichen in ein Wort gepackt werden.
<P>
Es ist im Gegensatz zum Original Motorola-Assembler auch erlaubt, mit
diesem Kommando Speicher zu reservieren, indem man als Argument ein
Fragezeichen angibt. Diese Erweiterung haben wohl einige
Drittanbieter von 68K-Assemblern eingebaut, in Anlehnung an das, was
Intel-Assembler machen. Wer dies benutzt, sollte sich aber im klaren
sein, da&szlig; dies zu Problemen beim Portieren von Code auf andere
Assembler f&uuml;hren kann. Des weiteren d&uuml;rfen Fragezeichen als
Operanden nicht mit 'normalen' Konstanten in einer Anweisung gemischt
werden.
<P>

<H3><A NAME="sect_3_3_2_">3.3.2. DS[.size]</A></H3>
<A NAME="index_DS_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0, M*Core, 68xx, H8, SH7x00, DSP56xxx,<BR>
XA, ST7/STM8, MN161x, IM61x0, CP-3F, PPS-4, SC61860</EM>
<P>
Mit diesem Befehl l&auml;&szlig;t sich zum einen Speicherplatz
f&uuml;r die angegebene Zahl im Attribut beschriebener Zahlen
reservieren. So reserviert
<PRE>

        DS.B    20

</PRE>
z.B. 20 Bytes Speicher,
<PRE>

        DS.X    20

</PRE>
aber 240 Byte !
<P>
Die andere Bedeutung ist die Ausrichtung des Programmz&auml;hlers,
die mit der Wertangabe 0 erreicht wird. So wird mit
<PRE>

        DS.W    0

</PRE>
der Programmz&auml;hler auf die n&auml;chste gerade Adresse
aufgerundet, mit
<PRE>

        DS.D    0

</PRE>
dagegen auf die n&auml;chste Langwortgrenze. Eventuell dabei
freibleibende Speicherzellen sind nicht etwa mit Nullen oder NOPs
gef&uuml;llt, sondern undefiniert.
<P>
Vorgabe f&uuml;r die Operandengr&ouml;&szlig;e ist --- wie
&uuml;blich --- W, also 16 Bit.
<P>
Beim 56xxx ist die Operandengr&ouml;&szlig;e auf Worte (a 24 Bit)
festgelegt, Attribute gibt es deswegen wie bei<TT> DC</TT> auch hier
nicht.
<P>

<H3><A NAME="sect_3_3_3_">3.3.3. BLKB, BLKW, BLKL, BLKD</A></H3>
<A NAME="index_BLKB_1"></A><A NAME="index_BLKW_1"></A><A
NAME="index_BLKL_1"></A><A NAME="index_BLKD_1"></A>
<P>
<EM> G&uuml;ltigkeit: Renesas RX</EM>
<P>
Mit diesen Befehlen wird auf dem Renesas RX Speicher reserviert. Die
Gesamtgr&ouml;&szlig;e des reservierten Speicher resultiert aus dem
Produkt des Arguments und der durch den Befehl gegebenen
Operandengr&ouml;&szlig;e (1 Byte f&uuml;r<TT> BLKB</TT>, 2 Byte
f&uuml;r<TT> BLKW</TT>, 4 Byte f&uuml;r<TT> BLKL</TT> und 8 Byte
f&uuml;r<TT> BLKD</TT>).
<P>

<H3><A NAME="sect_3_3_4_">3.3.4. DN,DB,DW,DD,DQ,DT &amp; DO</A></H3>
<A NAME="index_DN_1"></A><A NAME="index_DB_1"></A><A
NAME="index_DW_1"></A><A NAME="index_DD_1"></A><A
NAME="index_DQ_1"></A><A NAME="index_DT_1"></A><A
NAME="index_DO_1"></A>
<P>
<EM>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><EM> G&uuml;ltigkeit:</EM></TD><TD NOWRAP><EM> Intel (au&szlig;er 4004/4040), Zilog, Toshiba, NEC, TMS370,</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> Siemens, AMD, M16(C), MELPS7700/65816, National, ST9,</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> Atmel, TMS7000, TMS1000, &micro;PD77230, Signetics,</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> Fairchild, Intersil,</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> XS1, SC62015</EM></TD></TR>
</TABLE></EM>
<P>
Diese Befehle stellen sozusagen das Intel-Gegenst&uuml;ck zu<TT>
DS</TT> und<TT> DC</TT> dar, und wie nicht anders zu erwarten, ist
die Logik etwas anders:
<P>
Zum einen wird die Kennung der Operandengr&ouml;&szlig;e in das
Mnemonic verlegt:
<UL>
<LI> <TT>DN</TT>: 4-Bit-Integer</LI>
<LI> <TT>DB</TT>: Byte oder ASCII-String wie bei<TT> DC.B</TT></LI>
<LI> <TT>DW</TT>: 16-Bit-Integer oder Gleitkomma mit halber
    Genauigkeit</LI>
<LI> <TT>DD</TT>: 32-Bit-Integer oder Gleitkomma mit einfacher
    Genauigkeit</LI>
<LI> <TT>DQ</TT>: 64-Bit-Integer oder Gleitkomma mit doppelter
    Genauigkeit</LI>
<LI> <TT>DT</TT>: Gepackter BCD Integer oder Gleitkomma mit erweiterter
    Genauigkeit (80 Bit)</LI>
<LI> <TT>DO</TT>: Gleitkomma mit vierfacher Genauigkeit (128 Bit)</LI>
</UL>
Zum anderen erfolgt die Unterscheidung, ob Konstantendefinition oder
Speicherreservierung, im Operanden. Eine Reservierung von Speicher
wird durch ein<TT> ?</TT> gekennzeichnet:
<PRE>

        db  ?   ; reserviert ein Byte
        dw  ?,? ; reserviert Speicher fuer 2 Worte (=4 Byte)
        dd  -1  ; legt die Konstante -1 (FFFFFFFFH) ab !

</PRE>
Speicherreservierung und Konstantendefinition d&uuml;rfen<B> nicht in
einer Anweisung</B> gemischt werden:
<PRE>

        db  "Hallo",?  ; --&gt;Fehlermeldung

</PRE>
<A NAME="index_DUP_1"></A> Zus&auml;tzlich ist noch der<TT>
DUP</TT>-Operator erlaubt, der die mehrfache Ablage von
Konstantenfolgen oder die Reservierung ganzer Speicherbl&ouml;cke
erlaubt:
<PRE>

        db  3 dup (1,2) ; --&gt; 1 2 1 2 1 2
        dw  20 dup (?)  ; reserviert 40 Byte Speicher.

</PRE>
Wie man sehen kann, mu&szlig; das<TT> DUP</TT>-Argument geklammert
werden, darf daf&uuml;r aber auch wieder aus mehreren Teilen
bestehen, die selber auch wieder<TT> DUP</TT>s sein k&ouml;nnen...das
ganze funktioniert also rekursiv.
<P>
<TT> DUP</TT> ist aber auch eine Stelle, an der man mit einer anderen
Grenze des Assemblers in Ber&uuml;hrung kommen kann: maximal
k&ouml;nnen 1024 Byte Code oder Daten in einer Zeile erzeugt werden.
Dies bezieht sich<B> nicht</B> auf die Reservierung von Speicher, nur
auf die Definition von Konstantenfeldern!
<P>
Der<TT> DUP</TT>-Operator wird nur erkannt, wenn er selber geklammert
ist und links von ihm ein nicht-leeres Argument steht; auf diese
Weise ist es m&ouml;glich ein eventuell definiertes Symbol gleichen
Namens auch als Argument zu verwenden.
<P>
<TT> DB</TT> und<TT> DW</TT> auf 65xx- und 68xx-Plattformen verstehen
neben dem<TT> DUP</TT>-Operator zus&auml;tzlich die
'Motorola-Variante' davon, n&auml;mlich eine in eckigen Klammern
davor geschriebene Zahl von Wiederholungen.
<P>
Auf verschiedenen Plattformen existieren Befehle mit identischer
Funktionalit&auml;t, jedoch anderem Namen:
<UL>
    <A NAME="index_DEFB_1"></A><A NAME="index_DEFW_1"></A>
<LI> Um mit dem M80 vertr&auml;glich zu sein, darf im Z80-Modus anstelle
    von<TT> DB</TT>/<TT>DW</TT> auch<TT> DEFB</TT>/<TT>DEFW</TT>
    geschrieben werden.<A NAME="index_BYTE_1"></A><A
    NAME="index_WORD_1"></A><A NAME="index_ADDR_1"></A><A
    NAME="index_ADDRW_1"></A></LI>
<LI> <TT>BYTE/ADDR</TT> bzw.<TT> WORD/ADDRW</TT> beim COP4/8 stellen
    einen Alias f&uuml;r<TT> DB</TT> bzw.<TT> DW</TT> dar, wobei die
    beiden Paare sich jedoch in der Byte-Order unterscheiden: Die
    Befehle, die von National zur Adre&szlig;ablage vorgesehen waren,
    benutzen Big-Endian,<TT> BYTE</TT> bzw.<TT> WORD</TT> jedoch
    Little-Endian.<A NAME="index_BYTE_2"></A><A
    NAME="index_WORD_2"></A></LI>
<LI> <TT>BYTE</TT> bzw.<TT> WORD</TT> funktionieren auf der PDP-11, VAX
    und WD16 wie<TT> DB</TT> bzw.<TT> DW</TT>, akzeptieren aber nur
    Ganzzahl-Argumente.</LI>
<LI> <TT>LWORD</TT> bzw.<TT> QUAD</TT> funktionieren auf der VAX wie<TT>
    DD</TT> bzw.<TT> DQ</TT>, akzeptieren aber nur
    Ganzzahl-Argumente.<A NAME="index_BYTE_3"></A><A
    NAME="index_WORD_3"></A><A NAME="index_LWORD_1"></A><A
    NAME="index_QUAD_1"></A><A NAME="index_FLOAT_1"></A><A
    NAME="index_DOUBLE_1"></A></LI>
<LI> Auf dem Renesas RX existieren:
<UL>
<LI>     <TT>BYTE</TT> (wie<TT> DB</TT>)</LI>
<LI>     <TT>WORD</TT> (wie<TT> DW</TT>, nur Ganzzahl-Argumente)</LI>
<LI>     <TT>LWORD</TT> (wie<TT> DD</TT>, nur Ganzzahl-Argumente)</LI>
<LI>     <TT>FLOAT</TT> (wie<TT> DD</TT>, nur Gleitkomma-Argumente)</LI>
<LI>     <TT>DOUBLE</TT> (wie<TT> DQ</TT>, nur Gleitkomma-Argumente)</LI>
</UL>
 </LI>
</UL>
<P>
Wird<TT> DB</TT> in einem Adre&szlig;raum angewendet, der nicht
byte-adressierbar ist (z.B. das<TT> CODE</TT>-Segment des Atmel AVR),
so werden immer zwei Bytes in ein 16-Bit-Wort gepackt, entsprechend
der durch die Architektur gegebenen Endinaness - das untere Byte wird
bei Little-Endian also zuerst gef&uuml;llt. Ist die Gesamtmenge aller
Bytes ungerade, so bleibt die andere Worth&auml;lfte ungenutzt und
ist quasi ''Padding''. Sie wird auch nicht genutzt, falls im
Quellcode eine weitere<TT> DB</TT>-Anweisung unmittelbar folge
sollte. Sinngem&auml;&szlig; gilt das gleiche f&uuml;r<TT> DN</TT>,
nur werden hier zwei oder vier Nibbles in ein Byte oder 16-Bit-Wort
gepackt.
<P>
Der NEC 77230 nimmt mit seiner<TT> DW</TT>-Anweisung eine
Sonderstellung ein: Sie funktioniert eher wie<TT> DATA</TT> bei
seinen kleineren Br&uuml;dern, akzeptiert aber neben String- und
Integerargumenten auch Gleitkommawerte (und legt sie
prozessorspezifischen 32-Bit-Format ab).<TT> DUP</TT> gibt es<EM>
nicht</EM>!
<P>
Bei der Ablage von Gleitkommazahlen ist zu beachten, da&szlig; diese
keine h&ouml;here Genauigkeit und Wertebereich haben k&ouml;nnen als
das auf dem Host-System verwendete Format. Handelt es sich dabei z.B.
um das '&uuml;bliche' IEEE 754 64-Bit-Format, so ist der Wertebereich
auf ca. +/-1.8*10<SUP>308</SUP> beschr&auml;nkt (siehe Variable<TT>
FLOATMAX</TT>), und die untersten zwei bzw. acht Bytes bei<TT>
DT</TT> bzw.<TT> DO</TT> sind Null.
<P>

<H3><A NAME="sect_3_3_5_">3.3.5. FLT2, FLT3, FLT4</A></H3>
<A NAME="index_FLT2_1"></A><A NAME="index_FLT3_1"></A><A
NAME="index_FLT4_1"></A>
<P>
<EM>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><EM> G&uuml;ltigkeit:</EM></TD><TD NOWRAP><EM> PDP-11 (<TT>FLT2, FLT4</TT>),</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> WD16 (<TT>FLT3</TT>)</EM></TD></TR>
</TABLE></EM>
<P>
<TT> FLT2</TT> und<TT> FLT4</TT> funktionieren analog zu<TT> DD</TT>
bzw.<TT> DQ</TT>, legen jedoch ausschlie&szlig;lich
Gleitkomma-Konstanten im DEC-eigenen F- bzw. D-Format ab. Der WD16
verwendet hingegen ein eigenes, 48 Bit (drei Maschinenworte) langes
Format. Gleitkomma-Konstanten in diesem Format k&ouml;nnen mit
der<TT> FLT3</TT>-Anweisung im Speicher abgelegt werden.
<P>

<H3><A NAME="sect_3_3_6_">3.3.6. x_FLOATING</A></H3>
<A NAME="index_F\_FLOATING_1"></A><A NAME="index_FLOAT_2"></A><A
NAME="index_D\_FLOATING_1"></A><A NAME="index_DOUBLE_2"></A><A
NAME="index_G\_FLOATING_1"></A><A NAME="index_H\_FLOATING_1"></A>
<P>
<EM> G&uuml;ltigkeit: VAX</EM>
<P>
Mit diesen Befehlen werden auf der VAX Gleitkomma-Konstanten in den
DEC-eigenen Formaten im Speicher abgelegt, wobei<TT> x</TT> f&uuml;r
die vier unterst&uuml;tzten Formate (F, D, G und H) steht.<TT>
FLOAT</TT> ist ein Alias f&uuml;r<TT> F_FLOATING</TT>,<TT>
DOUBLE</TT> einer f&uuml;r<TT> D_FLOATING</TT>. Die Befehle
funktionieren ansonsten wie<TT> DD</TT> und<TT> DQ</TT>.
<P>

<H3><A NAME="sect_3_3_7_">3.3.7. DS, DS8</A></H3>
<A NAME="index_DS_2"></A><A NAME="index_DS8_1"></A>
<P>
<EM>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><EM> G&uuml;ltigkeit:</EM></TD><TD NOWRAP><EM> Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD, M16(C),</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> National, ST9, TMS7000, TMS1000, Intersil, 6502, 68xx</EM></TD></TR>
</TABLE></EM>
<P>
Dieser Befehl stellt eine Kurzschreibweise dar, um Speicherbereiche
zu reservieren:
<BLOCKQUOTE>
    <TT> DS &lt;Anzahl&gt;</TT>
</BLOCKQUOTE>
ist eine Kurzschreibweise f&uuml;r
<BLOCKQUOTE>
    <TT> DB &lt;Anzahl&gt; DUP (?)</TT>
</BLOCKQUOTE>
dar, lie&szlig;e sich also prinzipiell auch einfach &uuml;ber ein
Makro realisieren, nur scheint dieser Befehl in den K&ouml;pfen
einiger mit Motorola-CPUs gro&szlig; gewordener Leute (gell,
Michael?) so fest verdrahtet zu sein, da&szlig; sie ihn als
eingebauten Befehl erwarten...hoffentlich sind selbige jetzt
zufrieden<TT> ;-)</TT>
<P>
<TT> DS8</TT> ist beim National SC14xxx als Alias f&uuml;r<TT>
DS</TT> definiert. Achten Sie aber darauf, da&szlig; der Speicher
dieser Prozessoren in Worten zu 16 Bit organisiert ist, d.h. es ist
unm&ouml;glich, einzelne Bytes zu reservieren. Falls das Argument
von<TT> DS</TT> ungerade ist, wird es auf die
n&auml;chstgr&ouml;&szlig;ere gerade Zahl aufgerundet.
<P>

<H3><A NAME="sect_3_3_8_">3.3.8. BLKx</A></H3>
<A NAME="index_BLKB_2"></A><A NAME="index_BLKW_2"></A><A
NAME="index_BLKL_2"></A><A NAME="index_BLKQ_1"></A><A
NAME="index_BLKO_1"></A><A NAME="index_BLKF_1"></A><A
NAME="index_BLKD_2"></A><A NAME="index_BLKG_1"></A><A
NAME="index_BLKH_1"></A>
<P>
<EM> G&uuml;ltigkeit: VAX</EM>
<P>
Diese Befehle reservieren Speicher f&uuml;r die angegebene Menge von
Datenelementen, deren Typ im letzten Zeichen des Befehls kodiert ist.
Dementsprechend ist der insgeamt reservierte Bereich in Bytes bei<TT>
BLKB</TT> gleich der Anzahl der Elemente, bei<TT> BLKW</TT> das
doppelte, und bei<TT> BLKO</TT> und<TT> BLKH</TT> das sechzehnfache.
<P>

<H3><A NAME="sect_3_3_9_">3.3.9. BYT oder FCB</A></H3>
<A NAME="index_BYT_1"></A><A NAME="index_FCB_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, 68xx, SC61860</EM>
<P>
Mit diesem Befehl werden im 65xx/68xx-Modus Byte-Konstanten oder
ASCII-Strings abgelegt, er entspricht also<TT> DC.B</TT> beim 68000
oder bei Intel dem<TT> DB</TT> (was ebenfalls erlaubt ist). Ein
Wiederholungsfaktor darf analog zu<TT> DC</TT> jedem einzelnen
Parameter in eckigen Klammern vorangestellt werden.
<P>

<H3><A NAME="sect_3_3_10_">3.3.10. BYTE</A></H3>
<A NAME="index_BYTE_4"></A>
<P>
<EM> G&uuml;ltigkeit: ST6, 320C2(0)x, 320C5x, MSP, TMS9900,
CP-1600</EM>
<P>
Dito. Ein im 320C2(0)x/5x-Modus vor dem Befehl stehendes Label wird
als untypisiert gespeichert, d.h. keinem Adre&szlig;raum zugeordnet.
Der Sinn dieses Verhaltens wird bei den prozessorspezifischen
Hinweisen erl&auml;utert.
<P>
Ob beim MSP bzw. TMS9900 ungerade Mengen von Bytes automatisch um ein
Null-Byte erg&auml;nzt werden sollen, kann mit dem PADDING-Befehl
eingestellt werden.
<P>
Auf dem CP-1600 weicht die Verhaltensweise von<TT> BYTE</TT> etwas
ab: die angegebenen 16-Bit-Werte werden in jeweils zwei
aufeinanderfolgenden W&ouml;rtern aufgeteilt abgelegt (LSB zuerst).
Wenn einzelne Bytes (gepackt) abgelegt werden sollen, mu&szlig;
stattdessen<TT> TEXT</TT> verwendet werden!
<P>

<H3><A NAME="sect_3_3_11_">3.3.11. DC8</A></H3>
<A NAME="index_DC8_1"></A>
<P>
<EM> G&uuml;ltigkeit: SC144xx</EM>
<P>
Dieser Befehl ist ein Alias f&uuml;r<TT> DB</TT>, d.h. mit ihm
k&ouml;nnen Byte-Konstanten oder Strings im Speicher abgelegt werden.
<P>

<H3><A NAME="sect_3_3_12_">3.3.12. ADR oder FDB</A></H3>
<A NAME="index_ADR_1"></A><A NAME="index_FDB_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, 68xx, SC61860</EM>
<P>
Mit diesem Befehl werden im 65xx/68xx-Modus Wortkonstanten abgelegt,
er entspricht also<TT> DC.W</TT> beim 68000 oder bei Intel dem<TT>
DW</TT> (was auch zul&auml;ssig ist). Ein Wiederholungsfaktor darf
analog zu<TT> DC</TT> jedem einzelnen Parameter in eckigen Klammern
vorangestellt werden.
<P>

<H3><A NAME="sect_3_3_13_">3.3.13. DDB</A></H3>
<A NAME="index_DDB_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, MELPS-7700</EM>
<P>
Dieser Befehl funktioniert analog zu<TT> ADR</TT>, nur mit dem
Unterschied, da&szlig; die 16-BitWerte im Big-Endian-Format im
Speicher abgelegt werden.
<P>

<H3><A NAME="sect_3_3_14_">3.3.14. DCM</A></H3>
<A NAME="index_DCM_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502</EM>
<P>
Mit diesem Befehl werden Gleitkomma-Konstanten im Speicher abgelegt,
und zwar in dem in <A HREF="#cite_AppleFloat">[3]</A> beschriebenen
Format: Ein Exponent von 8 Bit und eine 24-bittige Mantisse im
Zweierkomplement, im Big-Endian-Format abgelegt.
<P>

<H3><A NAME="sect_3_3_15_">3.3.15. WORD</A></H3>
<A NAME="index_WORD_4"></A>
<P>
<EM> G&uuml;ltigkeit: ST6, i960, 320C2(0)x, 320C3x/C4x/C5x, MSP,
CP-1600,<BR>
IMP-16, IPC-16</EM>
<P>
F&uuml;r den 320C3x/C4x und i960 werden hiermit 32-Bit-Worte
abgelegt, f&uuml;r die alle anderen Familien 16-Bit-Worte. Ein im
320C2(0)x/5x-Modus vor dem Befehl stehendes Label wird als
untypisiert gespeichert, d.h. keinem Adre&szlig;raum zugeordnet. Der
Sinn dieses Verhaltens wird bei den prozessorspezifischen Hinweisen
erl&auml;utert.
<P>

<H3><A NAME="sect_3_3_16_">3.3.16. DW16</A></H3>
<A NAME="index_DW16_1"></A>
<P>
<EM> G&uuml;ltigkeit: SC144xx</EM>
<P>
Dieser Befehl ist beim SC144xx der Weg, Konstanten mit Wortl&auml;nge
(16 Bit) im Speicher abzulegen und damit ein ALIAS f&uuml;r DW.
<P>

<H3><A NAME="sect_3_3_17_">3.3.17. ACON</A></H3>
<A NAME="index_ACON_1"></A>
<P>
<EM> G&uuml;ltigkeit: 2650</EM>
<P>
<TT> ACON</TT> arbeitet analog zu<TT> DW</TT>, jedoch werden die
16-Bit-Zahlenwerte im Big-Endian-Format abgelegt.
<P>

<H3><A NAME="sect_3_3_18_">3.3.18. LONG</A></H3>
<A NAME="index_LONG_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Hiermit werden 32-Bit-Integer im Speicher abgelegt, und zwar in der
Reihenfolge LoWord-HiWord. Ein eventuell vor dem Befehl stehendes
Label wird dabei wieder als untypisiert abgelegt (der Sinn dieser
Ma&szlig;nahme ist in den prozessorspezifischen Hinweisen
erl&auml;utert).
<P>

<H3><A NAME="sect_3_3_19_">3.3.19. SINGLE, DOUBLE und EXTENDED</A></H3>
<A NAME="index_SINGLE_1"></A><A NAME="index_DOUBLE_3"></A><A
NAME="index_EXTENDED_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C3x/C4x (nicht<TT> DOUBLE</TT>), 320C6x
(nicht<TT> EXTENDED</TT>)</EM>
<P>
Mit diesen Befehlen werden Gleitkomma-Konstanten im Speicher
abgelegt, jedoch beim 320C3x/C4x nicht im IEEE-Format, sondern in den
vom Prozessor verwendeten 32- und 40-Bit-Formaten. Da 40 Bit nicht
mehr in eine Speicherzelle hineinpassen, werden im Falle von<TT>
EXTENDED</TT> immer derer 2 pro Wert belegt. Im ersten Wort finden
sich die oberen 8 Bit (der Exponent), der Rest (Vorzeichen und
Mantisse) in zweiten Wort.
<P>

<H3><A NAME="sect_3_3_20_">3.3.20. FLOAT und DOUBLE</A></H3>
<A NAME="index_FLOAT_3"></A><A NAME="index_DOUBLE_4"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Mit diesen Befehlen k&ouml;nnen 32- bzw. 64-Bit-Gleitkommazahlen im
IEEE-Format im Speicher abgelegt werden. Dabei wird das
niederwertigste Byte jeweils auf der ersten Speicherstelle abgelegt.
Ein eventuell vor dem Befehl stehendes Label wird wieder als
untypisiert gespeichert (der Sinn dieser Ma&szlig;nahme ist in den
prozessorspezifischen Hinweisen erl&auml;utert).
<P>

<H3><A NAME="sect_3_3_21_">3.3.21. SINGLE und DOUBLE</A></H3>
<A NAME="index_SINGLE_2"></A><A NAME="index_DOUBLE_5"></A>
<P>
<EM> G&uuml;ltigkeit: TMS99xxx</EM>
<P>
Mit diesen Befehlen k&ouml;nnen 32- bzw. 64-Bit-Gleitkommazahlen im
prozessoreigenen Format im Speicher abgelegt werden. Das Format
entspricht dem IBM/360-Gleitkommaformat.
<P>

<H3><A NAME="sect_3_3_22_">3.3.22. EFLOAT, BFLOAT, TFLOAT</A></H3>
<A NAME="index_EFLOAT_1"></A><A NAME="index_BFLOAT_1"></A><A
NAME="index_TFLOAT_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Auch diese Befehle legen Gleitkommazahlen im Speicher ab, jedoch in
einem nicht-IEEE-Format, das evtl. leichter von Signalprozessoren zu
verarbeiten ist:
<UL>
<LI> <TT>EFLOAT</TT>: Mantisse mit 16 Bit, Exponent mit 16 Bit</LI>
<LI> <TT>BFLOAT</TT>: Mantisse mit 32 Bit, Exponent mit 16 Bit</LI>
<LI> <TT>TFLOAT</TT>: Mantisse mit 64 Bit, Exponent mit 32 Bit</LI>
</UL>
Gemeinsam ist den Befehlen, da&szlig; die Mantisse vor dem Exponenten
abgelegt wird (Lo-Word jeweils zuerst) und beide im Zweierkomplement
dargestellt werden. Ein eventuell vor dem Befehl stehendes Label wird
wieder als untypisiert gespeichert (der Sinn dieser Ma&szlig;nahme
ist in den prozessorspezifischen Hinweisen erl&auml;utert).
<P>

<H3><A NAME="sect_3_3_23_">3.3.23. Qxx und LQxx</A></H3>
<A NAME="index_Qxx_1"></A><A NAME="index_LQxx_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Mit diesen Befehlen k&ouml;nnen Gleitkommazahlen in einem
Festkommaformat abgelegt werden.<TT> xx</TT> ist dabei eine
zweistellige Zahl, mit deren Zweierpotenz der Gleitkommawert vor der
Umwandlung in eine ganze Zahl multipliziert werden soll. Er bestimmt
also praktisch, wieviele Bits f&uuml;r die Nachkommastellen
reserviert werden sollen. W&auml;hrend aber<TT> Qxx</TT> nur ein Wort
(16 Bit) ablegt, wird das Ergebnis bei<TT> LQxx</TT> in 2 Worten
(LoWord zuerst) abgelegt. Das sieht dann z.B. so aus:
<PRE>

        q05     2.5      ; --&gt; 0050h
        lq20    ConstPI  ; --&gt; 43F7h 0032h

</PRE>
Mich m&ouml;ge niemand steinigen, wenn ich mich auf meinem HP28
verrechnet haben sollte...
<P>

<H3><A NAME="sect_3_3_24_">3.3.24. DATA</A></H3>
<A NAME="index_DATA_1"></A>
<P>
<EM> G&uuml;ltigkeit: PIC, 320xx, AVR, MELPS-4500, H8/500,<BR>
HMCS400, 4004/4040, &micro;PD772x, OLMS-40/50, Padauk</EM>
<P>
Mit diesem Befehl werden Daten im aktuellen Segment abgelegt, wobei
sowohl Integer- als auch Stringwerte zul&auml;ssig sind. Bei Strings
belegt beim 16C5x/16C8x, 17C4x im Datensegment, beim 4500er, 4004 und
HMCS400 im Code-Segement ein Zeichen ein Wort, bei AVR, 17C4x im
Codesegment, &micro;PD772x in den Datensegmenten und 3201x/3202x
passen zwei Zeichen in ein Wort (LSB zuerst), beim &micro;PD7725 drei
und beim 320C3x/C4x sogar derer 4 (MSB zuerst). Im Gegensatz dazu
mu&szlig; im Datensegment des 4500 bzw. ein Zeichen auf zwei
Speicherstellen verteilt werden, ebenso wie beim 4004 und HMCS400.
Der Wertebereich f&uuml;r Integers entspricht der Wortbreite des
jeweiligen Prozessors im jeweiligen Segment. Das bedeutet,
da&szlig;<TT> DATA</TT> beim 320C3x/C4x die Funktion von<TT>
WORD</TT> mit einschlie&szlig;t (die von<TT> SINGLE</TT>
&uuml;brigens auch, wenn AS das Argument als Gleitkommazahl erkennt).
<P>

<H3><A NAME="sect_3_3_25_">3.3.25. ZERO</A></H3>
<A NAME="index_ZERO_1"></A>
<P>
<EM> G&uuml;ltigkeit: PIC, CP-1600</EM>
<P>
Dieser Befehl legt einen durch den Parameter spezifizierte Zahl von
Nullworten (=NOP bei PIC) im Speicher ab.
<P>

<H3><A NAME="sect_3_3_26_">3.3.26. FB und FW</A></H3>
<A NAME="index_FB_1"></A><A NAME="index_FW_1"></A>
<P>
<EM> G&uuml;ltigkeit: COP4/8</EM>
<P>
Mit diesen Befehlen kann ein gr&ouml;&szlig;erer Block von Speicher
(dessen L&auml;nge in Bytes bzw. Worten der erste Parameter angibt)
mit einer Byte- bzw. Wortkonstanten gef&uuml;llt werden, die durch
den zweiten Parameter angegeben wird.
<P>

<H3><A NAME="sect_3_3_27_">3.3.27. ASCII, ASCIC und ASCIZ</A></H3>
<A NAME="index_ASCII_1"></A><A NAME="index_ASCIC_1"></A><A
NAME="index_ASCIZ_1"></A>
<P>
<EM>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><EM> G&uuml;ltigkeit:</EM></TD><TD NOWRAP><EM> ST6, PDP-11, VAX, IMP-16, IPC-16 (<TT> ASCII</TT>)</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> ST6, PDP-11, VAX (<TT> ASCIZ</TT>)</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> PDP-11, VAX (<TT> ASCIC</TT>)</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD></TR>
</TABLE></EM>
<P>
Mit diesen Befehlen k&ouml;nnen Stringkonstanten im Speicher abgelegt
werden. W&auml;hrend ASCII nur die reinen Daten im Speicher ablegt,
versieht<TT> ASCIZ</TT> automatisch<I> jeden</I> angegebenen String
mit einem NUL-Zeichen am Ende, und<TT> ASCIC</TT> stellt ihm ein
L&auml;ngen- Byte voran.
<P>

<H3><A NAME="sect_3_3_28_">3.3.28. STRING und RSTRING</A></H3>
<A NAME="index_STRING_1"></A><A NAME="index_RSTRING_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Diese Anweisungen funktionieren analog zu<TT> DATA</TT>, jedoch
werden hier Integer-Ausdr&uuml;cke grunds&auml;tzlich als<I>
Bytes</I> mit einem entsprechend eingeschr&auml;nkten Wertebereich
betrachtet, wodurch es m&ouml;glich wird, die Zahlen zusammen mit
anderen Zahlen oder Zeichen paarweise in Worte zu verpacken. Die
beiden Befehle unterscheiden sich lediglich in der Reihenfolge der
Bytes in einem Wort: Bei<TT> STRING</TT> wird zuerst das obere und
danach das untere gef&uuml;llt, bei<TT> RSTRING</TT> ist es genau
umgekehrt.
<P>
Ein eventuell vor dem Befehl stehendes Label wird wieder als
untypisiert gespeichert. Der Sinn dieser Ma&szlig;nahme ist im
entsprechenden Kapitel mit den prozessorspezifischen Befehlen
erl&auml;utert.
<P>

<H3><A NAME="sect_3_3_29_">3.3.29. PACKED</A></H3>
<A NAME="index_PACKED_1"></A>
<P>
<EM> G&uuml;ltigkeit: PDP-11, VAX</EM>
<P>
Mit diesem Befehl werden Zahlen im gepackten dezimalen Format (zwei
Stellen pro Byte) im Speicher abgelegt. Als Argument sind entweder
eine (vorzeichenbehaftete) Ganzzahl oder ein String erlaubt, wobei
letzterer nat&uuml;rlich nur dezimale Ziffern und optional ein
Vorzeichen am Anfang enthalten darf. Die Maximalzahl Stellen ist 31,
und das Vorzeichen wird als letzte Stelle angef&uuml;gt, wobei 12 und
13 f&uuml;r Plus bzw. Minus stehen. Ist die Gesamtzahl aus Stellen
und Vorzeichen ungerade, wird vorne eine Null eingef&uuml;gt.
<P>
Optional darf als zweites Argument des Name eines Symbols angegeben
werden, in dem die Anzahl Stellen hinterlegt wird. In dieser
Stellenzahl sind weder Vorzeichen noch eine automatisch
eingef&uuml;gte Null zu Beginn enthalten.
<P>

<H3><A NAME="sect_3_3_30_">3.3.30. RADIX50</A></H3>
<A NAME="index_RADIX50_1"></A>
<P>
<EM> G&uuml;ltigkeit: diverse</EM>
<P>
Mit dieser Anweisung kann ein String im gepackten RADIX50-Format im
Speicher abgelegt werden. Diese Darstellung war besonders im
DEC-Umfeld f&uuml;r Dateinamen g&auml;ngig und packt drei Zeichen in
ein 16-Bit-Wort.<TT> RADIX50</TT> ist keine eingebaute Anweisung,
sondern in der Include- Datei<TT> radix50.inc</TT> als Makro
definiert.
<P>

<H3><A NAME="sect_3_3_31_">3.3.31. FCC</A></H3>
<A NAME="index_FCC_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, 68xx</EM>
<P>
Mit diesem Befehl werden im 65xx/68xx-Modus String-Konstanten
abgelegt. Beachten Sie jedoch, da&szlig; im Gegensatz zum
Originalassembler AS11 von Motorola (dessentwegen dieser Befehl
existiert, bei AS ist diese Funktion im<TT> BYT</TT>-Befehl
enthalten), String-Argumente nur in G&auml;nsef&uuml;&szlig;chen und
nicht in Hochkommas oder Schr&auml;gstrichen eingeschlossen werden
d&uuml;rfen! Ein Wiederholungsfaktor darf analog zu<TT> DC</TT> jedem
einzelnen Parameter in eckigen Klammern vorangestellt werden.
<P>

<H3><A NAME="sect_3_3_32_">3.3.32. TEXT</A></H3>
<P>
Mit diesem Befehl werden im CP-1600-Modus String-Konstanten gepackt,
d.h. zwei Zeichen pro Wort, abgelegt.
<P>

<H3><A NAME="sect_3_3_33_">3.3.33. DFS oder RMB</A></H3>
<A NAME="index_DFS_1"></A><A NAME="index_RMB_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, 68xx</EM>
<P>
Dieser Befehl dient im 65xx/68xx-Modus zur Reservierung von Speicher,
er entspricht<TT> DS.B</TT> beim 68000 oder<TT> DB ?</TT> bei Intel.
<P>

<H3><A NAME="sect_3_3_34_">3.3.34. BLOCK</A></H3>
<A NAME="index_BLOCK_1"></A>
<P>
<EM> G&uuml;ltigkeit: ST6</EM>
<P>
Dito.
<P>

<H3><A NAME="sect_3_3_35_">3.3.35. SPACE</A></H3>
<A NAME="index_SPACE_1"></A>
<P>
<EM> G&uuml;ltigkeit: i960</EM>
<P>
Dito.
<P>

<H3><A NAME="sect_3_3_36_">3.3.36. RES</A></H3>
<A NAME="index_RES_1"></A>
<P>
<EM> G&uuml;ltigkeit: PIC, MELPS-4500, HMCS400, 3201x, 320C2(0)x,<BR>
320C5x, AVR, &micro;PD772x, OLMS-40/50, Padauk, CP-1600,<BR>
PPS-4, 2650</EM>
<P>
Dieser Befehl dient zur Reservierung von Speicher. Er reserviert im
Codesegment immer W&ouml;rter (10/12/14/16 Bit), im Datensegment bei
den PICs Bytes, beim 4500er, PPS-4 und OLMS-40/50 Nibbles sowie bei
TI W&ouml;rter.
<P>

<H3><A NAME="sect_3_3_37_">3.3.37. BSS</A></H3>
<A NAME="index_BSS_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C3x/C4x/C5x/C6x, MSP</EM>
<P>
<TT> BSS</TT> arbeitet analog zu<TT> RES</TT>, lediglich ein
eventuell vor dem Befehl stehendes Symbol wird beim 320C2(0)x/5x als
untypisiert gespeichert. Der Sinn dieser Ma&szlig;nahme kann im
Kapitel mit den prozessorspezifischen Hinweisen nachgelesen werden.
<P>

<H3><A NAME="sect_3_3_38_">3.3.38. DSB und DSW</A></H3>
<A NAME="index_DSB_1"></A><A NAME="index_DSW_1"></A>
<P>
<EM> G&uuml;ltigkeit: COP4/8</EM>
<P>
Diese beiden Befehle stellen im COP4/8-Modus die zum ASMCOP von
National kompatible Methode dar, Speicher zu reservieren.
W&auml;hrend<TT> DSB</TT> nur einzelne Bytes freih&auml;lt,
reserviert<TT> DSW</TT> W&ouml;rter und damit effektiv doppelt soviel
Bytes wie<TT> DSB</TT>.
<P>

<H3><A NAME="sect_3_3_39_">3.3.39. DS16</A></H3>
<A NAME="index_DS16_1"></A>
<P>
<EM> G&uuml;ltigkeit: SC144xx</EM>
<P>
Dieser Befehl reserviert Speicher in Schritten von vollst&auml;ndigen
Worten, d.h. 16 Bit. Er stellt einen Alias zu<TT> DW</TT> dar.
<P>

<H3><A NAME="sect_3_3_40_">3.3.40. ALIGN</A></H3>
<A NAME="index_ALIGN_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> ALIGN</TT> mit einem Integerausdruck als Argument erlaubt es,
den Programmz&auml;hler auf eine bestimmte Adresse auszurichten. Die
Ausrichtung erfolgt dergestalt, da&szlig; der Programmz&auml;hler so
weit erh&ouml;ht wird, da&szlig; er ein ganzzahliges mehrfaches des
Argumentes wird. In seiner Funktion entspricht<TT> ALIGN</TT>
also<TT> DS.x 0</TT> beim den 680x0ern, nur ist die Ausrichtung noch
flexibler.
<P>
Beispiel:
<PRE>

        align 2

</PRE>
macht den Programmz&auml;hler gerade. Wird<TT> ALIGN</TT> in dieser
Form mit nur einem Argument verwendet, ist der Inhalt des dadurch
frei bleibenden Speicherbereichs nicht definiert. Alternativ kann als
zweites Argument ein (Byte-)Wert angegeben werden, mit dem dieser
Bereich gef&uuml;llt wird.
<P>

<H3><A NAME="sect_3_3_41_">3.3.41. LTORG</A></H3>
<A NAME="index_LTORG_1"></A>
<P>
<EM> G&uuml;ltigkeit: SH7x00, IM61x0, IMP-16, IPC-16</EM>
<P>
Da der SH7000-Prozessor seine Register immediate nur mit 8-Bit-Werten
laden kann, AS dem Programmierer jedoch vorgaukelt, da&szlig; es eine
solche Einschr&auml;nkung nicht g&auml;be, mu&szlig; er die dabei
entstehenden Konstanten irgendwo im Speicher ablegen. Da es nicht
sinnvoll w&auml;re, dies einzeln zu tun (wobei jedes Mal
Sprungbefehle anfallen w&uuml;rden...), werden die Literale gesammelt
und k&ouml;nnen vom Programmierer mit diesem Befehl gezielt
blockweise (z.B. am Ende eines Unterprogrammes) abgelegt werden. Zu
den zu beachtenden Details und Fallen sei auf das Kapitel mit den
SH7000-spezifischen Dingen hingewiesen.
<P>

<H2><A NAME="sect_3_4_">3.4. Makrobefehle</A></H2>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Kommen wir nun zu dem, was einen Makroassembler vom normalen
Assembler unterscheidet: der M&ouml;glichkeit, Makros zu definieren
(ach was ?!).
<P>
Unter Makros verstehe ich hier erst einmal eine Menge von Anweisungen
(normal oder Pseudo), die mit bestimmten Befehlen zu einem Block
zusammengefa&szlig;t werden und dann auf bestimmte Weise bearbeitet
werden k&ouml;nnen. Zur Bearbeitung solcher Bl&ouml;cke kennt der
Assembler folgende Befehle:
<P>

<H3><A NAME="sect_3_4_1_">3.4.1. MACRO</A></H3>
<A NAME="index_MACRO_1"></A><A NAME="index_ENDM_1"></A><A
NAME="ref_SectMacros"></A>
<P>
ist der wohl wichtigste Befehl zur Makroprogrammierung. Mit der
Befehlsfolge
<PRE>

&lt;Name&gt;  MACRO   [Parameterliste]
        &lt;Befehle&gt;
        ENDM

</PRE>
wird das Makro<TT> &lt;Name: &gt;</TT> als die eingeschlossene
Befehlsfolge definiert. Diese Definition alleine erzeugt noch keinen
Code! Daf&uuml;r kann fortan die Befehlsfolge einfach durch den Namen
abgerufen werden, das Ganze stellt also eine Schreiberleichterung
dar. Um die ganze Sache etwas n&uuml;tzlicher zu machen, kann man der
Makrodefinition eine Parameterliste mitgeben.
<P>
W&auml;hrend der Makroname selber nur den &uuml;blichen Regeln
f&uuml;r Symbolnamen (<A HREF="#ref_SectSymConv">2.7</A>)
gen&uuml;gen mu&szlig;, gilt f&uuml;r die Namen der
(kommaseparierten) Parameternamen die weitere Einschr&auml;nkung,
da&szlig; sie keine Unterstriche enthalten d&uuml;rfen. Dies kann
durch den Kommandozeilen-Parameter<TT> -underscore-macroargs</TT>
aufgehoben werden, hat aber Nebenwirkungen bei der Expansion von
Makros und sollte nur eingesetzt werden, wenn unbedingt n&ouml;tig.
<P>
Sowohl Makronamen als auch -parameter sind von einer Umschaltung von
AS in den case-sensitiven Modus betroffen.
<P>
Makros sind &auml;hnlich wie Symbole lokal, d.h. bei Definition in
einer Sektion sind sie nur in dieser Sektion und ihren Untersektionen
bekannt. Dieses Verhalten l&auml;&szlig;t sich aber durch die weiter
unten beschriebenen Optionen<TT> PUBLIC</TT> und<TT> GLOBAL</TT> in
weiten Grenzen steuern.
<P>
F&uuml;r jeden Makroparameter kann ein Defaultwert mit
angeh&auml;ngtem Gleichheitszeichen angegeben werden. Dieser Wert
wird f&uuml;r den Parameter eingesetzt, wenn beim Makroaufruf kein
Argument f&uuml;r diesen Parameter angegeben wird, bzw. wenn ein
Positionsargument (s.u.) f&uuml;r diesen Parameter leer ist.
<P>
Neben den eigentlichen Makroparametern k&ouml;nnen in der
Parameterliste auch Steuerparameter enthalten sein, die die
Abarbeitung des betroffenen Makros beeinflussen; diese Parameter
werden von normalen Parametern dadurch unterschieden, da&szlig; sie
in geschweifte Klammern eingeschlossen sind. Es sind folgende
Steuerparameter definiert:
<UL>
<LI> <TT>EXPAND/NOEXPAND</TT> : legen fest, ob bei der sp&auml;teren
    Verwendung diese Makros der expandierte Code mit angezeigt werden
    soll. Default ist der durch den Pseudobefehl<TT> MACEXP_DFT</TT>
    festgelegte Wert.</LI>
<LI> <TT>EXPIF/NOEXPIF</TT> : legen fest, ob bei der sp&auml;teren
    Verwendung diese Makros Befehle zur bedingten Assemblierung und
    dadurch ausgeschlossener Code angezeigt werden soll. Default ist
    der durch den Pseudobefehl<TT> MACEXP_DFT</TT> festgelegte
    Wert.</LI>
<LI> <TT>EXPMACRO/NOEXPMACRO</TT> : legen fest, ob bei der sp&auml;teren
    Verwendung diese Makros darin definierte Makros angezeigt werden
    sollen. Default ist der durch den Pseudobefehl<TT>
    MACEXP_DFT</TT> festgelegte Wert.</LI>
<LI> <TT>EXPREST/NOEXPREST</TT> : legen fest, ob bei der sp&auml;teren
    Verwendung Code-Zeilen angezeigt werden sollen, die weder
    Makro-Definitionen, bedingte Assemblierung noch durch bedingte
    Assemblierung ausgeschlossene Zeilen sind. Default ist der durch
    den Pseudobefehl<TT> MACEXP_DFT</TT> festgelegte Wert.</LI>
<LI> <TT>PUBLIC[:Sektionsname]</TT> : ordnet das Makro nicht der
    aktuellen, sondern einer ihr &uuml;bergeordneten Sektion zu. Auf
    diese Weise kann eine Sektion Makros f&uuml;r die
    ,,Au&szlig;enwelt'' zur Verf&uuml;gung stellen. Fehlt eine
    Sektionsangabe, so wird das Makro v&ouml;llig global, d.h. ist
    &uuml;berall benutzbar.</LI>
<LI> <TT>GLOBAL[:Sektionsname]</TT> : legt fest, da&szlig; neben diesem
    Makro noch ein weiteres Makro abgelegt werden soll, das zwar den
    gleichen Inhalt hat, dessen Name aber zus&auml;tzlich mit dem
    Namen der Sektion versehen ist, in der es definiert wurde und das
    der spezifizierten Sektion zugeordnet werden soll. Bei dieser
    mu&szlig; es sich um eine Obersektion zu der aktuellen Sektion
    handeln; fehlt die Angabe, so wird das zus&auml;tzliche Makro
    global sichtbar. Wird z.B. ein Makro<TT> A</TT> in der
    Sektion<TT> B</TT> definiert, die wiederum eine Untersektion der
    Sektion<TT> C</TT> ist, so w&uuml;rde neben z.B. dem Makro A ein
    weiteres globales mit dem Namen<TT> C_B_A</TT> erzeugt.
    W&uuml;rde dagegen<TT> C</TT> als Zielsektion angegeben, so
    w&uuml;rde das Makro<TT> B_A</TT> hei&szlig;en und der
    Sektion<TT> C</TT> zugeordnet. Diese Option ist
    defaultm&auml;&szlig;ig ausgeschaltet und hat auch nur einen
    Effekt, falls sie innerhalb einer Sektion benutzt wird. Das lokal
    bekannte Originalmakro wird von ihr nicht beeinflu&szlig;t.</LI>
<LI> <TT>EXPORT/NOEXPORT</TT> : legen fest, ob die Definition dieses
    Makros in einer getrennten Datei abgelegt werden soll, falls die
    Kommandozeilenoption<TT> -M</TT> gegeben wurde. Auf diese Weise
    k&ouml;nnen einzelne Definitionen ,,privater'' Makros selektiv
    ausgeblendet werden. Der Default ist FALSE, d.h. die Definition
    wird nicht in der Datei abgelegt. Ist zus&auml;tzlich die<TT>
    GLOBAL</TT>-Option gegeben worden, so wird das Makro mit dem
    modifizierten Namen abgelegt.</LI>
<LI> <TT>INTLABEL/NOINTLABEL</TT> : legen fest, ob ein in der Zeile mit
    dem Makroaufruf definiertes Label innerhalb des Rumpfes als
    zus&auml;tzlicher Parameter verwendet werden soll, als einfach
    nur die Adresse dieser Zeile zu 'labeln'.</LI>
<LI> <TT>GLOBALSYMBOLS/NOGLOBALSYMBOLS</TT> : legt fest, ob im Makro
    definierte Labels lokal zu diesem Makro sein sollen oder auch
    au&szlig;erhalb des Makros verf&uuml;gbar sein sollen. Der
    Default ist, da&szlig; Labels lokal sind, weil mehrfache
    Benutzung eines Makros ansonsten schwierig w&auml;re.</LI>
</UL>
Diese eben beschriebenen Steuerparameter werden von AS aus der
Parameterliste ausgefiltert, haben also keine weitere Wirkung in der
folgenden Verarbeitung und Benutzung.
<P>
Beim Aufruf eines Makros werden die beim Aufruf angegebenen
Parameternamen &uuml;berall textuell im Befehlsblock eingesetzt und
der sich so ergebene Assemblercode wird normal assembliert. Sollten
beim Aufruf zu wenige Parameter angegeben werden, werden Nullstrings
eingef&uuml;gt. Wichtig ist zu wissen, da&szlig; bei der
Makroexpansion keine R&uuml;cksicht auf eventuell in der Zeile
enthaltene Stringkonstanten genommen wird. Zu diesem Detail gilt die
alte IBM-Regel:
<BLOCKQUOTE>
    <I> It's not a bug, it's a feature!</I>
</BLOCKQUOTE>
Diese L&uuml;cke kann man bewu&szlig;t ausnutzen, um Parameter
mittels Stringvergleichen abzupr&uuml;fen. So kann man auf folgende
Weise z.B. pr&uuml;fen, wie ein Makroparameter aussieht:
<PRE>

mul     MACRO   para,parb
        IF      UpString("PARA")&lt;&gt;"A"
         MOV    a,para
        ENDIF
        IF      UpString("PARB")&lt;&gt;"B"
         MOV    b,parb
        ENDIF
        !mul     ab
        ENDM

</PRE>
Wichtig ist bei obigem Beispiel, da&szlig; der Assembler alle
Parameternamen im case-sensitiven Modus in Gro&szlig;buchstaben
umsetzt, in Strings aber nie eine Umwandlung in Gro&szlig;buchstaben
erfolgt. Die Makroparameternamen m&uuml;ssen in den Stringkonstanten
daher gro&szlig; geschrieben werden.
<P>
Des weiteren wird die Parameter-Ersetzung davon beeinflusst, ob
Unterstriche im Parameternamen erlaubt sind oder nicht. Falls nicht
--- was der Default ist --- wirken Unterstriche auch als
'Begrenzungszeichen', um Parameternamen im Makrorumpf zu erkennen. Im
Default w&uuml;rde also im folgenden Beispiel
<PRE>

setled  macro led,value
        out   led,value
        ld    led_shadow,value
        endm

</PRE>
der Parameter 'led' in beiden Zeilen ersetzt, mit dem
Kommandozeilen-Schalter<TT> -underscore-macroargs</TT> jedoch nur in
der ersten. Diverse der mitgelieferten Include-Dateien setzen das
Default-Verhalten voraus, weshalb dieser Schalter nur wenn unbedingt
n&ouml;tig genutzt werden sollte.
<P>
Argumente an ein Makro k&ouml;nnen in zwei Formen angegeben werden:
als<EM> Positionsargumente</EM> oder als<EM>
Schl&uuml;sselwortargumente</EM>.
<P>
Bei Positionsargumenten ergibt sich die Zuordnung von Argumenten zu
Makro-Parametern einfach durch ihre Position in der Aufrufliste, d.h.
das erste Argument wird dem ersten Parameter zugeordnet, das zweite
Argument dem zweiten Parameter usw.. Werden weniger Argumente
angegeben als das Makro Parameter hat, werden eventuell definierte
Defaultwerte oder ein Leerstring eingesetzt. Gleiches gilt auch
f&uuml;r leere Argumente.
<P>
Schl&uuml;sselwortargumente geben jedoch explizit an, f&uuml;r
welchen Makro-Parameter sie gelten, indem der Parametername dem Wert
vorangestellt wird, z.B. so:
<PRE>

       mul  para=r0,parb=r1

</PRE>
Wiederum wird f&uuml;r nicht definierte Parameter ein eventuell
vorhandener Default oder ein Leerstring eingesetzt.
<P>
Im Unterschied zu Positionsargumenten ist es mit
Schl&uuml;sselwortargumenten auch m&ouml;glich, einem Parameter einen
Leerstring zuzuweisen, der einen nicht-leeren Default-Wert hat.
<P>
Positions- und Schl&uuml;sselwortargumente d&uuml;rfen auch in einem
Aufruf gemischt werden, jedoch d&uuml;rfen ab dem ersten
Schl&uuml;sselwortargument keine Positionsargumente mehr verwendet
werden.
<P>
F&uuml;r die Makroparameter gelten die gleichen Konventionen wie bei
normalen Symbolen, mit der Ausnahme, da&szlig; hier nur Buchstaben
und Ziffern zugelassen sind, also weder Punkte noch Unterstriche.
Diese Einschr&auml;nkung hat ihren Grund in einem verstecktem
Feature: Der Unterstrich erlaubt es, einzelne Makroparameternamen zu
einem Symbol zusammenzuketten, z.B. in folgendem Beispiel:
<PRE>

concat  MACRO   part1,part2
        CALL    part1_part2
        ENDM

</PRE>
Der Aufruf
<PRE>

        concat  Modul,Funktion

</PRE>
ergibt also
<PRE>

        CALL    Modul_Funktion

</PRE>
<P>
Neben den am Makro selber angegebenen Parametern existieren vier
weitere 'implizite' Parameter, die immer vorhanden sind und daher
nicht als eigene Makroparameter verwendet werden sollten:
<UL>
<LI> <TT> ATTRIBUTE</TT> bezeichnet bei Architekturen, die Attribute
    f&uuml;r Prozessorbefehle zulassen, das bei einem Makroaufruf
    angeh&auml;ngte Argument. F&uuml;r ein Beispiel siehe z.B.
    unten!</LI>
<LI> <TT> ALLARGS</TT> bezeichnet eine kommaseparierte Liste aller
    Makroargumente, z.B., um sie an eine<TT> IRP</TT>-Anweisung
    weiterzureichen.</LI>
<LI> <TT> ARGCOUNT</TT> bezeichnet die tat&auml;chlich &uuml;bergebene
    Anzahl der an das Makro &uuml;bergebenen Argumente. Zu beachten
    ist allerdings, da&szlig; diese Zahl niemals geringer als die
    Zahl der formalen Parameter ist, da AS fehlende Argumente mit
    Leerstrings auff&uuml;llt!</LI>
<LI> <TT> __LABEL__</TT> bezeichnet das Label, das in der das Makro
    aufrufenden Zeile stand. Diese Ersetzung findet nur statt, wenn
    f&uuml;r dieses Makro die<TT> INTLABEL</TT>-Option gesetzt
    wurde!</LI>
</UL>
<B> WICHTIG:</B> Die Namen dieser impliziten Parameter sind auch
case-insensitiv, wenn AS insgesamt angewiesen wurde, case-sensitiv zu
arbeiten!
<P>
Der Zweck, ein Label 'intern' im Makro verwenden zu k&ouml;nnen, ist
sicher nicht unmittelbar einleuchtend. Den einen oder anderen Fall
mag es ja geben, in dem es sinnvoll ist, den Einsprungpunkt in ein
Makro irgendwo in seinen Rumpf zu verschieben. Der wichtigste
Anwendungsfall sind aber TI-Signalprozessoren, die eine
Parallelisierung von Befehlen durch einen doppelten senkrechten
Strich in der Label-Spalte kennzeichnen, etwa so:
<PRE>

    instr1
||  instr2

</PRE>
(da die beiden Instruktionen im Maschinencode in ein Wort
verschmelzen, kann man die zweite Instruktion &uuml;brigens gar nicht
separat anspringen - man verliert also durch das Belegen der
Label-Position nichts). Das Problem ist aber, da&szlig; einige
'Bequemlichkeits-Befehle' durch Makros realisiert werden. Ein vor das
Makro geschriebenes Parallelisierungssymbol w&uuml;rde normalerweise
dem Makro selber zugeordnet,<I> nicht dem ersten Befehl im Makro
selber</I>. Aber mit diesem Trick funktioniert's:
<PRE>

myinstr    macro {INTLABEL}
__LABEL__  instr2
           endm

           instr1
||         myinstr

</PRE>
Das Ergebnis nach der Expansion von<TT> myinstr</TT> ist identisch zu
dem vorherigen Beispiel ohne Makro.
<P>
Rekursion von Makros, also das wiederholte Aufrufen eines Makros
innerhalb seines Rumpfes oder indirekt &uuml;ber andere von ihm
aufgerufene Makros ist vollkommen legal. Wie bei jeder Rekusion
mu&szlig; man dabei nat&uuml;rlich sicherstellen, da&szlig; sie
irgendwann ein Ende findet. F&uuml;r den Fall, da&szlig; man dies
vergessen hat, f&uuml;hrt AS in jedem definierten Makro einen
Z&auml;hler mit, der bei Beginn einer Makroexpansion inkrementiert
und an deren Ende wieder dekrementiert wird. Bei rekursiven Aufrufen
eines Makros erreicht dieser Z&auml;hler also immer h&ouml;here
Werte, und bei einem per<TT> NESTMAX</TT> einstellbaren Wert bricht
AS ab. Vorsicht, wenn man diese Bremse abschaltet: der Speicherbedarf
auf dem Heap kann so beliebig steigen und selbst ein Unix-System in
die Knie zwingen...
<P>
Um alle Klarheiten auszur&auml;umen, ein einfaches Beispiel: Ein an
,,Intel-Syntax'' gew&ouml;hnter Programmierer m&ouml;chte diex
Befehle<TT> PUSH/POP</TT> unbedingt auch auf dem 68000 haben. Er
l&ouml;st das folgenderma&szlig;en:
<PRE>

push    MACRO   op
        MOVE.ATTRIBUTE op,-(sp)
        ENDM

pop     MACRO   op
        MOVE.ATTRIBUTE (sp)+,op
        ENDM

</PRE>
Schreibt man nun im Code
<PRE>

        push    d0
        pop.l   a2        ,

</PRE>
so wird daraus
<PRE>

        MOVE.   d0,-(sp)
        MOVE.L  (sp)+,a2

</PRE>
Eine Makrodefinition darf nicht &uuml;ber Include-Datei-Grenzen
hinausgehen.
<P>
In Makror&uuml;mpfen definierte Labels werden immer als lokal
betrachtet, au&szlig;er bei der Definition des Makros wurde die<TT>
GLOBALSYMBOLS</TT>-Option verwendet. Ist es aus irgendwelchen
Gr&uuml;nden erforderlich, ein einzelnes Label in einem Makro global
zu machen, das ansonsten lokale Labels benutzt, so kann man es
mit<TT> LABEL</TT> definieren, dessen Anwendung (wie bei<TT>
BIT,SFR</TT>...) immer globale Symbole ergibt :
<PRE>

&lt;Name&gt;  LABEL   *

</PRE>
Da der Assembler beim Parsing einer Zeile zuerst die Makroliste und
danach die Prozessorbefehle abklappert, lassen sich auch
Prozessorbefehle neu definieren. Die Definition sollte dann aber vor
der ersten Benutzung des Befehles durchgef&uuml;hrt werden, um
Phasenfehler wie im folgenden Beispiel zu vermeiden:
<PRE>

        BSR     ziel

bsr     MACRO   target
        JSR     ziel
        ENDM

        BSR     ziel

</PRE>
Im ersten Pass ist bei der Assemblierung des<TT> BSR</TT>-Befehles
das Makro noch nicht bekannt, es wird ein 4 Byte langer Befehl
erzeugt. Im zweiten Pass jedoch steht die Makrodefinition sofort (aus
dem ersten Pass) zur Verf&uuml;gung, es wird also ein 6 Byte
langer<TT> JSR</TT> kodiert. Infolgedessen sind alle darauffolgenden
Labels um zwei zu niedrig, bei allen weiteren Labels sind
Phasenfehler die Folge, und ein weiterer Pass ist erforderlich.
<P>
Da durch die Definition eines Makros ein gleichnamiger Maschinen-
oder Pseudobefehl nicht mehr zugreifbar ist, gibt es eine
Hintert&uuml;r, die Originalbedeutung zu erreichen: Stellt man dem
Mnemonic ein<TT> !</TT> voran, so wird das Durchsuchen der Makroliste
unterdr&uuml;ckt. Das kann beispielsweise n&uuml;tzlich sein, um
Befehle in ihrer M&auml;chtigkeit zu erweitern, z.B. die
Schiebebefehle beim TLCS-90:
<PRE>

srl     macro   op,n      ; Schieben um n Stellen
        rept    n         ; n einfache Befehle
         !srl   op
        endm
        endm

</PRE>
Fortan hat der<TT> SRL</TT>-Befehl einen weiteren Parameter...
<P>

<H4>Expansion im Listing</H4>
<P>
Wird ein Makro im Quellcode aufgerufen, wird der durch dieses Makro
definierte Quellcode, inklusiver eingesetzter Parameter, an dieser
Stelle im Listing expandiert. Das kann das Listing stark
aufbl&auml;hen und schwerer lesbar machen. Es ist daher m&ouml;glich,
diese Expansion ganz oder teilweise zu unterdr&uuml;cken. Generell
teilt AS die in einem Makrorumpf enthaltenen Quelltext-Zeilen in drei
Klassen ein:
<UL>
<LI> Darin enthaltene Makrodefinitionen, d.h. das Makro wird benutzt, um
    seinerseits weitere Makros zu definieren, oder es
    enth&auml;lt<TT> REPT/ IRP/IRPC/WHILE</TT>-Bl&ouml;cke.</LI>
<LI> Befehle zur bedingten Assemblierung plus Zeilen, die aufgrund
    solcher Anweisungen<I> nicht</I> assembliert werden. Da bedingte
    Assemblierung von Makro-Parametern abh&auml;ngig sein darf, kann
    diese Untermenge ebenfalls davon abh&auml;ngen.</LI>
<LI> Alle restlichen Zeilen, die nicht unter die beiden ersten Klassen
    fallen.</LI>
</UL>
F&uuml;r jedes Makro kann einzeln festgelegt werden, welche Teile im
Listing auftauchen oder nicht auftauchen sollen. Vorgabewert bei der
Definition eines Makros ist dabei die zuletzt mit dem Befehl<TT>
MACEXP_DFT</TT> (<A HREF="#ref_MACEXPDFT">3.7.3</A>) vorgegebene
Menge. Wird bei der Definition eines Makros eine der Direktiven<TT>
EXPAND/NOEXPAND</TT>,<TT> EXPIF/NOEXPIF</TT>,<TT>
EXPMACRO/NOEXPMACRO</TT> oder<TT> EXPREST/NOEXPREST</TT> gegeben, so
wirken diese<I> zus&auml;tzlich</I> und mit h&ouml;herer
Priorit&auml;t. Ist z.B. die Expansion global komplett ausgeschaltet
(<TT>MACEXP_DFT OFF</TT>), so bewirkt das Hinzuf&uuml;gen von<TT>
EXPREST</TT>, da&szlig; bei der Benutzung dieses Makro nur die Zeilen
im Listing angezeigt werden, die nach Auswertung bedingter
Assemblierung verblieben sind und auch keine Makrodefinition selber
sind.
<P>
Daraus ergibt sich, da&szlig; eine &Auml;nderung der Untermenge
per<TT> MACEXP_DFT</TT> keine Auswirkungen mehr auf Makros hat,
die<I> vor</I> dieser Anweisung<I> definiert</I> wurden. Im Listing
f&uuml;hrt der Abschnitt mit definierten Makros f&uuml;r jedes Makro
auf, welche Direktiven in der Summe f&uuml;r dieses Makro gelten. Die
in geschweiften Klammern aufgef&uuml;hrte Liste ist dabei soweit
gek&uuml;rzt, da&szlig; f&uuml;r jede Klasse nur die
letztg&uuml;ltige Direktive aufgef&uuml;hrt wird. Ein per<TT>
MACEXP_DFT</TT> gegebenes<TT> NOIF</TT> taucht dort also nicht mehr
auf, falls speziell f&uuml;r dieses Makro die Direktive<TT>
EXPIF</TT> gegeben wurde.
<P>
In Einzelf&auml;llen kann es sinnvoll sein, die f&uuml;r ein Makro
definierten Expansionsregeln zu &uuml;bersteuern, egal ob diese
per<TT> MACEXP_DFT</TT> oder Direktiven gesetzt wurden. Dazu dient
der Befehl<TT> MACEXP_OVR</TT> (<A HREF="#ref_MACEXPOVR">3.7.3</A>),
der auf in der Folge<I> expandierte</I> Makros wirkt. Auch bei diesem
Befehl gilt, da&szlig; damit gegebene Direktiven zus&auml;tzlich zu
denen in einem Makro hinterlegten und mit h&ouml;herer Priorit&auml;t
wirken. Ein<TT> MACEXP_OVR</TT> ohne jegliche Argumente schaltet so
einen ''Override'' wieder ab.
<P>

<H3><A NAME="sect_3_4_2_">3.4.2. IRP</A></H3>
<A NAME="index_IRP_1"></A>
<P>
ist die eine vereinfachte Form von Makrodefinitionen f&uuml;r den
Fall, da&szlig; eine Befehlsfolge einmal auf mehrere Operanden
angewendet werden soll und danach nicht mehr gebraucht wird.<TT>
IRP</TT> ben&ouml;tigt als ersten Parameter ein Symbol f&uuml;r den
Operanden, und danach eine (fast) beliebige Menge von Parametern, die
nacheinander in den Befehlsblock eingesetzt werden. Um eine Menge von
Registern auf den Stack zu schieben, kann man z.B. schreiben
<PRE>

        IRP     op, acc,b,dpl,dph
        PUSH    op
        ENDM

</PRE>
was in folgendem resultiert:
<PRE>

        PUSH    acc
        PUSH    b
        PUSH    dpl
        PUSH    dph

</PRE>
Die Argumentliste darf analog zu einer Makro-Definition die folgenden
Steueranweisungen (durch geschweifte Klammern als solche
gekennzeichnet) enthalten:
<UL>
<LI> <TT>GLOBALSYMBOLS</TT> bzw.<TT> NOGLOBALSYMBOLS</TT>, um zu steuern,
    ob benutzte Labels f&uuml;r jeden Durchgang automatisch lokal
    sind oder nicht.</LI>
<LI> <TT>EXPAND</TT> bzw.<TT> NOEXPAND</TT></LI>
<LI> <TT>EXPIF</TT> bzw.<TT> NOEXPIF</TT></LI>
<LI> <TT>EXPMACRO</TT> bzw.<TT> NOEXPMACRO</TT></LI>
<LI> <TT>EXPREST</TT> bzw.<TT> NOEXPREST</TT></LI>
</UL>
<P>

<H3><A NAME="sect_3_4_3_">3.4.3. IRPC</A></H3>
<A NAME="index_IRPC_1"></A>
<P>
<TT> IRPC</TT> ist eine Variante von<TT> IRP</TT>, bei der das erste
Argument in den bis<TT> ENDM</TT> folgenden Zeilen nicht sukzessiv
durch die weiteren Parameter, sondern durch die Zeichen eines Strings
ersetzt wird. Einen String kann man z.B. also auch ganz
umst&auml;ndlich so im Speicher ablegen:
<PRE>

        irpc    char,"Hello World"
        db      'CHAR'
        endm

</PRE>
<B>ACHTUNG!</B> Wie das Beispiel schon zeigt, setzt<TT> IRPC</TT> nur
das Zeichen selber ein, da&szlig; daraus ein g&uuml;ltiger Ausdruck
entsteht (also hier durch die Hochkommas, inklusive des Details,
da&szlig; hier keine automatische Umwandlung in Gro&szlig;buchstaben
vorgenommen wird), mu&szlig; man selber sicherstellen.
<P>

<H3><A NAME="sect_3_4_4_">3.4.4. REPT</A></H3>
<A NAME="index_REPT_1"></A>
<P>
ist die einfachste Form der Makrobenutzung. Der im Rumpf angegebene
Code wird einfach sooft assembliert, wie der Integerparameter von<TT>
REPT</TT> angibt. Dieser Befehl wird h&auml;ufig in kleinen Schleifen
anstelle einer programmierten Schleife verwendet, um den
Schleifenoverhead zu sparen.
<P>
Der Vollst&auml;ndigkeit halber ein Beispiel:
<PRE>

        REPT    3
        RR      a
        ENDM

</PRE>
rotiert den Akku um 3 Stellen nach rechts.
<P>
An Steueranweisungen sind die gleichen wie f&uuml;r<TT> IRP</TT>
erlaubt.
<P>
Ist das Argument von<TT> REPT</TT> kleiner oder gleich Null, so wird
&uuml;berhaupt keine Expansion durchgef&uuml;hrt. Dies ist ein
Unterschied zu fr&uuml;heren Versionen von AS, die hier etwas
,,schlampig'' waren und immer mindestens eine Expansion
ausf&uuml;hrten.
<P>

<H3><A NAME="sect_3_4_5_">3.4.5. WHILE</A></H3>
<A NAME="index_WHILE_1"></A>
<P>
<TT> WHILE</TT> arbeitet analog zu<TT> REPT</TT>, allerdings tritt an
die Stelle einer festen Anzahl als Argument ein boolescher Ausdruck,
und der zwischen<TT> WHILE</TT> und<TT> ENDM</TT> eingeschlossene
Code wird sooft assenbliert, bis der Ausdruck logisch falsch wird. Im
Extremfall kann dies bedeuten, da&szlig; der Code &uuml;berhaupt
nicht assembliert wird, falls die Bedingung bereits beim Eintritt in
das Konstrukt falsch ist. Andererseits kann es nat&uuml;rlich auch
passieren, da&szlig; die Bedingung immer wahr bleibt, und AS
l&auml;uft bis an das Ende aller Tage...hier sollte man also etwas
Umsicht walten lassen, d.h. im Rumpf mu&szlig; eine Anweisung stehen,
die die Bedingung auch beeinflu&szlig;t, z.B. so:
<PRE>

cnt     set     1
sq      set     cnt*cnt
        while   sq&lt;=1000
         dc.l    sq
cnt      set     cnt+1
sq       set     cnt*cnt
        endm

</PRE>
An Steueranweisungen sind die gleichen wie f&uuml;r<TT> IRP</TT>
und<TT> REPT</TT> erlaubt.
<P>
Dieses Beispiel legt alle Quadratzahlen bis 1000 im Speicher ab.
<P>
Ein unsch&ouml;nes Detail bei<TT> WHILE</TT> ist im Augenblick leider
noch, da&szlig; am Ende der Expansion eine zus&auml;tzliche
Leerzeile, die im Quellrumpf nicht vorhanden war, eingef&uuml;gt
wird. Dies ist ein ,,Dreckeffekt'', der auf einer Schw&auml;che des
Makroprozessors beruht und leider nicht so einfach zu beheben ist.
Hoffentlich st&ouml;rt es nicht allzusehr....
<P>

<H3><A NAME="sect_3_4_6_">3.4.6. EXITM</A></H3>
<A NAME="index_EXITM_1"></A>
<P>
<TT> EXITM</TT> stellt einen Weg dar, um eine Makroexpansion oder
einen der Befehle<TT> REPT</TT>,<TT> IRP</TT> oder<TT> WHILE</TT>
vorzeitig abzubrechen. Eine solche M&ouml;glichkeit hilft zum
Beispiel, umfangreichere Klammerungen mit<TT> IF-ENDIF</TT>-Sequenzen
in Makros &uuml;bersichtlicher zu gestalten. Sinnvollerweise ist
ein<TT> EXITM</TT> aber selber auch immer bedingt, was zu einem
wichtigen Detail f&uuml;hrt: Der Stack, der &uuml;ber momentan
offene<TT> IF</TT>- oder<TT> SWITCH</TT>-Konstrukte Buch f&uuml;hrt,
wird auf den Stand vor Beginn der Makroexpansion zur&uuml;ck gesetzt.
Dies ist f&uuml;r bedingte<TT> EXITM</TT>'s zwingend notwendig, da
das den<TT> EXITM</TT>-Befehl in irgendeiner Form
einschlie&szlig;ende<TT> ENDIF</TT> oder<TT> ENDCASE</TT> nicht mehr
erreicht wird und AS ohne einen solchen Trick eine Fehlermeldung
erzeugen w&uuml;rde. Weiterhin ist es f&uuml;r verschachtelte
Makrokonstruktionen wichtig, zu beachten, da&szlig;<TT> EXITM</TT>
immer nur das momentan innerste Konstrukt abbricht! Wer aus seiner
geschachtelten Konstruktion vollst&auml;ndig ,,ausbrechen'' will,
mu&szlig; auf den h&ouml;heren Ebenen ebenfalls<TT> EXITM</TT>'s
vorsehen!
<P>

<H3><A NAME="sect_3_4_7_">3.4.7. SHIFT</A></H3>
<A NAME="index_SHIFT_1"></A><A NAME="index_.SHIFT_1"></A><A
NAME="index_SHFT_1"></A>
<P>
<TT> SHIFT</TT> ist ein Mittel, um Makros mit variablen
Argumentlisten abzuarbeiten: Es verwirft den ersten Parameter, so
da&szlig; der zweite Parameter seinen Platz einnimmt usw. Auf diese
Weise k&ouml;nnte man sich durch eine variable Argumentliste
durcharbeiten...wenn man es richtig macht. Folgendes funktioniert zum
Beispiel<EM> nicht</EM>...
<PRE>

pushlist  macro reg
          rept  ARGCOUNT
          push  reg
          shift
          endm
          endm

</PRE>
...weil das Makro<EM> einmal</EM> expandiert wird, seine Ausgabe
von<TT> REPT</TT> aufgenommen und dann n-fach ausgef&uuml;hrt wird.
Das erste Argument wird also n-fach gesichert...besser geht es schon
so:
<PRE>

pushlist  macro reg
          if      "REG"&lt;&gt;""
           push    reg
           shift
           pushlist ALLARGS
          endif
          endm

</PRE>
Also eine Rekursion, in der pro Schritt die Argumentliste (<TT>
ALLARGS</TT>) um eins verk&uuml;rzt wird. Der wichtige Trick ist,
da&szlig; jedes Mal eine neue Expansion gestartet wird...
<P>
Auf Plattformen, bei denen<TT> SHIFT</TT> bereits eine
Maschineninstruktion ist, kann stattdessen<TT> SHFT</TT> geschrieben
werden, oder man spricht explizit die Pseudoinstruktion durch einen
vorangestellten Punkt (<TT>.SHIFT</TT> anstelle<TT> SHIFT</TT>) an.
<P>

<H3><A NAME="sect_3_4_8_">3.4.8. MAXNEST</A></H3>
<A NAME="index_MAXNEST_1"></A>
<P>
Mit<TT> MAXNEST</TT> kann man einstellen, wie oft ein Makro maximal
rekursiv aufgerufen werden kann, bevor AS mit einer Fehlermeldung
abbricht. Dies darf ein beliebiger ganzer, positiver Wert sein, wobei
der Sonderwert 0 diese Sicherheitsbremse komplett abschaltet
(vorsicht damit...). Der Vorgabewert f&uuml;r die maximale
Verschachtelungstiefe ist 256; die momentane Einstellung kann aus
einer gleichnamigen Variablen gelesen werden.
<P>

<H3><A NAME="sect_3_4_9_">3.4.9. FUNCTION</A></H3>
<A NAME="index_FUNCTION_1"></A><A NAME="ref_SectFUNCTION"></A>
<P>
<TT> FUNCTION</TT> ist zwar kein Makrobefehl im engeren Sinne, da
hierbei aber &auml;hnliche Mechanismen wie bei Makroersetzungen
angewendet werden, soll er hier beschrieben werden.
<P>
Dieser Befehl dient dazu, neue Funktionen zu definieren, die in
Formelausdr&uuml;cken wie die vordefinierten Funktionen verwendet
werden k&ouml;nnen. Die Definition mu&szlig; in folgender Form
erfolgen:
<PRE>

&lt;Name&gt;  FUNCTION &lt;Arg&gt;,..,&lt;Arg&gt;,&lt;Ausdruck&gt;

</PRE>
Die Argumente sind die Werte, die sozusagen in die Funktion
,,hineingesteckt'' werden. In der Definition werden f&uuml;r die
Argumente symbolische Namen gebraucht, damit der Assembler bei der
Benutzung der Funktion wei&szlig;, an welchen Stellen die aktuellen
Werte einzusetzen sind. Dies kann man an folgendem Beispiel sehen:
<PRE>

isgit   FUNCTION ch,(ch&gt;='0')&&(ch&lt;='9')

</PRE>
Diese Funktion &uuml;berpr&uuml;ft, ob es sich bei dem Argument (wenn
man es als Zeichen interpretiert) um eine Ziffer im momentan
g&uuml;ltigen Zeichencode handelt (der momentane Zeichencode ist
mittels<TT> CHARSET</TT> ver&auml;nderbar, daher die vorsichtige
Formulierung).
<P>
Die Argumentnamen (in diesem Falle<TT> CH</TT>) m&uuml;ssen den
gleichen h&auml;rteren Symbolkonventionen gen&uuml;gen wie Parameter
bei einer Makrodefinition, d.h. die Sonderzeichen . und _ sind nicht
erlaubt.
<P>
Selbst definierte Funktionen werden genauso benutzt wie eingebaute,
d.h. mit einer durch Kommas getrennten, geklammerten Argumentliste:
<PRE>

        IF isdigit(Zeichen)
         message "\{Zeichen} ist eine Ziffer"
        ELSEIF
         message "\{Zeichen} ist keine Ziffer"
        ENDIF

</PRE>
<P>
Bei dem Aufruf der Funktion werden die Argumente nur einmal berechnet
und danach an allen Stellen der Formel eingesetzt, um den
Rechenaufwand zu reduzieren und Seiteneffekte zu vermeiden. Bei
Funktionen mit mehreren Argumenten m&uuml;ssen die einzelnen
Argumente bei der Benutzung durch Kommata getrennt werden.
<P>
<B> ACHTUNG!</B> Analog wie bei Makros kann man mit der Definition
von Funktionen bestehende Funktionen umdefinieren. Damit lassen sich
auch wieder Phasenfehler provozieren. Solche Definitionen sollten
daher auf jeden Fall vor der ersten Benutzung erfolgen!
<P>
Der Ergebnistyp kann bei Funktionen vom Typ der Argumente
abh&auml;ngen. So kann bei folgender Funktion
<PRE>

double  function x,x+x

</PRE>
das Ergebnis ein Integer, eine Gleitkommazahl oder sogar ein String
sein, je nach Typ des Arguments!
<P>
Bei der Definition und Ansprache von Funktionen wird im
case-sensitiven Modus zwischen Gro&szlig;- und Kleinschreibung
unterschieden, im Gegensatz zu eingebauten Funktionen!
<P>

<H2><A NAME="sect_3_5_">3.5. Strukturen</A></H2>
<A NAME="index_STRUCT_1"></A><A NAME="index_ENDSTRUCT_1"></A><A
NAME="index_UNION_1"></A><A NAME="index_ENDUNION_1"></A><A
NAME="index_STRUC_1"></A><A NAME="index_ENDSTRUC_1"></A><A
NAME="index_ENDS_1"></A><A NAME="index_DOTTEDSTRUCTS_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Auch in Assemblerprogrammen ergibt sich dann und wann die
Notwendigkeit, analog zu Hochsprachen zusammengesetzte
Datenstrukturen zu definieren. AS unterst&uuml;tzt sowohl die
Definition als auch die Nutzung von Strukturen mit einer Reihe von
Konstrukten und Anweisungen, die im folgenden erl&auml;utert werden
sollen:
<P>

<H3><A NAME="sect_3_5_1_">3.5.1. Definition</A></H3>
<P>
Die Definition einer Struktur wird duch den Befehl<TT> STRUCT</TT>
eingeleitet und durch<TT> ENDSTRUCT</TT> abgeschlossen (schreibfaule
Zeitgenossen d&uuml;rfen aber auch stattdessen<TT> STRUC</TT>
bzw.<TT> ENDSTRUC</TT> oder<TT> ENDS</TT> schreiben). Ein eventuell
diesen Befehlen voranstehendes Label wird als Name der zu
definierenden Struktur genommen; am Ende der Definition ist der Name
optional und kann von zur Festlegung des L&auml;ngennamens (s.u.)
genutzt werden. Das restliche Verfahren ist simpel: Mit einem<TT>
STRUCT</TT> wird der momentane Programmz&auml;hler gesichert und auf
Null zur&uuml;ck gesetzt. Alle zwischen<TT> STRUCT</TT> und<TT>
ENDSTRUCT</TT> definierten Labels ergeben mithin die Offsets der
einzelnen Datenfelder in der Struktur. Die Reservierung des Platzes
f&uuml;r die einzelnen Felder erfolgt mit den f&uuml;r den jeweils
aktiven Zielprozessor zul&auml;ssigen Befehlen zur
Speicherplatzreservierung, also z.B.<TT> DS.x</TT> f&uuml;r die
Motorolas oder<TT> DB</TT> &amp; Co. f&uuml;r Intels. Es gelten hier
auch gleichfalls die Regeln f&uuml;r das Aufrunden von L&auml;ngen,
um Alignments zu erhalten - wer also 'gepackte' Strukturen definieren
will, mu&szlig; eventuell ein<TT> PADDING OFF</TT> voranstellen.
Umgekehrt lassen sich Ausrichtungen nat&uuml;rlich mit Befehlen
wie<TT> ALIGN</TT> erzwingen.
<P>
Da eine solche Definition nur eine Art 'Prototypen' darstellt,
k&ouml;nnen nur Befehle benutzt werden, die Speicherplatz
reservieren, aber keine solchen, die Konstanten im Speicher ablegen
oder Code erzeugen.
<P>
Innerhalb von Strukturen definierte Labels (also die Namen der
Elemente) werden nicht direkt abgespeichert, sondern es wird ihnen
der Name der Struktur vorangestellt, durch ein Trennzeichen
verbunden, bei dem es sich defaultm&auml;&szlig;ig um den Unterstrich
(_) handelt. Dieses Verhalten l&auml;&szlig;t sich aber durch dem<TT>
STRUCT</TT>-Befehl mitgegebene Argumente steuern:
<UL>
<LI> <TT>NOEXTNAMES</TT> unterdr&uuml;ckt das Voranstellen des
    Strukturnamens. Der Programmierer ist in diesem Falle selber
    daf&uuml;r verantworlich, da&szlig; Feldnamen nicht mehrfach
    verwendet werden.</LI>
<LI> <TT>DOTS</TT> weist AS an, als verbindendes Zeichen einen Punkt
    anstelle des Unterstriches zu verwenden. Es sei jedoch
    ausdr&uuml;cklich darauf hingewiesen, da&szlig; der Punkt bei
    vielen Zielprozessoren ein Sonderfunktion zur Bitadressierung hat
    und diese zu Problemen f&uuml;hren kann!</LI>
</UL>
Des weiteren ist es m&ouml;glich, die Verwendung des Punktes durch
den Befehl
<PRE>

        dottedstructs &lt;on|off&gt;

</PRE>
dauerhaft ein- bzw. auszuschalten.
<P>
Neben den Namen der Elemente definiert AS beim Abschlu&szlig; der
Definition ein weiteres Symbol mit dem Namen<TT> LEN</TT>, das nach
dem gleichen Regeln um den Namen der Struktur erweitert wird - oder
um den Label-Namen, der optional bei<TT> ENDSTRUCT</TT> angegeben
werden kann.
<P>
Das ganze sieht dan in der Praxis z.B. so aus:
<PRE>

Rec     STRUCT
Ident   db      ?
Pad     db      ?
Pointer dd      ?
Rec     ENDSTRUCT

</PRE>
Hier w&uuml;rde z.B. dem Symbol<TT> REC_LEN</TT> der Wert 6
zugewiesen.
<P>

<H3><A NAME="sect_3_5_2_">3.5.2. Nutzung</A></H3>
<P>
Ist eine Struktur einmal definiert, ist die Nutzung denkbar einfach
und &auml;hnlich wie ein Makro: ein einfaches
<PRE>

thisrec Rec

</PRE>
reserviert Speicher in der Menge, wie er von der Struktur belegt
wird, und definiert gleichzeitig f&uuml;r jedes Element der Struktur
ein passendes Symbol mit dessen Adresse, in diesem Falle also<TT>
THISREC_IDENT, THISREC_PAD</TT> und<TT> THISREC_POINTER</TT>. Das
Label darf bei dem Aufruf einer Struktur naturgem&auml;&szlig; nicht
fehlen; wenn doch, gibt's eine Fehlermeldung.
<P>
&Uuml;ber zus&auml;tzliche Argumente ist es m&ouml;glich, nicht nur
Speicher f&uuml;r eine einzelne Struktur, sondern ein ganzes Feld
davon zu reservieren. Die (bis zu drei) Dimensionen werden &uuml;ber
in eckige Klammern gesetzte Argumente definiert:
<PRE>

thisarray Rec [10],[2]

</PRE>
In diesem Beispiel wird Platz f&uuml;r 2*10=20 Strukturen reserviert,
und f&uuml;r jede Einzelstruktur werden Symbole erzeugt, die die
Indizes im Namen enthalten.
<P>

<H3><A NAME="sect_3_5_3_">3.5.3. geschachtelte Strukturen</A></H3>
<P>
Es ist ohne weiteres erlaubt, eine bereits definierte Struktur in
einer anderen Struktur aufzurufen. Das dabei ablaufende Verfahren ist
eine Kombination aus den beiden vorigen Punkten: Elemente der
Substruktur werden definiert, mit dem Namen dieser Instanz
vorangestellt, und vor diese zusammengesetzten Namen wird wieder der
Name der Struktur bzw. sp&auml;ter bei einer Benutzung gesetzt. Das
sieht dann z.B. so aus:
<PRE>

TreeRec struct
left    dd         ?
right   dd         ?
data    Rec
TreeRec endstruct

</PRE>
<P>
Ebenso ist es erlaubt, eine Struktur direkt in einer anderen Struktur
zu definieren:
<PRE>

TreeRec struct
left    dd         ?
right   dd         ?
TreeData struct
name      db         32 dup(?)
id        dw         ?
TreeData endstruct
TreeRec endstruct

</PRE>
<P>

<H3><A NAME="sect_3_5_4_">3.5.4. Unions</A></H3>
<P>
Eine Union ist eine Sonderform einer Struktur, bei der die einzelnen
Elemente nicht hintereinander, sondern<EM> &uuml;bereinander</EM>
liegen, d.h. alle Elemente liegen an Startadresse 0 innerhalb der
Struktur und belegen den gleichen Speicherplatz.
Naturgem&auml;&szlig; tut so eine Definition nicht mehr, als einer
Reihe von Symbolen den Wert Null zuzuweisen, sie kann aber sinnvoll
sein, um programmtechnisch die &Uuml;berlappung der Elemente zu
verdeutlichen und den Code so etwas 'lesbarer' zu gestalten. Die
Gr&ouml;&szlig;e einer Struktur ist das Maximum der Gr&ouml;&szlig;en
aller Elemente.
<P>

<H3><A NAME="sect_3_5_5_">3.5.5. Namenlose Strukturen</A></H3>
<P>
Der Name einer Struktur oder Union ist optional, allerdings nur, wenn
diese Teil einer anderen, nicht namenlosen Struktur ist. Elemente
dieser Struktur werden dann Teil der 'n&auml;chsth&ouml;heren'
benamten Struktur:
<PRE>

TreeRec struct
left    dd         ?
right   dd         ?
        struct
name      db         32 dup(?)
id        dw         ?
        endstruct
TreeRec endstruct

</PRE>
erzeugt also die Symbole<TT> TREEREC_NAME</TT> und<TT>
TREEREC_ID</TT>.
<P>
Des weiteren wird f&uuml;r namenlose Strukturen oder Unions kein
Symbol mit deren L&auml;nge angelegt.
<P>

<H3><A NAME="sect_3_5_6_">3.5.6. Strukturen und Sektionen</A></H3>
<P>
Im Verlaufe der Definition oder der Nutzung von Strukturen definierte
Symbole werden genauso behandelt wie normale Symbole, d.h. bei der
Nutzung innerhalb einer Sektion werden diese Symbole als lokal zu
dieser Sektion definiert. Analoges gilt aber auch f&uuml;r die
Strukturen selber, d.h. eine innerhalb einer Sektion definierte
Struktur kann nicht au&euml;rhalb der Sektion benutzt werden.
<P>

<H3><A NAME="sect_3_5_7_">3.5.7. Strukturen und Makros</A></H3>
<P>
Will man Strukturen &uuml;ber Makros instanziieren, so mu&szlig; man
die<TT> GLOBALSYMBOLS</TT>-Option bei der Definition des Makros
benutzen, damit die dar&uuml;ber erzeugten Symbole auch
au&szlig;erhalb des Makros verwendbar sind. Eine Reihe von Strukturen
kann man z.B. so anlegen:
<P>
<PRE>

        irp     name,{GLOBALSYMBOLS},rec1,rec2,rec3
name    Rec
        endm

</PRE>
<P>

<H2><A NAME="sect_3_6_">3.6. bedingte Assemblierung</A></H2>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Der Assembler unterst&uuml;tzt die bedingte Assemblierung mit Hilfe
der Konstrukte<TT> IF</TT>... sowie<TT> SWITCH</TT>... . Diese
Befehle wirken zur Assemblierzeit, indem entsprechend der Bedingung
Teile &uuml;bersetzt oder &uuml;bersprungen werden. Diese Befehle
sind also<I> nicht</I> mit den IF-Statements h&ouml;herer
Programmiersprachen zu vergleichen (obwohl es sehr verlockend
w&auml;re, den Assembler um die Strukturierungsbefehle h&ouml;herer
Sprachen zu erweitern...).
<P>
Die folgenden Konstrukte d&uuml;rfen beliebig (bis zum
Speicher&uuml;berlauf) geschachtelt werden.
<P>

<H3><A NAME="sect_3_6_1_">3.6.1. IF / ELSEIF / ENDIF</A></H3>
<A NAME="index_IF_1"></A><A NAME="index_ELSEIF_1"></A><A
NAME="index_ELSE_1"></A><A NAME="index_ENDIF_1"></A>
<P>
<TT> IF</TT> ist das gebr&auml;uchlichere und allgemeiner verwendbare
Konstrukt. Die allgemeine Form eines<TT> IF</TT>-Befehles lautet
folgenderma&szlig;en:
<PRE>

       IF       &lt;Ausdruck 1&gt;
        &lt;Block 1&gt;
       ELSEIF   &lt;Ausdruck 2&gt;
        &lt;Block 2&gt;
       (evtl. weitere ELSEIFs)
       ELSEIF
        &lt;Block n&gt;
       ENDIF

</PRE>
<TT>IF</TT> dient als Einleitung und wertet den ersten Ausdruck aus
und assembliert Block 1, falls der Ausdruck wahr (d.h. ungleich 0)
ist. Alle weiteren<TT> ELSEIF</TT>-Teile werden dann ignoriert. Falls
der Ausdruck aber nicht wahr ist, wird Block 1 &uuml;bersprungen und
Ausdruck 2 ausgewertet. Sollte dieser nun wahr sein, wird Block 2
assembliert. Die Zahl der<TT> ELSEIF</TT>-Teile ist variabel und
ergibt eine<TT> IF-THEN-ELSE</TT>-Leiter beliebiger L&auml;nge. Der
dem letzten<TT> ELSEIF</TT> (ohne Parameter) zugeordnete Block wird
nur assembliert, falls alle vorigen Ausdr&uuml;cke falsch ergaben und
bildet sozusagen einen ,,Default-Zweig''. Wichtig ist, da&szlig; von
den Bl&ouml;cken immer nur<I> einer</I> assembliert wird, und zwar
der erste, dessen zugeordnetes<TT> IF/ELSEIF</TT> einen wahren
Ausdruck hatte.
<P>
Die<TT> ELSEIF</TT>-Teile sind optional, d.h. auf<TT> IF</TT> darf
auch direkt<TT> ENDIF</TT> folgen, ein parameterloses<TT> ELSEIF</TT>
bildet aber immer den letzten Zweig. Ein<TT> ELSEIF</TT> bezieht sich
immer auf das letzte, noch nicht abgeschlossene<TT> IF</TT>.
<P>
Neben<TT> IF</TT> sind noch folgende weitere bedingte Befehle
definiert:<A NAME="index_IFDEF_1"></A><A NAME="index_IFNDEF_1"></A><A
NAME="index_IFSYMEXIST_1"></A><A NAME="index_IFNSYMEXIST_1"></A><A
NAME="index_IFUSED_1"></A><A NAME="index_IFNUSED_1"></A><A
NAME="index_IFEXIST_1"></A><A NAME="index_IFNEXIST_1"></A><A
NAME="index_IFB_1"></A><A NAME="index_IFNB_1"></A>
<UL>
<LI> <TT>IFDEF</TT> &lt;Ausdruck&gt; : wahr, falls der Ausdruck keine
    Symbole enth&auml;lt, die im bis zu diesem Punkt assemblierten
    Quellcode (noch) nicht definiert wurden. ACHTUNG! Bei
    Vorw&auml;rtsdeklarationen liefert diese Abfrage in allen
    Durchl&auml;ufen ein negatives Ergebnis!</LI>
<LI> <TT>IFNDEF</TT> &lt;Ausdruck&gt; : Umkehrung zu<TT> IFDEF</TT></LI>
<LI> <TT>IFSYMEXIST</TT> &lt;Symbol&gt; : wahr, falls dieses Symbol in
    der Symboltabelle existiert. ACHTUNG! Bei
    Vorw&auml;rtsdeklarationen liefert diese Abfrage im ersten
    Durchlauf ein negatives Ergebnis, aber ein positives in allen
    weiteren!</LI>
<LI> <TT>IFNSYMEXIST</TT> &lt;Symbol&gt; : Umkehrung zu<TT>
    IFSYMEXIST</TT></LI>
<LI> <TT>IFUSED</TT> &lt;Symbol&gt; : wahr, falls das Symbol bisher
    mindestens einmal benutzt wurde. Siehe Abschnitt <A
    HREF="#ref_sect_symused">2.7</A> f&uuml;r Ausnahmen davon.</LI>
<LI> <TT>IFNUSED</TT> &lt;Symbol&gt; : Umkehrung zu<TT> IFUSED</TT></LI>
<LI> <TT>IFEXIST</TT> &lt;Name: &gt; : wahr, falls die angegebene Datei
    existiert. F&uuml;r Schreibweise und Suchpfade gelten gleiche
    Regeln wie beim<TT> INCLUDE</TT>-Befehl (siehe Abschnitt <A
    HREF="#ref_SectInclude">3.9.2</A>).</LI>
<LI> <TT>IFNEXIST</TT> &lt;Name: &gt; : Umkehrung zu<TT>
    IFEXIST</TT></LI>
<LI> <TT>IFB</TT> &lt;Arg-Liste&gt; : wahr, falls alle Argumente der
    Parameterliste leer sind.</LI>
<LI> <TT>IFNB</TT> &lt;Arg-Liste&gt; : Umkehrung zu IFB.</LI>
</UL>
<P>
Anstelle von<TT> ELSEIF</TT> darf auch<TT> ELSE</TT> geschrieben
werden, weil das wohl alle so gewohnt sind....
<P>
Zu jeder<TT> IF...</TT>-Anweisung geh&ouml;rt ein entsprechendes<TT>
ENDIF</TT>, 'offene' Konstrukte f&uuml;hren zu einer Fehlermeldung am
Ende des Assemblierungslaufes. Die Zuordnung, welches<TT> ENDIF</TT>
AS mit welchem<TT> IF...</TT> 'gepaart' hat, l&auml;&szlig;t sich im
Listing erkennen: dort wird die Zeilennummer des entsprechenden<TT>
IF</TT>s angezeigt.
<P>

<H3><A NAME="sect_3_6_2_">3.6.2. SWITCH / CASE / ELSECASE / ENDCASE</A></H3>
<A NAME="index_SWITCH_1"></A><A NAME="index_.SWITCH_1"></A><A
NAME="index_SELECT_1"></A><A NAME="index_CASE_1"></A><A
NAME="index_ELSECASE_1"></A><A NAME="index_ENDCASE_1"></A>
<P>
<TT> SWITCH</TT> ist ein Spezialfall von<TT> IF</TT> und f&uuml;r den
Fall gedacht, da&szlig; ein Ausdruck mit einer Reihe von Werten
verglichen werden soll. Dies ist nat&uuml;rlich auch mit<TT> IF</TT>
und einer Reihe von<TT> ELSEIF</TT>s machbar, die folgende Form
<PRE>

       SWITCH   &lt;Ausdruck&gt;
       ...
       CASE     &lt;Wert 1&gt;
       ...
       &lt;Block 1&gt;
       ...
       CASE &lt;Wert 2&gt;
       ...
       &lt;Block 2&gt;
       ...
       (weitere CASE-Konstrukte)
       ...
       CASE &lt;Wert n-1&gt;
       ...
       &lt;Block n-1&gt;
       ...
       ELSECASE
       ...
       &lt;Block n&gt;
       ...
       ENDCASE

</PRE>
bietet aber den Vorteil, da&szlig; der zu pr&uuml;fende Ausdruck nur
einmal hingeschrieben und berechnet werden mu&szlig;, er ist also
weniger fehleranf&auml;llig und etwas schneller als eine<TT>
IF</TT>-Kette, daf&uuml;r nat&uuml;rlich auch nicht so flexibel.
<P>
Es ist m&ouml;glich, bei den<TT> CASE</TT>-Anweisungen mehrere, durch
Kommata getrennte Werte anzugeben, um den entsprechenden Block in
mehreren F&auml;llen assemblieren zu lassen. Der<TT>
ELSECASE</TT>-Zweig dient wiederum als ,,Auffangstelle'' f&uuml;r den
Fall, da&szlig; keine der<TT> CASE</TT>-Bedingungen greift. Fehlt er
und fallen alle Pr&uuml;fungen negativ aus, so gibt AS eine Warnung
aus.
<P>
Auch wenn die Wertelisten der<TT> CASE</TT>-Teile sich
&uuml;berlappen, so wird immer nur<I> ein</I> Zweig ausgef&uuml;hrt,
und zwar bei Mehrdeutigkeiten der erste.
<P>
<TT> SWITCH</TT> dient nur der Einleitung des ganzen Konstruktes;
zwischen ihm und dem ersten<TT> CASE</TT> darf beliebiger Code stehen
(andere<TT> IF</TT>s d&uuml;rfen aber nicht offen bleiben!), im Sinne
eines durchschaubaren Codes sollte davon aber kein Gebrauch gemacht
werden.
<P>
Ist<TT> SWITCH</TT> auf dem gew&auml;hlten Target ein
Maschinenbefehl, so leitet man das Konstrukt stattdessen mit<TT>
SELECT</TT> ein, oder spricht den Pseudobefehl explizit durch einen
vorangestellten Punk an (<TT>.SWITCH</TT> anstelle von<TT>
SWITCH</TT>).
<P>
&Auml;hnlich wie bei<TT> IF...</TT>-Konstrukten, mu&szlig; es
f&uuml;r jedes<TT> SWITCH</TT> genau ein<TT> ENDCASE</TT> geben.
Analog zu<TT> ENDIF</TT> wird bei<TT> ENDCASE</TT> im Listing die
Zeilennummer des korrespondierenden<TT> SWITCH</TT> angezeigt.
<P>

<H2><A NAME="sect_3_7_">3.7. Listing-Steuerung</A></H2>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>

<H3><A NAME="sect_3_7_1_">3.7.1. PAGE, PAGESIZE</A></H3>
<A NAME="ref_SectPAGE"></A><A NAME="index_PAGE_1"></A><A
NAME="index_.PAGE_1"></A><A NAME="index_PAGESIZE_1"></A>
<P>
Mit<TT> PAGE</TT> kann man AS die Dimensionen des Papiers, auf dem
das Listing ausgedruckt werden soll, mitteilen. Als erster Parameter
wird dabei die Anzahl von Zeilen angegeben, nach der AS automatisch
einen Zeilenvorschub ausgeben soll. Zu ber&uuml;cksichtigen ist
allerdings, da&szlig; bei dieser Angabe die Kopfzeilen inklusive
einer evtl. mit<TT> TITLE</TT> spezifizierten Zeile nicht
mitgerechnet werden. Der Minimalwert f&uuml;r die Zeilenzahl ist 5,
der Maximalwert 255. Eine Angabe von 0 f&uuml;hrt dazu, da&szlig; AS
&uuml;berhaupt keine automatischen Seitenvorsch&uuml;be
ausf&uuml;hrt, sondern nur noch solche, die explizit durch<TT>
NEWPAGE</TT>-Befehle oder implizit am Ende des Listings (z.B. vor der
Symboltabelle) von AS ausgel&ouml;st wurden.
<P>
Die Angabe der Breite des Listings in Zeichen kann als optionaler
zweiter Parameter erfolgen und erf&uuml;llt zwei Zwecke: Zum einen
l&auml;uft der Zeilenz&auml;hler von AS korrekt weiter, wenn eine
Quell-Zeile &uuml;ber mehrere Listing-Zeilen geht, zum anderen gibt
es Drucker (wie z.B. Laserdrucker), die beim &Uuml;berschreiten des
rechten Randes nicht automatisch in eine neue Zeile umbrechen,
sondern den Rest einfach ,,verschlucken''. Aus diesem Grund
f&uuml;hrt AS auch den Zeilenumbruch selbstst&auml;ndig durch, d.h.
zu lange Zeilen werden in Bruchst&uuml;cke zerlegt, die eine
L&auml;nge kleiner oder gleich der eingestellten L&auml;nge haben. In
Zusammenhang mit Druckern, die einen automatischen Zeilenumbruch
besitzen, kann das aber zu doppelten Zeilenvorsch&uuml;ben
f&uuml;hren, wenn man als Breite exakt die Zeilenbreite des Druckers
angibt. Die L&ouml;sung in einem solchen Fall ist, als Zeilenbreite
ein Zeichen weniger anzugeben. Die eingestellte Zeilenbreite darf
zwischen 5 und 255 Zeichen liegen; analog zur Seitenl&auml;nge
bedeutet ein Wert von 0, da&szlig; AS keine Splittung der
Listing-Zeilen vornehmen soll; eine Ber&uuml;cksichtigung von zu
langen Zeilen im Listing beim Seitenumbruch kann dann nat&uuml;rlich
auch nicht mehr erfolgen.
<P>
Die Defaulteinstellung f&uuml;r die Seitenl&auml;nge ist 60 Zeilen,
f&uuml;r die Zeilenbreite 0; letztere Wert wird auch angenommen,
wenn<TT> PAGE</TT> nur mit einem Argument aufgerufen wird.
<P>
Falls<TT> PAGE</TT> auf dem gew&auml;hlten Target bereits ein
Maschinenbefehl ist, benutzt man stattdessen<TT> PAGESIZE</TT>.
Alternativ ist es immer m&ouml;glich, durch Voranstellen eines
Punktes (<TT>.PAGE</TT> anstelle<TT> PAGE</TT>) explizit den
Pseudobefehl anzusprechen.
<P>
<B> ACHTUNG!</B> AS hat keine M&ouml;glichkeit, zu
&uuml;berpr&uuml;fen, ob die eingestellte Listing-L&auml;nge und
Breite mit der Wirklichkeit &uuml;bereinstimmen!
<P>

<H3><A NAME="sect_3_7_2_">3.7.2. NEWPAGE</A></H3>
<A NAME="index_NEWPAGE_1"></A>
<P>
<TT> NEWPAGE</TT> kann dazu benutzt werden, einen Seitenvorschub zu
erzwingen, obwohl die Seite noch gar nicht voll ist. Dies kann z.B.
sinnvoll sein, um logisch voneinander getrennte Teile im
Assemblerprogramm auch seitenm&auml;&szlig;ig zu trennen. Der
programminterne Zeilenz&auml;hler wird zur&uuml;ck gesetzt, der
Seitenz&auml;hler um Eins heraufgez&auml;hlt. Der optionale Parameter
steht in Zusammenhang mit einer hierarchischen Seitennumerierung, die
AS bis zu einer Kapiteltiefe von 4 unterst&uuml;tzt. 0 bedeutet dabei
immer die tiefste Kapitelebene, der Maximalwert kann sich
w&auml;hrend des Laufes ver&auml;ndern, wenn das auch verwirrend
wirken kann, wie folgendes Beispiel zeigt:
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> Seite 1,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 0</TT></TD><TD NOWRAP> &rarr; Seite 2</TD></TR>
    <TR><TD NOWRAP> Seite 2,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 1</TT></TD><TD NOWRAP> &rarr; Seite 2.1</TD></TR>
    <TR><TD NOWRAP> Seite 2.1,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 1</TT></TD><TD NOWRAP> &rarr; Seite 3.1</TD></TR>
    <TR><TD NOWRAP> Seite 3.1,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 0</TT></TD><TD NOWRAP> &rarr; Seite 3.2</TD></TR>
    <TR><TD NOWRAP> Seite 3.2,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 2</TT></TD><TD NOWRAP> &rarr; Seite 4.1.1</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Je nach momentan vorhandener Kapiteltiefe kann<TT> NEWPAGE
&lt;Nummer&gt;</TT> also an verschiedenen Stellen eine Erh&ouml;hung
bedeuten. Ein automatischer Seitenvorschub wegen Zeilen&uuml;berlauf
oder ein fehlender Parameter ist gleichbedeutend mit<TT> NEWPAGE
0</TT>. Am Ende des Listings wird vor Ausgabe der Symboltabelle ein
implizites<TT> NEWPAGE &lt;bish. Maximum&gt;</TT> durchgef&uuml;hrt,
um sozusagen ein neues Hauptkapitel zu beginnen.
<P>

<H3><A NAME="sect_3_7_3_">3.7.3. MACEXP_DFT und MACEXP_OVR</A></H3>
<A NAME="index_MACEXP_1"></A><A NAME="index_MACEXP\_DFT_1"></A><A
NAME="index_MACEXP\_OVR_1"></A><A NAME="ref_MACEXPDFT"></A><A
NAME="ref_MACEXPOVR"></A>
<P>
Ist ein Makro einmal ausgestestet und 'fertig', m&ouml;chte man es
bei Benutzung vielleicht gar nicht mehr im Listing sehen. Wie im
Abschnitt &uuml;ber Makros (<A HREF="#ref_SectMacros">3.4.1</A>)
erl&auml;utert, kann man bei der Definition eines Makros &uuml;ber
Zusatzargumente steuern, ob und wenn ja welche Teile des
Makro-Rumpfes im Listing expandiert werden. F&uuml;r den Fall,
da&szlig; eine ganze Reihe von Makros in Folge definiert werden,
mu&szlig; man dies jedoch nicht f&uuml;r jedes Makro einzeln
festlegen. Der Befehl<TT> MACEXP_DFT</TT> setzt f&uuml;r alle im
folgenden definerten Makros, welche Teile ihres Rumpfes expandiert
werden sollen:
<UL>
<LI> <TT>ON</TT> bzw.<TT> OFF</TT> schalten die Expansion komplett ein
    bzw. aus.</LI>
<LI> Mit den Argumenten<TT> IF</TT> bzw.<TT> NOIF</TT> werden Befehle im
    Rumpf zur bedingten Assemblierung und derentwegen nicht
    assemblierte Code-Teile aus- bzw. eingeblendet.</LI>
<LI> Makro-Definitionen (dazu z&auml;hlen auch<TT> REPT</TT>,<TT>
    WHILE</TT> und<TT> IRP(C)</TT>) k&ouml;nnen &uuml;ber die
    Argumente<TT> MACRO</TT> bzw.<TT> NOMACRO</TT> ein- und
    ausgeblendet werden.</LI>
<LI> Mit den Argumenten<TT> REST</TT> bzw.<TT> NOREST</TT> k&ouml;nnen
    die Zeilen ein- und ausgeblendet werden, die nicht in die ersten
    beiden Klassen fallen.</LI>
</UL>
Default ist<TT> ON</TT>, d.h. im folgenden definierte Makros werden
komplett expandiert, au&szlig;er nat&uuml;rlich bei den einzelnen
Makros wurde dies durch Direktiven &uuml;bersteuert. Weiterhin wirken
angegebene Schalte relativ zur aktuellen Einstellung: ist z.B.
initial alles eingeschaltet, sorgt ein
<BLOCKQUOTE>
    <TT> MACEXP_DFT noif,nomacro</TT>
</BLOCKQUOTE>
daf&uuml;r, da&szlig; nur noch das gelistet wird, was weder eine
Makrodefinition ist noch per bedingter Assemblierung ausgeschlossen
wurde.
<P>
Mit diesem Befehl und den pro Makro setzbaren Direktiven
l&auml;&szlig;t sich f&uuml;r jedes einzelne Makro genau festlegen,
welche Teile bei einer Expansion im Listing erscheinen sollen und
welche nicht. Es kann jedoch in der Praxis auch vorkommen, da&szlig;
man ein bestimmtes Makro an einzelnen Stellen im Quellcode expandiert
haben m&ouml;chte, an anderen jedoch nicht. Dies ist mit dem
Befehl<TT> MACEXP_OVR</TT> m&ouml;glich: er akzeptiert die gleichen
Argumente, diese wirken jedoch als Overrides f&uuml;r alle im
folgenden<EM> expandierten</EM> Makros, im Gegensatz zu<TT>
MACEXP_DFT</TT>, das auf alle im folgenden<EM> definierten</EM>
Makros wirkt. Ist zum Beispiel f&uuml;r ein Makro festgelegt worden,
da&szlig; weder Makrodefinitionen noch per bedingte Assemblierung
ausgeschlossene Teile gelistet werden sollen, so schaltet ein
<BLOCKQUOTE>
    <TT> MACEXP_OVR MACRO</TT>
</BLOCKQUOTE>
f&uuml;r folgende Expansionen das Listen von Makrodefinitionen wieder
ein, w&auml;hrend ein
<BLOCKQUOTE>
    <TT> MACEXP_OVR ON</TT>
</BLOCKQUOTE>
wieder alles ins Listing expandiert.<TT> MACEXP_OVR</TT> ohne
Argumente schaltet wiederum s&auml;mtliche Overrides aus, Makros
verhalten sich bei der Expansion wieder so, wie zum Zeitpunkt ihrer
Definition festgelegt.
<P>
Beide Befehle wirken ebenfalls auf andere Makro-artige Konstrukte
(<TT>REPT, IRP, IRPC WHILE</TT>), da diese aber einmalig ,,in-place''
expandiert werden, verschwimmt der funktionale Unterschied zwischen
den beiden Befehlen - im Zweifelsfalle hat aber der per<TT>
MACEXP_OVR</TT> gesetzte Override eine h&ouml;here Priorit&auml;t.
<P>
Die momentane mit<TT> MACEXP_DFT</TT> gesetzte Einstellung
l&auml;&szlig;t sich aus dem Symbol<TT> MACEXP</TT> auslesen.
Anstelle von<TT> MACEXP_DFT</TT> darf auch einfach<TT> MACEXP</TT>
geschrieben werden, davon sollte aber in neuen Programmen kein
Gebrauch mehr gemacht werden.
<P>

<H3><A NAME="sect_3_7_4_">3.7.4. LISTING</A></H3>
<A NAME="index_LISTING_1"></A>
<P>
Mit diesem Befehl kann das Listing komplett ein- und ausgeschaltet
werden. Nach einem
<PRE>

        LISTING off

</PRE>
wird<I> &uuml;berhaupt</I> nichts mehr im Listing ausgegeben. Diese
Anweisung macht Sinn f&uuml;r erprobte Codeteile oder
Include-Dateien, um den Papierverbrauch nicht ins Unerme&szlig;liche
zu steigern.<B> ACHTUNG!</B> Wer sp&auml;ter das Gegenst&uuml;ck
vergi&szlig;t, bekommt auch keine Symboltabelle mehr zu sehen!
Zus&auml;tzlich zu<TT> ON</TT> und<TT> OFF</TT> akzeptiert<TT>
LISTING</TT> auch<TT> NOSKIPPED</TT> und<TT> PURECODE</TT> als
Argument. Mit der<TT> NOSKIPPED</TT>-Einstellung werden aufgrund
bedingter Assemblierung nicht assemblierte Teile nicht im Listing
aufgef&uuml;hrt, w&auml;hrend<TT> PURECODE</TT> - wie der Name schon
erahnen l&auml;&szlig;t - auch die<TT> IF</TT>-Konstrukte selber
nicht mehr im Listing auff&uuml;hrt. Diese Einstellungen sind
n&uuml;tzlich, wenn man Makros, die anhand von Parametern
verschiedene Aktionen ausf&uuml;hren, benutzt, und im Listing nur
noch die jeweils benutzten Teile sehen m&ouml;chte.
<P>
Die momentane Einstellung l&auml;&szlig;t sich aus dem Symbol<TT>
LISTING</TT> (0=<TT>OFF</TT>, 1=<TT>ON</TT>, 2=<TT>NOSKIPPED</TT>,
3=<TT>PURECODE</TT>) auslesen.
<P>

<H3><A NAME="sect_3_7_5_">3.7.5. PRTINIT und PRTEXIT</A></H3>
<A NAME="index_PRTINIT_1"></A><A NAME="index_PRTEXIT_1"></A>
<P>
Bei der Listingausgabe auf Druckern ist es oftmals sinnvoll, den
Drucker in eine andere Betriebsart (z.B. Schmalschrift) umzuschalten
und am Ende des Listings diese Betriebsart wieder zu deaktivieren.
Mit diesen Befehlen kann die Ausgabe dieser Steuerfolgen
automatisiert werden, indem man mit
<PRE>

        PRTINIT &lt;String&gt;

</PRE>
die Zeichenfolge angibt, die vor Listingbeginn an das
Ausgabeger&auml;t geschickt werden soll und mit
<PRE>

        PRTEXIT &lt;String&gt;

</PRE>
analog den Deinitialisierungsstring. In beiden F&auml;llen
mu&szlig;<TT> &lt;String&gt;</TT> ein Stringausdruck sein. Die
Syntaxregeln f&uuml;r Stringkonstanten erm&ouml;glichen es, ohne
Verrenkungen Steuerzeichen in den String einzubauen.
<P>
Bei der Ausgabe dieser Strings unterscheidet der Assembler<B>
nicht</B>, wohin das Listing geschickt wird, d.h.
Druckersteuerzeichen werden r&uuml;cksichtslos auch auf den
Bildschirm geschickt!
<P>
Beispiel :
<P>
Bei Epson-Druckern ist es sinnvoll, f&uuml;r die breiten Listings in
den Kompre&szlig;druck zu schalten. Die beiden Zeilen
<PRE>

        PRTINIT "\15"
        PRTEXIT "\18"

</PRE>
sorgen daf&uuml;r, da&szlig; der Kompre&szlig;druck ein- und nach dem
Druck wieder ausgeschaltet wird.
<P>

<H3><A NAME="sect_3_7_6_">3.7.6. TITLE</A></H3>
<A NAME="index_TITLE_1"></A>
<P>
Normalerweise versieht der Assembler bereits jede Listingseite mit
einer Titelzeile, die Quelldatei, Datum und Uhrzeit enth&auml;lt. Mit
diesem Befehl kann man den Seitenkopf um eine beliebige
zus&auml;tzliche Zeile erweitern. Der anzugebende String ist dabei
ein beliebiger Stringausdruck.
<P>
Beispiel:
<P>
Bei dem bereits oben angesprochenenen Epson-Drucker soll eine
Titelzeile im Breitdruck ausgegeben werden, wozu vorher der
Kompre&szlig;modus abgeschaltet werden mu&szlig;:
<PRE>

        TITLE   "\18\14Breiter Titel\15"

</PRE>
(Epson-Drucker schalten den Breitdruck automatisch am Zeilenende
aus.)
<P>

<H3><A NAME="sect_3_7_7_">3.7.7. RADIX</A></H3>
<A NAME="index_RADIX_1"></A><A NAME="index_DECIMAL_1"></A><A
NAME="index_OCTAL_1"></A>
<P>
<TT> RADIX</TT> mit einem numerischen Argument zwischen 2 und 36 legt
das Default-Zahlensystem f&uuml;r Integer-Konstanten fest, d.h. das
Zahlensystem, das angenommen wird, wenn man nichts ausdr&uuml;cklich
anderes angegeben hat. Defaultm&auml;&szlig;ig ist dies 10, und bei
der Ver&auml;nderung dieses Wertes sind einige Fallstricke zu
beachten, die in Abschnitt <A HREF="#ref_SectIntConsts">2.9.1</A>
beschrieben sind.
<P>
Unabh&auml;ngig von der momentanen Einstellung ist das Argument
von<TT> RADIX</TT><EM> immer dezimal</EM>; weiterhin d&uuml;rfen
keine symbolischen oder Formelausdr&uuml;cke verwendet werden,
sondern nur einfache Zahlenkonstanten!
<P>
Eine<TT> RADIX</TT>-Anweisung &uuml;bersteuert einen eventuell
gesetzten<TT> -radix</TT>-Schalter auf der Kommandozeile.
<P>
Auf dem IM61x0 stehen die Anweisungen<TT> DECIMAL</TT> und<TT>
OCTAL</TT> zur Verf&uuml;gung, dies sind Kurzschreibweisen
f&uuml;r<TT> RADIX 10</TT> beziehungsweise<TT> RADIX 8</TT>.
<P>

<H3><A NAME="sect_3_7_8_">3.7.8. OUTRADIX</A></H3>
<A NAME="index_OUTRADIX_1"></A>
<P>
<TT> OUTRADIX</TT> is gewisserma&szlig;en das Gegenst&uuml;ck zu<TT>
RADIX</TT>: Mit ihm kann man festlegen, in welchem Zahlensystem
berechnete Integer-Ausdr&uuml;cke in Strings eingesetzt werden
sollen, wenn man \{...}-Konstrukte in Stringkonstanten verwendet
(siehe Abschnitt <A HREF="#ref_SectStringConsts">2.9.3</A>). Als
Argument sind wieder Werte zwischen 2 und 36 erlaubt; der Default ist
16.
<P>

<H2><A NAME="sect_3_8_">3.8. lokale Symbole</A></H2>
<A NAME="ref_ChapLocSyms"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Bei den lokalen Labels und den dazu eingef&uuml;hrten Sektionen
handelt es sich um eine grundlegend neue Funktion, die mit Version
1.39 eingef&uuml;hrt wird. Da dieser Teil sozusagen ,,1.0'' ist, ist
er sicherlich noch nicht der Weisheit letzter Schlu&szlig;.
Anregungen und (konstruktive) Kritik sind daher besonders
erw&uuml;nscht. Insbesondere habe ich die Verwendung von Sektionen
hier so dargestellt, wie ich sie mir vorstelle. Es kann dadurch
passiert sein, da&szlig; die Realit&auml;t nicht ganz meinem Modell
im Kopf entspricht. F&uuml;r den Fall von Diskrepanzen verspreche
ich, da&szlig; die Realit&auml;t der Dokumentation angepa&szlig;t
wird, und nicht umgekehrt, wie es bei gr&ouml;&szlig;eren Firmen
schon einmal vorgekommen sein soll...
<P>
AS erzeugt keinen linkf&auml;higen Code (und wird es wohl auch nicht
in n&auml;herer Zukunft tun<TT> :-(</TT> ). Diese Tatsache zwingt
dazu, ein Programm immer im ganzen zu &uuml;bersetzen. Dieser Technik
gegen&uuml;ber h&auml;tte eine Aufteilung in Linker-Module einige
Vorteile:
<UL>
<LI> k&uuml;rzere &Uuml;bersetzungszeiten, da lediglich die
    ge&auml;nderten Module neu &uuml;bersetzt werden
    m&uuml;ssen;</LI>
<LI> die M&ouml;glichkeit, durch Definition &ouml;ffentlicher und
    privater Symbole definierte Schnittstellen zwischen den Modulen
    festzulegen;</LI>
<LI> Durch die geringere L&auml;nge der einzelnen Module reduziert sich
    die Anzahl der Symbole im einzelnen Modul, so da&szlig;
    k&uuml;rzere und trotzdem eindeutige Symbolnamen benutzt werden
    k&ouml;nnen.</LI>
</UL>
Insbesondere der letzte Punkt hat mich pers&ouml;nlich immer etwas
gest&ouml;rt: War ein Label-Name einmal am Anfang eines 2000 Zeilen
langen Programms benutzt, so durfte er nirgendwo wieder verwendet
werden --- auch nicht am anderen Ende des Quelltextes, wo Routinen
mit ganz anderem Kontext standen. Ich war dadurch gezwungen,
zusammengesetzte Namen der Form
<PRE>

&lt;Unterprogrammname&gt;_&lt;Symbolname&gt;

</PRE>
zu verwenden, die dann L&auml;ngen zwischen 15 und 25 Zeichen hatten
und das Programm un&uuml;bersichtlich machten. Das im folgenden
eingehender beschriebene Sektionen-Konzept sollte zumindest den
beiden letzten genannten Punkten abhelfen. Es ist vollst&auml;ndig
optional: Wollen Sie keine Sektionen verwenden, so lassen Sie es
einfach bleiben und arbeiten weiter wie unter den &auml;lteren
AS-Versionen.
<P>

<H3><A NAME="sect_3_8_1_">3.8.1. Grunddefinition (SECTION/ENDSECTION)</A></H3>
<P>
Eine<I> Sektion</I> stellt einen durch spezielle Befehle eingerahmten
Teil des Assembler-Programms dar und hat einen vom Programmierer
festlegbaren, eindeutigen Namen:
<PRE>

        ...
        &lt;anderer Code&gt;
        ...
        SECTION &lt;Sektionsname&gt;
        ...
        &lt;Code in der Sektion&gt;
        ...
        ENDSECTION [Sektionsname]
        ...
        &lt;anderer Code&gt;
        ...

</PRE>
Der Name f&uuml;r eine Sektion mu&szlig; den Konventionen f&uuml;r
einen Symbolnamen entsprechen; da AS Sektions-und Symbolnamen in
getrennten Tabellen speichert, darf ein Name sowohl f&uuml;r ein
Symbol als auch eine Sektion verwendet werden. Sektionsnamen
m&uuml;ssen in dem Sinne eindeutig sein, da&szlig; auf einer Ebene
nicht zwei Sektionen den gleichen Namen haben d&uuml;rfen (was es mit
den ,,Ebenen'' auf sich hat, erl&auml;utere ich im n&auml;chsten
Abschnitt). Das Argument zu<TT> ENDSECTION</TT> ist optional, es darf
auch weggelassen werden; Falls es weggelassen wird, zeigt AS den
Namen der Sektion an, der er das<TT> ENDSECTION</TT> zugeordnet hat.
Code in einer Sektion wird von AS genauso behandelt wie
au&szlig;erhalb, lediglich mit drei entscheidenden Unterschieden:
<UL>
<LI> Innerhalb der Sektion definierte Symbole (z.B. Labels,<TT>
    EQU</TT>s...) werden mit einer von AS intern vergebenen, der
    Sektion zugeordneten Nummer versehen. Diese Symbole sind von Code
    au&szlig;erhalb der Sektion nicht ansprechbar (das
    l&auml;&szlig;t sich nat&uuml;rlich durch Pseudobefehle
    variieren, aber dazu sp&auml;ter mehr).</LI>
<LI> Durch das zus&auml;tzliche Attribut kann ein Symbolname sowohl
    au&szlig;erhalb der Sektion als auch innerhalb definiert werden,
    das Attribut erlaubt also, Symbolnamen mehrfach zu benutzen, ohne
    da&szlig; AS Protest anmeldet.</LI>
<LI> Falls ein Symbol sowohl au&szlig;erhalb als auch innerhalb definiert
    ist, wird innerhalb der Sektion das ,,lokale'' verwendet, d.h. AS
    sucht in der Symboltabelle zuerst nach einem Symbol des
    gew&uuml;nschten Namens, das auch gleichzeitig der Sektion
    zugeordnet wurde. Erst danach wird nach einem globalen Symbol
    dieses Namens gefahndet.</LI>
</UL>
Mit diesem Mechanismus kann man z.B. den Code in Module aufteilen,
wie man es mit einem Linker getan h&auml;tte. Eine feinere Aufteilung
w&auml;re dagegen, alle Routinen in getrennte Sektionen zu verpacken.
Je nach L&auml;nge der Routinen k&ouml;nnen die nur intern
ben&ouml;tigten Symbole dann sehr kurze Namen haben.
<P>
Defaultm&auml;&szlig;ig unterscheidet AS Gro&szlig;-und
Kleinschreibung in Sektions- namen nicht; schaltet man jedoch in den
case-sensitiven Modus um, so wird die Schreibweise genauso wie bei
Symbolnamen ber&uuml;cksichtigt.
<P>
Die bisher beschriebene Aufteilung w&uuml;rde in etwa der Sprache C
entsprechen, in der alle Funktionen auf gleicher Ebene nebeneinander
stehen. Da mein ,,hochsprachliches'' Vorbild aber Pascal ist, bin ich
noch einen Schritt weiter gegangen:
<P>

<H3><A NAME="sect_3_8_2_">3.8.2. Verschachtelung und Sichtbarkeitsregeln</A></H3>
<P>
Es ist erlaubt, in einer Sektion weitere Sektionen zu definieren,
analog zu der M&ouml;glichkeit in Pascal, in einer Prozedur/Funktion
weitere Prozeduren zu definieren. Dies zeigt folgendes Beispiel:
<PRE>

sym     EQU        0

        SECTION    ModulA
         SECTION    ProcA1
sym       EQU        5
         ENDSECTION ProcA1
         SECTION    ProcA2
sym       EQU        10
         ENDSECTION ProcA2
        ENDSECTION ModulA

        SECTION    ModulB
sym      EQU        15
         SECTION    ProcB
         ENDSECTION ProcB
        ENDSECTION ModulB

</PRE>
Bei der Suche nach einem Symbol sucht AS zuerst ein Symbol, das der
aktuellen Sektion zugeordnet ist, und geht danach die ganze ,,Liste''
der Vatersektionen durch, bis er bei den globalen Symbolen angekommen
ist. Im Beispiel sehen die Sektionen die in Tabelle <A
HREF="#ref_TabSymErg">3.1</A> angegebenen Werte f&uuml;r das
Symbol<TT> sym</TT>.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Sektion</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Wert</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>aus Sektion...</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Global</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Global</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ModulA</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Global</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcA1</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>5</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcA1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcA2</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>10</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcA2</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ModulB</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>15</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ModulB</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcB</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>15</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ModulB</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 3.1: F&uuml;r die einzelnen Sektionen g&uuml;ltigen Werte<A
             NAME="ref_TabSymErg"></A>
</CENTER><P>

Diese Regel kann man durchbrechen, indem man explizit an den
Symbolnamen die Sektion anh&auml;ngt, aus der man das Symbol holen
will, und zwar in eckigen Klammern am Ende des Symbolnamens:
<PRE>

        move.l  #sym[ModulB],d0

</PRE>
Es d&uuml;rfen dabei nur Sektionsnamen verwendet werden, die eine
Obersektion zur aktuellen Sektion darstellen. Als Sonderwert sind die
Namen<TT> PARENT0..PARENT9</TT> erlaubt, mit denen man die n-ten
,,Vatersektionen'' relativ zur momentanen Sektion ansprechen
kann;<TT> PARENT0</TT> entspricht also der momentanen Sektion
selber,<TT> PARENT1</TT> der direkt &uuml;bergeordneten usw.
Anstelle<TT> PARENT1</TT> kann man auch kurz nur<TT> PARENT</TT>
schreiben. L&auml;&szlig;t man dagegen den Platz zwischen den
Klammern komplett frei, also etwa so
<PRE>

        move.l  #sym[],d0 ,

</PRE>
so erreicht man das globale Symbol.<B> ACHTUNG!</B> Wenn man explizit
ein Symbol aus einer Sektion anspricht, so wird auch nur noch bei den
Symbolen dieser Sektion gesucht, der Sektionsbaum wird nicht mehr bis
nach oben durchgegangen!
<P>
Analog zu Pascal ist es erlaubt, da&szlig; verschiedene Sektionen
Untersektionen gleichen Namens haben d&uuml;rfen, das Prinzip der
Lokalit&auml;t verhindert hier Irritationen. M.E. sollte man davon
aber trotzdem sparsamen Gebrauch machen, da in Symbol-und
Querverweisliste Symbole zwar mit der Sektion, in der sie definiert
wurden, gekennzeichnet werden, aber nicht mit der &uuml;ber dieser
Sektion evtl. liegenden ,,Sektionshierarchie'' (das h&auml;tte
einfach den Platz in der Zeile gesprengt); Unterscheidungen sind
dadurch nicht erkennbar.
<P>
Da ein<TT> SECTION</TT>-Befehl von selber kein Label definiert,
besteht hier ein wichtiger Unterschied zu Pascal: Eine
Pascal-Prozedur kann ihre Unterprozeduren/funktionen automatisch
,,sehen'', unter AS mu&szlig; man noch einen Einsprungpunkt extra
definieren. Das kann man z.B. mit folgendem Makro-P&auml;rchen tun:
<PRE>

proc    MACRO   name
        SECTION name
name    LABEL   $
        ENDM

endp    MACRO   name
        ENDSECTION name
        ENDM

</PRE>
Diese Beispiel zeigt gleichzeitig, da&szlig; die Lokalit&auml;t von
Labels in Makros nicht von den Sektionen beeinflu&szlig;t wird,
deshalb der Trick mit dem<TT> LABEL</TT>-Befehl.
<P>
Nat&uuml;rlich ist mit dieser Definition das Problen noch nicht ganz
gel&ouml;st, bisher ist das Einsprung-Label ja noch lokal und von
au&szlig;en nicht zu erreichen. Wer nun meint, man h&auml;tte das
Label einfach nur vor der SECTION-Anweisung plazieren m&uuml;ssen,
sei jetzt bitte ruhig, denn er verdirbt mir den &Uuml;bergang auf das
n&auml;chste Thema:
<P>

<H3><A NAME="sect_3_8_3_">3.8.3. PUBLIC und GLOBAL</A></H3>
<P>
Die<TT> PUBLIC</TT>-Anweisung erlaubt es, die Zugeh&ouml;rigkeit
eines Symbols zu einer bestimmten Sektion zu ver&auml;ndern. Es ist
m&ouml;glich, mit einem<TT> PUBLIC</TT>-Befehl mehrere Symbole zu
bearbeiten, ohne Beschr&auml;nkung der Allgemeinheit will ich aber
ein Beispiel mit nur einer Variable verwenden: Im einfachsten Falle
erkl&auml;rt man ein Symbol als vollst&auml;ndig global, d.h. es ist
von allen Stellen des Programms ansprechbar:
<PRE>

        PUBLIC  &lt;Name&gt;

</PRE>
Da ein Symbol bei seiner Definition endg&uuml;ltig in der
Symboltabelle einsortiert wird, mu&szlig; diese Anweisung<B> vor</B>
der Definition des Symbols erfolgen. Alle<TT> PUBLIC</TT>s werden von
AS in einer Liste vermerkt und bei ihrer Definition aus dieser Liste
wieder entfernt. Bei Beendigung einer Sektion gibt AS Fehlermeldungen
f&uuml;r alle nicht aufgel&ouml;sten ,,Vorw&auml;rtsreferenzen'' aus.
<P>
Angesichts des hierarchischen Sektionenkonzepts erscheint die
Methode, ein Symbol als vollst&auml;ndig global zu definieren,
reichlich brachial. Es geht aber auch etwas differenzierter, indem
man zus&auml;tzlich einen Sektionsnamen angibt:
<PRE>

        PUBLIC  &lt;Name&gt;:&lt;Sektion&gt;

</PRE>
Damit wird das Symbol der genannten Sektion zugeordnet und damit auch
allen ihren Untersektionen zug&auml;nglich (es sei denn, diese
definieren wiederum ein Symbol gleichen Namens, das dann das
,,globalere'' &uuml;bersteuert). Naturgem&auml;&szlig; protestiert
AS, falls mehrere Untersektionen ein Symbol gleichen Namens auf die
gleiche Ebene exportieren wollen. Als Spezialwert f&uuml;r<TT>
&lt;Sektion&gt;</TT> sind die im vorigen Abschnitt genannten<TT>
PARENTx</TT>-Namen zugelassen, um das Symbol genau n Ebenen
hinaufzuexportieren. Es sind als Sektionen nur der momentanen Sektion
&uuml;bergeordnete Sektionen zugelassen, also keine, die im Baum
aller Sektionen in einem anderen Zweig stehen. Sollten dabei mehrere
Sektionen den gleichen Namen haben (dies ist legal), so wird die
tiefste gew&auml;hlt.
<P>
Mit diesem Werkzeug kann das obige Prozedurmakro nun Sinn ergeben:
<PRE>

proc    MACRO   name
        SECTION name
        PUBLIC  name:PARENT
name    LABEL   $
        ENDM

</PRE>
Diese Einstellung entspricht dem Modell von Pascal, in der eine
Unterprozedur auch nur von ihrem ,,Vater'' gesehen werden kann,
jedoch nicht vom ,,Gro&szlig;vater''.
<P>
Falls mehrere Untersektionen versuchen, ein Symbol gleichen Namens in
die gleiche Obersektion zu exportieren, meckert AS &uuml;ber doppelt
definierte Symbole, was an sich ja korrekt ist. War das gewollt, so
mu&szlig; man die Symbole in irgendeiner Weise ,,qualifizieren'',
damit sie voneinander unterschieden werden k&ouml;nnen. Dies ist mit
der<TT> GLOBAL</TT>-Anweisung m&ouml;glich. Die Syntax von<TT>
GLOBAL</TT> ist der von<TT> PUBLIC</TT> identisch, das Symbol bleibt
aber lokal, anstatt einer h&ouml;heren Sektion zugeordnet zu werden.
Stattdessen wird ein weiteres Symbol gleichen Werts erzeugt, dem
jedoch der Untersektionsname mit einem Unterstrich vorangestellt
wird, und nur dieses Symbol wird der Sektionsangabe entsprechend
&ouml;ffentlich gemacht. Definieren z.B. zwei Sektionen<TT> A</TT>
und<TT> B</TT> ein Symbol<TT> SYM</TT> und exportieren es mit<TT>
GLOBAL</TT> zu ihrer Vatersektion, so werden dort die Symbole unter
den Namen<TT> A_SYM</TT> und<TT> B_SYM</TT> eingeordnet.
<P>
Falls zwischen Quell- und Zielsektion mehrere Stufen stehen sollten,
so wird entsprechend der komplette Namenszweig von der Ziel- bis zur
Quellsektion dem Symbolnamen vorangestellt.
<P>

<H3><A NAME="sect_3_8_4_">3.8.4. FORWARD</A></H3>
<P>
So sch&ouml;n das bisher besprochene Modell ist, ein bei Pascal nicht
auftauchendes Detail macht &Auml;rger: die bei Assembler
m&ouml;glichen Vorw&auml;rtsreferenzen. Bei Vorw&auml;rtsreferenzen
kann es sein, da&szlig; AS im ersten Pass auf ein Symbol einer
h&ouml;heren Sektion zugreift. Dies ist an sich nicht weiter
tragisch, solange im zweiten Pass das richtige Symbol genommen wird,
es k&ouml;nnen aber Unf&auml;lle der folgenden Art passieren:
<PRE>

loop:   .
        &lt;Code&gt;
        ..
        SECTION sub
        ..              ; ***
        bra.s   loop
        ..
loop:   ..
        ENDSECTION
        ..
        jmp     loop    ; Hauptschleife

</PRE>
AS wird im ersten Pass das globale Label<TT> loop</TT> verwenden,
sofern das Programmst&uuml;ck bei<TT> &lt;Code&gt;</TT> hinreichend
lang ist, wird er sich &uuml;ber eine zu gro&szlig;e Sprungdistanz
beklagen und den zweiten Pass erst gar nicht versuchen. Um die
Uneindeutigkeit zu vermeiden, kann man den Symbolnamen mit einem
expliziten Bezug versehen:
<PRE>

        bra.s   loop[sub]

</PRE>
Falls ein lokales Symbol h&auml;ufig referenziert wird, k&ouml;nnen
die vielen Klammern mit dem<TT> FORWARD</TT>-Befehl eingespart
werden. Das Symbol wird damit explizit als lokal angek&uuml;ndigt. AS
wird bei Zugriffen auf dieses Symbol automatisch nur im lokalen
Symbolbereich suchen. In diesem Falle m&uuml;&szlig;te an der mit<TT>
***</TT> gekennzeichneten Stelle daf&uuml;r der Befehl
<PRE>

        FORWARD loop

</PRE>
stehen. Damit<TT> FORWARD</TT> Sinn macht, mu&szlig; es nicht nur vor
der Definition des Symbols, sondern vor seiner ersten Benutzung in
der Sektion gegeben werden. Ein Symbol gleichzeitig privat und
&ouml;ffentlich zu definieren, ergibt keinen Sinn und wird von AS
auch angemahnt.
<P>
Im Gegensatz zu<TT> PUBLIC</TT> und<TT> GLOBAL</TT> darf<TT>
FORWARD</TT> auch au&szlig;erhalb von Sektionen verwendet werden. In
diesem Fall bleibt die Funktion erhalten, da&szlig; in der
Symboltabelle ein 'Platzhalter-Eintrag' angelegt wird. Dieser
enth&auml;lt zwar keinen Wert, und die Bezugnahme auf so einen
Eintrag wird wie der Zugriff auf ein (bisher) nicht definiertes
Symbol behandelt. Es wird in so einem Fall aber das Used-Flag an
diesem Platzhalter-Eintrag gesetzt. Eine<TT> FORWARD</TT>-Deklaration
eines Symbols kann daher n&uuml;tzlich sein, wenn ein Symbol per<TT>
SYMUSED</TT> auf Benutzung gepr&uuml;ft werden soll, und es
Referenzen vor seiner eigentlichen Definition im Quellcode gibt.
<P>

<H3><A NAME="sect_3_8_5_">3.8.5. Geschwindigkeitsaspekte</A></H3>
<P>
Die mehrstufige Suche in der Symboltabelle und die Entscheidung, mit
welchem Attribut ein Symbol eingetragen werden soll, kosten
naturgem&auml;&szlig; etwas Rechenzeit. Ein 1800 Zeilen langes
8086-Programm z.B. wurde nach der Umstellung auf Sektionen statt in
33 in 34,5 Sekunden assembliert (80386 SX, 16MHz, 3 Durchg&auml;nge).
Der Overhead h&auml;lt sich also in Grenzen: Ob man ihn in Kauf
nehmen will, ist (wie am Anfang erw&auml;hnt) eine Frage des
Geschmacks; man kann AS genauso gut ohne Sektionen verwenden.
<P>

<H2><A NAME="sect_3_9_">3.9. Diverses</A></H2>
<P>

<H3><A NAME="sect_3_9_1_">3.9.1. SHARED</A></H3>
<A NAME="ref_ChapShareOrder"></A><A NAME="index_SHARED_3"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit diesem Befehl weist man den AS an, die in der Parameterliste
angegebenen Symbole (egal ob Integer, Gleitkomma oder String) im
Sharefile mit ihren Werten abzulegen. Ob eine solche Datei
&uuml;berhaupt und in welchem Format erzeugt wird, h&auml;ngt von den
in <A HREF="#ref_SectCallConvention">2.4</A> beschriebenen
Kommandozeilenschaltern ab. Findet AS diesen Befehl und es wird keine
Datei erzeugt, f&uuml;hrt das zu einer Warnung.
<P>
<B> VORSICHT!</B> Ein eventuell der Befehlszeile anh&auml;ngender
Kommentar wird in die erste, ausgegebene Zeile mit &uuml;bertragen
(sofern die Argumentliste von<TT> SHARED</TT> leer ist, wird nur der
Kommentar ausgegeben). Falls die Share-Datei f&uuml;r C oder Pascal
erzeugt wird, sind einen C/Pascal-Kommentar schlie&szlig;ende
Zeichenfolgen (*/ bzw. *)) im Kommentar zu vermeiden. AS pr&uuml;ft
dies<I> nicht</I>!
<P>

<H3><A NAME="sect_3_9_2_">3.9.2. INCLUDE</A></H3>
<A NAME="index_INCLUDE_1"></A><A NAME="ref_SectInclude"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Dieser Befehl f&uuml;gt die im Parameter angegebene Datei (die
optional in G&auml;nsef&uuml;&szlig;chen eingeschlossen sein darf) so
im Text ein, als ob sie dort stehen w&uuml;rde. Dieser Befehl ist
sinnvoll, um Quelldateien aufzuspalten, die alleine nicht in den
Speicher passen w&uuml;rden oder um sich ''Toolboxen'' zu erzeugen.
<P>
Falls der angegebene Dateiname keine Endung hat, wird in einem ersten
Schritt eine Endung<TT> .INC</TT> angenommen. Erst wenn keine solche
Datei existiert, oder der angegebene Name bereits einen Punkt und
damit eine Endung enth&auml;lt, wird nach einer Datei genau mit dem
anggegebenen Namen gesucht.
<P>
Der Assembler versucht als erstes, die Datei in dem Verzeichnis zu
finden, in dem sich auch die Quelldatei befindet, die das<TT>
INCLUDE</TT>-Statement enth&auml;lt - ein eventuell in der
Dateiangabe enthaltener Pfad ist also relativ zu deren Pfad, und
nicht zu dem Verzeichnis, von dem aus man den Assembler aufgerufen
hat. Mit der Kommandozeilenoption
<PRE>

   -i &lt;Pfadliste&gt;

</PRE>
l&auml;&szlig;t sich eine Liste von Verzeichnissen angeben, in denen
automatisch zus&auml;tzlich nach der Include-Datei gesucht werden
soll. Wird die Datei nicht gefunden, so ist dies ein<I> fataler</I>
Fehler, d.h. der Assembler bricht sofort ab.
<P>
Aus Kompatibilit&auml;tsgr&uuml;nden ist es erlaubt, den Namen in
G&auml;nsef&uuml;&szlig;chen zu schreiben,
<PRE>

        INCLUDE stddef51

</PRE>
und
<PRE>

        INCLUDE "stddef51.inc"

</PRE>
sind also &auml;quivalent.<B> ACHTUNG!</B> Wegen dieser Wahlfreiheit
ist hier nur eine Stringkonstante, aber kein Stringausdruck
zul&auml;ssig!
<P>

<H3><A NAME="sect_3_9_3_">3.9.3. BINCLUDE</A></H3>
<A NAME="index_BINCLUDE_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> BINCLUDE</TT> dient dazu, in den von AS erzeugten Code
Bin&auml;rdaten einzubetten, die von einem anderen Programm erzeugt
wurden (das kann nat&uuml;rlich theoretisch auch von AS selber
erzeugter Code sein...).<TT> BINCLUDE</TT> hat drei Formen:
<PRE>

   BINCLUDE &lt;Datei&gt;

</PRE>
In dieser Form wird die Datei komplett eingebunden.
<PRE>

   BINCLUDE &lt;Datei&gt;,&lt;Offset&gt;

</PRE>
In dieser Form wird der Inhalt der Datei ab &lt;Offset&gt; bis zum
Ende der Datei eingebunden.
<PRE>

   BINCLUDE &lt;Datei&gt;,&lt;Offset&gt;,&lt;Len&gt;

</PRE>
In dieser Form werden &lt;Len&gt; Bytes ab Offset &lt;Offset&gt;
eingebunden.
<P>
Es gelten die gleichen Regeln bez&uuml;glich Suchpfaden und
impliziten Suffixen wie bei<TT> INCLUDE</TT>.
<P>

<H3><A NAME="sect_3_9_4_">3.9.4. MESSAGE, WARNING, ERROR und FATAL</A></H3>
<A NAME="index_MESSAGE_1"></A><A NAME="index_WARNING_1"></A><A
NAME="index_ERROR_1"></A><A NAME="index_FATAL_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Der Assembler pr&uuml;ft zwar die Quelltexte so streng wie
m&ouml;glich und liefert differenzierte Fehlermeldungen, je nach
Anwendung kann es aber sinnvoll sein, unter bestimmten Bedingungen
zus&auml;tzliche Fehlermeldungen auszul&ouml;sen, mit denen sich
logische Fehler automatisch pr&uuml;fen lassen. Der Assembler
unterscheidet drei Typen von Fehlermeldungen, die &uuml;ber die drei
Befehle auch dem Programmierer zug&auml;nglich sind:
<UL>
<LI> <TT>WARNING</TT>: Fehler, die auf m&ouml;glicherweise falschen oder
    ineffizienten Code hinweisen. Die Assemblierung l&auml;uft
    weiter, eine Codedatei wird erzeugt.</LI>
<LI> <TT>ERROR</TT>: echte Fehler im Programm. Die Assemblierung
    l&auml;uft weiter, um m&ouml;gliche weitere Fehler in einem
    Durchgang entdecken und korrigieren zu k&ouml;nnen. Eine
    Codedatei wird nicht erzeugt.</LI>
<LI> <TT>FATAL</TT>: schwerwiegende Fehler, die einen sofortigen Abbruch
    des Assemblers bedingen. Eine Codedatei kann m&ouml;glicherweise
    entstehen, ist aber unvollst&auml;ndig.</LI>
</UL>
Allen drei Befehlen ist das Format gemeinsam, in dem die
Fehlermeldung angegeben werden mu&szlig;: Ein beliebiger
String-Ausdruck, der sowohl eine einfache Konstante als auch eine
komplizierte Formel sein darf, die zu einem String evaluiert. Dies
schlie&szlig;t auch die in <A HREF="#ref_SectSymConv">2.7</A>
beschriebene Funktion ein, um Zahlenwerte mit auszugeben:
<PRE>

       message "Startadresse ist \{start_address}"

</PRE>
Diejenigen Anweisungen, die Warnungen oder Fehlermeldungen erzeugen,
ergeben nur in Zusammenhang mit bedingter Assemblierung Sinn. Ist
f&uuml;r ein Programm z.B. nur ein begrenzter Adre&szlig;raum
vorhanden, so kann man den &Uuml;berlauf folgenderma&szlig;en testen:
<PRE>

ROMSize equ     8000h   ; 27256-EPROM

ProgStart: ..
        &lt;das eigentliche Programm&gt;
           ..
ProgEnd:
        if      ProgEnd-ProgStart&gt;ROMSize
         error   "\aDas Programm ist zu lang!"
        endif

</PRE>
Neben diesen fehlererzeugenden Befehlen gibt es noch den Befehl<TT>
MESSAGE</TT>, der einfach nur eine Meldung im Listing und auf der
Konsole erzeugt (letzteres nur, wenn nicht im quiet-Modus gearbeitet
wird). Seine Benutzung ist den anderen drei Befehlen gleich.
<P>

<H3><A NAME="sect_3_9_5_">3.9.5. READ</A></H3>
<A NAME="index_READ_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> READ</TT> ist sozusagen das Gegenst&uuml;ck zu der vorigen
Befehlsgruppe: mit ihm ist es m&ouml;glich,<I> w&auml;hrend</I> der
Assemblierung Werte von der Tastatur einzulesen. Wozu das gut sein
soll? Um das darzulegen, soll hier ausnahmsweise einmal das Beispiel
vor die genauere Erl&auml;uterung gezogen werden:
<P>
Ein Programm ben&ouml;tigt zum Datentransfer einen Puffer mit einer
zur &Uuml;bersetzungszeit festzulegenden Gr&ouml;&szlig;e. Um die
Gr&ouml;&szlig;e des Puffers festzulegen, k&ouml;nnte man sie einmal
mit<TT> EQU</TT> in einem Symbol ablegen, es geht aber auch
interaktiv mit<TT> READ</TT> :
<PRE>

        IF      MomPass=1
         READ    "Puffer (Bytes)",BufferSize
        ENDIF

</PRE>
Auf diese Weise k&ouml;nnen Programme sich w&auml;hrend der
&Uuml;bersetzung interaktiv konfigurieren, man kann sein Programm
z.B. jemandem geben, der es mit seinen Parametern &uuml;bersetzen
kann, ohne im Quellcode ,,herumstochern'' zu m&uuml;ssen. Die im
Beispiel gezeigte<TT> IF-</TT> Abfrage sollte &uuml;brigens immer
verwendet werden, damit der Anwender nur einmal mit der Abfrage
bel&auml;stigt wird.
<P>
<TT> READ</TT> &auml;hnelt sehr stark dem<TT> SET-</TT> Befehl, nur
da&szlig; der dem Symbol zuzuweisende Wert nicht rechts vom
Schl&uuml;sselwort steht, sondern von der Tastatur eingelesen wird.
Dies bedeutet z.B. auch, da&szlig; AS anhand der Eingabe automatisch
festlegt, ob es sich um eine Integer- oder Gleitkommazahl oder einen
String handelt und anstelle einzelner Konstanten auch ganze
Formelausdr&uuml;cke eingegeben werden k&ouml;nnen.
<P>
<TT> READ</TT> darf entweder nur einen Parameter oder zwei Parameter
haben, denn die Meldung zur Eingabeaufforderung ist optional. Fehlt
sie, so gibt AS eine aus dem Symbolnamen konstruierte Meldung aus.
<P>

<H3><A NAME="sect_3_9_6_">3.9.6. INTSYNTAX</A></H3>
<A NAME="ref_SectINTSYNTAX"></A><A NAME="index_INTSYNTAX_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit diesem Befehl kann die Menge der Schreibweisen, die f&uuml;r
Integer-Konstanten in verschiedenen Zahlensystemen zul&auml;ssig
sind, ver&auml;ndert werden. Nach Auswahl eines bestimmten Zieles
gilt ein bestimmter Default-Satz (siehe Abschnitt <A
HREF="#ref_SectPseudoInst">E</A>), der um einzelne Schreibweisen
erg&auml;nzt oder bereinigt werden kann.<TT> INTSYNTAX</TT>
akzeptiert eine beliebige Liste von Argumenten, von denen jedes mit
einem Plus- oder Minuszeichen beginnt, direkt gefolgt von der Kennung
der jeweiligen Schreibweise. So stellt man z.B. mit folgendem Befehl
<PRE>

       intsyntax    -0oct,+0hex

</PRE>
ein, da&szlig; eine f&uuml;hrende Null keine Oktal-, sondern eine
Hexadezimalzahl kennzeichnet, was bei manchen Assemblern f&uuml;r den
SC/MP gebr&auml;uchlich ist. Die Kennungen f&uuml;r die einzelnen
Schreibweisen finden sich in Tabelle <A
HREF="#ref_TabSystems">2.7</A>. Den Kombinationsm&ouml;glichkeiten
sind keine Grenzen gesetzt, au&szlig;er wenn sich zwei Schreibweisen
direkt widersprechen. Im obigen Beispiel w&auml;re es z.B. nicht
erlaubt, gleichzeitig<TT> 0oct</TT> und<TT> 0hex</TT> einzuschalten.
<P>

<H3><A NAME="sect_3_9_7_">3.9.7. RELAXED</A></H3>
<A NAME="ref_SectRELAXED"></A><A NAME="index_RELAXED_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Defaultm&auml;&szlig;ig ist einer Prozessorfamilie eine bestimmte
Schreibweise von Integer-Konstanten zugeordnet (die i.a. der
Herstellervorgabe entspricht, solange der nicht eine allzu
abgefahrene Syntax benutzt...). Nun hat aber jeder seine
pers&ouml;nlichen Vorlieben f&uuml;r die eine oder andere
Schreibweise und kann gut damit leben, da&szlig; sich seine Programme
nicht mehr mit dem Standard-Assembler &uuml;bersetzen lassen. Setzt
man ein
<PRE>

        RELAXED ON

</PRE>
an den Programmanfang, so kann man fortan alle Schreibweisen beliebig
gemischt und durcheinander verwenden; bei jedem Ausdruck versucht AS
automatisch zu ermitteln, welche Schreibweise verwendet wurde.
Da&szlig; diese Automatik nicht immer das Ergebnis liefert, das man
sich vorgestellt hat, ist auch der Grund, weshalb diese Option
explizit eingeschaltet werden mu&szlig; (und man sich davor
h&uuml;ten sollte, sie einfach in einem existierenden Programm
dazuzusetzen): Ist nicht durch vor- oder nachgestellte Zeichen zu
erkennen, da&szlig; es sich um Intel- oder Motorola-Konstanten
handelt, wird im C-Modus gearbeitet. Eventuell vorangestellte,
eigentlich &uuml;berfl&uuml;ssige Nullen haben in diesem Modus
durchaus eine Bedeutung:
<PRE>

        move.b  #08,d0

</PRE>
Diese Konstante w&uuml;rde als Oktalkonstante verstanden werden, und
weil Oktalzahlen nur Ziffern von 0..7 enthalten k&ouml;nnen,
f&uuml;hrt das zu einem Fehler. Dabei h&auml;tte man in diesem Fall
noch Gl&uuml;ck gehabt, bei der Zahl<TT> 077</TT> z.B. h&auml;tte man
ohne Meldung Probleme bekommen. Ohne<TT> RELAXED</TT>-Modus w&auml;re
in beiden F&auml;llen klar gewesen, da&szlig; es sich um dezimale
Konstanten handelt.
<P>
Die momentane Einstellung kann aus dem gleichnamigen Symbol
ausgelesen werden.
<P>

<H3><A NAME="sect_3_9_8_">3.9.8. COMPMODE</A></H3>
<A NAME="ref_SectCompMode"></A><A NAME="index_COMPMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: verschiedene</EM>
<P>
Auch wenn sich AS bem&uuml;ht, sich m&ouml;glichst genauso zu
verhalten wie die jeweiligen ''Original-Assembler'', so gibt es in
der Praxis immer wieder Details, wo ein hundertprozentiges Nachbilden
des jeweiligen Original- Verhaltens Optimierungen verhindern
w&uuml;rde, die aus meiner Sicht valide und n&uuml;tzlich sind. Mit
einem
<PRE>

        compmode on

</PRE>
kann man in eine Betriebsart umschalten, die dem
''Original-Verhalten'' Vorrang vor optimalem Code gibt. Ob f&uuml;r
das jeweilige Target solche F&auml;lle vorliegen, ist im jeweiligen
Unterkapitel mit dem prozessorspezifischen Hinweisen ausgef&uuml;hrt.
<P>
Im Default ist dieser Kompatibilit&auml;ts-Modus ausgeschaltet,
au&szlig;er er wurde durch die gleichnamige Kommandozeilen-Option
eingeschaltet. Die momentane Einstellung kann aus dem gleichnamigen
Symbol ausgelesen werden.
<P>

<H3><A NAME="sect_3_9_9_">3.9.9. END</A></H3>
<A NAME="index_END_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> END</TT> kennzeichnet das Ende des Assemblerprogrammes. Danach
noch in der Quelldatei stehende Zeilen werden ignoriert.<B>
WICHTIG:</B><TT> END</TT> darf zwar aus einem Makro heraus aufgerufen
werden, der Stapel der bedingten Assemblierung wird aber nicht
automatisch abger&auml;umt. Das folgende Konstrukt f&uuml;hrt daher
zu einer Fehlermeldung:
<PRE>

        IF      KeineLustMehr
         END
        ENDIF

</PRE>
Optional darf<TT> END</TT> auch einen Integer-Ausdruck als Argument
haben, der den Startpunkt des Programms vermerkt. Dieser wird von AS
in einem speziellen Record der Datei vermerkt und kann z.B. von P2HEX
weiterverarbeitet werden.
<P>
<TT> END</TT> war eigentlich schon immer in AS definiert, nur war es
bei fr&uuml;heren Versionen von AS aus Kompatibilit&auml;t zu anderen
Assemblern vorhanden und hatte keine Wirkung.
<P>

<H1><A NAME="sect_4_">4. Prozessorspezifische Hinweise</A></H1>
<P>
Ich habe mich bem&uuml;ht, die einzelnen Codegeneratoren
m&ouml;glichst kompatibel zu den Originalassemblern zu halten, jedoch
nur soweit, wie es keinen unvertretbaren Mehraufwand bedeutete.
Wichtige Unterschiede, Details und Fallstricke habe ich im folgenden
aufgelistet.
<P>

<H2><A NAME="sect_4_1_">4.1. 6811</A></H2>
<P>
,,Wo gibt es denn das zu kaufen, den HC11 in NMOS?'', fragt jetzt
vielleicht der eine oder andere. Gibt es nat&uuml;rlich nicht, aber
ein H l&auml;&szlig;t sich nun einmal nicht in einer Hexzahl
darstellen (&auml;ltere Versionen von AS h&auml;tten solche Namen
deswegen nicht akzeptiert), und dann habe ich die Buchstaben gleich
ganz weggelassen...
<P>
<BLOCKQUOTE>
    <I> ,,Jemand, der sagt, etwas sei unm&ouml;glich,sollte
    wenigstens so kooperativ sein, denjenigen, der es gerade tut,
    nicht am Arbeiten zu hindern.''</I>
</BLOCKQUOTE>
Ab und zu ist man gezwungen, seine Meinung zu revidieren. Vor einigen
Versionen hatte ich an dieser Stelle noch behauptet, ich k&ouml;nne
es im Parser von AS nicht realisieren, da&szlig; man die Argumente
von<TT> BSET/BCLR</TT> bzw.<TT> BRSET/BRCLR</TT> auch mit Leerzeichen
trennen kann. Offensichtlich kann selbiger aber mehr, als ich
vermutet habe...nach der soundsovielten Anfrage habe ich mich noch
einmal drangesetzt, und jetzt scheint es zu laufen. Man darf sowohl
Leerzeichen als auch Kommas verwenden, aber nicht in allen Varianten,
um es nicht uneindeutig zu machen: Es gibt zu jeder Befehlsvariante
zwei M&ouml;glichkeiten; eine, die nur Kommas verwendet, sowie eine,
wie sie von Motorola wohl definiert wurde (leider sind die
Datenb&uuml;cher nicht immer so gut wie die zugeh&ouml;rige
Hardware...):
<PRE>

   Bxxx  abs8 #mask         entspricht    Bxxx  abs8,#mask
   Bxxx  disp8,X #mask      entspricht    Bxxx  disp8,X,#mask
   BRxxx abs8 #mask adr     entspricht    BRxxx abs8,#mask,adr
   BRxxx disp8,X #mask adr  entspricht    BRxxx disp8,X,#mask,adr

</PRE>
Dabei steht<TT> xxx</TT> entweder f&uuml;r<TT> SET</TT> oder<TT>
CLR</TT> und<TT> #mask</TT> f&uuml;r die zu verwendende Bitmaske; der
Lattenzaun ist dabei optional. Anstelle des X-Registers darf
nat&uuml;rlich auch Y verwendet werden.
<P>
Mit der K4-Version des HC11 hat Motorola ein Banking-Schema
eingef&uuml;hrt, mit dem man zwar einerseits eine zu klein gewordene
Architektur noch einmal aufbohren kann, den Software- und
Tool-Entwicklern aber nicht unbedingt das Leben einfacher macht...wie
stellt man so etwas vern&uuml;nftig dar?
<P>
Die K4-Architektur<EM> erweitert</EM> den Adre&szlig;raum des HC11 um
2x512 Kbyte, so da&szlig; jetzt insgesamt 64+1024=1088 Kbyte zur
Verf&uuml;gung stehen. AS tut so, als ob es sich dabei um einen
Adre&szlig;raum handeln w&uuml;rde, der folgenderma&szlig;en
organisiert ist:
<UL>
<LI> $000000...$00ffff: der alte HC11-Adre&szlig;raum</LI>
<LI> $010000...$08ffff: Fenster 1</LI>
<LI> $090000...$10ffff: Fenster 2</LI>
</UL>
&Uuml;ber den<TT> ASSUME</TT>-Befehl teilt man AS mit, wie die
Banking-Register eingestellt sind und damit, wie und wo die
erweiterten Bereiche eingeblendet werden. Bei absoluten
Adressierungen mit Adressen jenseits $10000 berechnet AS dann
automatisch, welche Adresse innerhalb der ersten 64K anzusprechen
ist. Das kann nat&uuml;rlich wieder nur f&uuml;r direkte
Adressierungsarten funktionieren, bei indizierten/indirekten
Adre&szlig;ausdr&uuml;cken ist der Programmierer daf&uuml;r
verantwortlich, &uuml;ber die momentan aktiven Banks den
&Uuml;berblick zu behalten!
<P>
Wer sich nicht ganz sicher ist, ob die momentane Einstellung korrekt
ist, kann den Pseudobefehl<TT> PRWINS</TT> benutzen, der dann z.B.
<PRE>

MMSIZ e1 MMWBR 84 MM1CR 00 MM2CR 80
Window 1: 10000...12000 --&gt; 4000...6000
Window 1: 90000...94000 --&gt; 8000...c000

</PRE>
ausgibt. Ein z.B. an Stelle $10000 liegender Befehl
<PRE>

        jmp     *+3

</PRE>
w&uuml;rde effektiv einen Sprung auf Adresse $4003 ausl&ouml;sen.
<P>

<H2><A NAME="sect_4_2_">4.2. PowerPC</A></H2>
<P>
Sicher hat es ein bi&szlig;chen den Anflug einer Schnapsidee, einen
Prozessor, der eher f&uuml;r den Einsatz in Workstations konzipiert
wurde, in AS einzubauen, der sich ja eher an Programmierer von
Einplatinencomputern wendet. Aber was heute noch das Hei&szlig;este
vom Hei&szlig;en ist, ist es morgen schon nicht mehr, und sowohl der
Z80 als auch der 8088 haben ja inzwischen die Mutation von der
Personal Computer-CPU zum sog. ,,Mikrocontroller'' vollzogen. Mit dem
Erscheinen von MPC505 und PPC403 hat sich die Vermutung dann auch
best&auml;tigt, da&szlig; IBM und Motorola diese Prozessorserie auf
allen Ebenen durchdr&uuml;cken wollen.
<P>
Die Unterst&uuml;tzung ist momentan noch nicht vollst&auml;ndig: Als
Pseudobefehle zur Datenablage werden momentan provisorisch die
Intel-Mnemonics unterst&uuml;tzt und es fehlen die etwas
ungew&ouml;hnlicheren, in <A HREF="#cite_Mot601">[81]</A> genannten
RS6000-Befehle (die aber hoffentlich keiner vermi&szlig;t...). Das
wird aber nachgeholt, sobald Informationen verf&uuml;gbar sind!
<P>

<H2><A NAME="sect_4_3_">4.3. PALM</A></H2>
<P>
Der PALM-Prozessor von IBM war lange Zeit ,,Terra Incognita'', weil
er au&szlig;erhalb von IBM nie eingesetzt wurde. Des weiteren waren
die damit best&uuml;ckten IBM-Systeme 5100 bis 5120 recht exotisch
und teuer, und gerieten &uuml;ber den Erfolg des IBM PC schnell in
Vergessenheit. Es ist Christian Corti und seinem akribischen Reverse
Engineering zu verdanken, da&szlig; dieses Target &uuml;berhaupt
implementiert werden konnte <A HREF="#cite_CortPalm">[43]</A>.
<P>
Als Christian mit dem Reverse Engineering des PALM-Prozessors begann,
waren ihm die von IBM definierten Assembler-Mnemonics nicht bekannt,
er mu&szlig;te sich seine eigenen ausdenken. Das geschah
nat&uuml;rlich mit dem Wissen im Hinterkopf &uuml;ber all die
Architekturen, die nach 1973 bis heute entwickelt wurden.
<P>
Vergleicht man seine Mnemonics mit den originalen von IBM (f&uuml;r
die dann doch noch eine Dokumentation in <A
HREF="#cite_IBMPalm">[40]</A> aufgetaucht ist...), dann dr&auml;ngt
sich ein Vergleich mit den Mnemonics f&uuml;r den Intel 8080/8085 auf
der einen Seite, und den Zilog Z80 auf der anderen Seite auf: Die
einen packen zum Teil die Adressierungsart mit in den Befehlsnamen,
z.B.<TT> MVI</TT> f&uuml;r ,,Move Immediate'' oder<TT> LDHD</TT>
f&uuml;r ,,LoaD Halfword Direct''. Dies ist f&uuml;r einen Assembler
deutlich einfacher zu parsen und in Maschinencode umzusetzen.
<P>
Die anderen fassen unter einem Mnemonic alle Maschinenbefehle
zusammen, die grob das gleiche tun, zum Beispiel<TT> LD</TT> bzw.<TT>
MOVE</TT> um Daten zu transferieren. Das macht die Nutzung f&uuml;r
den Programmierer einfacher, sie sind mit den als Operanden
geschriebenen Adressierungsarten f&uuml;r einen Assembler aber etwas
komplexer zu parsen.
<P>
Auf diese Weise haben beide Mnemonic-S&auml;tze ihre Berechtigung:
Die einen, weil sie einfach das ,,Original'' sind und in allen
Herstellerdokumenten verwendet werden, und die anderen, weil sie
einfach moderner, zug&auml;nglicher und praktischer sind. Ich habe
mich deshalb entschieden,<EM> beide</EM> in meinem Assembler zu
unterst&uuml;tzen, und gl&uuml;cklicherweise war dies auch ohne
Konflikte m&ouml;glich. Das schlie&szlig;t auch die
,,Makrobefehle''<TT> CALL, RCALL, JMP, BRA, LWI</TT> und<TT> RET</TT>
ein. Und was ich selber noch dazu gedichtet habe:
<UL>
<LI> <TT> AND</TT> und<TT> OR</TT> akzeptieren auch einen Immediate-Wert
    als zweites Argument. Dies wird auf<TT> SET</TT> bzw.<TT>
    CLR</TT> abgebildet, wobei bei<TT> AND</TT> nat&uuml;rlich das
    Einerkomplement des Wertes eingesetzt wird.</LI>
<LI> <TT> MOVE</TT> akzeptiert auch einen immediate-Wert als Quelle und
    erzeugt dann den gleichen Code wie<TT> LWI</TT>. Gleiches gilt
    f&uuml;r<TT> MOVB</TT> und<TT> LBI</TT>.</LI>
</UL>
Makrobefehle, die aus mehr als einem (Halb-)Wort bestehen, bringen
allerdings ein neues Problem mit sich: Der PALM-Prozessor kennt als
bedingten Sprung nur das &Uuml;berspringen des folgenden
Instruktionsworts. Folgt auf so einen Sprung ein Makrobefehl, so
w&uuml;rde dieser nur teilweise &uuml;bersprungen. Ich habe daher
eine kleine State-Machine vorgesehen, die solche Befehlsfolgen zu
erkennen versucht und dann warnt.
<P>
Die IBM-Systeme 5110 und 5120 verwenden nicht den heute &uuml;blichen
ASCII-Zeichensatz, sondern den von IBM-Gro&szlig;rechnern bekannten
EBCDIC. Im Include-Verzeichnis befindet sich eine Datei, die man zur
Umsetzung von ASCII nach EDCDIC einbinden kann. WICHTIG: EBCDIC ist
in dieser Datei als eigene Codepage definiert, man mu&szlig; die
Umsetzung also noch mit einem
<PRE>

        codepage        cp037

</PRE>
aktivieren.
<P>
Noch ein Wort zur Integer-Syntax: Christian Corti hatte sich bei
seiner Implementierung f&uuml;r die Motorola-Syntax entschieden, also
Hex-Konstanten mit vorangestelltem Dollar-Zeichen. Ich habe mich
f&uuml;r die 'IBM-Syntax' entschieden, also Zahlenkonstanten in
Hochkommas, und z.B. ein vorangestelltes<TT> X</TT> f&uuml;r
hexadezimal. Um die Programmbeispiele auf Christians Seiten ohne
&Auml;nderungen zu &uuml;bersetzen, f&uuml;ge man folgenden Befehl zu
Beginn ein:
<PRE>

        intsyntax       +$hex,-x'hex'

</PRE>
<P>

<H2><A NAME="sect_4_4_">4.4. DSP56xxx</A></H2>
<P>
Motorola, was ist nur in Dich gefahren! Wer bei Dir ist nur auf das
schmale Brett gekommen, die einzelnen parallelen Datentransfers
ausgerechnet durch Leerzeichen zu trennen! Wer immer nun seine Codes
etwas &uuml;bersichtlicher formatieren will, z.B. so:
<PRE>

        move    x:var9 ,r0
        move    y:var10,r3   ,

</PRE>
der ist gekniffen, weil das Leerzeichen als Trennung paralleler
Datentransfers erkannt wird!
<P>
Sei's drum; Motorola hat es so definiert, und ich kann es nicht
&auml;ndern. Als Trennung der Operationen sind statt Leerzeichen auch
Tabulatoren zugelassen, und die einzelnen Teile sind ja wieder ganz
normal mit Kommas getrennt.
<P>
In <A HREF="#cite_Mot56">[76]</A> steht, da&szlig; bei den
Befehlen<TT> MOVEC, MOVEM, ANDI</TT> und<TT> ORI</TT> auch die
allgemeineren Mnemonics<TT> MOVE, AND</TT> und<TT> OR</TT> verwendet
werden k&ouml;nnen. Bei AS geht das (noch) nicht.
<P>

<H2><A NAME="sect_4_5_">4.5. H8/300</A></H2>
<P>
Bei der Assemblersyntax dieser Prozessoren hat Hitachi reichlich bei
Motorola abgekupfert (was so verkehrt ja nun auch nicht war...), nur
leider wollte die Firma unbedingt ihr eigenes Format f&uuml;r
Hexadezimalzahlen einf&uuml;hren, und dazu noch eines, das ein
einzelne Hochkommas verwendet, etwa in dieser Form:
<PRE>

   mov.w #h'ff,r0

</PRE>
Dieses Format wird von AS im Default nicht unterst&uuml;tzt, es wird
stattdessen die ''Motorola-Syntax'' mit vorangestelltem Dollarzeichen
angeboten. Falls man doch unbedingt die 'Hitachi-Syntax' benutzen
will, z.B. um existierenden Code zu &uuml;bersetzen, so mu&szlig; der
RELAXED-Modus eingeschaltet werden. Bitte beachten, da&szlig; diese
Syntax bisher wenig getestet wurde und ich keine Garantie geben kann,
da&szlig; sie in allen F&auml;llen funktioniert!
<P>

<H2><A NAME="sect_4_6_">4.6. H8/500</A></H2>
<P>
Der<TT> MOV</TT>-Befehl des H8/500 bietet eine interessante und
ungew&ouml;hnliche Optimierung: Hat der Zieloperand eine L&auml;nge
von 16 Bit, so ist es trotzdem m&ouml;glich, einen nur 8-bittigen
(Immediate-)Quelloperanden zu verwenden. Bei einer Anweisung der Form
<PRE>

   mov.w #$ffff,@$1234

</PRE>
ist es also m&ouml;glich, den Immediate-Quellwert lediglich in einem
Byte mit dem Wert $ff zu kodieren und ein Byte einzusparen. Der
Prozessor f&uuml;hrt eine Vorzeichenerweiterung durch, so da&szlig;
aus $ff das gew&uuml;nschte $ffff wird. AS kennt diese Optimierung
und benutzt sie auch, wenn dies nicht durch einen expliziten<TT>
:16</TT>-Suffix am Immediate-Operanden verboten wird.
<P>
Es hat sich in diesem Zusammenhang nur herausgestellt, da&szlig; der
Original-Assembler von Hitachi diese Optimierung anders umsetzt: er
scheint von einer Null- statt einer Vorzeichen-Erweiterung
auszugehen. Das bedeutet, nicht Argumente von -128 bis +127 ($ff80
bis $007f) werden als ein Byte kodiert, sondern von 0 bis 255 ($0000
bis $00ff). Tests an echter Hardware haben ergeben, da&szlig; das
Programmers Manual in dieser Hinsicht Recht hat: Es wird eine
Vorzeichen- Erweiterung durchgef&uuml;hrt. Deshalb verwendet AS im
Default die k&uuml;rzere Kodierung nur, wenn im Quellcode ein Wert
von -128 bis +127 bzw. ($ff80 bis $007f) benutzt wird. F&uuml;r
existierenden Code, der sich darauf verl&auml;&szlig;t, da&szlig;
Werte von $80 bis $ff mit nur einem Byte kodiert werden, kann in
einen Kompatibilit&auml;tsmodus geschaltet werden, entweder durch ein
<PRE>

  compmode on

</PRE>
im Quellcode oder den gleichnamigen Schalter auf der Kommandozeile.
<P>
Ansonsten gelten die gleichen Hinweise bez&uuml;glich der Syntax
hexadezimaler Zahlen wie f&uuml;r H8/300.
<P>

<H2><A NAME="sect_4_7_">4.7. SH7000/7600/7700</A></H2>
<P>
Leider hat Hitachi auch hier wieder das Extrawurst-Format f&uuml;r
Hexadezimalzahlen verwendet, und wieder habe ich in AS das nicht
nachvollzogen...bitte Motorola-Syntax benutzen!
<P>
Bei der Verwendung von Literalen und dem<TT> LTORG</TT>-Befehl sind
einige Details zu beachten, wenn man nicht auf einmal mit
eigenartigen Fehlermeldungen konfrontiert werden will:
<P>
Literale existieren, weil der Prozessor nicht in der Lage ist,
Konstanten au&szlig;erhalb des Bereiches von -128 bis 127 mit
immediate-Adressierung zu laden. AS (und der Hitachi-Assembler)
verstecken diese Unzul&auml;nglichkeit, indem sie automatisch
entsprechende Konstanten im Speicher ablegen, die dann mittels
PC-relativer Adressierung angesprochen werden. Die Frage, die sich
nun erhebt, ist die, wo diese Konstanten im Speicher abgelegt werden
sollen. AS legt sie nicht sofort ab, sondern sammelt sie so lange
auf, bis im Programm eine<TT> LTORG</TT>-Anweisung auftritt. Dort
werden alle Konstanten abgelegt, wobei deren Adressen mit ganz
normalen Labels versehen werden, die man auch in der Symboltabelle
sehen kann. Ein Label hat die Form
<PRE>

   LITERAL_s_xxxx_n   .

</PRE>
Dabei repr&auml;sentiert<TT> s</TT> den Typ des Literals.
Unterschieden werden Literale, die 16-Bit-Konstanten (<TT>s=W</TT>),
32-Bit-Konstanten (<TT>s=L</TT>) oder Vorw&auml;rtsreferenzen, bei
denen AS die Operandengr&ouml;&szlig;e nicht im voraus erkennen kann
(<TT>s=F</TT>), enthalten. F&uuml;r<TT> W</TT> oder<TT> L</TT>
bedeutet<TT> xxxx</TT> den hexadezimal geschriebenen Wert der
Konstante, bei Vorw&auml;rtsreferenzen, bei denen man den Literalwert
ja noch nicht kennt, bezeichnet<TT> xxxx</TT> eine einfache
Durchnumerierung.<TT> n</TT> kennzeichnet das wievielte Auftreten
dieses Literals in dieser Sektion. Literale machen ganz normal die
Lokalisierung durch Sektionen mit, es ist daher zwingend
erforderlich, in einer Sektion entstandene Literale mit<TT>
LTORG</TT> auch dort abzulegen!
<P>
Die Durchnumerierung mit<TT> n</TT> ist erforderlich, weil ein
Literal in einer Sektion mehrfach auftreten kann. Dies ist einmal
bedingt dadurch, da&szlig; die PC-relative Adressierung nur positive
Displacements erlaubt, einmal mit<TT> LTORG</TT> abgelegte Literale
also im folgenden Code nicht mitbenutzt werden k&ouml;nnen,
andererseits auch, weil die Reichweite der Displacements
beschr&auml;nkt ist (512 bzw. 1024 Byte). Ein automatisches<TT>
LTORG</TT> am Ende des Programms oder beim Umschalten zu einer
anderen CPU erfolgt nicht; findet AS in einer solchen Situation noch
abzulegende Literale, so wird eine Fehlermeldung ausgegeben.
<P>
Da bei der PC-relativen Adressierung der zur Adressierung
herangezogene PC-Wert der Instruktionsadresse+4 entspricht, ist es
nicht m&ouml;glich, ein Literal zu benutzen, welches direkt hinter
dem betroffenen Befehl abgelegt wird, also z.B. so:
<PRE>

        mov     #$1234,r6
        ltorg

</PRE>
Da der Prozessor dann aber sowieso versuchen w&uuml;rde, Daten als
Code auszuf&uuml;hren, sollte diese Situation in realen Programmen
nicht auftreten. Wesentlich realer ist aber ein anderer Fallstrick:
Wird hinter einem verz&ouml;gerten Sprung PC-relativ zugegriffen, so
ist der Programmz&auml;hler bereits auf die Sprungzieladresse
gesetzt, und das Displacement wird relativ zum Sprungziel+2
berechnet. Im folgenden Beispiel kann daher das Literal nicht
erreicht werden:
<PRE>

        bra     Target
        mov	#$12345678,r4        ; wird noch ausgefuehrt
        .
        .
        ltorg                        ; hier liegt das Literal
        .
        .
Target: mov     r4,r7                ; hier geht es weiter

</PRE>
Da Target+2 hinter dem Literal liegt, w&uuml;rde sich ein negatives
Displacement ergeben. Besonders haarig wird es, wenn mit den
Befehlen<TT> JMP, JSR, BRAF</TT> oder<TT> BSRF</TT> verzweigt wird:
Da AS die Zieladresse hier nicht ermitteln kann (sie ergibt sich erst
zur Laufzeit aus dem Registerinhalt), nimmt AS hier eine Adresse an,
die nach M&ouml;glichkeit nie pa&szlig;t, so da&szlig; PC-relative
Adressierung g&auml;nzlich unm&ouml;glich wird.
<P>
Es ist nicht direkt m&ouml;glich, aus der Zahl und Gr&ouml;&szlig;e
der Literale auf den belegten Speicher zu schlie&szlig;en. U.u.
mu&szlig; AS ein F&uuml;llwort einbauen, um einen Langwort-Wert auf
eine durch 4 teilbare Adresse auszurichten, andererseits kann er
m&ouml;glicherweise Teile eines 32-bittigen Literals f&uuml;r
16-Bit-Literale mitbenutzten. Mehrfach auftretende Literale erzeugen
nat&uuml;rlich nur einen Eintrag. Solche Optimierungen werden
f&uuml;r Vorw&auml;rtsreferenzen allerdings ganz unterdr&uuml;ckt, da
AS den Wert dieser Literale noch nicht kennt.
<P>
Da Literale die PC-relative Adressierung ausnutzen, die nur beim<TT>
MOV</TT>-Befehl erlaubt sind, beschr&auml;nken sich Literale
ebenfalls auf die Verwendung in<TT> MOV</TT>. Etwas trickreich ist
hier die Art und Weise, in der AS die Operandengr&ouml;&szlig;e
auswertet. Eine Angabe von Byte oder Wort bedeutet, da&szlig; AS
einen m&ouml;glichst kurzen<TT> MOV</TT>-Befehl erzeugt, der den
angegebenen Wert in den unteren 8 oder 16 Bit erzeugt, d.h. die
oberen 24 oder 16 Bit werden als don't care behandelt. Gibt man
dagegen Langwort oder gar nichts an, so sagt dies aus, da&szlig; das
komplette 32-Bit-Register den angegebenen Wert enthalten soll. Das
hat z.B. den Effekt, da&szlig; in folgendem Beispiel
<PRE>

        mov.b   #$c0,r0
        mov.w   #$c0,r0
        mov.l   #$c0,r0

</PRE>
der erste Befehl echte immediate-Adressierung erzeugt, der zweite und
dritte jedoch ein Wort-Literal benutzen: Da das Bit 7 in der Zahl
gesetzt ist, erzeugt der Byte-Befehl effektiv $FFFFFFC0 im Register,
was nach der Konvention nicht das w&auml;re, was man im zweiten und
dritten Fall haben m&ouml;chte. Im dritten Fall reicht auch ein
Wort-Literal, weil das gel&ouml;schte Bit 15 des Operanden vom
Prozessor in Bit 16..31 fortgesetzt wird.
<P>
Wie man sieht, ist dieses ganze Literal-Konzept reichlich
kompliziert; einfacher ging's aber wirklich nicht. Es liegt leider in
der Natur der Sache, da&szlig; man manchmal Fehlermeldungen &uuml;ber
nicht gefundene Literale bekommt, die eigentlich logisch nicht
auftreten k&ouml;nnten, weil AS die Literale ja komplett in eigener
Regie verwaltet. Treten aber bei der Assemblierung Fehler erst im
zweiten Pass auf, so verschieben sich z.B. hinter der Fehlerstelle
liegende Labels gegen&uuml;ber dem ersten Pass, weil AS f&uuml;r die
jetzt als fehlerhaft erkannten Befehle keinen Code mehr erzeugt. Da
aber Literalnamen u.a. aus den Werten von Symbolen erzeugt werden,
werden als Folgefehler davon eventuell andere Literalnamen
nachgefragt, als im ersten Pass abgelegt wurden und AS beschwert sich
&uuml;ber nicht gefundene Symbole...sollten also neben anderen
Fehlern solche Literal-Fehler auftreten, beseitigen Sie erst die
anderen Fehler, bevor Sie mich und alle Literale verfluchen...
<P>
Wer aus der Motorola-Ecke kommt und PC-relative Adressierung explizit
benutzen will (z.B. um Variablen lageunabh&auml;ngig zu erreichen),
sollte wissen, da&szlig; beim Ausschreiben der Adressierung nach
Programmierhandbuch, also z.B. so:
<PRE>

        mov.l   @(Var,PC),r8

</PRE>
<I> keine</I> implizite Umrechnung der Adresse auf ein Displacement
erfolgt, d.h. der Operand wird so eingesetzt, wie er ist (und
w&uuml;rde in diesen Beispiel wohl mit hoher Wahrscheinlichkeit eine
Fehlermeldung hervorrufen...). Will man beim SH7x00 PC-relativ
adressieren, so tut man das einfach mit ,,absoluter'' Adressierung,
die auf Maschinenebene ja gar nicht existiert:
<PRE>

        mov.l   Var,r8

</PRE>
Hier wird das Displacement korrekt berechnet (es gelten
nat&uuml;rlich die gleichen Einschr&auml;nkungen f&uuml;r das
Displacement wie bei Literalen).
<P>

<H2><A NAME="sect_4_8_">4.8. HMCS400</A></H2>
<P>
Beim Befehlssatz dieser 4-Bit-Prozessoren f&uuml;hlte ich mich
spontan an den 8080/8085 erinnert - sehr viele Menemonics, die
Adressierungsart (z.B. indirekt oder direkt) ist in den Befehl
einkodiert, die Befehle sind zum Teil nur schwer zu merken.
Nat&uuml;rlich unterst&uuml;tzt AS diese Syntax, wie Hitachi sie
seinerzeit definiert hat, ich habe aber zus&auml;tzlich f&uuml;r die
meisten Befehle eine - finde ich - sch&ouml;nere und besser lesbare
Variante implementiert, so wie Zilog es seinerzeit mit den Z80
gemacht hat. Zum Beispiel k&ouml;nnen alle Maschineninstruktionen,
die in irgendeiner Form Daten transferieren, egal ob die Operanden
Register, Konstanten oder Speicherstellen sind, &uuml;ber den
AS-spezifischen<TT> LD</TT>-Befehl angesprochen werden. &Auml;hnliche
'Meta-Befehle' gibt es f&uuml;r arithmetische und logische Befehle.
Eine vollst&auml;ndige Liste aller Meta-Befehle und ihrer Operanden
findet sich in den Tabellen <A HREF="#ref_TabHMCS400Meta">4.8</A> und
<A HREF="#ref_TabHMCS400MetaOps">4.8</A>, ihre praktische Verwendung
kann man sich in der Datei<TT> t_hmcs4x.asm</TT> ansehen.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Meta-Instruktion</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Ersetzt</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LD</TT><EM> src, dest</EM><BR>
<BR>
<BR>
<BR>
<TT> XCH</TT><EM> src, dest</EM><BR>
<TT> ADD</TT><EM> src, dest</EM><BR>
<TT> ADC</TT><EM> src, dest</EM><BR>
<TT> SUB</TT><EM> src, dest</EM><BR>
<TT> SBC</TT><EM> src, dest</EM><BR>
<TT> OR</TT><EM> src, dest</EM><BR>
<TT> AND</TT><EM> src, dest</EM><BR>
<TT> EOR</TT><EM> src, dest</EM><BR>
<TT> CP</TT><EM> cond, src, dest</EM><BR>
<BR>
<BR>
<TT> BSET</TT><EM> bit</EM><BR>
<TT> BCLR</TT><EM> bit</EM><BR>
<TT> BTST</TT><EM> bit</EM></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LAI, LBI, LMID, LMIIY,</TT><BR>
<TT> LAB, LBA, LAY, LASPX, LASPY, LAMR,</TT><BR>
<TT> LWI, LXI, LYI, LXA, LYA, LAM, LAMD</TT><BR>
<TT> LBM, LMA, LMAD, LMAIY, LMADY</TT><BR>
<TT> XMRA, XSPX, XSPY, XMA, XMAD, XMB</TT><BR>
<TT> AYY, AI, AM, AMD</TT><BR>
<TT> AMC, AMCD</TT><BR>
<TT> SYY</TT><BR>
<TT> SMC, SMCD</TT><BR>
<TT> OR, ORM, ORMD</TT><BR>
<TT> ANM, ANMD</TT><BR>
<TT> EORM, EORMD</TT><BR>
<TT> INEM, INEMD, ANEM, ANEMD, BNEM,</TT><BR>
<TT> YNEI, ILEM, ILEMD, ALEM, ALEMD,</TT><BR>
<TT> BLEM, ALEI</TT><BR>
<TT> SEC, SEM, SEMD</TT><BR>
<TT> REC, REM, REMD</TT><BR>
<TT> TC, TM, TMD</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.1: Meta-Befehle HMCS400
</CENTER><P>
<A NAME="ref_TabHMCS400Meta"></A>

<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Operand</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Typen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><EM> src, dest</EM><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<EM> cond</EM><BR>
<BR>
<EM> bit</EM><BR>
<BR>
<BR>
<EM> bitpos</EM></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A, B, X, Y, W, SPX, SPY</TT> (Register)<BR>
<TT> M</TT> (Speicher adressiert durch X/Y/W)<BR>
<TT> M+</TT> (dito, mit Autoinkrement)<BR>
<TT> M-</TT> (dito, mit Autodekrement)<BR>
<TT> #val</TT> (2/4 bit immediate)<BR>
<TT> addr10</TT> (Speicherzelle direkt)<BR>
<TT> MRn</TT> (Memory-Register 0..15)<BR>
<TT> NE</TT> (ungleich)<BR>
<TT> LE</TT> (kleiner oder gleich)<BR>
<TT> CA</TT> (Carry)<BR>
<EM> bitpos</EM>,<TT>M</TT><BR>
<EM> bitpos</EM>,<TT>addr10</TT><BR>
<TT> 0..3</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.2: Operandentypen f&uuml;r Meta-Befehle HMCS400
</CENTER><P>
<A NAME="ref_TabHMCS400MetaOps"></A>

<P>

<H2><A NAME="sect_4_9_">4.9. H16</A></H2>
<P>
Der Befehlssatz des H16-Kerns verdient mit Recht den Namen ,,CISC'':
komplexe Adressierungsarten, sehr variable Instruktionsl&auml;ngen,
und f&uuml;r viele Befehle mit g&auml;ngigen Operanden gibt es
Kurzschreibweisen. So gibt es f&uuml;r diverse Befehle mehrere
,,Formate'', je nachdem welchen Typ Quell- und Zieloperand haben. Die
generelle Regel ist, da&szlig; AS immer das k&uuml;rzestm&ouml;gliche
Format benutzt, es sei denn, es wurde explizit angegeben:
<PRE>

       mov.l     r4,r7     ; benutzt R-Format
       mov.l     #4,r7     ; benutzt RQ-Format
       mov.l     #4,@r7    ; benutzt Q-Format
       mov.l     @r4,@r7   ; benutzt G-Format
       mov:q.l   #4,r7     ; Q- statt RQ-Format erzwungen 
       mov:g.l   #4,r7     ; G- statt RQ-Format erzwungen 

</PRE>
F&uuml;r Immediate-Argumente wird die ,,nat&uuml;rliche''
Operandenl&auml;nge benutzt, also z.B. 2 Bytes f&uuml;r 16 Bits.
K&uuml;rzere oder l&auml;ngere Argumente lassen sich durch eine
angeh&auml;ngte Operandengr&ouml;&szlig;e (.b, .w, .l oder :8, :16,
:32) erzwingen. Bei Displacements oder absoluten Adressen gilt
jedoch, da&szlig; ohne explizite L&auml;ngenangabe immer die
k&uuml;rzestm&ouml;gliche Schreibweise benutzt wird. Das
schlie&szlig;t ein, da&szlig; bei absoluten Adressen die oberen acht
Adre&szlig;bits vom Prozessor nicht herausgegeben werden: eine
Adresse $ffff80 kann also mit einem Byte ($80) kodiert werden.
<P>
Des weiteren kennt AS das ''Akkumulator-Bit'', d.h. bei Instruktionen
mit zwei beliebigen Operanden kann der zweite Operand weggelassen
werden, falls das Ziel Register Null ist. Dieses Verhalten kann nicht
&uuml;bersteuert werden.
<P>
Des weiteren werden folgende Optimierungen durchgef&uuml;hrt:
<UL>
<LI> <TT>MOV R0,&lt;ea&gt;</TT> wird zu<TT> MOVF &lt;ea&gt;</TT>
    optimiert, sofern<TT> &lt;ea&gt;</TT> kein PC-relativer Ausdruck
    ist und sich die L&auml;nge des Displacements &auml;ndern
    w&uuml;rde. Diese Optimierung kann durch eine explizite
    Formatangabe unterdr&uuml;ckt werden.</LI>
<LI> <TT>SUB</TT> existiert nicht im Q-Format, kann aber durch ein<TT>
    ADD:Q</TT> mit negiertem immediate-Argument ersetzt werden, falls
    das Argument zu<TT> SUB</TT> im Bereich -127...+128 liegt. Auch
    diese Optimierung kann durch eine explizite Formatangabe
    unterdr&uuml;ckt werden.</LI>
</UL>
<P>

<H2><A NAME="sect_4_10_">4.10. OLMS-40</A></H2>
<P>
&Auml;hnlich wie beim HMCS400 sind die Adressierungsarten zu einem
gro&szlig;en Teil in die Mnemonics hineinkodiert, und ich habe mich
auch hier daf&uuml;r entschieden, f&uuml;r h&auml;ufig genutzte
Befehle eine alternative, modernere und besser lesbare Notation
bereitzustellen. Eine vollst&auml;ndige Liste aller Meta-Befehle und
ihrer Operanden findet sich in den Tabellen <A
HREF="#ref_TabOLMS40Meta">4.10</A> und <A
HREF="#ref_TabOLMS40MetaOps">4.10</A>, ihre praktische Verwendung
kann man sich in der Datei<TT> t_olms4.asm</TT> ansehen.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Meta-Instruktion</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Ersetzt</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LD</TT><EM> dest, src</EM><BR>
<BR>
<BR>
<TT> DEC</TT><EM> dest</EM><BR>
<TT> INC</TT><EM> dest</EM><BR>
<TT> BSET</TT><EM> bit</EM><BR>
<TT> BCLR</TT><EM> bit</EM><BR>
<TT> BTST</TT><EM> bit</EM></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LAI, LLI, LHI, L,</TT><BR>
<TT> LAL, LLA, LAW, LAX, LAY, LAZ,</TT><BR>
<TT> LWA, LXA, LYA, LPA, LTI, RTH, RTL</TT><BR>
<TT> DCA, DCL, DCM, DCW, DCX, DCY, DCZ, DCH</TT><BR>
<TT> INA, INL, INM, INW, INX, INY, INZ</TT><BR>
<TT> SPB, SMB, SC</TT><BR>
<TT> RPB, RMB, RC</TT><BR>
<TT> TAB, TMB, Tc</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.3: Meta-Befehle OLMS-40
</CENTER><P>
<A NAME="ref_TabOLMS40Meta"></A>

<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Operand</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Typen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><EM> src, dest</EM><BR>
<BR>
<BR>
<BR>
<BR>
<EM> bit</EM><BR>
<BR>
<BR>
<BR>
<EM> bitpos</EM></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A, W, X, Y, Z, DPL, DPH</TT> (Register)<BR>
<TT> T, TL, TH</TT> (Timer, obere/untere H&auml;lfte)<BR>
<TT> (DP), M</TT> (Speicher adressiert durch DPH/DPL)<BR>
<TT> #val</TT> (4/8 bit immediate)<BR>
<TT> PP</TT> (Port-Pointer)<BR>
<TT> C</TT> (Carry)<BR>
<TT> (PP)</TT>,<EM> bitpos</EM><BR>
<TT> (DP)</TT>,<EM> bitpos</EM><BR>
<TT> (A)</TT>,<EM> bitpos</EM><BR>
<TT> 0..3</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.4: Operandentypen f&uuml;r Meta-Befehle OLMS-40
</CENTER><P>
<A NAME="ref_TabOLMS40MetaOps"></A>

<P>

<H2><A NAME="sect_4_11_">4.11. OLMS-50</A></H2>
<P>
Der Datenspeicher dieser 4-Bit-Controller besteht aus bis zu 128
Nibbles. F&uuml;r die daf&uuml;r ben&ouml;tigten sieben
Adre&szlig;bits war jedoch nur in den wenigsten Instruktionen Platz,
so da&szlig; einmal wieder Banking zur Adressierung herhalten
mu&szlig;. Die meisten Befehle, die Speicher adressieren, enthalten
nur die untersten vier Bits der RAM-Adresse, und sofern nicht die
untersten 16 Nibbles angesprochen werden sollen, liefert das
P-Register die notwendigen obere Adre&szlig;bits. Dessen aktuellen
Wert teilt man dem Assembler &uuml;ber ein
<PRE>

   assume  p:&lt;Wert&gt;

</PRE>
mit, z.B. direkt nach einem<TT> PAGE</TT>-Befehl.
<P>
Mit<TT> PAGE</TT> ist auch ein anderes Thema angeschnitten:
sowohl<TT> PAGE</TT> als auch<TT> SWITCH</TT> sind auf diesen
Controllern Maschinenbefehle, d.h. haben nicht ihre von anderen
Targets &uuml;bliche Funktion. Der Pseudobefehl, um ein<TT>
SWITCH/CASE</TT>- Konstrukt einzuleiten, lautet im OLMS-50-Modus<TT>
SELECT</TT>, und die Seitengr&ouml;&szlig;e des Listings legt man
mit<TT> PAGESIZE</TT> fest.
<P>

<H2><A NAME="sect_4_12_">4.12. MELPS-4500</A></H2>
<P>
Der Programmspeicher dieser Mikrokontroller ist in Seiten zu 128
Worten eingeteilt. Diese Einteilung existiert eigentlich nur
deswegen, weil es Sprungbefehle gibt, deren Ziel innerhalb der
gleichen Seite liegen darf, und andererseits ,,lange'' Exemplare, die
den ganzen Adre&szlig;bereich erreichen k&ouml;nnen. Die
Standard-Syntax von Mitsubishi verlangt eigentlich, da&szlig; Seite
und Offset als getrennte Argument geschrieben werden m&uuml;ssen. Da
das aber reichlich unpraktisch ist (ansonsten hat man als
Programmierer keine Veranlassung, sich um Seiten zu k&uuml;mmern, mit
der Ausnahme von indirekten Spr&uuml;ngen), erlaubt es AS auch
wahlweise, die Zieladresse linear zu schreiben, also z.B.
<PRE>

      bl        $1234

</PRE>
anstelle
<PRE>

      bl        $24,$34  .

</PRE>
<P>

<H2><A NAME="sect_4_13_">4.13. 6502UNDOC</A></H2>
<P>
Da die undokumentierten Befehle des 6502 sich naturgem&auml;&szlig;
in keinem Datenbuch finden, sollen sie an dieser Stelle kurz
aufgelistet werden. Die Verwendung erfolgt naturgem&auml;&szlig; auf
eigene Gefahr, da es keine Gew&auml;hr gibt, da&szlig; alle
Maskenversionen alle Varianten unterst&uuml;tzen! Bei den
CMOS-Nachfolgern des 6502 funktionieren sie sowieso nicht mehr, da
diese die entsprechenden Bitkombinationen mit offiziellen Befehlen
belegen...
<P>
<P>
Es bedeuten:
<P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> &amp;</TD><TD NOWRAP> bin&auml;res UND</TD></TR>
<TR><TD NOWRAP> |</TD><TD NOWRAP> bin&auml;res ODER</TD></TR>
<TR><TD NOWRAP> ^</TD><TD NOWRAP> bin&auml;res EXOR</TD></TR>
<TR><TD NOWRAP> &lt;&lt;</TD><TD NOWRAP> logischer Linksshift</TD></TR>
<TR><TD NOWRAP> &gt;&gt;</TD><TD NOWRAP> logischer Rechtsshift</TD></TR>
<TR><TD NOWRAP> &lt;&lt;&lt;</TD><TD NOWRAP> Linksrotation</TD></TR>
<TR><TD NOWRAP> &gt;&gt;&gt;</TD><TD NOWRAP> Rechtsrotation</TD></TR>
<TR><TD NOWRAP> &larr;</TD><TD NOWRAP> Zuweisung</TD></TR>
<TR><TD NOWRAP> (..)</TD><TD NOWRAP> Inhalt von ..</TD></TR>
<TR><TD NOWRAP>..</TD><TD NOWRAP> Bits ..</TD></TR>
<TR><TD NOWRAP> A</TD><TD NOWRAP> Akkumulator</TD></TR>
<TR><TD NOWRAP> X,Y</TD><TD NOWRAP> Indexregister X,Y</TD></TR>
<TR><TD NOWRAP> S</TD><TD NOWRAP> Stapelzeiger</TD></TR>
<TR><TD NOWRAP> An</TD><TD NOWRAP> Akkumulatorbit n</TD></TR>
<TR><TD NOWRAP> M</TD><TD NOWRAP> Operand</TD></TR>
<TR><TD NOWRAP> C</TD><TD NOWRAP> Carry</TD></TR>
<TR><TD NOWRAP> PCH</TD><TD NOWRAP> obere H&auml;lfte Programmz&auml;hler</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> JAM, KIL</TT> oder<TT> CRS</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> keine, Prozessor wird angehalten</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> implizit</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SLO</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;((M)&lt;&lt;1)|(A)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ANC</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> A&larr;(A)&amp;(M), C&larr; A7</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RLA</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;((M)&lt;&lt;1)&amp;(A)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SRE</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;((M)&gt;&gt;1)^(A)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ASR</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> A&larr;((A)&amp;(M))&gt;&gt;1</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RRA</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;((M)&gt;&gt;&gt;1)+(A)+(C)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ARR</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> A&larr;((A)&amp;(M))&gt;&gt;&gt;1</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SAX</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;(A)&amp;(X)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, Y-indiziert kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ANE</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;((A)&amp;$ee)|((X)&amp;(M))</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHA</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;(A)&amp;(X)&amp;(PCH+1)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> X/Y-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHS</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> X&larr;(A)&amp;(X), S&larr;(X), M&larr;(X)&amp;(PCH+1)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> Y-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHY</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;(Y)&amp;(PCH+1)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> Y-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHX</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;(X)&amp;(PCH+1)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> X-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LAX</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> A,X&larr;(M)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, Y-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LXA</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> X04&larr;(X)04 &amp; (M)04,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> A04&larr;(A)04 &amp; (M)04</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LAE</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> X,S,A&larr;((S)&amp;(M))</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> Y-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> DCP</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M &larr;(M)-1, Flags&larr;((A)-(M))</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SBX</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> X&larr;((X)&amp;(A))-(M)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ISB</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M&larr;(M)+1, A&larr;(A)-(M)-(C)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>

<H2><A NAME="sect_4_14_">4.14. MELPS-740</A></H2>
<P>
Die Mikrokontroller dieser Reihe haben ein sehr nettes, verstecktes
Feature: Setzt man mit dem Befehl<TT> SET</TT> das Bit 5 des
Statusregisters, so wird bei allen arithmetischen Operationen (und
Ladebefehlen) der Akkumulator durch die durch das X-Register
adressierte Speicherzelle ersetzt. Dieses Feature
syntaxm&auml;&szlig;ig sauber zu integrieren, ist bisher nicht
geschehen, d.h. es kann bisher nur im ,,Handbetrieb''
(<TT>SET</TT>...Befehle mit Akkuadressierung...<TT>CLT</TT>) genutzt
werden.
<P>
Nicht alle MELPS-740-Prozessoren implementieren alle Befehle. An
dieser Stelle mu&szlig; der Programmierer aufpassen, da&szlig; er nur
die Befehle benutzt, die auch wirklich vorhanden sind, da AS die
Prozessoren dieser Familie nicht n&auml;her unterscheidet. Die
Besonderheiten der Special-Page-Adressierung werden bei der
Erkl&auml;rung von<TT> ASSUME</TT> n&auml;her erl&auml;utert.
<P>

<H2><A NAME="sect_4_15_">4.15. MELPS-7700/65816</A></H2>
<A NAME="ref_MELPS7700Spec"></A>
<P>
Offensichtlich haben diese beiden Prozessorfamilien ausgehend vom
6502 (&uuml;ber ihre 8-bittigen Vorg&auml;nger) etwas disjunkte
Entwicklungswege hinter sich. Kurz aufgelistet, ergeben sich folgende
Unterschiede:
<UL>
<LI> der 65816 hat keinen B-Akkumulator.</LI>
<LI> beim 65816 fehlen Multiplikations- sowie Divisionsbefehle.</LI>
<LI> Die Befehle<TT> SEB</TT>,<TT> CLB</TT>,<TT> BBC</TT>,<TT>
    BBS</TT>,<TT> CLM</TT>,<TT> SEM</TT>,<TT> PSH</TT>,<TT> PUL</TT>
    und<TT> LDM</TT> fehlen beim 65816. An deren Stelle in der
    Code-Tabelle finden sich<TT> TSB</TT>,<TT> TRB</TT>,<TT>
    BIT</TT>,<TT> CLD</TT>,<TT> SED</TT>,<TT> XBA</TT>,<TT> XCE</TT>
    und<TT> STZ</TT>.</LI>
</UL>
Identische Funktion, jedoch andere Namen haben folgende Befehle:
<P>
<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>65816</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>MELPS-7700</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>65816</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>MELPS-7700</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><TT> REP</TT><BR>
<TT> TCS</TT><BR>
<TT> TCD</TT><BR>
<TT> PHB</TT><BR>
<TT> WAI</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><TT> CLP</TT><BR>
<TT> TAS</TT><BR>
<TT> TAD</TT><BR>
<TT> PHT</TT><BR>
<TT> WIT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><TT> PHK</TT><BR>
<TT> TSC</TT><BR>
<TT> TDC</TT><BR>
<TT> PLB</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><TT> PHG</TT><BR>
<TT> TSA</TT><BR>
<TT> TDA</TT><BR>
<TT> PLT</TT><BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>
Besonders t&uuml;ckisch sind die Befehle<TT> PHB</TT>,<TT> PLB</TT>
und<TT> TSB</TT>: diese Befehle haben jeweils eine v&ouml;llig andere
Funktion und Kodierung!
<P>
Leider tun diese Prozessoren mit ihrem Speicher etwas, was f&uuml;r
mich auf der nach oben offenen Perversit&auml;tsskala noch vor der
Intel-m&auml;&szlig;igen Segmentierung rangiert: sie banken ihn!
Nunja, dies ist wohl der Preis f&uuml;r die
6502-Aufw&auml;rtskompatibilit&auml;t; wie dem auch sei, damit AS den
gew&uuml;nschten Code erzeugen kann, mu&szlig; man ihn &uuml;ber
den<TT> ASSUME</TT>-Befehl &uuml;ber den Inhalt einiger Register in
Kenntnis setzen:
<P>
Das M-Flag bestimmt, ob die Akkumulatoren A und B 8 Bit (1) oder 16
Bit (0) breit sein sollen. Analog entscheidet das Flag X &uuml;ber
die Breite der Indexregister X und Y. AS ben&ouml;tigt die
Information &uuml;ber die Registerbreite bei unmittelbarer
Adressierung (<TT>#&lt;Konstante&gt;</TT>), ob das Argument 8 oder 16
Bit breit sein soll.
<P>
Der Speicher ist in 256 B&auml;nke zu 64 Kbyte geteilt. Da alle
Register im Prozessor nur maximal 16 Bit breit sind, kommen die
obersten 8 Adre&szlig;bits aus 2 speziellen Bank-Registern: DT
liefert die oberen 8 Bits bei Datenzugriffen, PG erweitert den
16-bittigen Programmz&auml;hler auf 24 Bit. Die vom 6502 her bekannte
,,Zero-Page'' ist mittels des 16 Bit breiten Registers DPR frei
innerhalb der ersten Bank verschiebbar. Trifft AS nun im Code auf
eine Adresse (egal ob in einem absoluten, indizierten oder indirekten
Ausdruck), so versucht er der Reihe nach folgende
Adressierungsvarianten:
<OL>
<LI>Liegt die Adresse im Bereich von DPR...DPR+$ff? Falls ja, Verwendung
    von direkter Adressierung mit 8-Bit-Adresse.</LI>
<LI>Liegt die Adresse innerhalb der durch DT (bzw. PG f&uuml;r
    Sprungbefehle) festgelegten Seite? Falls ja, Verwendung von
    absoluter Adressierung mit 16-Bit-Adresse.</LI>
<LI>Falls nichts anderes hilft, Verwendung von langer Adressierung mit
    24-Bit-Adresse.</LI>
</OL>
Aus dieser Aufz&auml;hlung folgt, da&szlig; das Wissen &uuml;ber die
momentanen Werte von DT,PG und DPR f&uuml;r die Funktion von AS
essentiell ist; sind die Angaben fehlerhaft, adressiert das Programm
,,in die W&uuml;ste''. Diese Aufz&auml;hlung geht &uuml;brigens davon
aus, da&szlig; alle drei Adre&szlig;l&auml;ngen verf&uuml;gbar sind;
sollte dies einmal nicht der Fall sein, so wird die
Entscheidungskette entsprechen k&uuml;rzer.
<P>
Die oben geschilderte, automatische Festlegung der
Adre&szlig;l&auml;nge l&auml;&szlig;t sich auch durch die Verwendung
von Pr&auml;fixen &uuml;bersteuern. Stellt man der Adresse ein &lt;,
&gt; oder &gt;&gt; ohne trennendes Leerzeichen voran, so wird eine
Adresse mit 1, 2 oder 3 Bytes benutzt, unabh&auml;ngig davon, ob dies
die optimale L&auml;nge ist. Benutzt man eine f&uuml;r diesen Befehl
nicht erlaubte oder f&uuml;r die Adresse zu kurze L&auml;nge, gibt es
eine Fehlermeldung.
<P>
Um die Portierung von 6502-Programmen zu erleichtern, verwendet AS
f&uuml;r Hexadezimalkonstanten die Motorola-Syntax und nicht die von
Mitsubishi &uuml;brigens f&uuml;r die 740er favorisierte
Intel/IEEE-Schreibweise. Ich halte erstere auch f&uuml;r die bessere
Schreibweise, und die Entwickler des 65816 werden dies vermutlich
&auml;hnlich gesehen haben (da man mittels der<TT>
RELAXED</TT>-Anweisung auch Intel-Notation benutzen kann, wird durch
diese Entscheidung auch niemand festgelegt). Ein f&uuml;r die
Portierung &auml;hnlich wichtiges Detail ist, da&szlig; der
Akkumulator A als Ziel von Operationen auch weggelassen werden darf,
anstelle von<TT> LDA A,#0</TT> darf also z.B. auch einfach<TT> LDA
#0</TT> geschrieben werden.
<P>
Ein echtes Bonbon in dem Befehlssatz sind dagegen die
Blocktransferbefehle<TT> MVN</TT> und<TT> MVP</TT>. Etwas eigenartig
ist nur die Adre&szlig;angabe: Bit 0--15 im Indexregister, Bit 16--23
im Befehl. Bei AS gibt man als Argument f&uuml;r beide
Speicherbl&ouml;cke einfach die vollen Adressen an, AS fischt sich
dann die passenden Bits automatisch heraus. Dies ist ein feiner, aber
wichtiger Unterschied zum Mitsubishi-Assembler, bei dem man die
oberen 8 Bit selber herausziehen mu&szlig;. Richtig bequem wird es
aber erst mit einem Makro im folgendem Stil:
<PRE>

mvpos   macro   src,dest,len
        if      MomCPU=$7700
         lda    #len
        elseif
         lda    #(len-1)
        endif
        ldx     #(src&$ffff)
        ldy     #(dest&$ffff)
        mvp     dest,src
        endm

</PRE>
Vorsicht, Falle: Steht im Akkumulator die Zahl n, so transferiert der
Mitsubishi n Bytes, der 65816 jedoch n+1 Bytes!
<P>
Sehr nett sind auch die Befehle<TT> PSH</TT> und<TT> PUL</TT>, mit
deren Hilfe es m&ouml;glich ist, mit einem Befehl einen frei
w&auml;hlbaren Satz von Registern auf dem Stack zu sichern oder von
ihm zu laden. Nach dem Mitsubishi-Datenbuch<A
HREF="#cite_Mit16">[62]</A> mu&szlig; die Angabe der Bitmasken
immediate erfolgen, der Programmierer soll also entweder alle
Register&harr;Bitstellen-Zuordnungen im Kopf behalten oder sich
passende Symbole definieren. Hier habe ich die Syntax
eigenm&auml;chtig erweitert, um die Sache etwas angenehmer zu machen:
Es darf eine Liste angegeben werden, die sowohl
immediate-Ausdr&uuml;cke als auch Registernamen enthalten darf. Damit
sind z.B. die Anweisungen
<PRE>

        psh     #$0f

</PRE>
und
<PRE>

        psh     a,b,#$0c

</PRE>
und
<PRE>

        psh     a,b,x,y

</PRE>
&auml;quivalent. Da die immediate-Version weiterhin erlaubt ist,
bleibt AS hier ,,aufw&auml;rtskompatibel'' zu den
Mitsubishi-Assemblern.
<P>
Nicht ganz habe ich beim Mitsubishi-Assembler die Behandlung des<TT>
PER</TT>-Befehles verstanden: Mit diesem Befehl kann man eine
16-Bit-Variable auf den Stack legen, deren Adresse relativ zum
Programmz&auml;hler angegeben wird. Es ist aus der Sicht des
Programmierers also eine absolute Adressierung einer Speicherzelle.
Nichtsdestotrotz verlangt Mitsubishi eine immediate-Adressierung, und
das Argument wird so in den Code eingesetzt, wie es im Quelltext
steht. Die Differenz mu&szlig; man selber ausrechnen, was mit der
Einf&uuml;hrung von symbolischen Assemblern ja abgeschafft werden
sollte...da ich aber auch ein bi&szlig;chen ,,kompatibel'' denken
mu&szlig;, enth&auml;lt AS eine Kompromi&szlig;l&ouml;sung:
W&auml;hlt man immediate-Adressierung (also mit Gartenzaun), so
verh&auml;lt sich AS wie das Original von Mitsubishi. L&auml;&szlig;t
man ihn jedoch weg, so berechnet AS die Differenz vom Argument zum
momentanen Programmz&auml;hler und setzt diese ein.
<P>
&Auml;hnlich sieht es beim<TT> PEI</TT>-Befehl aus, der den Inhalt
einer 16-Bit-Variablen auf der Zeropage auf den Stack legt: Obwohl
der Operand eine Adresse ist, wird wieder immediate-Adressierung
verlangt. Hier l&auml;&szlig;t AS schlicht beide Versionen zu (d.h.
mit oder ohne Gartenzaun).
<P>

<H2><A NAME="sect_4_16_">4.16. M16</A></H2>
<P>
Die M16-Familie ist eine Familie &auml;u&szlig;erst komplexer
CISC-Prozessoren mit einem entsprechend komplizierten Befehlssatz. Zu
den Eigenschaften dieses Befehlssatzes geh&ouml;rt es unter anderem,
da&szlig; bei Operationen mit zwei Operanden beide Operanden
verschiedene L&auml;ngen haben d&uuml;rfen. Die bei Motorola
&uuml;bliche und von Mitsubishi &uuml;bernommene Methode, die
Operandengr&ouml;&szlig;e als Attribut an den Befehl anzuh&auml;ngen,
mu&szlig;te daher erweitert werden: Es ist erlaubt, auch an die
Operanden selber Attribute anzuh&auml;ngen. So wird im folgenden
Beispiel
<PRE>

        mov     r0.b,r6.w

</PRE>
Register 0 8-bittig gelesen, auf 32 Bit vorzeichenerweitert und das
Ergebnis in Register 6 kopiert. Da man in 9 von 10 F&auml;llen aber
von diesen M&ouml;glichkeiten doch keinen Gebrauch macht, kann man
weiterhin die Operandengr&ouml;&szlig;e an den Befehl selber
schreiben, z.B. so:
<PRE>

        mov.w   r0,r6

</PRE>
Beide Varianten d&uuml;rfen auch gemischt verwendet werden, eine
Gr&ouml;&szlig;enangabe am Operanden &uuml;bersteuert dann den
,,Default'' am Befehl. Eine Ausnahme stellen Befehle mit zwei
Operanden dar. Bei diesen ist der Default f&uuml;r den Quelloperanden
die Gr&ouml;&szlig;e des Zieloperanden. In folgendem Beispiel
<PRE>

        mov.h   r0,r6.w

</PRE>
wird also auf Register 0 32-bittig zugegriffen, die
Gr&ouml;&szlig;enangabe am Befehl wird &uuml;berhaupt nicht mehr
benutzt. Finden sich &uuml;berhaupt keine Angaben zur
Operandengr&ouml;&szlig;e, so wird Wort(w) verwendet. Merke: im
Gegensatz zu den 68000ern bedeutet dies 32 und nicht 16 Bit!
<P>
Reichlich kompliziert sind auch die verketteten Adressierungsmodi;
dadurch, da&szlig; AS die Verteilung auf Kettenelemente automatisch
vornimmt, bleibt die Sache aber einigerma&szlig;en
&uuml;bersichtlich. Die einzige Eingriffsm&ouml;glichkeit, die bei AS
gegeben ist (der Originalassembler von Mitsubishi/Green Hills kann da
noch etwas mehr), ist die explizite Festlegung von
Displacement-L&auml;ngen mittels der Anh&auml;ngsel<TT> :4</TT>,<TT>
:16</TT> und<TT> :32</TT>.
<P>

<H2><A NAME="sect_4_17_">4.17. CP-3F</A></H2>
<P>
Der CP-3F wurde Anfang der 70er-Jahre entwickelt, wo auch die
Entwicklungssysteme deutlich weniger leistungsf&auml;hig waren und
bei der Assembler-Syntax auch auf die leichte Umsetzbarkeit im
Maschinensprache geachtet wurde. So gruppieren sich die
Original-Mnemonics in wenige Gruppen: Befehle mit 3/4- oder
8-Bit-immediate-Argument, solche mit einem Registeroperanden,
Spr&uuml;nge und Befehle ganz ohne Argumente. Das l&auml;st sich mit
relativ wenig Aufwand in Maschinencode &uuml;bersetzen, der
Lesbarkeit des Quellcodes ist das aber eher abtr&auml;glich -
&auml;hnlich wie beim Intel 8080. Ich habe mich deshalb entschlossen,
f&uuml;r die meisten Befehle eine alternative Schreibweise
anzubieten, die verst&auml;ndlicher ausdr&uuml;ckt, was der jeweilige
Befehl tut:
<P>
<P><CENTER>Tabelle 4.5: Alternative Befehlsschreibweisen f&uuml;r CP-3F
</CENTER><P>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Original</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Alternativ</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> las imm4</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,#&lt;imm4</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> 0:imm4</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lal imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,#&gt;imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> imm8</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lss imm3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld s,#imm3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> S</TT> &#10229;<TT> imm3</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lts imm3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld t,#imm3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> T</TT> &#10229;<TT> imm3</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> anl imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> and [a,]#imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &and;<TT> imm8</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> eol imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> xor [a,]#imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &veebar;<TT> imm8</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> orl imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> or [a,]#imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &or;<TT> imm8</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> adl imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> add [a,]#imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> +<TT> imm8</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> cml imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> cp [a,]#imm8</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> Flags</TT> &#10229;<TT> A</TT> -<TT> imm8</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lav</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,v</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> V</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> law</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,w</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> W</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lax</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,x</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> X</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lay</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,y</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> Y</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sav</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld v,a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> V</TT> &#10229;<TT> A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> saw</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld w,a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> W</TT> &#10229;<TT> A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sax</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld x,a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> X</TT> &#10229;<TT> A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> say</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld y,a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> Y</TT> &#10229;<TT> A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sat</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld t,a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> T</TT> &#10229;<TT> A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sst</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld st,a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> S|T</TT> &#10229;<TT> A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> als</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sla [a]</TT><BR>
<TT> sla [a],1</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A(7..1)</TT> &#10229;<TT> A(6..0)</TT>,<BR>
<TT> A(0)</TT> &#10229;<TT> 0</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ars</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> srl [a]</TT><BR>
<TT> srl [a],1</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A(6..0)</TT> &#10229;<TT> A(7..1)</TT>,<BR>
<TT> A(7)</TT> &#10229;<TT> 0</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> alf</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sla [a],4</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A(7..4)</TT> &#10229;<TT> A(3..0)</TT>,<BR>
<TT> A(3..0)</TT> &#10229;<TT> 0</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> arf</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> srl [a],4</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A(3..0)</TT> &#10229;<TT> A(7..4)</TT>,<BR>
<TT> A(7..4)</TT> &#10229;<TT> 0</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lar n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> R(n), n=0..11</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lar 12</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,(st)</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> R(S,T)</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lar 13</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,(st)-</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> R(S,T)</TT>,<BR>
<TT> S</TT> &#10229;<TT> S-1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lar 14</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,(st)+</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> R(S,T)</TT>,<BR>
<TT> S</TT> &#10229;<TT> S+1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sar n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld n,a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> R(n)</TT> &#10229;<TT> A, n=0..11</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sar 12</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld (st),a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> R(S,T)</TT> &#10229;<TT> A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sar 13</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld (st)-,a</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> R(S,T)</TT> &#10229;<TT> A</TT>,<BR>
<TT> S</TT> &#10229;<TT> S-1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sar 14</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld (st)+,a</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> R(S,T)</TT> &#10229;<TT> A</TT>,<BR>
<TT> S</TT> &#10229;<TT> S+1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> adr n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> add a,n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> +<TT> R(n), n=0..11</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> adr 12</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> add a,(st)</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> +<TT> R(S,T)</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> adr 13</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> add a,(st)-</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> +<TT> R(S,T)</TT>,<BR>
<TT> S</TT> &#10229;<TT> S-1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> adr 14</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> add a,(st)+</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> +<TT> R(S,T)</TT>,<BR>
<TT> S</TT> &#10229;<TT> S+1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> anr n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> and a,n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &and;<TT> R(n), n=0..11</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> anr 12</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> and a,(st)</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &and;<TT> R(S,T)</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> anr 13</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> and a,(st)-</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &and;<TT> R(S,T)</TT>,<BR>
<TT> S</TT> &#10229;<TT> S-1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> anr 14</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> and a,(st)+</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &and;<TT> R(S,T)</TT>,<BR>
<TT> S</TT> &#10229;<TT> S+1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> eor n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> xor a,n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &veebar;<TT> R(n), n=0..11</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> eor 12</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> xor a,(st)</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &veebar;<TT> R(S,T)</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> eor 13</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> xor a,(st)-</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &veebar;<TT> R(S,T)</TT>,<BR>
<TT> S</TT> &#10229;<TT> S-1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> eor 14</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> xor a,(st)+</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> A</TT> &veebar;<TT> R(S,T)</TT>,<BR>
<TT> S</TT> &#10229;<TT> S+1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> dec n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> dec a,n</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> R(n)</TT> &#10229;<TT> R(n) - 1, n=0..11</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> dec 12</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> dec a,(st)</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> R(S,T)</TT> &#10229;<TT> R(S,T) - 1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> dec 13</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> dec a,(st)-</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> R(S,T)</TT> &#10229;<TT> R(S,T) - 1</TT>,<BR>
<TT> S</TT> &#10229;<TT> S-1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> dec 14</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> dec a,(st)+</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> R(S,T)</TT> &#10229;<TT> R(S,T) - 1</TT>,<BR>
<TT> S</TT> &#10229;<TT> S+1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> six</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld (z(x)),a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> (Z(module X))</TT> &#10229;<TT> A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> lix</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,(z(x))</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> (Z(module X))</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> liy</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld a,(z(y))</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> A</TT> &#10229;<TT> (Z(module Y))</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sqx</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld q(x),a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> Q(module X)</TT> &#10229;<TT> X|A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> sqy</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld q(y),a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> Q(module Y)</TT> &#10229;<TT> Y|A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> szx</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld z(x),a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> Z(module X)</TT> &#10229;<TT> X|A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> szy</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ld z(y),a</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> Z(module Y)</TT> &#10229;<TT> Y|A</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><A NAME="ref_CP3FInst"></A></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
</TABLE></CENTER>
<P>

<H2><A NAME="sect_4_18_">4.18. 4004/4040</A></H2>
<P>
John Weinrich sei dank, habe ich nun auch die offiziellen
Datenbl&auml;tter von Intel &uuml;ber diese 'Urv&auml;ter' aller
Mikroprozessoren, und die Unklarheiten &uuml;ber die Syntax von
Registerpaaren (f&uuml;r 8-Bit-Operationen) sind f&uuml;rs erste
ausger&auml;umt. Die Syntax lautet<TT> RnRm</TT>, wobei<TT> n</TT>
bzw.<TT> m</TT> gerade Integers im Bereich 0 bis E bzw. 1 bis F sind.
Dabei gilt immer<TT> m = n + 1</TT>.
<P>

<H2><A NAME="sect_4_19_">4.19. MCS-48</A></H2>
<P>
Der maximale Adre&szlig;raum dieser Prozessoren betr&auml;gt 4 KByte,
bzw. 8 KByte bei einigen Philips-Varianten. Dieser Raum ist jedoch
nicht linear organisiert (wie k&ouml;nnte das bei Intel auch anders
sein...), sondern in 2 B&auml;nke zu 2 Kbyte geteilt. Ein Wechsel
zwischen diesen beiden B&auml;nken ist nur durch die Befehle<TT>
CALL</TT> und<TT> JMP</TT> erlaubt, indem vor dem Sprung das
h&ouml;chste Adre&szlig;bit mit den Befehlen<TT> SEL MB0</TT> bis<TT>
SEL MB3</TT> vorgegeben wird.
<P>
Man kann dem Assembler mit einem
<PRE>

         ASSUME MB:&lt;0..3&gt;

</PRE>
mitteilen, welche Speicherbank gerade f&uuml;r Sprungziele
gew&auml;hlt ist; wird auf eine Adresse gesprungen, die
au&szlig;erhalb dieser Bank liegt, wird eine Warnung ausgegeben.
<P>
Wenn der Sonderwert<TT> NOTHING</TT> angegeben wird (dies ist auch
der Default), so greift eine in den Befehlen<TT> JMP</TT> und<TT>
CALL</TT> eingebaute Automatik , die den Wechsel zwischen den
B&auml;nken vereinfacht. Sie f&uuml;gt automatisch einen<TT> SEL
MBx</TT> Befehl ein, falls die Adresse des Sprungbefehles und das
Sprungziel in unterschiedlichen B&auml;nken liegen. Die explizite
Benutzung der<TT> SEL MBx</TT>-Befehle ist dann nicht mehr notwendig
(obwohl sie m&ouml;glich bleibt) und kann die Automatik auch
durcheinanderbringen, wie in dem folgenden Beispiel:
<PRE>

000:    SEL     MB1
	JMP     200h

</PRE>
AS nimmt an, da&szlig; das MB-Flag auf 0 steht und f&uuml;gt
keinen<TT> SEL MB0</TT>-Befehl vor dem Sprung ein, mit der Folge,
da&szlig; der Prozessor zur Adresse A00h springt. Weiterhin ist zu
beachten, da&szlig; ein Sprungbefehl durch diesen Mechanismus unter
Umst&auml;nden ein Byte l&auml;nger wird.
<P>

<H2><A NAME="sect_4_20_">4.20. MCS-51</A></H2>
<P>
Dem Assembler liegen die Dateien STDDEF51.INC bzw. 80C50X.INC bei, in
denen alle Bits und SFRs der Prozessoren 8051, 8052 und 80515 bzw.
80C501, 502 und 504 verzeichnet sind. Je nach Einstellung des
Prozessortyps mit dem<TT> CPU</TT>-Befehl wird dabei die korrekte
Untermenge eingebunden, die richtige Reihenfolge f&uuml;r den Anfang
eines Programms ist daher
<PRE>

	CPU     &lt;Prozessortyp&gt;
	INCLUDE stddef51.inc   ,

</PRE>
sonst f&uuml;hren die MCS-51-Pseudobefehle in der Include-Datei zu
Fehlermeldungen.
<P>
Da der 8051 keinen Befehl kennt, um die Register 0..7 auf den Stack
zu legen, mu&szlig; mit deren absoluten Adressen gearbeitet werden.
Diese h&auml;ngen aber von der momentan aktiven Registerbank ab. Um
diesem Mi&szlig;stand etwas abzuhelfen, ist in den Include-Dateien
das Makro<TT> USING</TT> definiert, dem als Parameter die Symbole<TT>
Bank0..Bank3</TT> gegeben werden k&ouml;nnen. Das Makro belegt
daraufhin die Symbole<TT> AR0..AR7</TT> mit den passenden absoluten
Adressen der Register. Dieses Makro sollte nach jeder Bankumschaltung
benutzt werden. Es erzeugt selber<I> keinen</I> Code zur Umschaltung!
<P>
Das Makro f&uuml;hrt in der Variablen<TT> RegUsage</TT> gleichzeitig
Buch &uuml;ber alle jemals benutzten Registerb&auml;nke; Bit 0
entspricht Bank 0, Bit 1 der Bank 1 usw. . Der Inhalt kann am Ende
der Quelldatei z.B. mit folgendem Codest&uuml;ck ausgegeben werden:
<PRE>

	irp     BANK,Bank0,Bank1,Bank2,Bank3
	 if      (RegUsage&(2^BANK))&lt;&gt;0
	  message "Bank \{BANK} benutzt"
	 endif
	endm

</PRE>
Mit der Mehrpass-F&auml;higkeit ab Version 1.38 wurde es
m&ouml;glich, zus&auml;tzlich die Befehle<TT> JMP</TT> und<TT>
CALL</TT> einzuf&uuml;hren. Bei der Kodierung von Spr&uuml;ngen mit
diesen Befehlen w&auml;hlt AS je nach Adre&szlig;lage automatisch die
optimale Variante, d.h.<TT> SJMP/AJMP/LJMP</TT> f&uuml;r<TT> JMP</TT>
und<TT> ACALL/LCALL</TT> f&uuml;r<TT> CALL</TT>. Es ist
nat&uuml;rlich weiterhin m&ouml;glich, die Varianten direkt zu
verwenden, um eine bestimmte Kodierung zu erzwingen.
<P>

<H2><A NAME="sect_4_21_">4.21. MCS-251</A></H2>
<P>
Intel hat sich beim 80C251 ja bem&uuml;ht, den &Uuml;bergang f&uuml;r
den Programmierer auf die neue Familie so weich wie m&ouml;glich zu
gestalten, was darin gipfelt, da&szlig; alte Anwendungen ohne
Neu&uuml;bersetzung auf dem neuen Prozessor ablaufen k&ouml;nnen.
Sobald man jedoch den erweiterten Befehlssatz der 80C251 nutzen will,
gilt es, einige Details zu beachten, die sich als versteckte
Fu&szlig;angeln auftun.
<P>
An vorderster Stelle steht dabei die Tatsache, da&szlig; der 80C251
keinen getrennten Bitadre&szlig;raum mehr hat. Es sind nunmehr alle
SFRs unabh&auml;ngig von ihrer Adre&szlig;lage sowie die ersten 128
Speicherstellen des internen RAMs bitadressierbar. M&ouml;glich wird
dies dadurch, da&szlig; die Bitadressierung nicht mehr &uuml;ber
einen zus&auml;tzlichen virtuellen Adre&szlig;raum, der andere
Adre&szlig;r&auml;ume &uuml;berdeckt, erfolgt, sondern so wie bei
anderen Prozessoren auch durch eine zweidimensionale Adressierung,
die aus der Speicherstelle, die das Bit beinhaltet sowie der
Bitstelle im Byte besteht. Dies bedeutet zum einen, da&szlig; bei
einer Bitangabe wie z.B. PSW.7 AS die Zerlegung der Teile links und
rechts vom Punkt selber vornimmt. Es ist also nicht mehr n&ouml;tig,
mittels eines<TT> SFRB</TT>-Befehls wie noch beim 8051 explizit 8
Bitsymbole zu erzeugen. Dies bedeutet zum anderen, da&szlig; es
den<TT> SFRB</TT>-Befehl &uuml;berhaupt nicht mehr gibt. Wird er in
zu portierenden 8051-Programmen benutzt, kann er durch einen
einfachen<TT> SFR</TT>-Befehl ersetzt werden.
<P>
Weiterhin hat Intel in den unterschiedlichen Adre&szlig;r&auml;umen
des 8051 geh&ouml;rig aufger&auml;umt: Der Bereich des internen RAMs
(<TT>DATA</TT> bzw.<TT> IDATA</TT>), der<TT> XDATA</TT>-Bereich und
er bisherige<TT> CODE</TT>-Bereich wurden in einem einzigen, 16 Mbyte
gro&szlig;en<TT> CODE</TT>-Bereich vereinigt. Das interne RAM beginnt
bei Adresse 0, das interne ROM beginnt bei Adresse ff0000h, dorthin
mu&szlig; also auch der Code mittels<TT> ORG</TT> hinverlagert
werden. Ausgelagert wurden dagegen die<TT> SFRs</TT> in einen eigenen
Adre&szlig;raum (der bei AS als<TT> IO</TT>-Segment definiert ist).
In diesem neuen Adre&szlig;raum haben sie aber die gleichen Adressen
wie beim 8051. Der<TT> SFR</TT>-Befehl kennt diesen Unterschied und
legt mit ihm erzeugte Symbole je nach Zielprozessor automatisch
ins<TT> DATA</TT>- bzw.<TT> IO</TT>-Segment. Da es keinen
Bit-Adre&szlig;raum mehr gibt, funktioniert der<TT> BIT</TT>-Befehl
v&ouml;llig anders: anstelle einer linearen Adresse von 0 bis 255
beinhalten Bit-Symbole jetzt in Bit 0..7 die Adresse, in Bit 24..26
die Bitstelle. Damit ist es jetzt leider nicht mehr so einfach
m&ouml;glich, Felder von Flags mit symbolischen Namen anzulegen: Wo
man beim 8051 noch z.B.
<PRE>

        segment bitdata

bit1    db      ?
bit2    db      ?

</PRE>
oder
<PRE>

defbit	macro   name
name    bit     cnt
cnt     set     cnt+1
        endm

</PRE>
schreiben konnte, hilft jetzt nur noch die zweite Variante weiter,
z.B. so:
<PRE>

adr     set     20h     ; Startadresse Flags im internen RAM
bpos    set     0

defbit  macro   name
name    bit     adr.bpos
bpos    set     bpos+1
        if      bpos=8
bpos     set     0
adr      set     adr+1
        endif
        endm

</PRE>
Ein weiteres, kleines Detail: Da Intel als Kennzeichnung f&uuml;r den
Carry nun CY statt C bevorzugt, sollte man ein eventuell benutztes
Symbol umbenennen. AS versteht aber auch weiterhin die alte Variante
in den Befehlen<TT> CLR, CPL, SETB, MOV, ANL,</TT> und<TT> ORL</TT>.
Gleiches gilt sinngem&auml;&szlig; f&uuml;r die dazugekommenen
Register<TT> R8..R15, WR0..WR30, DR0..DR28, DR56, DR60, DPX</TT>
und<TT> SPX</TT>.
<P>
Intel m&ouml;chte es gerne, da&szlig; man absolute Adressen in der
Form<TT> XX:YYYY</TT> schreibt, wobei<TT> XX</TT> eine 64K-Bank im
Adre&szlig;raum angibt bzw. mit einem<TT> S</TT> Adressen im IO-Raum
kennzeichnet. Wie man sich schon denken kann, halte ich davon nicht
allzu viel, weshalb man an allen Stellen Adressen genauso gut linear
angeben kann; lediglich um das S f&uuml;r die Kennzeichnung von
I/O-Adressen kommt man nicht herum, z.B. hier:
<PRE>

Carry   bit   s:0d0h.7

</PRE>
Ohne den Pr&auml;fix w&uuml;rde AS die absolute Adresse in das
Code-Segment legen, und dort sind ja nur die ersten 128 Byte
bitadressierbar...
<P>
Wie auch schon beim 8051 gibt es die generischen Befehle<TT> JMP</TT>
und<TT> CALL</TT>, die je nach Adre&szlig;lage automatisch die
k&uuml;rzeste Variante einsetzen. W&auml;hrend<TT> JMP</TT> aber die
Variante mit 24 Bit mitber&uuml;cksichtigt, tut<TT> CALL</TT> dies
aus gutem Grund nicht: Der<TT> ECALL</TT>-Befehl legt n&auml;mlich im
Gegensatz zu<TT> ACALL</TT> und<TT> LCALL</TT> 3 Bytes auf den Stack,
und man h&auml;tte sonst einen<TT> CALL</TT>-Befehl, bei dem man
nicht mehr genau wei&szlig;, was er tut. Bei<TT> JMP</TT> tritt diese
Problem nicht auf.
<P>
Aus einer Sache bin ich nicht ganz schlau geworden: Der 80251 kann
auch immediate-Operanden auf den Stack legen, und zwar sowohl
einzelne Bytes als auch ganze W&ouml;rter. F&uuml;r beide Varianten
ist aber der gleiche Befehl<TT> PUSH</TT> vorgesehen -- und woher
soll bitte ein Assembler bei einer Anweisung wie
<PRE>

        push #10

</PRE>
wissen, ob ein Byte oder ein Wort mit dem Wert 10 auf den Stack
gelegt werden soll? Daher gilt im Augenblick die Regelung,
da&szlig;<TT> PUSH</TT> grunds&auml;tzlich ein Byte ablegt; wer ein
Wort ablegen will, schreibt einfach<TT> PUSHW</TT> anstelle<TT>
PUSH</TT>.
<P>
Noch ein gut gemeinter Ratschlag: Wer den erweiterten Befehlssatz des
80C251 nutzt, sollte den Prozessor auch tunlichst im Source-Modus
betreiben, sonst werden alle neuen Anweisungen ein Byte l&auml;nger!
Um die origin&auml;ren 8051-Anweisungen, die daf&uuml;r im
Source-Modus l&auml;nger werden, ist es nicht besonders schade: Sie
werden entweder von AS automatisch durch neue, leistungsf&auml;higere
ersetzt oder sind be- treffen veraltete Adressierungsarten (indirekte
Adressierung mit 8-Bit-Registern).
<P>

<H2><A NAME="sect_4_22_">4.22. 8080/8085</A></H2>
<A NAME="ref_8080Spec"></A>
<P>
Wie schon weiter vorne erw&auml;hnt, ist es m&ouml;glich, durch ein
<PRE>

       Z80SYNTAX &lt;OFF|ON|EXCLUSIVE&gt;

</PRE>
f&uuml;r die allermeisten 8080/8085-Befehle m&ouml;glich, sie auch
wahlweise oder ausschlie&szlig;lich im 'Z80-Stil' zu schreiben, d.h.
mit weniger Mnemonics, daf&uuml;r aber mit deutlich
aussagekr&auml;ftigeren Operanden. F&uuml;r die folgenden Befehle ist
die Z80-Syntax im nicht-exklusiven Modus nicht m&ouml;glich, da sie
mit existierenden 8080-Mnemonics kollidieren:
<UL>
<LI> <TT>CP</TT> ist in der 'Intel-Syntax' der Befehl f&uuml;r 'Call on
    Positive', in der Zilog-Syntax jedoch der Befehl f&uuml;r
    'Compare'. Verwendet man<TT> CP</TT> mit einem absoluten
    Zahlenwert als Argument, so ist f&uuml;r den Assembler nicht zu
    erkennen, ob das ein Sprung zu einer absoluten Adresse sein soll
    oder ein Vergleich mit einem immediate-Wert. Der Assembler wird
    in so einem Fall einen Sprung kodieren, da die Intel-Syntax bei
    Mehrdeutigkeiten Vorrang hat. M&ouml;chte man den Vergleich
    haben, so kann man den Akkumulator als Zieloperanden explizit
    hinschreiben, also z.B.<TT> CP A,12h</TT> anstatt<TT> CP
    12h</TT>.</LI>
<LI> <TT>JP</TT> ist in der Intel-Syntax der Befehl f&uuml;r 'Jump on
    Positive', in der Zilog-Syntax jedoch der allgemeine
    Sprung-Befehl. F&uuml;r bedingte Spr&uuml;nge in Zilog-Syntax
    (<TT>JP cond,addr</TT>) ist die Sache wegen der zwei Argumente
    eindeutig, bei nur einem Argument wird der Assembler aber den
    bedingten Sprung kodieren. Wer einen unbedingten Sprung zu einer
    absoluten Adresse haben m&ouml;chte, mu&szlig; weiterhin die
    Intel-Variante (<TT>JMP addr</TT>) verwenden.</LI>
</UL>
Der 8085 unterst&uuml;tzt mit<TT> RIM</TT> und<TT> SIM</TT> zwei
Befehle, die im Z80-Befehlssatz nicht existieren. Diese k&ouml;nnen
''Z80-artig'' als<TT> LD A,IM</TT> bzw.<TT> LD IM,A</TT> geschrieben
werden.
<P>
Der beim Z80-Target definierte 'generische Sprungbefehl'<TT> J</TT>
ist bei aktivierter Z80-Syntax ebenfalls verf&uuml;gbar, da der
8080/8085 jedoch keine relativen Spr&uuml;nge unterst&uuml;tzt,
wird<TT> J</TT> immer in<TT> JP</TT> &uuml;bersetzt.
<P>

<H2><A NAME="sect_4_23_">4.23. 8085UNDOC</A></H2>
<A NAME="ref_8085Spec"></A>
<P>
&Auml;hnlich wie beim Z80 oder 6502, sind auch beim 8085 die
undokumentierten Befehle nicht n&auml;her von Intel spezifiziert
worden, weshalb es nicht undenkbar ist, da&szlig; andere Assembler
andere Mnemonics daf&uuml;r verwenden. Deshalb sollen auch diese
Befehle und ihre Funktion hier kurz aufgelistet werden. Und auch hier
wieder ist die Verwendung dieser Befehle auf eigenes Risiko - schon
der an sich zum 8085 aufw&auml;rtskompatible Z80 benutzt diese
Opcodes f&uuml;r v&ouml;llig andere Funktionen...
<P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> DSUB [reg]</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SUB HL,reg</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> HL &larr; HL - reg</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> CY, S, X5, AC, Z, V, P</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> reg</TT> = B f&uuml;r BC (optional f&uuml;r nicht-Z80-Syntax)</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ARHL</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SRA HL</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> HL,CY &larr; HL &gt;&gt; 1 (arithmetisch)</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> CY</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP> keine bzw. fix f&uuml;r Z80-Syntax</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RDEL</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RLC DE</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> CY,DE &larr; DE &lt;&lt; 1</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> CY, V</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP> keine bzw. fix f&uuml;r Z80-Syntax</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LDHI d8</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ADD DE,HL,d8</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> DE &larr; HL +<TT> d8</TT></TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> d8</TT> = 8-Bit-Konstante, Register fix f&uuml;r Z80-Syntax</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LDSI d8</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ADD DE,SP,d8</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> DE &larr; SP +<TT> d8</TT></TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> d8</TT> = 8-Bit-Konstante, Register fix f&uuml;r Z80-Syntax</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RSTflag</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RST flag</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> Restart zu 40h wenn<TT> flag</TT>=1</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> flag</TT> = V f&uuml;r Overflow-Bit</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHLX [reg]</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LD (reg),HL</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> [reg] &larr; HL</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> reg</TT> = D/DE f&uuml;r DE (optional f&uuml;r nicht-Z80-Syntax)</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LHLX [reg]</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LD HL,(reg)</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> HL &larr;[reg]</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> reg</TT> = D/DE f&uuml;r DE (optional f&uuml;r nicht-Z80-Syntax)</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> JNX5 adr</TT></TD></TR>
<TR><TD NOWRAP> Z80-Syntax</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> JP NX5, adr</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> springe zu<TT> adr</TT> wenn X5=0</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> adr</TT> = absolute 16-Bit-Adresse</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> JX5 adr</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> springe zu<TT> adr</TT> wenn X5=1</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> adr</TT> = absolute 16-Bit-Adresse</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
Mit X5 ist dabei das ansonsten unbenutzte Bit 5 im PSW-Register
gemeint.
<P>

<H2><A NAME="sect_4_24_">4.24. 8086..V35</A></H2>
<P>
Eigentlich hatte ich mir geschworen, die Segmentseuche der 8086er aus
diesem Assembler herauszuhalten. Da aber nun eine Nachfrage kam und
Studenten flexiblere Menschen als die Entwickler dieses Prozessors
sind, findet sich ab sofort auch eine rudiment&auml;re
Unterst&uuml;tzung dieser Prozessoren in AS. Unter
,,rudiment&auml;r'' verstehe ich dabei nicht, da&szlig; der
Befehlssatz nicht vollst&auml;ndig abgedeckt wird, sondern da&szlig;
ich nicht den ganzen Wust an Pseudoanweisungen integriert habe, die
sich bei MASM, TASM &amp; Co. finden. AS ist auch nicht in erster
Linie geschrieben worden, um PC-Programme zu entwickeln (Gott
bewahre, das hie&szlig;e wirklich, das Rad neu zu erfinden), sondern
zur Programmentwicklung f&uuml;r Einplatinenrechner, die eben unter
anderem auch mit 8086ern best&uuml;ckt sein k&ouml;nnen.
<P>
F&uuml;r Unentwegte, die mit AS doch DOS-Programme schreiben wollen,
eine kleine Liste dessen, was zu beachten ist:
<UL>
<LI> Es k&ouml;nnen nur COM-Programme erzeugt werden.</LI>
<LI> Verwenden Sie nur das<TT> CODE</TT>-Segment, und legen Sie auch alle
    Variablen darin ab.</LI>
<LI> Alle Segmentregister werden von DOS auf das Codesegment
    vorinitialisiert. Ein<TT> ASSUME DS:CODE, SS:CODE</TT> am
    Programmanfang ist daher notwendig.</LI>
<LI> DOS l&auml;dt den Code ab Adresse 100h. Ein<TT> ORG</TT> auf diese
    Adresse ist daher zwingend.</LI>
<LI> Die Umwandlung in eine Bin&auml;rdatei erfolgt mit P2BIN (s.u.),
    wobei als als Adre&szlig;bereich<TT> $-$</TT> anzugeben ist.</LI>
</UL>
Allgemein unterst&uuml;tzt AS f&uuml;r diese Prozessoren nur ein
Small-Programmiermodell, d.h.<I> ein</I> Codesegment mit maximal 64
KByte und ein ebenfalls h&ouml;chstens 64 KByte gro&szlig;es
Datensegment mit (f&uuml;r COM-Dateien uninitialisierten) Daten.
Zwischen diesen beiden Segmenten kann mit dem<TT> SEGMENT</TT>-Befehl
hin-und hergeschaltet werden. Aus dieser Tatsache folgert, da&szlig;
Spr&uuml;nge immer intrasegment&auml;r sind, sofern sie sich auf
Adressen im Codesegment beziehen. Falls weite Spr&uuml;nge doch
einmal erforderlich sein sollten, k&ouml;nnen sie mit<TT> CALLF</TT>
und<TT> JMPF</TT> und einer Speicheradresse oder einen
Segment:Offset-Wert als Argument erreicht werden.
<P>
Ein weiteres gro&szlig;es Problem dieser Prozessoren ist deren
Assemblersyntax, deren genaue Bedeutung nur aus dem Zusammenhang
erkennbar ist. So kann im folgenden Beispiel je nach Symboltyp sowohl
unmittelbare als auch absolute Adressierung gemeint sein:
<PRE>

        mov     ax,wert

</PRE>
Bei AS ist immer unmittelbare Adressierung gemeint, wenn um den
Operanden keine eckigen Klammern stehen. Soll z.B. die Adresse oder
der Inhalt einer Variablen geladen werden, so ergeben sich die in
Tabelle <A HREF="#ref_TabMASM">4.5</A> aufgelisteten Unterschiede.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Assembler</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Adresse</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Inhalt</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>MASM<BR>
<BR>
<BR>
<BR>
AS<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> mov ax,offset vari</TT><BR>
<TT> lea ax,vari</TT><BR>
<TT> lea ax,[vari]</TT><BR>
<BR>
<TT> mov ax,vari</TT><BR>
<TT> lea ax,[vari]</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> mov ax,vari</TT><BR>
<TT> mov ax,[vari]</TT><BR>
<BR>
<BR>
<TT> mov ax,[vari]</TT><BR>
<BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.5: Unterschiede in der Adressierungssyntax AS&harr;MASM<A
             NAME="ref_TabMASM"></A>
</CENTER><P>

<P>
Der Assembler pr&uuml;ft bei Symbolen, ob sie im Datensegment liegen
und versucht, automatisch einen passenden Segmentpr&auml;fix
einzuf&uuml;gen, z.B. falls ohne CS-Pr&auml;fix auf Symbole im Code
zugegriffen wird. Dieser Mechanismus kann jedoch nur funktionieren,
falls der<TT> ASSUME</TT>-Befehl (siehe dort) korrekt angewendet
wurde.
<P>
Die Intel-Syntax verlangt eine Abspeicherung, ob an einem Symbol
Bytes oder W&ouml;rter abgelegt wurden. AS nimmt diese Typisierung
nur vor, falls in der gleichen Zeile wie das Label ein<TT> DB</TT>
oder<TT> DW</TT> steht. F&uuml;r alle anderen F&auml;lle mu&szlig;
mit den Operatoren<TT> WORD PTR, BYTE PTR</TT> usw. explizit
angegeben werden, um was f&uuml;r eine Operandengr&ouml;&szlig;e es
sich handelt. Solange ein Register an der Operation beteiligt ist,
kann auf diese Kennzeichnung verzichtet werden, da durch den
Registernamen die Operandengr&ouml;&szlig;e eindeutig bestimmt ist.
<P>
Der Koprozessor in 8086-Systemen wird &uuml;blicherweise durch den
TEST-Eingang des Prozessors synchronisiert, indem selbiger mit dem
BUSY-Ausgang des Koprozessors verbunden wird. AS unterst&uuml;tzt
dieses Handshaking, indem vor jedem 8087-Befehl automatisch ein<TT>
WAIT</TT>-Befehl eingef&uuml;gt wird. Ist dies aus irgendwelchen
Gr&uuml;nden unerw&uuml;nscht (z.B. w&auml;hrend der
Initialisierung), so mu&szlig; im Opcode hinter dem<TT> F</TT>
ein<TT> N</TT> eingef&uuml;gt werden; aus
<PRE>

        FINIT
        FSTSW   [vari]

</PRE>
wird so z.B.
<PRE>

        FNINIT
        FNSTSW  [vari]

</PRE>
Diese Variante ist bei<I> allen</I> Koprozessorbefehlen erlaubt.
<P>

<H2><A NAME="sect_4_25_">4.25. 8X30x</A></H2>
<A NAME="ref_8X30xSpec"></A>
<P>
Die Prozessoren dieser Reihe sind auf eine einfache Manipulation von
Bitgruppen auf Peripherieadressen optimiert worden. Um mit solchen
Bitgruppen auch symbolisch umgehen zu k&ouml;nnen, existieren die
Befehle<TT> LIV</TT> und<TT> RIV</TT>, mit denen einer solchen
Bitgruppe ein symbolischer Name zugewiesen wird. Diese Befehle
arbeiten &auml;hnlich wie<TT> EQU</TT>, ben&ouml;tigen aber drei
Parameter:
<OL>
<LI>die Adresse der peripheren Speicherzelle, in der sich die Bitgruppe
    befindet (0..255);</LI>
<LI>die Bitnummer des ersten Bits in der Gruppe (0..7);</LI>
<LI>die L&auml;nge der Gruppe in Bits (1..8).</LI>
</OL>
<B> ACHTUNG!</B> Der 8X30x unterst&uuml;tzt keine Bitgruppen, die
&uuml;ber mehrere Speicherstellen hinausreichen, so da&szlig; je nach
Startposition der Wertebereich f&uuml;r die L&auml;nge
eingeschr&auml;nkt sein kann. AS nimmt hier<B> keine</B> Pr&uuml;fung
vor, man bekommt lediglich zur Laufzeit merkw&uuml;rdige Ergebnisse!
<P>
Im Maschinencode dr&uuml;cken sich L&auml;nge und Position durch ein
3-Bit-Feld im Instruktionswort sowie ein passende Registernummer
(<TT>LIVx</TT> bzw.<TT> RIVx</TT>) aus. Bei der Verwendung eines
symbolischen Objektes wird AS diese Felder automatisch richtig
besetzen, es ist aber auch erlaubt, die L&auml;nge als dritten
Operanden explizit anzugeben, wenn man nicht mit symbolischen
Busobjekten arbeitet. Trifft AS auf eine L&auml;ngenangabe trotz
eines symbolischen Operanden, so vergleicht er beide L&auml;ngen und
gibt eine Fehlermeldung bei Ungleichheit aus (das gleiche passiert
&uuml;brigens auch, wenn man bei einem<TT> MOVE</TT>-Befehl zwei
symbolische Operanden mit unterschiedlicher L&auml;nge benutzt - die
Instruktion hat einfach nur ein L&auml;ngenfeld...).
<P>
Neben den eigentlichen Maschinenbefehlen des 8X30x implementiert AS
noch &auml;hnlich wie das ,,Vorbild'' MCCAP einige
Pseudoinstruktionen, die als eingebaute Makros ausgef&uuml;hrt sind:
<UL>
<LI> <TT>NOP</TT> ist eine Kurzschreibweise f&uuml;r<TT> MOVE
    AUX,AUX</TT></LI>
<LI> <TT>HALT</TT> ist eine Kurzschreibweise f&uuml;r<TT> JMP *</TT></LI>
<LI> <TT>XML ii</TT> ist eine Kurzschreibweise f&uuml;r<TT> XMIT
    ii,R12</TT> (nur 8X305)</LI>
<LI> <TT>XMR ii</TT> ist eine Kurzschreibweise f&uuml;r<TT> XMIT
    ii,R13</TT> (nur 8X305)</LI>
<LI> <TT>SEL &lt;busobj&gt;</TT> ist eine Kurzschreibweise f&uuml;r<TT>
    XMIT &lt;adr&gt;,IVL/IVR</TT>, f&uuml;hrt also die notwendige
    Vorselektion durch, um<TT> &lt;busobj&gt;</TT> ansprechen zu
    k&ouml;nnen.</LI>
</UL>
Die bei MCCAP ebenfalls noch vorhandenen<TT> CALL-</TT> und<TT>
RTN-</TT>Instruktionen sind mangels ausreichender Dokumentation
momentan nicht implementiert. Das gleiche gilt f&uuml;r einen Satz an
Pseudoinstruktionen zur Datenablage. Kommt Zeit, kommt Rat...
<P>

<H2><A NAME="sect_4_26_">4.26. XA</A></H2>
<P>
&Auml;hnlich wie sein Vorg&auml;nger MCS/51, jedoch im Unterschied zu
seinem ,,Konkurrenten'' MCS/251 besitzt der Philips XA einen
getrennten Bitadre&szlig;raum, d.h. alle mit Bitbefehlen
manipulierbaren Bits haben eine bestimmte, eindimensionale Adresse,
die in den Maschinenbefehlen auch so abgelegt wird. Die naheliegende
M&ouml;glichkeit, diesen dritten Adre&szlig;raum (neben Code und
Daten) auch so in AS anzubieten, habe ich nicht nutzen k&ouml;nnen,
und zwar aus dem Grund, da&szlig; ein Teil der Bitadressen im
Gegensatz zum MCS/51 nicht mehr eindeutig ist: Bits mit den Adressen
256 bis 511 bezeichnen Bits der Speicherzellen 20h..3fh aus dem
aktuellen Datensegment. Dies bedeutet aber, da&szlig; diese Adressen
je nach Situation unterschiedliche Bits ansprechen k&ouml;nnen - ein
definieren von Bits mit Hilfe von<TT> DC</TT>-Befehlen, was durch ein
extra Segment m&ouml;glich geworden w&auml;re, w&uuml;rde also nicht
&uuml;berm&auml;&szlig;ig viel Sinn ergeben. Zur Definition
einzelner, symbolisch ansprechbarer Bits steht aber nach wie vor
der<TT> BIT</TT>-Befehl zur Verf&uuml;gung, mit dem beliebige
Bitadressen (Register, RAM, SFR) definiert werden k&ouml;nnen.
F&uuml;r Bitadressen im internen RAM wird auch die 64K-Bank-Adresse
gespeichert, so da&szlig; AS Zugriffe &uuml;berpr&uuml;fen kann,
sofern das DS-Register korrekt mit<TT> ASSUME</TT> vorbesetzt wurde.
<P>
Nichts drehen kann man dagegen an den Bem&uuml;hungen von AS,
potentielle Sprungziele (also Zeilen im Code mit Label) auf gerade
Adressen auszurichten. Dies macht AS genauso wie andere XA-Assembler
auch durch Einf&uuml;gen von<TT> NOP</TT>s vor dem fraglichen Befehl.
<P>

<H2><A NAME="sect_4_27_">4.27. AVR</A></H2>
<P>
Im Gegensatz zum AVR-Assembler verwendet AS defaultm&auml;&szlig;ig
das Intel-Format zur Darstellung von Hexadezimalkonstanten und nicht
die C-Syntax. OK, nicht vorher in den (freien) AVR-Assembler
hineingeschaut, aber als ich mit dem AVR-Teil anfing, gab es zum AVR
noch nicht wesentlich mehr als ein vorl&auml;ufiges Datenbuch mit
Prozessortypen, die dann doch nie kamen...mit einem<TT> RELAXED
ON</TT> schafft man dieses Problem aus der Welt.
<P>
Optional kann AS f&uuml;r die AVRs (es geht auch f&uuml;r andere
CPU's, nur macht es dort keinen Sinn...) sogenannte
,,Objekt-Dateien'' erzeugen. Das sind Dateien, die sowohl Code als
auch Quellzeileninformationen enthalten und z.B. eine schrittweise
Abarbeitung auf Quellcodeebene mit dem von Atmel gelieferten
Simulator WAVRSIM erlauben. Leider scheint dieser mit
Quelldateispezifikationen, die l&auml;nger als ca. 20 Zeichen sind,
seine liebe Not zu haben: Namen werden abgeschnitten oder um wirre
Sonderzeichen erg&auml;nzt, wenn die Maximall&auml;nge
&uuml;berschritten wird. AS speichert deshalb in den Objekt-Dateien
Dateinamen ohne Pfadangabe, so da&szlig; es eventuell Probleme geben
k&ouml;nnte, wenn Dateien (z.B. Includes) nicht im Arbeitsverzeichnis
liegen.
<P>
Eine kleine Besonderheit sind Befehle, die Atmel bereits in der
Architektur vorgesehen hat, aber noch in keinem Mitglied der Familie
implementiert wurden. Dabei handelt es sich um die Befehle<TT> MUL,
JMP</TT> und<TT> CALL</TT>. Besonders bei letzteren fragt man sich
vielleicht, wie man denn nun den 4 KWorte gro&szlig;en
Adre&szlig;raum des AT90S8515 erreichen kann, wenn die
'n&auml;chstbesten' Befehle<TT> RJMP</TT> und<TT> RCALL</TT> doch nur
2 KWorte weit springen kann. Der Kunstgriff lautet 'Abschneiden der
oberen Adre&szlig;bits' und ist n&auml;her bei der<TT>
WRAPMODE</TT>-Anweisung beschrieben.
<P>
F&uuml;r alle AVR-CPUs ist das CPU-Argument<TT> CODESEGSIZE</TT>
definiert. Mit einem
<PRE>

   cpu atmega8:codesegsize=0

</PRE>
weist man den Assembler an, das Code-Segment (also das interne
Flash-ROM) nicht als in 16-Bit-Worten, sondern in 8-Bit-Bytes
organisiert zu betrachten. Dies ist die Sichtweise, wie man sie
beim<TT> LPM</TT>-Befehl hat und wie sie einige andere (nicht-Atmel)
Assembler grunds&auml;tzlich verfolgen. Sie hat den Vorteil,
da&szlig; man Adressen im<TT> CODE</TT>-Segment f&uuml;r
Datenzugriffe nicht selber mit zwei multiplizieren mu&szlig;,
andererseits mu&szlig; aber darauf geachtet werden, da&szlig;
Instruktionen niemals auf einer ungeraden Adresse liegen d&uuml;rfen
- sie w&uuml;rden dann ja quasi halb auf einem und halb auf dem
n&auml;chsten 16-Bit-Wort im Flash-ROM liegen.<TT> PADDING</TT> ist
deshalb im Default aktiviert, es bleibt aber m&ouml;glich, mit<TT>
DB</TT> oder<TT> DATA</TT> Byte-Felder zu definieren, ohne da&szlig;
zwischen den Anweisungen Padding-Bytes eingestreut werden. Bei
relativen oder absoluten Spr&uuml;ngen werden die Adressen im
''Byte-Modus'' automatisch durch zwei geteilt. Default ist die vom
Atmel-Assembler vorgegebene Organisation in unteilbare 16-Bit-Worte.
Diese kann auch explizit mit dem Argument codesegsize=1 gew&auml;hlt
werden.
<P>

<H2><A NAME="sect_4_28_">4.28. Z80, Z18, Z280, Z380</A></H2>
<P>
Der Z80 kennt zwei Arten von Spr&uuml;ngen: relativ (<TT> JR</TT>)
erlaubt Sprungdistanzen von -128 bis +127 Byte, w&auml;hrend man mit
absoluten Spr&uuml;ngen (<TT> JP</TT>) den kompletten Adre&szlig;raum
erreicht. AS unterst&uuml;tzt einen Pseudobefehl<TT> J</TT>, der
anhand der Zieladresse und der Sprungbedingung automatisch die
k&uuml;rzestm&ouml;gliche Variante w&auml;hlt (relative Spr&uuml;nge
sind nicht f&uuml;r alle Bedingungen definiert). Dies gilt auch
f&uuml;r alle vom Z80 abgeleiteten Targets, wie Z80UNDOC, Z180, Z280,
RABBIT2000 und LR35902.
<P>
F&uuml;r den Z380 wird<TT> J</TT> ebenfalls angeboten, da der Z380
jedoch gr&ouml;&szlig;ere Sprungdistanzen unterst&uuml;tzt, wird erst
auf absolute Spr&uuml;nge ausgewichen, wenn die
g&ouml;&szlig;tm&ouml;gliche Sprungdistanz (+/- 8 MByte) nicht mehr
ausreicht.
<P>
Generell sollte dieser Befehl mit Bedacht eingesetzt werden, da<TT>
JR</TT> und<TT> JP</TT> nicht g&auml;nzlich funktionsgleich sind:
Code, der ausschlie&szlig;lich relative Spr&uuml;nge benutzt, kann
positionsunabh&auml;ngig ausgef&uuml;hrt werden, w&auml;hrend
absolute Spr&uuml;nge einer Relozierung bed&uuml;rfen.
<P>

<H2><A NAME="sect_4_29_">4.29. Z80UNDOC</A></H2>
<P>
Da es von Zilog naturgem&auml;&szlig; keine Syntaxvorgaben f&uuml;r
die undokumentierten Befehle gibt und wohl auch nicht jeder den
kompletten Satz kennt, ist es vielleicht sinnvoll, diese Befehle hier
kurz aufzuz&auml;hlen:
<P>
Wie auch beim Z280/Z380 und eZ80 ist es m&ouml;glich, die
Byte-H&auml;lften von IX und IY einzeln anzusprechen. Im einzelnen
sind dies folgende Varianten:
<PRE>

 INC Rx              LD R,Rx             LD  Rx,n
 DEC Rx              LD Rx,R             LD  Rx,Ry
 ADD/ADC/SUB/SBC/AND/XOR/OR/CP A,Rx

</PRE>
Dabei stehen<TT> Rx</TT> bzw.<TT> Ry</TT> f&uuml;r<TT> IXL, IXU,
IYL</TT> oder<TT> IYU</TT>. Zu beachten ist jedoch, da&szlig; in
der<TT> LD Rx,Ry</TT>-Variante beide Register aus dem gleichen
Indexregister stammen m&uuml;ssen.
<P>
Die Kodierung von Schiebebefehlen besitzt noch eine undefinierte
Bitkombination, die als<TT> SL1</TT>-,<TT> SLI</TT>-,<TT> SLIA</TT>-
oder<TT> SLS</TT>-Befehl zug&auml;nglich ist. Er funktioniert wie<TT>
SLA</TT>, es wird jedoch eine Eins und nicht eine Null in Bit 0
eingeschoben.<B> ACHTUNG</B>: In Internet findet man f&uuml;r diesen
Befehl auch den Namen<TT> SLL</TT>, ich habe mich aber entschieden,
dies nicht zu implementieren.<TT> SLL</TT> steht f&uuml;r ,,Shift
Logically Left'' und die von diesem Befehl ausgef&uuml;hrte Operation
ist kein logischer Linksshift - wenn<TT> SLL</TT> &uuml;berhaupt
definiert werden sollte, dann als Alias zu<TT> SLA</TT>. Wer f&uuml;r
existierenden Code<TT> SLL</TT> mit der Funktion von<TT> SL1/SLI</TT>
braucht, definiere sich daf&uuml;r ein Makro.
<P>
Dieser undokumentierte Schiebebefehl kann, wie alle anderen
Schiebebefehle auch, noch in zwei weiteren Varianten benutzt werden:
<PRE>

        SLIA    R,(XY+d)
        SLIA    (XY+d),R

</PRE>
Dabei steht<TT> R</TT> f&uuml;r ein beliebiges 8-Bit-Register (aber
nicht eine Indexregisterh&auml;lfte...), und<TT> (XY+d)</TT> f&uuml;r
eine normale indexregister-relative Adressierung. Das Ergebnis dieser
Operation ist, da&szlig; das Schiebeergebnis zus&auml;tzlich ins
Register geladen wird. Dies funktioniert auch bei den<TT> RES-</TT>
und<TT> SET-</TT>Befehlen:
<PRE>

        SET/RES R,n,(XY+d)
        SET/RES n,(XY+d),R

</PRE>
Des weiteren gibt es noch zwei versteckte I/O-Befehle:
<PRE>

        IN      (C) bzw. TSTI
        OUT     (C),0

</PRE>
Deren Funktionsweise sollte klar sein.<B> ACHTUNG!</B> Es gibt keine
Garantie daf&uuml;r, da&szlig; alle Z80-Masken alle diese Befehle
beherrschen, und die Z80-Nachfolger l&ouml;sen zuverl&auml;ssig Traps
aus. Anwendung daher auf eigene Gefahr...
<P>

<H2><A NAME="sect_4_30_">4.30. GB_Z80 bzw. LR35902</A></H2>
<P>
Das im originalen Gameboy verbaute SoC namens LR35092 wurde von Sharp
entwickelt, und der darin verbaute Prozessorkern ist (vermutlich) der
gleiche wie in den SM83-Mikrokontrollern. Dieser ist vom Befehlssatz
auf dem ,,halben Weg'' zwischen 8080 und Z80, allerdings auch mit
seinen eigenen Auslassungen und Erweiterungen. F&uuml;r die neuen
Befehle hat Sharp nat&uuml;rlich eine Assembler-Syntax definiert, in
der ,,Gameboy-Szene'' haben sich aber auch einige alternative
Schreibweisen eingeb&uuml;rgert. Ich habe mich bem&uuml;ht, diese (so
weit bekannt) zu ber&uuml;cksichtigen:
<P>
<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Sharp</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>alternativ</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD A,(HLD)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD A,(HL-)<BR>
LDD A,(HL)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A &#10229; (HL),<BR>
HL &#10229; HL-1</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD A,(HLI)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD A,(HL+)<BR>
LDI A,(HL)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A &#10229; (HL),<BR>
HL &#10229; HL+1</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD (HLD),A<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD (HL-),A<BR>
LDD (HL),A</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>(HL) &#10229; A,<BR>
HL &#10229; HL-1</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD (HLI),A<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD (HL+),A<BR>
LDI (HL),A</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>(HL) &#10229; A,<BR>
HL &#10229; HL+1</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD A,(C)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD A,(FF00+C)<BR>
LDH A,(C)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A &#10229; (0ff00h+C)<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD (C),A<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD (FF00+C),A<BR>
LDH (C),A</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>(0ff00h+C) &#10229; A<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD (FF00+n),A</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LDH (n),A</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>(0ff00h+n) &#10229; A</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD A,(FF00+n)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LDH A,(n)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A &#10229; (0ff00h+n)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LDHL SP,d</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD HL,SP+d</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>HL &#10229; SP + d</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LDX A,(nn)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD A,(nn)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A &#10229; (nn)<SUP> 1</SUP></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LDX (nn),A</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LD (nn),A</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>(nn) &#10229; A<SUP> 1</SUP></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=3 ALIGN=LEFT><SUP>1</SUP> erzwingt 16-Bit-Adressierung.</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>

<H2><A NAME="sect_4_31_">4.31. Z380</A></H2>
<P>
Da dieser Prozessor als Enkel des wohl immer noch beliebtesten
8-Bit-Prozessors konzipiert wurde, war es bei der Entwicklung
unabdingbar, da&szlig; dieser bestehende Z80-Programme ohne
&Auml;nderung ausf&uuml;hren kann (nat&uuml;rlich geringf&uuml;gig
schneller, etwa um den Faktor 10...). Die erweiterten
F&auml;higkeiten k&ouml;nnen daher nach einem Reset mit zwei Flags
zugeschaltet werden, die XM (eXtended Mode, d.h. 32- statt
16-Bit-Adre&szlig;raum) und LW (long word mode, d.h. 32- statt 16-
Bit-Operanden) hei&szlig;en. Deren Stand mu&szlig; man AS &uuml;ber
die Befehle<TT> EXTMODE</TT> und<TT> LWORDMODE</TT> mitteilen, damit
Adressen und Konstantenwerte gegen die korrekten Obergrenzen
gepr&uuml;ft werden. Die Umschaltung zwischen 32- und 16-Bit-Befehlen
bewirkt nat&uuml;rlich nur bei solchen Befehlen etwas, die auch in
einer 32-Bit-Version existieren; beim Z380 sind das momentan leider
nur Lade- und Speicherbefehle, die ganze Arithmetik kann nur
16-bittig ausgef&uuml;hrt werden. Hier sollte Zilog wohl noch einmal
etwas nachbessern, sonst kann man den Z380 selbst beim besten Willen
nur als ,,16-Bit-Prozessor mit 32-Bit-Erweiterungen'' bezeichnen...
<P>
Kompliziert wird die Sache dadurch, da&szlig; sowohl die mit LW
eingestellte Operandengr&ouml;&szlig;e, als auch die L&auml;nge von
immediate- und absoluten Operanden, f&uuml;r einzelne Befehle mit den
Pr&auml;fixen<TT> DDIR W/LW/IB/IW</TT> AS merkt sich die Verwendung
solcher Befehle und ber&uuml;cksichtigt sie f&uuml;r den
n&auml;chsten Befehl automatisch mit. Dabei sind die folgenden
F&auml;lle zu unterscheiden:
<P>
Ging gar kein<TT> DDIR</TT>-Befehl voraus bzw. einer, der keine
explizite Operandenl&auml;nge enthielt (also weder<TT> IN</TT>,<TT>
IB</TT>, noch<TT> IW</TT>), so wird die Operandenl&auml;nge
automatisch festgelegt. Ein eventuell erforderlicher<TT>
DDIR</TT>-Pr&auml;fix wird automatisch eingef&uuml;gt. Ein einzelnes
<PRE>

        LD      BC,12345678h

</PRE>
wird also automatisch um ein f&uuml;hrendes<TT> DDIR IW</TT>
erg&auml;nzt. In diesem Fall jedoch:
<PRE>

        DDIR    LW
        LD      BC,12345678h

</PRE>
wird der<TT> DDIR</TT>-Pr&auml;fix automatisch um ein<TT> IW</TT>
erg&auml;nzt, effektiv wird also der Code f&uuml;r
<PRE>

        DDIR    LW,IW
        LD      BC,12345678h

</PRE>
erzeugt. Der im ersten Schritt erzeugte Code f&uuml;r<TT> DDIR
LW</TT> wird verworfen, was an einem<TT> R</TT> im Listing zu
erkennen ist.
<P>
Explizite<TT> DDIR</TT>-Pr&auml;fixe mit einem<TT> IN</TT>,<TT>
IB</TT>, oder<TT> IW</TT> k&ouml;nnen genutzt werden, um eine
bestimmte Operandenl&auml;nge zu erzwingen. Zu lange Operanden
f&uuml;hren zu einer Fehlermeldung, k&uuml;rzere werden mit Nullen
auf die geforderte L&auml;nge gebracht. Ein
<PRE>

        DDIR    IB
        LD      BC,12345678h

</PRE>
f&uuml;hrt also zu einer Fehlermeldung, weil die Konstante nicht in
24 Bit hineinpasst. Umgekehrt wird hier
<PRE>

        DDIR    LW,IW
        LD      BC,345678h

</PRE>
die Konstante mit einem Byte mehr kodiert, als eigentlich
erforderlich w&auml;re.
<P>

<H2><A NAME="sect_4_32_">4.32. Z8, Super8 und eZ8</A></H2>
<A NAME="ref_Z8Spec"></A>
<P>
Der Prozessorkern der Z8-Mikrokontroller beinhaltet keine eigenen
Register. Stattdessen kann ein 16er-Block des internen
Adre&szlig;raums aus RAM und I/O-Registern als 'Arbeitsregister'
benutzt werden, die mit 4-Bit-Adressen angesprochen werden
k&ouml;nnen. Welcher 16er-Block als Arbeitsregister benutzt werden
soll, wird mit den RP-Registern festgelegt: Bits 4 bis 7 von RP
definieren beim klassischen Z8 den 'Offset', der auf die
4-Bit-Arbeitsregisteradresse addiert wird, um eine 8-Bit-Adresse zu
erhalten. Beim Super8-Kern existieren zwei RP-Register (RP0 und RP1),
die es erlauben, obere und untere H&auml;lfte der Arbeitsregister an
getrennte Stellen zu legen.
<P>
&Uuml;blicherweise werden die Arbeitsregister in der Assemblersyntax
als Register R0...R15 angesprochen, man kann diese Arbeitsregister
aber auch als eine Methode zur effizienteren (k&uuml;rzeren)
Adressierung eines 16er-Bocks im internen RAM betrachten.
<P>
Mit dem<TT> ASSUME</TT>-Befehl teilt man AS den aktuellen Wert von RP
mit. AS ist dann in der Lage, bei einer Adresse aus dem internen RAM
automatisch zu entscheiden, ob dieser Operand mit einer 4-Bit Adresse
angesprochen werden kann oder eine 8-Bit-Adresse verwendet werden
mu&szlig;. Man kann diese Funktion auch dazu benutzen,
Arbeitsregistern symbolische Namen zu verpassen:
<PRE>

op1     equ     040h
op2     equ     041h

        srp     #040h
        assume  rp:040h

        ld      op1,op2		; entspricht ld r0,r1

</PRE>
Es ist auch auf dem Super8 m&ouml;glich, RP als Argument von<TT>
ASSUME</TT> anzugeben, obwohl dieser kein RP-Register hat (nur RP0
und RP1). In diesem Fall werden die angenommen Werte von RP0 und RP1
auf wert bzw. wert+8 gesetzt, analog zum<TT> SRP</TT> Maschinenbefehl
auf dem Super8- Kern.
<P>
Im Gegensatz zum Original Zilog-Assembler ist es nicht erforderlich,
eine 'Arbeitsregisteradressierung' explizit durch ein vorangestelltes
Ausrufezeichen anzufordern, wobei AS diese Syntax nichtsdestotrotz
versteht - ein vorangestelltes Ausrufezeichen erzwingt quasi
4-Bit-Adressierung, auch wenn die Adresse eigentlich nicht im durch
RP festgelegten 16-Bit-Fenster liegt (dann wird eine Warnung
ausgegeben). Umgekehrt ist es durch ein vorangestelltes &gt;-Zeichen
m&ouml;glich, eine Adressierung mit 8 Bit zu erzwingen, auch wenn die
Adresse eigentlich im aktuellen 16er-Fenster liegt.
<P>
Beim eZ8 wird das Spielchen quasi eine Stufe weiter getrieben: der
interne Daten-Adre&szlig;bereich ist jetzt 12 statt 8 Bit gro&szlig;.
Um kompatibel zum alten Z8-Kern zu sein, hat Zilog die
zus&auml;tzlichen Banking-Bits in den<EM> unteren</EM> vier Bits von
RP untergebracht - ein RP-Wert von 12h definiert also das
16er-Adre&szlig;fenster von 210h bis 21fh.
<P>
Die unteren vier Bits von RP definieren beim eZ8 gleichzeitig das
256er-Fenster, das man mit 8-Bit-Adressen erreichen kann - hier gilt
ein analoger Mechanismus, der daf&uuml;r sorgt, da&szlig; AS
automatisch 12- oder 8-Bit-Adressen verwendet. 'Lange'
12-Bit-Adressen kann man mit zwei vorangestellten &gt;-Zeichen
erzwingen.
<P>

<H2><A NAME="sect_4_33_">4.33. Z8000</A></H2>
<A NAME="ref_Z8000Spec"></A>
<P>
Der Z8001/8003 kann in zwei verschiedenen Modi betrieben werden:
<UL>
<LI> <EM> Nicht segmentiert</EM>: Der Speicheradre&szlig;raum ist auf 64
    KByte beschr&auml;nkt, alle Adressen sind 'einfache' lineare
    16-Bit- Adressen. Adre&szlig;register sind einfache
    16-Bit-Register (Rn), und absolute Adressen in Befehlen sind ein
    16-Bit-Wort lang.</LI>
<LI> <EM> Segmentiert</EM>: Der Speicher ist in bis zu 128 Segmente von
    jeweils maximal 64 KByte aufgeteilt. Adressen bestehen aus einem
    7-bittigen Segment und einem 16-bittigen Offset.
    Adre&szlig;register sind immer Registerpaare (RRn). Absolute
    Adressen in Befehlen sind zwei 16-Bit-Worte lang, au&szlig;er der
    Offset is kleiner 256.</LI>
</UL>
<P>
Die Betriebsart (segmentiert oder nicht segmentiert) hat also einen
Einflu&szlig; auf den erzeugten Code und wird implizit &uuml;ber den
verwendeten Prozessortyp umgeschaltet. Ist das Ziel also z.B. ein
Z8001 im nicht segmentierten Modus, so w&auml;hlt man einfach Z8002
als Ziel.
<P>
Eine 'echte' Unterst&uuml;tzung eines segmentierten Speichermodells
bietet AS indes f&uuml;r den Z8000 genauso wenig wie f&uuml;r den
8086. Im segmentierten Modus wird die Segmentnummer einfach als die
oberen sieben Adre&szlig;bits eines gedacht linearen
8MB-Adre&szlig;raums behandelt. Dies ist eigentlich nicht im Sinne
des Erfinders, aber es entspricht der Art und Weise, wie der Z8001 in
Systemen ohne MMU effektiv betrieben wurde.
<P>
Generell implementiert AS die Assembler-Syntax der
Z8000-Maschinenbefehle so, wie es von Zilog in der Dokumentation
vorgesehen ist. Es existieren jedoch Assembler, die Erweiterungen
bzw. Variationen unterst&uuml;tzen. AS implementiert davon folgendes:
<P>

<H3><A NAME="sect_4_33_1_">4.33.1. Bedingungen</A></H3>
<P>
Zus&auml;tzlich zu den von Zilog definierten Bedingungen sind
folgende alternative Namen definiert:
<P>
<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Alternativ</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Zilog</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>ZR<BR>
CY<BR>
LLE<BR>
LGE<BR>
LGT<BR>
LLT</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Z<BR>
C<BR>
ULE<BR>
UGE<BR>
UGT<BR>
ULT</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Z = 1<BR>
C = 1<BR>
(C OR Z) = 1<BR>
C = 0<BR>
((C = 0) AND (Z = 0)) = 1<BR>
C = 1</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>

<H3><A NAME="sect_4_33_2_">4.33.2. Flags</A></H3>
<P>
Als Argument f&uuml;r die Befehle<TT> SETFLG</TT>,<TT> COMFLG</TT>
und<TT> RESFLG</TT> werden auch die folgenden alternativen Namen
akzeptiert:
<P>
<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Alternativ</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Zilog</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>ZR<BR>
CY</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Z<BR>
C</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Zero-Flag<BR>
Carry-Flag</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>

<H3><A NAME="sect_4_33_3_">4.33.3. Indirekte Adressierung</A></H3>
<P>
Anstelle @Rn darf auch Rn^ geschrieben werden, falls beim<TT>
CPU</TT>- Statement die Option<TT> AMDSyntax=1</TT> gesetzt wurde.
Wird eine I/O-Adresse indirekt adressiert, so reicht es mit dieser
Option auch aus,<EM> nur</EM> Rn zu schreiben.
<P>

<H3><A NAME="sect_4_33_4_">4.33.4. Direkte versus unmittelbare Adressierung</A></H3>
<P>
Bei der von Zilog vorgegebenen Assembler-Syntax mu&szlig;
unmittelbare Adressierung durch ein vorangestelltes Doppelkreuz
kenntlich gemacht werden. Wurde dem<TT> CPU</TT>-Statement jedoch die
Option<TT> AMDSyntax=1</TT> mitgegeben, wird anhand des Arguments
(Label oder Konstante) entschieden, ob direkte oder unmittelbare
Adressierung verwendet werden soll. Unmittelbare Adressierung kann
erzwungen werden, indem dem Argument ein Circumflex vorangestellt
wird, z.B. um die Adresse eines Labels in ein Register zu laden.
<P>

<H2><A NAME="sect_4_34_">4.34. TLCS-900(L)</A></H2>
<A NAME="ref_TLCS900Spec"></A>
<P>
Diese Prozessoren k&ouml;nnen in zwei Betriebsarten laufen, einmal
im<I> Minimum</I>-Modus, der weitgehende Z80- und
TLCS-90-Quellcodekompatibilit&auml;t bietet, und zum anderen im<I>
Maximum</I>-Modus, in dem der Prozessor erst seine wahren
Qualit&auml;ten entfaltet. Die Hauptunterschiede zwischen den beiden
Betriebsarten sind:
<UL>
<LI> Breite der Register WA,BC,DE und HL: 16 oder 32 Bit;</LI>
<LI> Anzahl der Registerbanks: 8 oder 4;</LI>
<LI> Programmadre&szlig;raum: 64 Kbyte oder 16 Mbyte;</LI>
<LI> Breite von R&uuml;cksprungadressen: 16 oder 32 Bit.</LI>
</UL>
Damit AS gegen die richtigen Grenzen pr&uuml;fen kann, mu&szlig; man
ihm zu Anfang mit dem Befehl<TT> MAXMODE</TT> (siehe dort) mitteilen,
in welcher Betriebsart der Code ausgef&uuml;hrt werden wird;
Voreinstellung ist der Minimum-Modus.
<P>
Je nach Betriebsart m&uuml;ssen demzufolge auch die 16- oder
32-Bit-Versionen der Bankregister zur Adressierung verwendet werden,
d.h. WA, BC, DE und HL im Minimum-Modus sowie XWA, XBC, XDE und XHL
im Maximum-Modus. Die Register XIX..XIZ und XSP sind<B> immer</B> 32
Bit breit und m&uuml;ssen zur Adressierung auch immer in dieser Form
verwendet werden; hier mu&szlig; bestehender Z80-Code also auf jeden
Fall angepa&szlig;t werden (neben der Tatsache, da&szlig; es gar
keinen I/O-Adre&szlig;raum mehr gibt und alle I/O-Register
memory-mapped sind...).
<P>
Absolute Adressen sowie Displacements k&ouml;nnen in
unterschiedlichen L&auml;ngen kodiert werden. AS wird ohne explizite
Angaben immer versuchen, die k&uuml;rzestm&ouml;gliche Schreibweise
zu verwenden; dies schlie&szlig;t ein, da&szlig; ein Displacement von
Null &uuml;berhaupt nicht im Code erscheint und aus einen (XIX+0)
einfach ein (XIX) wird. Ist eine bestimmte L&auml;nge erw&uuml;nscht,
so kann sie durch Anh&auml;ngen eines passenden Suffixes (:8, :16,
:24) an das Displacement bzw. die Adresse erreicht werden.
<P>
Die von Toshiba gew&auml;hlte Syntax f&uuml;r Registernamen ist in
der Hinsicht etwas ungl&uuml;cklich, als da&szlig; zur Anwahl der
vorherigen Registerbank ein Hochkomma (') benutzt wird. Dieses
Zeichen wird von den prozessorunabh&auml;ngigen Teilen von AS bereits
zur Kennzeichnung von Zeichenkonstanten benutzt. Im Befehl
<PRE>

        ld      wa',wa

</PRE>
erkennt AS z.B. nicht das Komma zur Parametertrennung. Dieses Problem
kann man aber umgehen, indem man ein umgekehrtes Hochkomma (`)
verwendet, z.B.
<PRE>

        ld      wa`,wa

</PRE>
Toshiba liefert f&uuml;r die TLCS-900-Reihe selber einen Assembler
(TAS900), der sich in einigen Punkten von AS unterscheidet:
<P>

<H4>Symbolkonventionen</H4>
<P>
<UL>
<LI> TAS900 unterscheidet Symbolnamen nur auf den ersten 32 Zeichen. AS
    dagegen speichert Symbolnamen immer in der vollen L&auml;nge (bis
    255 Zeichen) und unterscheidet auch auf dieser L&auml;nge.</LI>
<LI> Unter TAS900 k&ouml;nnen Integerkonstanten sowohl in C-Notation (mit
    vorangestellter 0 f&uuml;r oktal bzw. 0x f&uuml;r hexadezimal)
    als auch in normaler Intel-Notation geschrieben werden. AS
    unterst&uuml;tzt in der Default-Einstellung<B> nur</B> die
    Intel-Notation. Mit dem<TT> RELAXED</TT>-Befehl bekommt man
    (unter anderem) auch die C-Notation.</LI>
<LI> AS macht keinen Unterschied zwischen Gro&szlig;- und
    Kleinschreibung, TAS900 hingegen unterscheidet Gro&szlig;-und
    Kleinbuchstaben in Symbolnamen. Dieses Verhalten erh&auml;lt man
    bei AS erst, wenn man die<TT> -u</TT>-Kommandozeilenoption
    benutzt.</LI>
</UL>
<P>

<H4>Syntax</H4>
<P>
AS ist bei vielen Befehlen in der Syntaxpr&uuml;fung weniger streng
als TAS900, bei einigen weicht er (sehr) geringf&uuml;gig ab. Diese
Erweiterungen bzw. &Auml;nderungen dienen teilweise der leichteren
Portierung von bestehendem Z80-Code, teilweise einer
Schreiberleichterung und teilweise einer besseren Orthogonalit&auml;t
der Assemblersyntax:
<UL>
<LI> Bei den Befehlen<TT> LDA, JP</TT> und<TT> CALL</TT> verlangt TAS,
    da&szlig; Adre&szlig;ausdr&uuml;cke wie<TT> XIX+5</TT> nicht
    geklammert sein d&uuml;rfen, wie es sonst &uuml;blich ist. AS
    verlangt im Sinne der Orthogonalit&auml;t f&uuml;r<TT> LDA</TT>
    dagegen immer eine Klammerung, bei<TT> JP</TT> und<TT> CALL</TT>
    ist sie dagegen f&uuml;r einfache, absolute Adressen
    optional.</LI>
<LI> Bei den bedingten Befehlen<TT> JP, CALL, JR</TT> und<TT> SCC</TT>
    stellt AS es dem Programmierer frei, die Default-Bedingung<TT>
    T</TT> (= true) als ersten Parameter anzugeben oder nicht. TAS900
    hingegen erlaubt es nur, die Default-Bedingung implizit zu
    benutzen (also z.B.<TT> jp (xix+5)</TT> anstelle von<TT> jp
    t,(xix+5)</TT>).</LI>
<LI> AS erlaubt beim<TT> EX</TT>-Befehl auch Operandenkombinationen, die
    zwar nicht direkt im User's Manual<A
    HREF="#cite_Tosh900">[166]</A> genannt werden, aber durch
    Vertauschung auf eine genannte zur&uuml;ck gef&uuml;hrt werden
    k&ouml;nnen. Kombinationen wie<TT> EX f`,f</TT> oder<TT> EX
    wa,(xhl)</TT> werden damit m&ouml;glich. TAS900 hingegen
    l&auml;&szlig;t nur die ,,reine Lehre'' zu.</LI>
<LI> AS erlaubt, bei den Befehlen<TT> INC</TT> und<TT> DEC</TT> die
    Angabe des Inkrements oder Dekrements wegzulassen, wenn dies 1
    ist. Unter TAS900 dagegen mu&szlig; auch eine 1 hingeschrieben
    werden.</LI>
<LI> &Auml;hnlich verh&auml;lt es sich bei allen Schiebebefehlen: Ist der
    zu verschiebende Operand ein Register, so verlangt TAS900,
    da&szlig; auch eine Schiebeamplitude von 1 ausgeschrieben werden
    mu&szlig;; ist dagegen eine Speicherstelle der Operand, so ist
    die Schiebezahl (hardwarebedingt) immer 1 und darf auch nicht
    hingeschrieben werden. Unter AS dagegen ist die Schiebezahl 1
    immer optional und auch f&uuml;r alle Operandentypen
    zul&auml;ssig.</LI>
</UL>
<P>

<H4>Makroprozessor</H4>
<P>
Der Makroprozessor wird TAS900 als externes Programm vorgeschaltet
und besteht aus zwei Komponenten: einem C-artigen Pr&auml;prozessor
und einer speziellen Makrosprache (MPL), die an h&ouml;here
Programmiersprachen erinnert. Der Makroprozessor von AS dagegen
orientiert sich an ,,klassischen'' Makroassemblern wie dem M80 oder
MASM (beides Programme von Microsoft). Er ist fester Bestandteil des
Programms.
<P>

<H4>Ausgabeformat</H4>
<P>
TAS900 erzeugt relokatiblen Code, so da&szlig; sich mehrere, getrennt
assemblierte Teile zu einem Programm zusammenbinden lassen. AS
hingegen erzeugt direkt absoluten Maschinencode, der nicht linkbar
ist. An eine Erweiterung ist (vorl&auml;ufig) nicht gedacht.
<P>

<H4>Pseudoanweisungen</H4>
<P>
Bedingt durch den fehlenden Linker fehlen in AS eine ganze Reihe von
f&uuml;r relokatiblen Code erforderlichen Pseudoanweisungen, die
TAS900 implementiert. In gleicher Weise wie bei TAS900 sind folgende
Anweisungen vorhanden:
<BLOCKQUOTE>
    <TT> EQU, DB, DW, ORG, ALIGN, END, TITLE, SAVE, RESTORE,</TT>
</BLOCKQUOTE>
wobei die beiden letzteren einen erweiterten Funktionsumfang haben.
Einige weitere TAS900-Pseudobefehle lassen sich durch
&auml;quivalente AS-Befehle ersetzen (siehe Tabelle <A
HREF="#ref_TabTAS900">4.6</A>).
<P>
Von Toshiba existieren zwei Versionen des Prozessorkerns, wobei die
L-Variante eine ,,Sparversion'' darstellt. Zwischen TLCS-900 und
TLCS-900L macht AS folgende Unterschiede:
<UL>
<LI> Die Befehle<TT> MAX</TT> und<TT> NORMAL</TT> sind f&uuml;r die
    L-Version nicht erlaubt, der<TT> MIN</TT>-Befehl ist f&uuml;r die
    Vollversion gesperrt.</LI>
<LI> Die L-Version kennt den Normal-Stapelzeiger<TT> XNSP/NSP</TT> nicht,
    daf&uuml;r das Steuerregister<TT> INTNEST</TT>.</LI>
</UL>
Die Befehle<TT> SUPMODE</TT> und<TT> MAXMODE</TT> werden nicht
beeinflu&szlig;t, ebenso nicht deren initiale Einstellung OFF. Die
Tatsache, da&szlig; die L-Version im Maximum-Modus startet und keinen
Normal-Modus kennt, mu&szlig; also vom Programmierer
ber&uuml;cksichtigt werden. AS zeigt sich jedoch insofern kulant
gegen&uuml;ber der L-Variante, als da&szlig; Warnungen wegen
privilegierter Anweisungen im L-Modus unterdr&uuml;ckt werden.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>TAS900</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AS</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung/Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DL</TT> &lt;Daten&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DD</TT> &lt;Daten&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Speicher in Langworten belegen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DSB</TT> &lt;Zahl&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DB</TT> &lt;Zahl&gt;<TT> DUP</TT> (?)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Speicher byteweise reservieren</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DSW</TT> &lt;Zahl&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DW</TT> &lt;Zahl&gt;<TT> DUP</TT> (?)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Speicher wortweise reservieren</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DSD</TT> &lt;Zahl&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DD</TT> &lt;Zahl&gt;<TT> DUP</TT> (?)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Speicher langwortweise reservieren</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $MIN[IMUM]</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MAXMODE OFF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>folgender Code im Minimum-Modus</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $MAX[IMUM]</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MAXMODE ON</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>folgender Code im Maximum-Modus</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $SYS[TEM]</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUPMODE ON</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>folgender Code im System-Modus</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $NOR[MAL]</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUPMODE OFF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>folgender Code im User-Modus</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $NOLIST</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LISTING OFF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Assemblerlisting ausschalten</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $LIST</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LISTING ON</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Assemblerlisting einschalten</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $EJECT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> NEWPAGE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>neue Seite im Listing beginnen</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.6: &auml;quivalente Befehle TAS900&harr;AS<A
             NAME="ref_TabTAS900"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_4_35_">4.35. TLCS-90</A></H2>
<P>
Vielleicht fragt sich der eine oder andere, ob bei mir die
Reihenfolge durcheinander gekommen ist, es gab ja von Toshiba zuerst
den 90er als ,,aufgebohrten Z80'' und danach den 900er als
16-Bit-Version. Nun, ich bin einfach &uuml;ber den 900er zum 90er
gekommen (Danke, Oliver!). Die beiden Familien sind sich sehr
artverwandt, nicht nur was ihre Syntax angeht, sondern auch ihre
Architektur. Die Hinweise f&uuml;r den 90er sind daher eine
Untermenge derer f&uuml;r den 900er: Da Schieben, Inkrementieren und
Dekrementieren hier nur um eins m&ouml;glich sind, braucht und darf
diese Eins auch nicht als erstes Argument hingeschrieben werden. Bei
den Befehlen<TT> LDA, JP</TT> und<TT> CALL</TT> m&ouml;chte Toshiba
wieder die Klammern um Speicheroperanden weglassen, bei AS
m&uuml;ssen sie aber aus Gr&uuml;nden der Orthogonalit&auml;t gesetzt
werden (der tiefere Grund ist nat&uuml;rlich, da&szlig; ich mir damit
eine Sonderabfrage im Parser gespart habe, aber das sagt man nicht so
laut).
<P>
Die TLCS-90er besitzen bereits prinzipiell einen Adre&szlig;raum von
1 Mbyte, dieser Raum erschlie&szlig;t sich aber nur bei
Datenzugriffen &uuml;ber die Indexregister. AS verzichtet daher auf
eine Ber&uuml;cksichtigung der Bankregister und begrenzt den
Adre&szlig;raum f&uuml;r Code auf 64 Kbyte. Da der Bereich jenseits
aber sowieso nur &uuml;ber indirekte Adressierung erreichbar ist,
sollte dies keine allzu gro&szlig;e Einschr&auml;nkung darstellen.
<P>

<H2><A NAME="sect_4_36_">4.36. TLCS-870</A></H2>
<P>
Schon wieder Toshiba...diese Firma ist im Augenblick wirklich sehr
produktiv! Speziell dieser Spro&szlig; der Familie (Toshibas
Mikrokontroller sind sich ja alle in Bin&auml;rkodierung und
Programmiermodell recht &auml;hnlich) scheint auf den 8051-Markt
abzuzielen: Die Methode, Bitstellen durch einen Punkt getrennt an den
Adre&szlig;ausdruck anzuh&auml;ngen, hatte ja beim 8051 ihren
Ursprung, f&uuml;hrt jetzt aber auch genau zu den Problemen, die ich
beim 8051 geahnt hatte: Der Punkt ist jetzt einerseits legales
Zeichen in Symbolnamen, andererseits aber auch Teil der
Adre&szlig;syntax, d.h. AS mu&szlig; Adresse und Bitstelle trennen
und einzeln weiterverarbeiten. Diesen Interessenkonflikt habe ich
vorerst so gel&ouml;st, da&szlig; der Ausdruck von<B> hinten</B> an
nach Punkten durchsucht wird und so der letzte Punkt als Trenner
gilt, eventuelle weitere Punkte werden dem Symbolnamen zugerechnet.
Es gilt weiterhin die flehentliche Bitte, im eigenen Interesse auf
Punkte in Symbolnamen zu verzichten, sie f&uuml;hren nur zu
Verwirrungen:
<PRE>

        LD      CF,A.7  ; Akku Bit 7 nach Carry
        LD      C,A.7   ; Konstante A.7 nach Register C

</PRE>
<P>

<H2><A NAME="sect_4_37_">4.37. TLCS-47</A></H2>
<P>
Mit dieser 4-Bit-Prozessorfamilie d&uuml;rfte wohl das unter Ende
dessen erreicht sein, was AS unterst&uuml;tzen kann. Neben dem<TT>
ASSUME</TT>-Befehl f&uuml;r das Datenbankregister (siehe dort) ist
eigentlich nur ein Detail erw&auml;hnenswert: im Daten- und
I/O-Segment werden keine Bytes, sondern Nibbles reserviert (eben
4-Bitter...). Die Sache funktioniert &auml;hnlich wie das
Bitdatensegment beim 8051, wo ein<TT> DB</TT> ja nur einzelne Bit
reserviert, nur da&szlig; es hier eben Nibbles sind.
<P>
Toshiba hat f&uuml;r diese Prozessorfamilie einen ,,erweiterten
Befehlssatz'' in Makroform definiert, um das Arbeiten mit diesem doch
recht beschr&auml;nkten Befehlssatz zu erleichtern. Im Fall von AS
ist er in der Datei STDDEF47.INC definiert. Einige Befehle, deren
makrom&auml;&szlig;ige Realisierung nicht m&ouml;glich war, sind
allerdings ,,eingebaut'' und stehen daher auch ohne die Include-Datei
zur Verf&uuml;gung:
<UL>
<LI> der<TT> B</TT>-Befehl, der die jeweils optimale Version des
    Sprungbefehls (<TT>BSS, BS oder BSL</TT>) automatisch
    w&auml;hlt;</LI>
<LI> <TT>LD</TT> in der Variante HL mit immediate;</LI>
<LI> <TT>ROLC</TT> und<TT> RORC</TT> mit einer Schiebeamplitude
    &gt;1.</LI>
</UL>
<P>

<H2><A NAME="sect_4_38_">4.38. TLCS-9000</A></H2>
<P>
Hier ist es zum ersten Mal passiert, da&szlig; ich einen Prozessor in
AS implementiert habe, der zu diesem Zeitpunkt noch gar nicht auf dem
Markt war. Toshiba hatte sich nach meinen Informationen leider
zwischenzeitlich auch dazu entschieden, diesen Prozessor ,,auf Eis''
zu legen, also auch kein Silizium geben. Das hatte nat&uuml;rlich zur
Folge, da&szlig; dieser Teil
<DL COMPACT>
<DT>1.<DD>ein ,,Paper-Design'' ist, d.h. noch nicht praktisch getestet wurde
    und</DD>
<DT>2.<DD>Die Unterlagen, die ich zum 9000er hatte <A
    HREF="#cite_Tosh9000">[169]</A>, noch vorl&auml;ufig waren, also
    noch nicht bis ins letzte Klarheit lieferten.</DD>
</DL>
und dieses Target foratn in einen Dornr&ouml;schenschlaf fiel...
<P>
...Schnitt, 20 Jahre sp&auml;ter: auf einmal melden sich Leute bei
mir, da&szlig; Toshiba wohl doch TLCS-9000-Chips an Kunden verkauft
hat, und fragen nach den Unterlagen, weil sie Reverse-Engineering
betreiben. Vielleicht bekommen wir ja auf diesem Wege noch das eine
oder andere unklare Detail best&auml;tigt oder gekl&auml;rt. Fehler
in diesem Teil sind also weiterhin noch m&ouml;glich und werden
nat&uuml;rlich bereinigt. Zumindest die Handvoll Beispiele in <A
HREF="#cite_Tosh9000">[169]</A> werden aber richtig &uuml;bersetzt.
<P>
Displacements im Maschinenbefehl selber k&ouml;nnen nur eine
bestimmte maximale L&auml;nge (z.B. 13 oder 9 Bit) haben. Ist das
Displacement l&auml;nger, mu&szlig; dem Befehl ein Pr&auml;fix mit
den ''oberen Bits'' vorangestellt werden. AS wird solche Pr&auml;fixe
automatisch nach Bedarf einsetzen, man kann jedoch auch mit einem dem
Displacement vorangestellten '&gt;' das Setzen eines Pr&auml;fix
erzwingen, z.B. so:
<P>
<PRE>

  ld:g.b  (0h),0       ; kein Praefix
  ld:g.b  (400000h),0  ; Praefix automatisch erzeugt
  ld:g.b  (&gt;0h),0      ; Praefix erzwungen

</PRE>
<P>

<H2><A NAME="sect_4_39_">4.39. TC9331</A></H2>
<P>
Toshiba hat seinerzeit f&uuml;r diesen Prozessor einen
(DOS-basierten) Assembler namens ASM31T geliefert. Dieser Assembler
unterst&uuml;tzt eine Reihe von Syntax-Elementen, die sich auf AS
nicht ohne &Auml;nderungen abbilden lie&szlig;en, die die
Kompatibilit&auml;t zu existierenden Quelldateien f&uuml;r andere
Targets gef&auml;hrdert h&auml;tten. An folgenden Stellen werden
m&ouml;glicherweise &Auml;nderungen erforderlich sein, um f&uuml;r
den ASM31T geschriebene Programme mit AS &uuml;bersetzen zu
k&ouml;nnen:
<P>
<UL>
<LI> ASM31T unterst&uuml;tzt C-artige Kommentare (/* ... */), die auch
    &uuml;ber mehrere Zeilen gehen d&uuml;rfen. Diese werden von AS
    nicht unterst&uuml;tzt und m&uuml;ssen in mit einem Semikolon
    eingeleitete Kommentare umgesetzt werden.</LI>
<LI> Wie ASM31T unterst&uuml;tzt AS f&uuml;r den TC9331 Kommentare in
    runden Klammern (( ... )), aber nur innerhalb eines
    Befehlsarguments. Enth&auml;lt ein solcher Kommentar ein Komma,
    wird dieses Komma als Argument-Trenner behandelt und der
    Kommentar nicht beim Parsing der Argumente
    &uuml;bersprungen.</LI>
<LI> ASM31T erlaubt Symbol- und Label-Namen, die einen Bindestrich
    enthalten. Das ist bei AS nicht zugelassen, der Bindestrich ist
    hier der Subtraktionsoperator und in einem Ausdruck wie end-start
    w&auml;re sonst nicht klar, ob ein einzelnes Symbol oder die
    Differenz von zwei Symbolen gemeint ist.</LI>
<LI> ASM31T verlangt zwingend ein<TT> END</TT>-Statement am Ende des
    Programms; bei AS ist dies optional.</LI>
</UL>
<P>
Des weiteren fehlen AS im Moment die F&auml;higkeiten, auf
miteinander kollidierende Nutzungen von Funktionseinheiten in einem
Befehl hinzuweisen. Die Dokumentation von Toshiba ist an diesem Punkt
leider etwas schwer verst&auml;ndlich.
<P>

<H2><A NAME="sect_4_40_">4.40. 29xxx</A></H2>
<P>
Wie schon beim<TT> ASSUME</TT>-Befehl beschrieben, kann AS mit der
Kenntnis &uuml;ber den Inhalt des RBP-Registers feststellen, ob im
User-Modus auf gesperrte Register zugegriffen wird. Diese
F&auml;higkeit beschr&auml;nkt sich nat&uuml;rlich auf direkte
Zugriffe (also nicht, wenn die Register IPA...IPC benutzt werden),
und sie hat noch einen weiteren Haken: da lokale Register (also
solche mit Nummern&gt;127) relativ zum Stackpointer adressiert
werden, die Bits in RBP sich aber immer auf absolute Nummern
beziehen, wird die Pr&uuml;fung f&uuml;r lokale Register NICHT
durchgef&uuml;hrt. Eine Erweiterung auf lokale Register w&uuml;rde
bedingen, da&szlig; AS zu jedem Zeitpunkt den absoluten Wert von SP
kennt, und das w&uuml;rde sp&auml;testens bei rekursiven
Unterprogrammen scheitern...
<P>

<H2><A NAME="sect_4_41_">4.41. 80C16x</A></H2>
<P>
Wie in der Erkl&auml;rung des<TT> ASSUME</TT>-Befehls schon
erl&auml;utert, versucht AS, dem Programmierer die Tatsache,
da&szlig; der Prozessor mehr physikalischen als logischen Speicher
hat, soweit als m&ouml;glich zu verbergen. Beachten Sie aber,
da&szlig; die DPP-Register<B> nur</B> Datenzugriffe betreffen und
auch dort nur absolute Adressierung, also weder indirekte noch
indizierte Zugriffe, da AS ja nicht wissen kann, wie die berechnete
Adresse zur Laufzeit aussehen wird...Bei Codezugriffen arbeitet die
Paging-Einheit leider nicht, man mu&szlig; also explizit mit langen
oder kurzen<TT> CALL</TT>s,<TT> JMP</TT>s oder<TT> RET</TT>s
arbeiten. Zumindest bei den ,,universellen'' Befehlen<TT> CALL</TT>
und<TT> JMP</TT> w&auml;hlt AS automatisch die k&uuml;rzeste Form,
aber sp&auml;testens beim<TT> RET</TT> sollte man wissen, woher der
Aufruf kam. Prinzipiell verlangen<TT> JMPS</TT> und<TT> CALLS</TT>
dabei, da&szlig; man Segment und Adresse getrennt angibt, AS ist
jedoch so geschrieben, da&szlig; er eine Adresse selber zerlegen
kann, z.B.
<PRE>

        jmps    12345h

</PRE>
anstelle von
<PRE>

        jmps    1,2345h

</PRE>
Leider sind nicht alle Effekte der chipinternen Instruktions-Pipeline
versteckt: Werden CP (Registerbankadresse), SP (Stack) oder eines der
Paging-Register ver&auml;ndert, so steht der neue Wert noch nicht
f&uuml;r den n&auml;chsten Befehl zur Verf&uuml;gung. AS versucht,
solche Situationen zu erkennen und gibt im Falle eines Falles eine
Warnung aus. Aber auch diese Mimik greift nur bei direkten Zugriffen.
<P>
Mit<TT> BIT</TT> definierte Bits werden intern in einem 13-Bit-Wort
abgelegt, wobei die Bitadresse in Bit 4..11 liegt und die Bitnummer
in den unteren vier Bits. Diese Anordnung erlaubt es, das
n&auml;chsth&ouml;here bzw. n&auml;chstniedrigere Bit durch
Inkrementieren bzw. Dekrementieren anzusprechen. Bei expliziten
Bitangaben mit Punkt funktioniert das aber nicht &uuml;ber
Wortgrenzen hinaus. So erzeugt folgender Ausdruck eine
Wertebereichs&uuml;berschreitung:
<PRE>

        bclr    r5.15+1

</PRE>
Hier mu&szlig; ein<TT> BIT</TT> her:
<PRE>

msb     bit     r5.15
        .
        .
        .
        bclr    msb+1

</PRE>
F&uuml;r den 80C167/165/163 ist der SFR-Bereich verdoppelt worden;
da&szlig; ein Bit im zweiten Teil liegt, wird durch ein gesetztes Bit
12 vermerkt. Leider hatte Siemens bei der Definition des 80C166 nicht
vorausgesehen, da&szlig; 256 SFRs (davon 128 bitadressierbar)
f&uuml;r Nachfolgechips nicht reichen w&uuml;rden. So w&auml;re es
unm&ouml;glich, den zweiten SFR-Bereich von F000H..F1DFH mit kurzen
Adressen oder Bitbefehlen zu erreichen, h&auml;tten die Entwickler
nicht einen Umschaltbefehl eingebaut:
<PRE>

        EXTR    #n

</PRE>
Dieser Befehl bewirkt, da&szlig; f&uuml;r die n&auml;chsten<TT>
n</TT> Befehle (0&lt;<TT>n</TT>&lt;5) anstelle des normalen der
erweiterte SFR-Bereich angesprochen werden kann. AS erzeugt bei diesm
Befehl nicht nur den passenden Code, sondern setzt intern ein Flag,
da&szlig; f&uuml;r die n&auml;chsten<TT> n</TT> Befehle nur Zugriffe
auf den erweiterten SFR-Bereich zul&auml;&szlig;t. Da d&uuml;rfen
nat&uuml;rlich keine Spr&uuml;nge dabei sein... Bits aus beiden
Bereichen lassen sich nat&uuml;rlich jederzeit definieren, ebenso
sind komplette Register aus beiden SFR-Bereichen jederzeit mit
absoluter Adressierung erreichbar. Nur die kurze bzw. Bitadressierung
geht immer nur abwechselnd, Zuwiderhandlungen werden mit einer
Fehlermeldung geahndet.
<P>
&Auml;hnlich sieht es mit den Pr&auml;fixen f&uuml;r absolute bzw.
indirekte Adressierung aus: Da aber sowohl Argument des Pr&auml;fixes
als auch der Adre&szlig;ausdruck nicht immer zur
&Uuml;bersetzungszeit bestimmbar sind, sind die
Pr&uuml;fungsm&ouml;glichkeiten durch AS sehr eingeschr&auml;nkt,
weshalb er es auch bei Warnungen bel&auml;&szlig;t...im einzelnen
sieht das folgenderma&szlig;en aus:
<UL>
<LI> feste Vorgabe einer 64K-Bank mittels<TT> EXTS</TT> oder<TT>
    EXTSR</TT>: Im Adre&szlig;ausdruck werden direkt die unteren 16
    Bit der Zieladresse eingesetzt. Haben sowohl Pr&auml;fix als auch
    Befehl einen konstanten Operanden, so wird &uuml;berpr&uuml;ft,
    ob Pr&auml;fixargument und Bit 16..23 der Zieladresse identisch
    sind.</LI>
<LI> feste Vorgabe einer 16K-Seite mittels<TT> EXTP</TT> oder<TT>
    EXTPR</TT>: Im Adre&szlig;ausdruck werden direkt die unteren 14
    Bit der Zieladresse eingesetzt. Bit 14 und 15 bleiben konstant 0,
    da sie in diesem Modus nicht vom Prozessor ausgewertet werden.
    Haben sowohl Pr&auml;fix als auch Befehl einen konstanten
    Operanden, so wird &uuml;berpr&uuml;ft, ob Pr&auml;fixargument
    und Bit 14..23 der Zieladresse identisch sind.</LI>
</UL>
Damit das etwas klarer wird, ein Beispiel (die DPP-Register haben die
Reset-Vorbelegung) :
<PRE>

       extp     #7,#1           ; Bereich von 112K..128K
       mov      r0,1cdefh       ; ergibt Adresse 0defh im Code
       mov      r0,1cdefh       ; --&gt;Warnung
       exts     #1,#1           ; Bereich von 64K..128K
       mov      r0,1cdefh       ; ergibt Adresse 0cdefh im Code
       mov      r0,1cdefh       ; --&gt;Warnung

</PRE>
<P>

<H2><A NAME="sect_4_42_">4.42. PIC16C5x/16C8x</A></H2>
<P>
&Auml;hnlich wie die MCS-48-Familie teilen auch die PICs ihren
Programmspeicher in mehrere B&auml;nke auf, da im Opcode nicht
gen&uuml;gend Platz f&uuml;r die vollst&auml;ndige Adresse war. AS
verwendet f&uuml;r die Befehle<TT> CALL</TT> und<TT> GOTO</TT> die
gleiche Automatik, d.h. setzt die PA-Bits im Statuswort entsprechend
Start- und Zieladresse. Im Gegensatz zu den 48ern ist dieses
Verfahren hier aber noch deutlich problematischer:
<OL>
<LI>Die Befehle sind nicht mehr nur ein Wort, sondern bis zu drei Worten
    lang, k&ouml;nnen also nicht mehr in jedem Fall mit einem
    bedingten Sprung &uuml;bergangen werden.</LI>
<LI>Es ist m&ouml;glich, da&szlig; der Programmz&auml;hler beim normalen
    Programmfortgang eine Seitengrenze &uuml;berschreitet. Die vom
    Assembler angenommene Belegung der PA-Bits stimmt dann nicht mehr
    mit der Realit&auml;t &uuml;berein.</LI>
</OL>
Bei den Befehlen, die das Register W mit einem anderen Register
verkn&uuml;pfen, mu&szlig; normalerweise als zweiter Parameter
angegeben werden, ob das Ergebnis in W oder im Register abgelegt
werden soll. Bei diesem Assembler ist es erlaubt, den zweiten
Parameter wegzulassen. Welches Ziel dann angenommen werden soll,
h&auml;ngt vom Typ des Befehls ab: bei un&auml;ren Operationen wird
defaultm&auml;&szlig;ig das Ergebnis zur&uuml;ck ins Register gelegt.
Diese Befehle sind:
<BLOCKQUOTE>
    <TT> COMF, DECF, DECFSZ, INCF, INCFSZ, RLF, RRF</TT> und<TT>
    SWAPF</TT>
</BLOCKQUOTE>
Die anderen Befehle betrachten W defaultm&auml;&szlig;ig als
Akkumulator, zu dem ein Register verkn&uuml;pft wird:
<BLOCKQUOTE>
    <TT> ADDWF, ANDWF, IORWF, MOVF, SUBWF</TT> und<TT> XORWF</TT>
</BLOCKQUOTE>
<P>
Die von Microchip vorgegebene Schreibweise f&uuml;r Literale ist
ziemlich abstrus und erinnert an die auf IBM 360/370-Systemen
&uuml;bliche Schreibweise (Gr&uuml;&szlig;e aus Neandertal...). Um
nicht noch einen Zweig in den Parser einf&uuml;gen zu m&uuml;ssen,
sind bei AS Konstanten in Motorola-Syntax zu schreiben (wahlweise
auch Intel oder C im<TT> RELAXED</TT>-Modus).
<P>
Dem Assembler liegt die Include-Datei STDDEF16.INC bei, in der die
Adressen der Hardware-Register und Statusbits verewigt sind. Daneben
enth&auml;lt sie eine Liste von ,,Befehlen'', die der
Microchip-Assembler als Makro implementiert. Bei der Benutzung dieser
Befehlsmakros ist gro&szlig;e Vorsicht angebracht, da sie mehrere
Worte lang sind und sich somit nicht &uuml;berspringen lassen!!
<P>

<H2><A NAME="sect_4_43_">4.43. PIC17C4x</A></H2>
<P>
F&uuml;r diese Prozessoren gelten im wesentlichen die gleichen
Hinweise wie f&uuml;r ihre kleinen Br&uuml;der, mit zwei Ausnahmen:
Die zugeh&ouml;rige Include-Datei enth&auml;lt nur
Registerdefinitionen, und die Probleme bei Sprungbefehlen sind
deutlich kleiner. Aus der Reihe f&auml;llt nur<TT> LCALL</TT>, der
einen 16-Bit-Sprung erlaubt. Dieser wird mit folgendem ,,Makro''
&uuml;bersetzt:
<PRE>

        MOVLW   &lt;Adr15..8&gt;
        MOWF    3
        LCALL   &lt;Adr0..7&gt;

</PRE>
<P>

<H2><A NAME="sect_4_44_">4.44. SX20/28</A></H2>
<P>
Durch die beschr&auml;nkte L&auml;nge des Instruktionswortes ist es
nicht m&ouml;glich, darin eine vollst&auml;ndige
Programmspeicher-Adresse (11 Bit) oder Datenspeicher-Adresse (8 Bit)
unterzubringen. Der Prozessor erg&auml;nzt die gek&uuml;rzten
Adressen um die PA-Bits aus dem STATUS-Register bzw. oberen Bits aus
dem FSR-Register. &Uuml;ber<TT> ASSUME</TT>-Befehle teilt man dem
Assembler deren aktuellen Inhalt mit. Falls auf Adressen zugegriffen
wird, die mit den vermerkten Werten nicht zugreifbar sind, erfolgt
eine Warnung.
<P>

<H2><A NAME="sect_4_45_">4.45. ST6</A></H2>
<P>
Diese Prozessoren k&ouml;nnen das Code-ROM seitenweise in den
Datenbereich einblenden. Weil ich nicht die ganze Mimik des<TT>
ASSUME</TT>-Befehles hier wiederk&auml;uen m&ouml;chte, verweise ich
auf das entsprechende Kapitel (<A HREF="#ref_ST6Assume">3.2.21</A>),
in dem steht, wie man mit diesem Befehl einigerma&szlig;en unfallfrei
Konstanten aus dem ROM lesen kann.
<P>
Bei n&auml;herer Betrachtung des Befehlssatzes fallen einige
eingebaute ,,Makros'' auf. Die Befehle, die mir aufgefallen sind (es
gibt aber vielleicht noch mehr...), sind in Tabelle <A
HREF="#ref_TabHid62">4.7</A> aufgelistet.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Befehl</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>in Wirklichkeit</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> CLR A</TT><BR>
<TT> SLA A</TT><BR>
<TT> CLR adr</TT><BR>
<TT> NOP</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUB A,A</TT><BR>
<TT> ADD A,A</TT><BR>
<TT> LDI adr,0</TT><BR>
<TT> JRZ PC+1</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.7: versteckte Makros im ST6225-Befehlssatz<A
             NAME="ref_TabHid62"></A>
</CENTER><P>

Insbesondere der letztere Fall verbl&uuml;fft doch etwas... Leider
fehlen aber einige Anweisungen wirklich. So gibt es z.B. zwar
einen<TT> AND</TT>-Befehl, aber kein<TT> OR</TT>...von<TT> XOR</TT>
gar nicht zu reden. In der Datei STDDEF62.INC finden sich deshalb
neben den Adressen der SFRs noch einige Makros zur Abhilfe.
<P>
Der Original-Assembler AST6 von SGS-Thomson verwendet teilweise
andere Pseudobefehle als AS. Au&szlig;er der Tatsache, da&szlig; AS
Pseudobefehle nicht mit einem vorangestellten Punkt kennzeichnet,
sind folgende Befehle identisch:
<PRE>

  ASCII, ASCIZ, BLOCK, BYTE, END, ENDM, EQU, ERROR, MACRO,
  ORG, TITLE, WARNING

</PRE>
Tabelle <A HREF="#ref_TabAST6">4.8</A> zeigt die AST6-Befehle, zu
denen analoge in AS existieren.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AST6</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AS</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung/Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .DISPLAY</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MESSAGE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Meldung ausgeben</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .EJECT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> NEWPAGE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>neue Seite im Listing</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .ELSE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ELSEIF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>bed. Assemblierung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .ENDC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ENDIF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>bed. Assemblierung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .IFC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> IF...</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>bed. Assemblierung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .INPUT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INCLUDE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Include-Datei einbinden</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .LIST</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LISTING</TT>,<TT> MACEXP_DFT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Listing-Einstellung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .PL</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> PAGE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Seitenl&auml;nge Listing</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .ROMSIZE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> CPU</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Zielprozessor einstellen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .VERS</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> VERSION</TT> (Symbol)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Version abfragen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .SET</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> EVAL</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Variablen neu setzen</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.8: &auml;quivalente Befehle AST6&harr;AS<A
             NAME="ref_TabAST6"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_4_46_">4.46. ST7</A></H2>
<P>
In <A HREF="#cite_ST7Man">[133]</A> ist der '.w'-Postfix f&uuml;r
16-Bit-Adressen nur f&uuml;r speicherindirekte Operanden definiert,
um zu vermerken, da&szlig; auf einer Zeropageadresse eine 16-bittige
Adresse liegt; AS unterst&uuml;tzt ihn jedoch zus&auml;tzlich auch
f&uuml;r absolute Adressen oder Displacements in indizierter
Adressierung, um trotz eines nur 8 Bit langen Wertes (0..255) ein
16-bittiges Displacement zu erzeugen.
<P>

<H2><A NAME="sect_4_47_">4.47. ST9</A></H2>
<P>
Die Bitadressierungsm&ouml;glichkeiten des ST9 sind relativ
eingeschr&auml;nkt: Mit Ausnahme des<TT> BTSET</TT>-Befehls ist es
nur m&ouml;glich, auf Bits innerhalb des aktuellen
Arbeitsregistersatzes zuzugreifen. Eine Bit-Adresse sieht also
folgenderma&szlig;en aus:
<PRE>

  rn.[!]b

</PRE>
wobei ! eine optionale Invertierung eines Quelloperanden bedeutet.
Wird ein Bit symbolisch mittels des<TT> BIT</TT>-Befehles definiert,
so wird die Registernummer im Symbolwert in Bit 7..4, die Bitnummer
in Bit 3..1 und eine optionale Invertierung in Bit 0 vermerkt. AS
unterscheidet direkte und symbolische Bitangaben am Fehlen eines
Punktes, der Name eines Bitsymboles darf also keinen Punkt enthalten,
obwohl sie an sich zul&auml;ssig w&auml;ren. Es ist auch
zul&auml;ssig, bei der Referenzierung von Bitsymbolen diese zu
nachtr&auml;glich zu invertieren:
<PRE>

bit2    bit     r5.3
        .
        .
        bld	r0.0,!bit2

</PRE>
Auf diese Weise ist es auch m&ouml;glich, eine inverse Definition
nachtr&auml;glich wieder aufzuheben.
<P>
Bitdefinitionen finden sich in gro&szlig;er Zahl in der Include-Datei
REGST9.INC, in der die Register- und Bitnamen aller
On-Chip-Peripherie beschrieben sind. Beachten Sie jedoch, da&szlig;
deren Nutzung nur m&ouml;glich ist, wenn die Arbeitsregisterbank
vorher auch auf diese Register ausgerichtet wurde!
<P>
Im Gegensatz zu der zum AST9 von SGS-Thomson geh&ouml;renden
Definitionsdatei sind f&uuml;r AS die Namen der Peripherieregister
nur als allgemeine Registernamen definiert (<TT>R...</TT>), nicht
auch noch als Arbeitsregister (<TT>r...</TT>). Dies ist so, weil AS
Geschwindigkeitsgr&uuml;nden keine Aliasnamen f&uuml;r Register
definieren kann.
<P>

<H2><A NAME="sect_4_48_">4.48. 6804</A></H2>
<P>
Eigentlich habe ich diesen Prozessor ja nur eingebaut, um mich
&uuml;ber das seltsame Gebaren von SGS-Thomson zu beklagen: Als ich
das 6804-Datenbuch zum ersten Mal in die Hand bekam, f&uuml;hlte ich
mich ob des etwas ,,unvollst&auml;ndigen'' Befehlssatzes und der
eingebauten Makros spontan an die ST62-Serie vom gleichen Hersteller
erinnert. Ein genauerer Vergleich der Opcodes f&ouml;rderte
erstaunliches zu Tage: Ein 6804-Opcode ergibt sich durch Spiegelung
aller Bits im entsprechenden ST62-OpCode! Thomson hat hier also
offensichtlich etwas Prozessorkern-Recycling betrieben...wogegen ja
auch nichts einzuwenden w&auml;re, wenn nicht so eine
Verschleierungstaktik betrieben werden w&uuml;rde: andere Peripherie,
Motorola- anstelle Zilog-Syntax sowie das h&auml;&szlig;liche Detail,
in Opcodes enthaltene Argumente (z.B. Bitfelder mit Displacements)<B>
nicht</B> zu drehen. Letzterer Punkt hat mich auch nach l&auml;ngerem
&Uuml;berlegen dazu bewogen, den 6804 doch in AS aufzunehmen. Ich
wage &uuml;brigens keine Spekulationen, welche Abteilung bei Thomson
von welcher abgekupfert hat...
<P>
Im Gegensatz zur ST62-Version enth&auml;lt die Include-Datei f&uuml;r
den 6804 keine Makros, die die L&uuml;cken im Befehlssatz etwas
,,auspolstern'' sollen. Dies &uuml;berlasse ich dem geneigten Leser
als Finger&uuml;bung!
<P>

<H2><A NAME="sect_4_49_">4.49. TMS3201x</A></H2>
<P>
Offensichtlich ist es Ehrgeiz jedes Prozessorherstellers, seine
eigene Notation f&uuml;r Hexadezimalkonstanten zu erfinden. Texas
Instruments war bei diesen Prozessoren besonders originell: ein
vorangestelltes &gt;-Zeichen! Die &Uuml;bernahme dieses Formates in
AS h&auml;tte zu schweren Konflikten mit den Vergleichs-und
Schiebeoperatoren von AS im Formelparser gef&uuml;hrt. Ich habe mich
deshalb f&uuml;r die Intel-Notation entschieden, zu der sich TI bei
der 340x0-Serie und den 3201x-Nachfolgern ja dann auch durchgerungen
hat...
<P>
Leider hat das Instruktionswort dieser Prozessoren nicht
gen&uuml;gend Bits, um bei direkter Adressierung alle 8 Bits zu
enthalten, weshalb der Datenadre&szlig;raum logisch in 2 B&auml;nke
zu 128 W&ouml;rtern gespalten ist. AS verwaltet diesen als ein
durchgehendes Segment von 256 W&ouml;rtern und l&ouml;scht bei
direkten Zugriffen automatisch das Bit 7 (Ausnahme: Befehl<TT>
SST</TT>, der nur in die obere Bank schreiben kann). Der
Programmierer ist daf&uuml;r erforderlich, da&szlig; das Bank-Bit
stets den richtigen Wert hat!
<P>
Ein weiterer, nur sehr versteckt im Datenbuch stehender Hinweis:
Die<TT> SUBC</TT>-Anweisung ben&ouml;tigt zur Ausf&uuml;hrung intern
mehr als einen Takt, das Steuerwerk arbeitet jedoch schon an dem
n&auml;chsten Befehl weiter. Im auf ein<TT> SUBC</TT> folgenden
Befehl darf deshalb nicht auf den Akkumulator zugegriffen werden. AS
nimmt hier<B> keine</B> Pr&uuml;fung vor!
<P>

<H2><A NAME="sect_4_50_">4.50. TMS320C2x</A></H2>
<P>
Da ich nicht selber diesen Codegenerator geschrieben habe (was nichts
an seiner Qualit&auml;t mindert), kann ich nur kurz hier
umrei&szlig;en, wieso es Befehle gibt, bei denen ein vorangestelltes
Label als untypisiert, d.h. keinem Adre&szlig;raum zugeordnet,
gespeichert wird: Der 20er der TMS-Reihe kennt sowohl ein 64 Kbyte
gro&szlig;es Code- als auch Datensegment. Je nach externer
Beschaltung kann man dabei Code- und Datenbereiche &uuml;berlappen,
um z.B. Konstanten im Codebereich zu abzulegen und auf diese als
Daten zuzugreifen (Ablage im Code ist notwendig, weil &auml;ltere
AS-Versionen davon ausgehen, da&szlig; ein Datensegment aus RAM
besteht, das in einem Standalone-System nach dem Einschalten keinen
definierten Inhalt hat und verweigern in Segmenten au&szlig;er Code
deshalb die Ablage von Daten). Ohne dieses Feature w&uuml;rde AS nun
jeden Zugriff auf die abgelegten Daten mit einer Warnung (,,Symbol
aus falschem Segment'') quittieren. Im einzelnen erzeugen folgende
Pseudobefehle untypisierte Labels:
<BLOCKQUOTE>
    <TT> BSS, STRING, RSTRING, BYTE, WORD , LONG, FLOAT<BR>
    DOUBLE, EFLOAT, BFLOAT</TT> und<TT> TFLOAT</TT>
</BLOCKQUOTE>
Sollten doch einmal typisierte Labels gew&uuml;nscht sein, so kann
man sich behelfen, indem man das Label in eine getrennte Zeile vor
dem Pseudobefehl schreibt. Umgekehrt kann man einen der anderen
Pseudobefehle mit einem typenlosen Label versehen, indem man vor dem
Befehl das Label mit
<PRE>

&lt;Name&gt;  EQU     $

</PRE>
definiert.
<P>

<H2><A NAME="sect_4_51_">4.51. TMS320C3x/C4x</A></H2>
<P>
Die gr&ouml;&szlig;ten Magenschmerzen bei diesem Prozessor hat mir
die Syntax paralleler Befehle bereitet, die auf zwei Zeilen verteilt
werden, wobei beide Befehle an sich auch sequentiell ausgef&uuml;hrt
werden k&ouml;nnen. Deshalb erzeugt AS zuerst den Code f&uuml;r die
einzelne erste Operation, wenn er dann in der zweiten Zeile erkennt,
da&szlig; eine parallele Anweisung vorliegt, wird der zuerst erzeugte
Code durch den neuen ersetzt. Im Listing kann man dies daran
erkennen, da&szlig; der Programmz&auml;hler nicht weiterl&auml;uft
und in der zweiten Zeile anstelle eines Doppelpunktes ein<TT> R</TT>
vor dem erzeugten Code steht.
<P>
Bez&uuml;glich der doppelten senkrechten Striche und ihrer Position
in der Zeile ist man nicht ganz so flexibel wie beim TI-Assembler:
Entweder man schreibt sie anstelle eines Labels (d.h. in der ersten
Spalte oder mit einem angeh&auml;ngten Doppelpunkt, das ist aber
nicht mehr TI-kompatibel...) oder direkt vor den zweiten Befehl ohne
Leerzeichen, sonst bekommt der Zeilenparser von AS Probleme und
h&auml;lt die Striche f&uuml;r das Mnemonic.
<P>

<H2><A NAME="sect_4_52_">4.52. TMS9900</A></H2>
<P>
Wie bei den meisten &auml;lteren Prozessorfamilien auch, hatte TI
seinerzeit ein eigenes Format zur Schreibweise von Hexadezimal- und
Bin&auml;rkonstanten verwendet, anstelle deren AS die normale, heute
auch bei TI gebr&auml;uchliche Intel-Notation verwendet.
<P>
Die TI-Syntax f&uuml;r Register erlaubt es, da&szlig; anstelle eines
echten Namens (entweder<TT> Rx</TT> oder<TT> WRx</TT>) auch eine
einfache Integer-Zahl zwischen 0 und 15 benutzt werden kann. Dies hat
zwei Folgen:
<UL>
<LI> <TT>R0...R15</TT> bzw.<TT> WR0..WR15</TT> sind einfache,
    vordefinierte Integersymbole mit den Werten 0..15, und die
    Definition von Registeraliasen funktioniert &uuml;ber
    schlichte<TT> EQUs</TT>.</LI>
<LI> Im Gegensatz zu einigen anderen Prozessoren kann ich nicht das
    zus&auml;tzliche AS-Feature anbieten, da&szlig; das Kennzeichen
    f&uuml;r absolute Adressierung (hier ein Klammeraffe) weggelassen
    werden darf. Da ein fehlendes Kennzeichen hier aber
    Registernummern (im Bereich 0 bis 15) bedeuten w&uuml;rde, war
    das hier nicht m&ouml;glich.</LI>
</UL>
Weiterhin wechselt TI mit der Registerbezeichnung zwischen<TT>
Rx</TT> und<TT> WRx</TT>...vorerst ist beides zugelassen.
<P>

<H2><A NAME="sect_4_53_">4.53. TMS70Cxx</A></H2>
<P>
Diese Prozessorreihe geh&ouml;rt noch zu den &auml;lteren, von TI
entwickelten Reihen, und deswegen benutzt TI in ihren eigenen
Assemblern noch die herstellereigene Syntax f&uuml;r hexadezimale und
bin&auml;re Konstanten (vorangestelltes &lt; bzw. ?). Da das in AS
aber so nicht machbar ist, wird defaultm&auml;&szlig;ig die
Intel-Syntax verwendet. Auf diese ist Texas bei den Nachfolgern
dieser Familie, n&auml;mlich den 370ern auch umgestiegen. Beim
genaueren Betrachten des Maschinenbefehlssatzes stellt man fest,
da&szlig; ca. 80% der 7000er-Befehle bin&auml;r
aufw&auml;rtskompatibel sind, und auch die Assemblersyntax ist fast
gleich - aber eben nur fast. Bei der Erweiterung des
7000er-Befehlssatzes hat TI n&auml;mlich auch gleich die Chance
genutzt, die Syntax etwas zu vereinheitlichen und zu vereinfachen.
Ich habe mich bem&uuml;ht, einen Teil dieser &Auml;nderungen auch in
die 7000er Syntax einflie&szlig;en zu lassen:
<UL>
<LI> Anstelle eines Prozentzeichens zur Kennzeichnung von unmittelbarer
    Adressierung darf auch das allgemein bekanntere Doppelkreuz
    verwendet werden.</LI>
<LI> Wenn bei den Befehlen<TT> AND, BTJO, BTJZ, MOV, OR</TT> und<TT>
    XOR</TT> eine Port-Adresse (<TT>P...</TT>) als Quelle oder Ziel
    benutzt wird, ist es nicht notwendig, die Mnemonic-Form mit
    explizit angeh&auml;ngtem<TT> P</TT> zu benutzen - die allgemeine
    Form reicht genauso aus.</LI>
<LI> Der vorangestelle Klammeraffe f&uuml;r absolute oder B-indizierte
    Adressierung darf weggelassen werden.</LI>
<LI> Anstelle des<TT> CMPA</TT>-Befehls darf auch einfach<TT> CMP</TT>
    mit<TT> A</TT> als Ziel benutzt werden.</LI>
<LI> Anstelle<TT> LDA</TT> oder<TT> STA</TT> darf auch einfach der<TT>
    MOV</TT>-Befehl mit<TT> A</TT> als Ziel bzw. Quelle benutzt
    werden.</LI>
<LI> Anstelle des<TT> MOVD</TT>-Befehls darf auch<TT> MOVW</TT> benutzt
    werden.</LI>
<LI> Anstelle von<TT> RETS</TT> oder<TT> RETI</TT> darf auch
    verk&uuml;rzt<TT> RTS</TT> bzw.<TT> RTI</TT> geschrieben
    werden.</LI>
<LI> <TT>TSTA</TT> bzw.<TT> TSTB</TT> d&uuml;rfen auch als<TT> TST A</TT>
    bzw.<TT>TST B geschrieben werden.</TT></LI>
<LI> <TT>XCHB B</TT> ist als Alias f&uuml;r<TT> TSTB</TT>
    zugelassen.</LI>
</UL>
Wichtig - diese Varianten sind nur beim TMS70Cxx zugelassen -
entsprechende 7000er-Varianten sind bei den 370ern<EM> nicht</EM>
erlaubt!
<P>

<H2><A NAME="sect_4_54_">4.54. TMS370xxx</A></H2>
<P>
Obwohl diese Prozessoren keine speziellen Befehle zur Bitmanipulation
besitzen, wird mit Hilfe des Assemblers und des<TT>
DBIT</TT>-Befehles (siehe dort) die Illusion erzeugt, als ob man
einzelne Bits manipulieren w&uuml;rde. Dazu wird beim<TT>
DBIT</TT>-Befehl eine Adresse mit einer Bitposition
zusammengefa&szlig;t und in einem Symbol abgelegt, das man dann als
Argument f&uuml;r die Pseudobefehle<TT> SBIT0, SBIT1, CMPBIT,
JBIT0</TT> und<TT> JBIT1</TT> verwenden kann. Diese werden in die
Befehle<TT> OR, AND, XOR, BTJZ</TT> und<TT> BTJO</TT> mit einer
passenden Bitmaske &uuml;bersetzt.
<P>
An diesen Bit-Symbolen ist &uuml;berhaupt nichts geheimnisvolles, es
handelt sich um schlichte Integerwerte, in deren unterer H&auml;lfte
die Speicheradresse und in deren oberer H&auml;lfte die Bitstelle
gespeichert wird. Man k&ouml;nnte sich seine Symbole also auch ohne
weiteres selber basteln:
<PRE>

defbit  macro   name,bit,adr
name    equ     adr+(bit&lt;&lt;16)
        endm

</PRE>
aber mit dieser Schreibweise erreicht man nicht den<TT>
EQU</TT>-artigen Stil, den Texas vorgegeben hat (d.h. das zu
definierende Symbol steht anstelle eines Labels). ACHTUNG! Obwohl<TT>
DBIT</TT> eine beliebige Adresse zul&auml;&szlig;t, k&ouml;nnen
f&uuml;r die Pseudobefehle nur die Adressen 0..255 und 1000h..10ffh
verwendet werden, eine absolute Adressierungsart kennt der Prozessor
an dieser Stelle nicht...
<P>

<H2><A NAME="sect_4_55_">4.55. MSP430(X)</A></H2>
<A NAME="ref_MSPSpec"></A>
<P>
Der MSP430 wurde als RISC-Prozessor mit minimalem Stromverbrauch
konzipiert. Aus diesem Grund ist der Satz von Befehlen, die der
Prozessor in Hardware versteht, auf das absolut notwendige reduziert
worden (da RISC-Prozessoren keinen Mikrocode besitzen, mu&szlig;
jeder Befehl mit zus&auml;tzlichem Silizium implementiert werden und
erh&ouml;ht so den Stromverbrauch). Eine Reihe von Befehlen, die bei
anderen Prozessoren in Hardware gegossen wurden, werden beim MSP
durch eine Emulation mit anderen Befehlen realisiert. Fr&uuml;here
Versionen von AS implementierten diese Befehle &uuml;ber Makros in
der Datei<TT> REGMSP.INC</TT>. Wer diese Datei nicht einband, erhielt
bei &uuml;ber der H&auml;lfte der insgesamt von TI definierten
Befehle Fehlermeldungen. Dies ist aktuell nicht mehr so, zusammen mit
der Erweiterung auf den CPU430X-Befehlssatz werden die Instruktionen
vom Assembler direkt implementiert.<TT> REGMSP.INC</TT> enth&auml;lt
nur noch die Adressen von I/O-Registern. Wer aus irgendwelchen
Gr&uuml;nden die alten Makros braucht, findet sie jetzt in der
Datei<TT> EMULMSP.INC</TT>.
<P>
Die emulierten Instruktionen decken auch einige Sonderf&auml;lle ab,
die der TI-Assembler nicht beherrscht. So wird zum Beispiel
<PRE>

    rlc  @r6+

</PRE>
automatisch in
<PRE>

    addc @r6+,-2(r6)

</PRE>
umgesetzt.
<P>

<H2><A NAME="sect_4_56_">4.56. TMS1000</A></H2>
<P>
Der erste Mikrocontroller der Welt nun endlich auch in AS - lange hat
es gedauert, nun ist die L&uuml;cke geschlossen. Dieses Target hat
aber einige T&uuml;cken, die in diesem Abschnitt kurz angesprochen
werden sollen.
<P>
Zum einen ist der Befehlssatz dieser Controller teilweise &uuml;ber
die ROM-Maske ver&auml;nderbar, d.h. man kann die Funktion einiger
Opcodes in Grenzen frei definieren. AS kennt nur die Befehle und
deren Kodierungen, die in <A HREF="#cite_TMS1000PGMRef">[163]</A> als
Default-Kodierungen beschrieben sind. Wer f&uuml;r eine spezielle
Anwendung andere Befehle bzw. gleiche Befehle mit anderem Opcode hat,
kann diese &uuml;ber Makros mit passende<TT> DB</TT>-Befehlen
&auml;ndern.
<P>
Des weiteren ist zu beachten, da&szlig; Spr&uuml;nge und
Unterprogrammaufrufe nur die unteren 6 Bit der Zieladresse im Befehl
selber beinhalten. Die oberen 4 bzw. 5 Bits kommen aus Page- bzw.
Chapter-Registern, die vorher passend zu setzen sind. AS selber kann
hier nicht &uuml;berpr&uuml;fen, ob die Register vom Programmierer
korrekt gesetzt werden!. Zumindest f&uuml;r den Fall, da&szlig; man
im gleichen Chapter bleibt, gibt es die Assembler-Pseudobefehle<TT>
CALLL</TT> bzw.<TT> BL</TT>, die einen<TT> LDP</TT>- und einen<TT>
CALL/BR</TT>-Befehl zusammenfassen (was angesichts des kanppen
Programmspeichers eine bequeme, aber nicht immer effiziente Variante
ist).
<P>

<H2><A NAME="sect_4_57_">4.57. COP8</A></H2>
<A NAME="ref_COP8Spec"></A>
<P>
Leider Gottes hat sich auch National dazu entschieden, als
Schreibweise f&uuml;r nichtdezimale Integer-Konstanten die von
IBM-Gro&szlig;rechnern bekannte (und von mir nicht geliebte) Variante
X'... zu benutzen. Das geht nat&uuml;rlich (wie immer) nicht. Zum
Gl&uuml;ck scheint der ASMCOP aber auch die C-Variante zuzulassen,
und diese wurde deshalb der Default f&uuml;r die COPs...
<P>

<H2><A NAME="sect_4_58_">4.58. SC/MP</A></H2>
<P>
Benutzt man beim SC/MP indirekte Adressierung mit Displacement, und
ist das benutzte Basis- bzw. Pointer-Register nicht P0 bzw. PC, dann
hat ein Displacement von -128 (80 hex) eine Sonderbedeutung: Anstelle
eben dieses Werts wird der Inhalt des E-Registers als Displacement
verwendet. Im 'klassischen' NS-Assembler mu&szlig; der Programmierer
um diesen Umstand wissen bzw. ihn explizit benutzen, z.B. so:
<PRE>

ereg   equ -128
       ld  ereg(p1)

</PRE>
Dies birgt aber das Risiko, da&szlig; sich der Wert -128 auch einmal
'versehentlich' als Teil einer Berechnung ergeben kann, und man sucht
erst einmal, warum das Programm nicht tut, was erwartet wurde. Ich
habe mich deshalb entschlossen, diesen Sonderwert etwas expliziter zu
machen:
<P>
Wird ein Displacement von -128 verwendet, so erfolgt eine Warnung.
Diese Warnung kann man ignorieren; will man sie los werden, so
verwende man das eingebaute Literal E, das eben dieses Register
referenziert:
<PRE>

       ld e(p1)

</PRE>
Da das SC/MP-Target Registersymbole unterst&uuml;tzt, ist es auch
m&ouml;glich, das 'eigene Symbol' passend zu definieren:
<PRE>

ereg   reg e
       ld  ereg(p1)

</PRE>
Dies sollte die Anzahl notwendiger Anpassungen in existierendem Code
auf ein Minimum reduzieren.
<P>

<H2><A NAME="sect_4_59_">4.59. SC144xxx</A></H2>
<A NAME="ref_SC144xxspec"></A>
<P>
Original gab es f&uuml;r diese Reihe von DECT-Controllern mit relativ
einfachem Befehlssatz nur einen sehr schlichten Assembler von
National selber. Ein Assembler von IAR Systems ist angek&uuml;ndigt,
aber noch nicht erh&auml;ltlich. Da die Entwicklungstools von IAR
allerdings auch nach M&ouml;glichkeit CPU-unabh&auml;ngig angelegt
sind, kann man anhand erh&auml;ltlicher Zielplattformen in
ungef&auml;hr absch&auml;tzen, wie dessen Pseudobefehle aussehen
werden, und damit im Blick sind die (wenigen) SC144xx-spezifisch
realisierten Befehle<TT> DC, DC8, DW16, DS, DS8, DS16, DW</TT>
angelegt. Bei Befehlen, die bereits im AS-Kern angelegt sind, wollte
ich nat&uuml;rlich nicht das Rad neu erfinden, deshalb hier eine
Tabelle mit &Auml;quivalenzen:
<P>
Die Befehle<TT> ALIGN, END, ENDM, EXITM, MACRO, ORG, RADIX, SET</TT>
und<TT> REPT</TT> exisieren sowohl bei IAR als auch AS und haben
gleiche Bedeutung. Bei folgenden Befehlen mu&szlig; man umstellen:
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>IAR</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AS</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> #include</TT><BR>
<TT> #define</TT><BR>
<TT> #elif, ELIF, ELSEIF</TT><BR>
<TT> #else, ELSE</TT><BR>
<TT> #endif, ENDIF</TT><BR>
<TT> #error</TT><BR>
<TT> #if, IF</TT><BR>
<TT> #ifdef</TT><BR>
<TT> #ifndef</TT><BR>
<TT> #message</TT><BR>
<TT> =, DEFINE, EQU</TT><BR>
<TT> EVEN</TT><BR>
<TT> COL, PAGSIZ</TT><BR>
<TT> ENDR</TT><BR>
<TT> LSTCND, LSTOUT</TT><BR>
<TT> LSTEXP, LSTREP</TT><BR>
<TT> LSTXRF</TT><BR>
<TT> PAGE</TT><BR>
<TT> REPTC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> include</TT><BR>
<TT> SET, EQU</TT><BR>
<TT> ELSEIF</TT><BR>
<TT> ELSE</TT><BR>
<TT> ENDIF</TT><BR>
<TT> ERROR, FATAL</TT><BR>
<TT> IF</TT><BR>
<TT> IFDEF</TT><BR>
<TT> IFNDEF</TT><BR>
<TT> MESSAGE</TT><BR>
<TT> =, EQU</TT><BR>
<TT> ALIGN 2</TT><BR>
<TT> PAGE</TT><BR>
<TT> ENDM</TT><BR>
<TT> LISTING</TT><BR>
<TT> MACEXP</TT><BR>
 &lt;Kommandozeile&gt;<BR>
<TT> NEWPAGE</TT><BR>
<TT> IRPC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Include-Datei einbinden<BR>
Symbole definieren<BR>
Weiterer Zweig einer IF-Kette<BR>
Letzter Zweig einer IF-Kette<BR>
Beendet eine IF-Kette<BR>
Fehlermeldung erzeugen<BR>
Beginn einer IF-Kette<BR>
Symbol definiert ?<BR>
Symbol nicht definiert ?<BR>
Nachricht ausgeben<BR>
Feste Wertzuweisung<BR>
Programmz&auml;hler gerade machen<BR>
Seitengr&ouml;&szlig;e f&uuml;r Listing setzen<BR>
Ende einer REPT-Struktur<BR>
Umfang des Listings steuern<BR>
Expandierte Makros anzeigen?<BR>
Querverweisliste erzeugen<BR>
Neue Seite im Listing<BR>
Repetition mit Zeichenersetzung</TD>
</TR>
</TABLE></CENTER>
</CENTER>

<P>
Keine direkte Entsprechung gibt es f&uuml;r die Befehle<TT> CASEON,
CASEOFF, LOCAL, LSTPAG, #undef</TT> und<TT> REPTI</TT>.
<P>
Ein direktes &Auml;quivalent der Pr&auml;prozessorbefehle ist
nat&uuml;rlich nicht m&ouml;glich, solange AS keinen C-artigen
Pr&auml;prozessor besitzt. C-artige Kommentare sind im Moment leider
auch nicht m&ouml;glich. Achtung: Wer IAR-Codes f&uuml;r AS umsetzt,
mu&szlig; die Pr&auml;prozessorstatements nicht nur umwandeln,
sondern auch aus Spalte 1 herausbewegen, da bei AS in Spalte 1 nur
Labels stehen d&uuml;rfen!
<P>

<H2><A NAME="sect_4_60_">4.60. NS32xxx</A></H2>
<P>
Wie es sich f&uuml;r CISC-Prozessoren geh&ouml;rt, verf&uuml;gt diese
Serie &uuml;ber ausgefeilte und komplexe Adressierungsarten. National
definiert in ihren Manuals f&uuml;r jede davon die Assembler-Syntax,
und AS setzt auch genau diese um. Wie bei fast jeder Architektur,
f&uuml;r die Werkzeuge von Drittherstellern erstellt wurden, gibt es
jedoch auch Abweichungen und Erweiterungen, und ein paar davon habe
ich auch ,,mitgenommen'':
<P>
Die von National vorgesehene Methode, PC-relativ zu adressieren, ist
folgende:
<PRE>

 movb r0,*+disp

</PRE>
Das dr&uuml;ckt nat&uuml;rlich sehr klar aus, was in diesem Fall
passiert, will man aber einfach eine bestimmte Speicherstelle
PC-relativ adressieren, dann mu&szlig; man die Distanz selber
berechnen:
<PRE>

 movb r0,*+(addr-*)

</PRE>
Die erste Vereinfachung ist, da&szlig; es unter bestimmten
Umst&auml;nden auch ausreicht, einfach nur
<PRE>

 movb r0,addr

</PRE>
zu schreiben - absolute Adressierung wird ja durch ein
vorangestelltes @-Zeichen kenntlich gemacht. Diese vereinfachte
Schreibweise ist unter folgenden Bedingungen erlaubt:
<UL>
<LI> Immediate-Adressierung ist nicht erlaubt, z.B. weil es sich um einen
    Zieloperanden handelt, so da&szlig; keine Verwechslung damit
    m&ouml;glich ist.</LI>
<LI> Es wird mit einer Index-Erweiterung gearbeitet (in eckigen Klammern
    angeh&auml;ngt), die nicht mit Immediate-Adressierung
    kombinierbar ist.</LI>
</UL>
Alternativ unterst&uuml;tzt AS f&uuml;r PC-relative Addressierung
immer die Schreibweise
<PRE>

 movb r0,addr(pc)

</PRE>
Hier wird - analog zum 68000 - die Distanz ebenfalls automatisch
berechnet.
<P>
F&uuml;r den External-Mode, der in der National-Syntax
folgenderma&szlig;en geschrieben wird:
<PRE>

 movb r0,ext(disp1)+disp2

</PRE>
wird auch die Variante
<PRE>

 movb r0,disp2(disp1(ext))

</PRE>
unterst&uuml;tzt, die wohl im UNIX-Umfeld g&auml;ngig war.
<P>

<H2><A NAME="sect_4_61_">4.61. uPD78(C)1x</A></H2>
<A NAME="ref_78C1xSpec"></A>
<P>
F&uuml;r relative, unbedingte Spr&uuml;nge gibt es den<TT>
JR</TT>-Befehl (Sprungdistanz -32...+31, 1 Byte) sowie den<TT>
JRE</TT>-Befehl (Sprungdistanz -256...+255, 2 Bytes). AS kennt
weiterhin den Pseudobefehl<TT> J</TT>, der automatisch den
k&uuml;rzestm&ouml;glichen Befehl benutzt.
<P>
Architektur und Befehlssatz dieser Prozessoren sind grob an den Intel
8080/8085 angelehnt - das gilt auch f&uuml;r die Mnemonics. Die
Adressierungsart (direkt, indirekt, immediate) ist mit in das
Mnemonic verpackt, und 16-Bit-Register (BC, DE, HL) werden wie beim
8080 mit einem Buchstaben abgek&uuml;rzt. Da NEC in der
Erkl&auml;rung der einzelnen Adressierungsarten aber immer mal wieder
die ausgeschriebenen Registernamen benutzt, und auch mal und mal
nicht Klammern benutzt, um indirekte Adressierung anzudeuten, habe
ich mich entschlossen, neben den 'offiziellen' Notationen aus dem
NEC-Manual auch einige alternative Notationen zuzulassen. Einige
nicht-NEC-Tools wie z.B. Disassembler scheinen solche Notationen
ebenfalls zu benutzen:
<P>
<UL>
<LI> Anstelle<TT> B</TT> darf auch<TT> BC</TT>,<TT> (B)</TT> oder<TT>
    (BC)</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> D</TT> darf auch<TT> DE</TT>,<TT> (D)</TT> oder<TT>
    (DE)</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> H</TT> darf auch<TT> HL</TT>,<TT> (H)</TT> oder<TT>
    (HL)</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> D+</TT> darf auch<TT> DE+</TT>,<TT> (D+)</TT>,<TT>
    (DE+)</TT> oder<TT> (DE)+</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> H+</TT> darf auch<TT> HL+</TT>,<TT> (H+)</TT>,<TT>
    (HL+)</TT> oder<TT> (HL)+</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> D-</TT> darf auch<TT> DE-</TT>,<TT> (D-)</TT>,<TT>
    (DE-)</TT> oder<TT> (DE)-</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> H-</TT> darf auch<TT> HL-</TT>,<TT> (H-)</TT>,<TT>
    (HL-)</TT> oder<TT> (HL)-</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> D++</TT> darf auch<TT> DE++</TT>,<TT> (D++)</TT>,<TT>
    (DE++)</TT> oder<TT> (DE)++</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> H++</TT> darf auch<TT> HL++</TT>,<TT> (H++)</TT>,<TT>
    (HL++)</TT> oder<TT> (HL)++</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> D--</TT> darf auch<TT> DE--</TT>,<TT> (D--)</TT>,<TT>
    (DE--)</TT> oder<TT> (DE)--</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> H--</TT> darf auch<TT> HL--</TT>,<TT> (H--)</TT>,<TT>
    (HL--)</TT> oder<TT> (HL)--</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> H+A</TT> darf auch<TT> HL+A</TT>,<TT> A+H</TT>,<TT>
    A+HL</TT>,<TT> (H+A)</TT>,<TT> (HL+A)</TT>,<TT> (A+H)</TT>
    oder<TT> (A+HL)</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> H+B</TT> darf auch<TT> HL+B</TT>,<TT> B+H</TT>,<TT>
    B+HL</TT>,<TT> (H+B)</TT>,<TT> (HL+B)</TT>,<TT> (B+H)</TT>
    oder<TT> (B+HL)</TT> geschrieben werden.</LI>
<LI> Anstelle<TT> H+EA</TT> darf auch<TT> HL+EA</TT>,<TT> EA+H</TT>,<TT>
    EA+HL</TT>,<TT> (H+EA)</TT>,<TT> (HL+EA)</TT>,<TT> (EA+H)</TT>
    oder<TT> (EA+HL)</TT> geschrieben werden.</LI>
</UL>
<P>
Da Architektur und Befehlssatz so ,,8080-artig'' sind, lag es auch
nahe, den Schalter<TT> Z80SYNTAX</TT> zu unterst&uuml;tzen, so
da&szlig; sich viele Befehle in einer eing&auml;ngigeren und
vertrauteren Art und Weise schreiben lassen. Da die Architektur und
der Original-Befehlssatz der uCOM87-Familie sich jedoch in einigen
Punkten von 8080 unterscheiden, ist hier keine eins-zu-eins Abbildung
m&ouml;glich: Nicht alle Originalbefehle haben ein
,,Z80-&Auml;quivalent'', und einge vom 8080/Z80 bekannten Befehle
haben kein Pendant beim uCOM87. Deshalb ergibt ein<TT> Z80SYNTAX
EXCLUSIVE</TT> hier auch keinen Sinn.
<P>
Die folgende Tabelle listet alle im<TT> Z80SYNTAX</TT>-Modus
definierten Befehle und ihre &Auml;quivalente in der Original-Syntax:
<P>
<P><CENTER>Tabelle 4.10: Befehlsvarianten im<TT> Z80SYNTAX</TT>-Modus
</CENTER><P>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT><TT> Z80SYNTAX</TT></TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Original</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Operation</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>CPUs</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LD r1,A</TT><BR>
<BR>
<BR>
<BR>
<TT> LD A,r1</TT><BR>
<BR>
<BR>
<BR>
<TT> LD sr,A</TT><BR>
<TT> LD A,sr1</TT><BR>
<TT> LD r,(word)</TT><BR>
<BR>
<BR>
<BR>
<TT> LD (word),r</TT><BR>
<BR>
<BR>
<BR>
<TT> LD r,byte</TT><BR>
<BR>
<BR>
<BR>
<TT> LD sr2,byte</TT><BR>
<TT> LD (wa),byte</TT><BR>
<TT> LD (rpa1),byte</TT><BR>
<TT> LD (wa),a</TT><BR>
<TT> LD A,(wa)</TT><BR>
<TT> LD (rpa),a</TT><BR>
<TT> LD (rpa2),a</TT><BR>
<TT> LD A,(rpa)</TT><BR>
<TT> LD A,(rpa2)</TT><BR>
<TT> LD rp3,EA</TT><BR>
<TT> LD sr3,EA</TT><BR>
<TT> LD EA,sr4</TT><BR>
<TT> LD EA,rp3</TT><BR>
<TT> LD (word),BC</TT><BR>
<TT> LD (word),DE</TT><BR>
<TT> LD (word),HL</TT><BR>
<TT> LD (word),SP</TT><BR>
<TT> LD (rpa3),EA</TT><BR>
<TT> LD BC,(word)</TT><BR>
<TT> LD DE,(word)</TT><BR>
<TT> LD HL,(word)</TT><BR>
<TT> LD SP,(word)</TT><BR>
<TT> LD EA,(rpa3)</TT><BR>
<TT> LD rp,word</TT><BR>
<TT> LD EA,word</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOV r1,A</TT><BR>
<BR>
<BR>
<BR>
<TT> MOV A,r1</TT><BR>
<BR>
<BR>
<BR>
<TT> MOV sr,A</TT><BR>
<TT> MOV A,sr1</TT><BR>
<TT> MOV r,word</TT><BR>
<BR>
<BR>
<BR>
<TT> MOV word,r</TT><BR>
<BR>
<BR>
<BR>
<TT> MVI r,byte</TT><BR>
<BR>
<BR>
<BR>
<TT> MVI sr2,byte</TT><BR>
<TT> MVIW wa,byte</TT><BR>
<TT> MVIX rpa1,byte</TT><BR>
<TT> STAW wa</TT><BR>
<TT> LDAW wa</TT><BR>
<TT> STAX rpa</TT><BR>
<TT> STAX rpa2</TT><BR>
<TT> LDAX rpa</TT><BR>
<TT> LDAX rpa2</TT><BR>
<TT> DMOV rp3,EA</TT><BR>
<TT> DMOV sr3,EA</TT><BR>
<TT> DMOV EA,sr4</TT><BR>
<TT> DMOV EA,rp3</TT><BR>
<TT> SBCD word</TT><BR>
<TT> SDED word</TT><BR>
<TT> SHLD word</TT><BR>
<TT> SSPD word</TT><BR>
<TT> STEAX rpa3</TT><BR>
<TT> LBCD word</TT><BR>
<TT> LDED word</TT><BR>
<TT> LHLD word</TT><BR>
<TT> LSPD word</TT><BR>
<TT> LDEAX rpa3</TT><BR>
<TT> LXI rp,word</TT><BR>
<TT> LXI EA,word</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>r1&larr;A<BR>
<BR>
<BR>
<BR>
A&larr;r1<BR>
<BR>
<BR>
<BR>
sr&larr;A<BR>
A&larr;sr1<BR>
r&larr;(word)<BR>
<BR>
<BR>
<BR>
(word)&larr;r<BR>
<BR>
<BR>
<BR>
r&larr;byte<BR>
<BR>
<BR>
<BR>
sr2&larr;byte<BR>
(wa)&larr;byte<BR>
(rpa1)&larr;byte<BR>
(wa)&larr;A<BR>
A&larr;(wa)<BR>
(rpa)&larr;(wa)<BR>
(rpa2)&larr;(wa)<BR>
(wa)&larr;(rpa)<BR>
(wa)&larr;(rpa2)<BR>
rp3&larr;EA<BR>
sr3&larr;EA<BR>
EA&larr;sr4<BR>
EA&larr;rp3<BR>
(word)&larr;BC<BR>
(word)&larr;DE<BR>
(word)&larr;HL<BR>
(word)&larr;SP<BR>
(rpa3)&larr;EA<BR>
BC&larr;(word)<BR>
DE&larr;(word)<BR>
HL&larr;(word)<BR>
SP&larr;(word)<BR>
EA&larr;(word)<BR>
rp&larr;word<BR>
EA&larr;word</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r1&ne;EAx)<BR>
3,4<BR>
(r1=EAx)<BR>
1,2,3,4<BR>
(r1&ne;EAx)<BR>
3,4<BR>
(r1=EAx)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
1,2,3,4<BR>
(r1&ne;V)<BR>
2,3,4<BR>
(r1=V)<BR>
1,2,3,4<BR>
(r1&ne;V)<BR>
2,3,4<BR>
(r1=V)<BR>
1,2,3,4<BR>
(r1&ne;V)<BR>
2,3,4<BR>
(r1=V)<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
1,2,3,4<BR>
1,2<BR>
3,4<BR>
1,2<BR>
3,4<BR>
3,4<BR>
3,4<BR>
3,4<BR>
3,4<BR>
1,2,3,4<BR>
1,2,3,4<BR>
1,2,3,4<BR>
1,2,3,4<BR>
3,4<BR>
1,2,3,4<BR>
1,2,3,4<BR>
1,2,3,4<BR>
1,2,3,4<BR>
3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ADD A,(rpa)</TT><BR>
<TT> ADD A,byte</TT><BR>
<TT> ADD r,byte</TT><BR>
<TT> ADD sr2,byte</TT><BR>
<TT> ADD A,(wa)</TT><BR>
<TT> ADD EA,r2</TT><BR>
<TT> ADD EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ADDX rpa</TT><BR>
<TT> ADI A,byte</TT><BR>
<TT> ADI r,byte</TT><BR>
<TT> ADI sr2,byte</TT><BR>
<TT> ADDW wa</TT><BR>
<TT> EADD EA,r2</TT><BR>
<TT> DADD EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A+(rpa)<BR>
A&larr;A+byte<BR>
r&larr;r+byte<BR>
sr2&larr;A+sr2<BR>
A&larr;A+(wa)<BR>
EA&larr;EA+r2<BR>
EA&larr;EA+rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ADC A,(rpa)</TT><BR>
<TT> ADC A,byte</TT><BR>
<TT> ADC r,byte</TT><BR>
<TT> ADC sr2,byte</TT><BR>
<TT> ADC A,(wa)</TT><BR>
<TT> ADC EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ADCX rpa</TT><BR>
<TT> ACI A,byte</TT><BR>
<TT> ACI r,byte</TT><BR>
<TT> ACI sr2,byte</TT><BR>
<TT> ADCW wa</TT><BR>
<TT> DADC EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A+(rpa)+CY<BR>
A&larr;A+byte+CY<BR>
r&larr;r+A+CY<BR>
sr2&larr;A+sr2+CY<BR>
A&larr;A+(wa)+CY<BR>
EA&larr;EA+rp3+CY</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ADDNC A,(rpa)</TT><BR>
<BR>
<TT> ADDNC A,byte</TT><BR>
<BR>
<TT> ADDNC r,byte</TT><BR>
<BR>
<TT> ADDNC sr2,byte</TT><BR>
<BR>
<TT> ADDNC A,(wa)</TT><BR>
<BR>
<TT> ADDNC EA,rp3</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ADDNCX rpa</TT><BR>
<BR>
<TT> ADINC A,byte</TT><BR>
<BR>
<TT> ADINC r,byte</TT><BR>
<BR>
<TT> ADINC sr2,byte</TT><BR>
<BR>
<TT> ADDNCW wa</TT><BR>
<BR>
<TT> DADDNC EA,rp3</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A+(rpa)<BR>
skip if !CY<BR>
A&larr;A+byte<BR>
skip if !CY<BR>
r&larr;r+A<BR>
skip if !CY<BR>
sr2&larr;A+sr2<BR>
skip if !CY<BR>
A&larr;A+(wa)<BR>
skip if !CY<BR>
EA&larr;EA+rp3<BR>
skip if !CY</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
<BR>
1,2,3,4<BR>
<BR>
2,3,4<BR>
<BR>
2,3,4<BR>
<BR>
2,3,4<BR>
<BR>
3, 4<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUB A,(rpa)</TT><BR>
<TT> SUB A,byte</TT><BR>
<TT> SUB r,byte</TT><BR>
<TT> SUB sr2,byte</TT><BR>
<TT> SUB A,(wa)</TT><BR>
<TT> SUB EA,r2</TT><BR>
<TT> SUB EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUBX rpa</TT><BR>
<TT> SUI A,byte</TT><BR>
<TT> SUI r,byte</TT><BR>
<TT> SUI sr2,byte</TT><BR>
<TT> SUBW wa</TT><BR>
<TT> ESUB EA,r2</TT><BR>
<TT> DSUB EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A-(rpa)<BR>
A&larr;A-byte<BR>
r&larr;r-A<BR>
sr2&larr;A-sr2<BR>
A&larr;A-(wa)<BR>
EA&larr;EA-r2<BR>
EA&larr;EA-rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SBB A,(rpa)</TT><BR>
<TT> SBB A,byte</TT><BR>
<TT> SBB r,byte</TT><BR>
<TT> SBB sr2,byte</TT><BR>
<TT> SBB A,(wa)</TT><BR>
<TT> SBB EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SBBX rpa</TT><BR>
<TT> SBI A,byte</TT><BR>
<TT> SBI r,byte</TT><BR>
<TT> SBI sr2,byte</TT><BR>
<TT> SBBW wa</TT><BR>
<TT> DSBB EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A-(rpa)-CY<BR>
A&larr;A-byte-CY<BR>
r&larr;r-A-CY<BR>
sr2&larr;A-sr2-CY<BR>
A&larr;A-(wa)-CY<BR>
EA&larr;EA-rp3-CY</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUBNB A,(rpa)</TT><BR>
<BR>
<TT> SUBNB A,byte</TT><BR>
<BR>
<TT> SUBNB r,byte</TT><BR>
<BR>
<TT> SUBNB sr2,byte</TT><BR>
<BR>
<TT> SUBNB A,(wa)</TT><BR>
<BR>
<TT> SUBNB EA,rp3</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUBNBX rpa</TT><BR>
<BR>
<TT> SUINB A,byte</TT><BR>
<BR>
<TT> SUINB r,byte</TT><BR>
<BR>
<TT> SUINB sr2,byte</TT><BR>
<BR>
<TT> SUBNBW wa</TT><BR>
<BR>
<TT> DSUBNB EA,rp3</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A-(rpa)<BR>
skip if !CY<BR>
A&larr;A-byte<BR>
skip if !CY<BR>
r&larr;r-A<BR>
skip if !CY<BR>
sr2&larr;A-sr2<BR>
skip if !CY<BR>
A&larr;A-(wa)<BR>
skip if !CY<BR>
EA&larr;EA-rp3<BR>
skip if !CY</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
<BR>
1,2,3,4<BR>
<BR>
2,3,4<BR>
<BR>
2,3,4<BR>
<BR>
2,3,4<BR>
<BR>
3,4<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> AND A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> AND r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> AND A,(rpa)</TT><BR>
<TT> AND A,byte</TT><BR>
<TT> AND r,byte</TT><BR>
<TT> AND sr2,byte</TT><BR>
<TT> AND A,(wa)</TT><BR>
<TT> AND (wa),byte</TT><BR>
<TT> AND EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ANA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> ANA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> ANAX rpa</TT><BR>
<TT> ANI A,byte</TT><BR>
<TT> ANI r,byte</TT><BR>
<TT> ANI sr2,byte</TT><BR>
<TT> ANAW wa</TT><BR>
<TT> ANIW wa,byte</TT><BR>
<TT> DAN EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A&and;r<BR>
<BR>
<BR>
<BR>
r&larr;A&and;r<BR>
<BR>
<BR>
<BR>
A&larr;A&and;(rpa)<BR>
A&larr;A&and;byte<BR>
r&larr;r&and;byte<BR>
sr2&larr;sr2&and;byte<BR>
A&larr;A&and;(wa)<BR>
(wa)&larr;(wa)&and;byte<BR>
EA&larr;EA&and;rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> OR A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> OR r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> OR A,(rpa)</TT><BR>
<TT> OR A,byte</TT><BR>
<TT> OR r,byte</TT><BR>
<TT> OR sr2,byte</TT><BR>
<TT> OR A,(wa)</TT><BR>
<TT> OR (wa),byte</TT><BR>
<TT> OR EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ORA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> ORA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> ORAX rpa</TT><BR>
<TT> ORI A,byte</TT><BR>
<TT> ORI r,byte</TT><BR>
<TT> ORI sr2,byte</TT><BR>
<TT> ORAW wa</TT><BR>
<TT> ORIW wa,byte</TT><BR>
<TT> DOR EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A&or;r<BR>
<BR>
<BR>
<BR>
r&larr;A&or;r<BR>
<BR>
<BR>
<BR>
A&larr;A&or;(rpa)<BR>
A&larr;A&or;byte<BR>
r&larr;r&or;byte<BR>
sr2&larr;sr2&or;byte<BR>
A&larr;A&or;(wa)<BR>
(wa)&larr;(wa)&or;byte<BR>
EA&larr;EA&or;rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> XOR A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> XOR r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> XOR A,(rpa)</TT><BR>
<TT> XOR A,byte</TT><BR>
<TT> XOR r,byte</TT><BR>
<TT> XOR sr2,byte</TT><BR>
<TT> XOR A,(wa)</TT><BR>
<TT> XOR EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> XRA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> XRA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> XRAX rpa</TT><BR>
<TT> XRI A,byte</TT><BR>
<TT> XRI r,byte</TT><BR>
<TT> XRI sr2,byte</TT><BR>
<TT> XRAW wa</TT><BR>
<TT> DXR EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>A&larr;A&veebar;r<BR>
<BR>
<BR>
<BR>
r&larr;A&veebar;r<BR>
<BR>
<BR>
<BR>
A&larr;A&veebar;(rpa)<BR>
A&larr;A&veebar;byte<BR>
r&larr;r&veebar;byte<BR>
sr2&larr;sr2&veebar;byte<BR>
A&larr;A&veebar;(wa)<BR>
EA&larr;EA&veebar;rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SKGT A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> SKGT r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> SKGT A,(rpa)</TT><BR>
<TT> SKGT A,byte</TT><BR>
<TT> SKGT r,byte</TT><BR>
<TT> SKGT sr2,byte</TT><BR>
<TT> SKGT A,(wa)</TT><BR>
<TT> SKGT (wa),byte</TT><BR>
<TT> SKGT EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> GTA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> GTA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> GTAX rpa</TT><BR>
<TT> GTI A,byte</TT><BR>
<TT> GTI r,byte</TT><BR>
<TT> GTI sr2,byte</TT><BR>
<TT> GTAW wa</TT><BR>
<TT> GTIW wa,byte</TT><BR>
<TT> DGT EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>skip if A&gt;r<BR>
<BR>
<BR>
<BR>
skip if r&gt;A<BR>
<BR>
<BR>
<BR>
skip if A&gt;(rpa)<BR>
skip if A&gt;byte<BR>
skip if r&gt;byte<BR>
skip if sr2&gt;byte<BR>
skip if A&gt;(wa)<BR>
skip if (wa)&gt;byte<BR>
skip if EA&gt;rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SKLT A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> SKLT r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> SKLT A,(rpa)</TT><BR>
<TT> SKLT A,byte</TT><BR>
<TT> SKLT r,byte</TT><BR>
<TT> SKLT sr2,byte</TT><BR>
<TT> SKLT A,(wa)</TT><BR>
<TT> SKLT (wa),byte</TT><BR>
<TT> SKLT EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LTA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> LTA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> LTAX rpa</TT><BR>
<TT> LTI A,byte</TT><BR>
<TT> LTI r,byte</TT><BR>
<TT> LTI sr2,byte</TT><BR>
<TT> LTAW wa</TT><BR>
<TT> LTIW wa,byte</TT><BR>
<TT> DLT EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>skip if A&lt;r<BR>
<BR>
<BR>
<BR>
skip if r&lt;A<BR>
<BR>
<BR>
<BR>
skip if A&lt;(rpa)<BR>
skip if A&lt;byte<BR>
skip if r&lt;byte<BR>
skip if sr2&lt;byte<BR>
skip if A&lt;(wa)<BR>
skip if (wa)&lt;byte<BR>
skip if EA&lt;rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SKNE A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> SKNE r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> SKNE A,(rpa)</TT><BR>
<TT> SKNE A,byte</TT><BR>
<TT> SKNE r,byte</TT><BR>
<TT> SKNE sr2,byte</TT><BR>
<TT> SKNE A,(wa)</TT><BR>
<TT> SKNE (wa),byte</TT><BR>
<TT> SKNE EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> NEA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> NEA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> NEAX rpa</TT><BR>
<TT> NEI A,byte</TT><BR>
<TT> NEI r,byte</TT><BR>
<TT> NEI sr2,byte</TT><BR>
<TT> NEAW wa</TT><BR>
<TT> NEIW wa,byte</TT><BR>
<TT> DNE EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>skip if A&ne;r<BR>
<BR>
<BR>
<BR>
skip if r&ne;A<BR>
<BR>
<BR>
<BR>
skip if A&ne;(rpa)<BR>
skip if A&ne;byte<BR>
skip if r&ne;byte<BR>
skip if sr2&ne;byte<BR>
skip if A&ne;(wa)<BR>
skip if (wa)&ne;byte<BR>
skip if EA&ne;rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SKEQ A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> SKEQ r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> SKEQ A,(rpa)</TT><BR>
<TT> SKEQ A,byte</TT><BR>
<TT> SKEQ r,byte</TT><BR>
<TT> SKEQ sr2,byte</TT><BR>
<TT> SKEQ A,(wa)</TT><BR>
<TT> SKEQ (wa),byte</TT><BR>
<TT> SKEQ EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> EQA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> EQA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> EQAX rpa</TT><BR>
<TT> EQI A,byte</TT><BR>
<TT> EQI r,byte</TT><BR>
<TT> EQI sr2,byte</TT><BR>
<TT> EQAW wa</TT><BR>
<TT> EQIW wa,byte</TT><BR>
<TT> DEQ EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>skip if A=r<BR>
<BR>
<BR>
<BR>
skip if r=A<BR>
<BR>
<BR>
<BR>
skip if A=(rpa)<BR>
skip if A=byte<BR>
skip if r=byte<BR>
skip if sr2=byte<BR>
skip if A=(wa)<BR>
skip if (wa)=byte<BR>
skip if AEA=rp3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SKON A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> SKON r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> SKON A,(rpa)</TT><BR>
<TT> SKON A,byte</TT><BR>
<TT> SKON r,byte</TT><BR>
<TT> SKON sr2,byte</TT><BR>
<TT> SKON A,(wa)</TT><BR>
<TT> SKON (wa),byte</TT><BR>
<TT> SKON EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ONA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> ONA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> ONAX rpa</TT><BR>
<TT> ONI A,byte</TT><BR>
<TT> ONI r,byte</TT><BR>
<TT> ONI sr2,byte</TT><BR>
<TT> ONAW wa</TT><BR>
<TT> ONIW wa,byte</TT><BR>
<TT> DON EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>skip if (A&and;r)&ne;0<BR>
<BR>
<BR>
<BR>
skip if (r&and;A)&ne;0<BR>
<BR>
<BR>
<BR>
skip if (A&and;(rpa))&ne;0<BR>
skip if (A&and;byte)&ne;0<BR>
skip if (r&and;byte)&ne;0<BR>
skip if (sr2&and;byte)&ne;0<BR>
skip if (A&and;(wa))&ne;0<BR>
skip if (wa)&and;byte&ne;0<BR>
skip if (EA&and;rp3)&ne;0</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SKOFF A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> SKOFF r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> SKOFF A,(rpa)</TT><BR>
<TT> SKOFF A,byte</TT><BR>
<TT> SKOFF r,byte</TT><BR>
<TT> SKOFF sr2,byte</TT><BR>
<TT> SKOFF A,(wa)</TT><BR>
<TT> SKOFF (wa),byte</TT><BR>
<TT> SKOFF EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> OFFA A,r</TT><BR>
<BR>
<BR>
<BR>
<TT> OFFA r,A</TT><BR>
<BR>
<BR>
<BR>
<TT> OFFAX rpa</TT><BR>
<TT> OFFI A,byte</TT><BR>
<TT> OFFI r,byte</TT><BR>
<TT> OFFI sr2,byte</TT><BR>
<TT> OFFAW wa</TT><BR>
<TT> OFFIW wa,byte</TT><BR>
<TT> DOFF EA,rp3</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>skip if (A&and;r)=0<BR>
<BR>
<BR>
<BR>
skip if (r&and;A)=0<BR>
<BR>
<BR>
<BR>
skip if (A&and;(rpa))=0<BR>
skip if (A&and;byte)=0<BR>
skip if (r&and;byte)=0<BR>
skip if (sr2&and;byte)=0<BR>
skip if (A&and;(wa))=0<BR>
skip if (wa)&and;byte=0<BR>
skip if (EA&and;rp3)=0</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
(r&ne;V)<BR>
2,3,4<BR>
(r=V)<BR>
1,2,3,4<BR>
1,2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
2,3,4<BR>
1,2,3,4<BR>
3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INC r2</TT><BR>
<TT> INC (wa)</TT><BR>
<TT> INC rp</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INR r2</TT><BR>
<TT> INRW wa</TT><BR>
<TT> INX rp</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>r2&larr;r2+1<BR>
(wa)&larr;(wa)+1<BR>
rp&larr;rp+1</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
1,2,3,4<BR>
1,2,3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DEC r2</TT><BR>
<TT> DEC (wa)</TT><BR>
<TT> DEC rp</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DCR r2</TT><BR>
<TT> DCRW wa</TT><BR>
<TT> DCX rp</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>r2&larr;r2-1<BR>
(wa)&larr;(wa)-1<BR>
rp&larr;rp-1</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1,2,3,4<BR>
1,2,3,4<BR>
1,2,3,4</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=4 ALIGN=LEFT>CPU-Gruppe 1: 78C05, 78C06<BR>
CPU-Gruppe 2: 7800, 7801, 7802<BR>
CPU-Gruppe 3: 7807, 7808, 7809, 7810<BR>
CPU-Gruppe 4: 7810, 78C1x</TD>
</TR>
</TABLE></CENTER>
<P>

<H2><A NAME="sect_4_62_">4.62. 75K0</A></H2>
<A NAME="ref_75K0Spec"></A>
<P>
Wie bei einigen anderen Prozessoren auch, kennt die Assemblersprache
der 75er von NEC Pseudo-Bitoperanden, d.h. man kann einem Symbol eine
Kombination aus Adresse und Bitnummer zuweisen, die dann bei
bitorientierten Befehlen anstelle direkter Ausdr&uuml;cke verwendet
werden kann. Die drei folgenden Befehle erzeugen daher z.B.
identischen Code:
<PRE>

ADM     sfr     0fd8h
SOC     bit     ADM.3

        skt     0fd8h.3
        skt     ADM.3
        skt     SOC

</PRE>
AS unterscheidet direkte und symbolische Bitzugriffe an einem bei
Symbolen fehlenden Punkt; Punkte in Symbolnamen darf man daher nicht
verwenden, da es sonst zu Mi&szlig;verst&auml;ndnissen bei der
Aufl&ouml;sung kommt.
<P>
Die Ablage von Bitsymbolen orientiert sich dabei weitgehend an der
bin&auml;ren Kodierung, die die Prozessorhardware selber verwendet:
Es werden 16 Bit belegt, und es existieren ein ,,kurzes'' und ein
,,langes'' Format. Das kurze Format kann folgende Varianten
aufnehmen:
<UL>
<LI> direkte Zugriffe auf die Bereiche 0FBxH und 0FFxH</LI>
<LI> indirekte Zugriffe der Form Adr.@L (0FC0H &le;<TT> Adr</TT> &le;
    0FFFH)</LI>
<LI> indirekte Zugriffe der Form @H+d4.bit</LI>
</UL>
Das obere Byte ist auf 0 gesetzt, das untere Byte enth&auml;lt den
gem&auml;&szlig; <A HREF="#cite_NEC75">[106]</A> kodierten
Bitausdruck. Das lange Format kennt im Gegensatz dazu nur direkte
Adressierung, kann daf&uuml;r aber (korrekte Einstellungen von<TT>
MBS</TT> und<TT> MBE</TT> vorausgesetzt) den ganzen Adre&szlig;raum
abdecken. Bei langen Ausdr&uuml;cken stehen im unteren Byte Bit 7..0
der Adresse, in Bit 8 und 9 die Bitstelle sowie in Bit 10 und 11
konstant 01. Letztere erm&ouml;glichen es, langes und kurzes Format
einfach durch einen Vergleich des oberen Bytes gegen Null zu
unterscheiden. Die Bits 12..15 enthalten Bit 8..11 der Adresse; sie
werden zwar nicht zur Generierung des Kodes ben&ouml;tigt,
m&uuml;ssen jedoch gespeichert werden, da eine Pr&uuml;fung auf ein
korrektes Banking erst bei der Verwendung des Symboles erfolgen kann.
<P>

<H2><A NAME="sect_4_63_">4.63. 78K0</A></H2>
<A NAME="ref_78K0Spec"></A>
<P>
NEC benutzt in seinen Datenb&uuml;chern zur Kennzeichnung der
Zugriffsweise auf absolute Adressen verschiedene Schreibweisen:
<UL>
<LI> absolut kurz: kein Pr&auml;fix</LI>
<LI> absolut lang: vorangestelltes !</LI>
<LI> PC-relativ: vorangestelltes $</LI>
</UL>
Bei AS sind diese Pr&auml;fixe nur notwendig, falls man eine
bestimmte Adressierung erzwingen will und der Befehl verschiedene
Varianten zul&auml;&szlig;t. Setzt man keinen Pr&auml;fix, so
w&auml;hlt AS automatisch die k&uuml;rzeste Variante. Es d&uuml;rfte
daher in der Praxis sehr selten notwendig sein, einen Pr&auml;fix zu
verwenden.
<P>

<H2><A NAME="sect_4_64_">4.64. 78K2/78K3/78K4</A></H2>
<A NAME="ref_78K234Spec"></A>
<P>
Analog wie beim 78K0 benutzt NEC auch hier wieder Dollar- und
Ausrufezeichen f&uuml;r verschiedene L&auml;ngen von
Adre&szlig;ausdr&uuml;cken. Zwischen langen und kurzen Adressen
(sowohl im RAM- als auch SFR-Bereich) wird wieder automatisch
entschieden, nur relative Adressierung mu&szlig; man manuell
anw&auml;hlen, wenn ein Befehl beides unterst&uuml;tzt (z.B.<TT>
BR</TT>).
<P>
Noch eine Anmerkung (die im &uuml;brigens auch f&uuml;r den 78K0
gilt): Wer mittels<TT> RELAXED</TT> mit Motorola-Syntax arbeitet,
mu&szlig; Hexadezimalkonstanten klammern, weil das f&uuml;hrende
Dollarzeichen u.U. als relative Adressierung mi&szlig;verstanden
wird...
<P>

<H2><A NAME="sect_4_65_">4.65. uPD772x</A></H2>
<P>
Sowohl 7720 als auch 7725 werden von dem gleichen Codegenerator
behandelt und sind sich in ihren Befehlssatz extrem &auml;hnlich.
Trotzdem sollte man sich nicht zu der Annahme verleiten lassen, sie
seien bin&auml;r kompatibel: Um die l&auml;ngeren Adre&szlig;felder
und zus&auml;tzlichen Befehle unterbringen zu k&ouml;nnen, haben sich
die Bitpositionen einiger Felder im Instruktionswort verschoben, die
Instruktionsl&auml;nge hat sich auch insgesamt von 23 auf 24 Bit
ge&auml;ndert. Im Code-Format sind deshalb auch unterschiedliche
Header-Ids f&uuml;r beide reserviert.
<P>
Gemeinsam ist beiden, da&szlig; sie neben Code- und Datensegment auch
noch ein ROM zur Ablage von Konstanten besitzen. Dieses ist bei AS
auf das<TT> ROMDATA</TT>-Segment abgebildet!
<P>

<H2><A NAME="sect_4_66_">4.66. uCOM-43</A></H2>
<P>
Der uCOM-43-Befehlssatz enth&auml;lt einen Befehl<TT> CZP</TT>, der
es erlaubt, einen Unterprogrammaufruf auf eine der Adressen 0, 4, 8,
12...60 mit einem einzigen Instruktions-Byte zu machen. Leider ist
die vorhandene Dokumentation dar&uuml;ber unklar, ob der Befehl im
Quelltext die Zieladresse (also einen durch vier teilbaren Wert) oder
den im Befehl enthaltenen Vektor (also eine Zahl von 0 bis 15)
erwartet. Im Moment betreibt der Assembler ein wenig
'Kaffeesatzleserei':
<UL>
<LI> Falls das Argument gr&ouml;&szlig;er als 15 ist, mu&szlig; es sich
    um eine Adresse handeln, ansonsten:</LI>
<LI> Falls das Argument kein mehrfaches von vier ist, mu&szlig; es sich
    um einen Vektor handeln, ansonsten:</LI>
<LI> Falls das Argument Null ist, ist keine Unterscheidung notwendig,
    ansonsten:</LI>
<LI> Falls das Argument ein Symbol aus dem<TT> CODE</TT>-Segment ist,
    z.B. ein Label, mu&szlig; es sich um eine Adresse handlen,
    ansonsten:</LI>
<LI> ist es ein Vektor.</LI>
</UL>
Die letzten beiden F&auml;lle treffen nur auf die Werte 4, 8 oder 12
zu, und weil die Entscheidung nicht intuitiv ist, wird bei der
Entscheidung f&uuml;r einen Vektor eine Warnung ausgegeben. F&uuml;r
den Fall, da&szlig; wirklich die Adresse 4, 8 oder 12 gemeint ist,
definiere man den Wert als Symbol im Code-Segment:
<PRE>

dest   label  4
       .
       .
       .
       czp dest

</PRE>
F&uuml;r den Fall, da&szlig; ein Vektor gemeint ist, und die Warnung
st&ouml;rt, kann man die Warnung folgender ma&szlig;en
unterdr&uuml;cken:
<PRE>

vector equ    4
       .
       .
       .
       expect 480
       czp    vector
       endexpect

</PRE>
Ich gestehe ein, da&szlig; diese Situation nicht 100% befriedigend
ist. Falls jemand Informationen &uuml;ber das Verhalten des
Original-NEC-Assemblers hat, w&auml;re ich f&uuml;r eine Nachricht
dankbar.
<P>

<H2><A NAME="sect_4_67_">4.67. F2MC16L</A></H2>
<P>
Darauf, da&szlig; man bei Anwendungen mit mehr als 64K ROM oder 64K
RAM darauf achten sollte, AS die korrekte momentane Belegung der
Bank-Register mitzuteilen, wurde bereits in Zusammenhang mit dem<TT>
ASSUME</TT>-Befehl erw&auml;hnt. AS &uuml;berpr&uuml;ft bei jedem
absoluten Zugriff anhand dieser Annahmen, ob evtl. ein Zugriff auf
eine Speicherstelle erfolgt, die momentan &uuml;berhaupt nicht
greifbar ist. Standardm&auml;&szlig;ig sind daf&uuml;r nat&uuml;rlich
nur DTB und DPR wichtig, denn ADB bzw. SSB/USB werden nur bei
indirekten Zugriffen &uuml;ber RW2/RW6 bzw. RW3/RW7 benutzt, und bei
indirekten Zugriffen greift diese Pr&uuml;fmimik ohnehin nicht. Nun
ist es aber so, da&szlig; man - &auml;hnlich wie beim 8086 - einem
Befehl eine Segmentpr&auml;fix voranstellen kann, mit dem DTB
f&uuml;r den folgenden Befehl durch ein beliebiges anderes Register
ersetzt werden kann. AS f&uuml;hrt deswegen &uuml;ber die verwendeten
Pr&auml;fixbefehle Buch und schaltet bei der Pr&uuml;fung f&uuml;r
den n&auml;chsten<EM> Prozessorbefehl</EM> um - eine zwischen dem
Segmentpr&auml;fix und Prozessorbefehl eingestreute Pseudoanweisung
l&ouml;scht den Merker also<EM> nicht</EM>. Dies gilt auch f&uuml;r
Pseudobefehle zur Datenablage oder Ver&auml;nderung des
Programmz&auml;hlers - aber wer macht so etwas schon ;-)
<P>

<H2><A NAME="sect_4_68_">4.68. MN161x</A></H2>
<P>
F&uuml;r dieses Target gilt die Besonderheit, da&szlig; man zwischen
zwei Code-Generatoren w&auml;hlen kann: Einer wurde freundlicherweise
von Haruo Asano geschrieben und ist &uuml;ber die CPU-Namen<TT>
MN1610</TT> bzw.<TT> MN1613</TT> erreichbar; der andere wurde von mir
erstellt und ist &uuml;ber die Namen<TT> MN1610ALT</TT> bzw.<TT>
MN1613ALT</TT> aktivierbar. Wer den erweiterten Adre&szlig;raum von
256 KWorten des MN1613 verwenden will, oder mit dem Gleitkommaformat
des MN1613 experimentieren will, mu&szlig; das<TT> ALT</TT>- Target
verwenden.
<P>

<H2><A NAME="sect_4_69_">4.69. CDP180x</A></H2>
<P>
Prozessoren dieser Reihe kennen sowohl kurze als auch lange
Sprungbefehle: W&auml;hrend ein kurzer Sprung nur innerhalb der
gleichen Speicherseite von 256 Byte m&ouml;glich ist, kann man mit
einem langen Sprung jedes beliebige Ziel im Adre&szlig;raum von 64
KByte erreichen. Die Assembler-Syntax sieht f&uuml;r beide Varianten
unterschiedliche Mnemonics vor (die lange Variante mit
vorangestelltem 'L'), aber keine, die dem Assembler gestatten
w&uuml;rde, automatisch einen langen oder kurzen Befehl einzusetzen.
AS kennt solche 'Pseudobehle' als Erweiterung:
<UL>
<LI> <TT>JMP</TT> wird zu<TT> BR</TT> oder<TT> LBR</TT>.</LI>
<LI> <TT>JZ</TT> wird zu<TT> BZ</TT> oder<TT> LBZ</TT>.</LI>
<LI> <TT>JNZ</TT> wird zu<TT> BNZ</TT> oder<TT> LBNZ</TT>.</LI>
<LI> <TT>JDF</TT> wird zu<TT> BDF</TT> oder<TT> LBDF</TT>.</LI>
<LI> <TT>JPZ</TT> wird zu<TT> BPZ</TT> oder<TT> LBPZ</TT>.</LI>
<LI> <TT>JGE</TT> wird zu<TT> BGE</TT> oder<TT> LBGE</TT>.</LI>
<LI> <TT>JNF</TT> wird zu<TT> BNF</TT> oder<TT> LBNF</TT>.</LI>
<LI> <TT>JM</TT> wird zu<TT> BM</TT> oder<TT> LBM</TT>.</LI>
<LI> <TT>JL</TT> wird zu<TT> BL</TT> oder<TT> LBL</TT>.</LI>
<LI> <TT>JQ</TT> wird zu<TT> BQ</TT> oder<TT> LBQ</TT>.</LI>
<LI> <TT>JNQ</TT> wird zu<TT> BNQ</TT> oder<TT> LBNQ</TT>.</LI>
</UL>
<P>

<H2><A NAME="sect_4_70_">4.70. KENBAK</A></H2>
<P>
Der KENBAK-1 wurde 1970 entwickelt, zu einer Zeit, als der erste
Mikroprozessor noch drei Jahre entfernt war. Man kann davon ausgehen,
da&szlig; er f&uuml;r die Hobbyisten, die sich den Bausatz seinerzeit
leisten konnten, ihr erster und einziger Computer war. Demzufolge
hatten sie auch nichts, auf dem sie einen Assembler f&uuml;r diesen
Computer h&auml;tten laufen lassen k&ouml;nnen - der KENBAK-1 mit
seinem Speicher von 256 Byte war daf&uuml;r viel zu klein. Die
pr&auml;ferierte Methode waren vorgedruckte Tabellen, in die man die
Befehle und ihren Maschinencode eintrug. War man mit dieser
,,Programmierung'' fertig, konnte man den Code &uuml;ber die
Schalterleiste per Hand in den Computer laden.
<P>
Daraus resultiert leider, da&szlig; die Assembler-Sprache des KENBAK
zwar im Programming Manual beschrieben, aber nicht wirklich formal
definiert ist. Als Grant Stockly vor ein paar Jahren neue KENBAK-Kits
herausbrachte, hat er eine erste KENBAK-Portierung f&uuml;r meinen
Assembler gemacht, die hat ihren Weg jedoch leider nie wieder
''upstream'' gefunden. In meiner Implementierung habe ich versucht,
seine Ideen aufzugreifen, jedoch andererseits auch eine Syntax
anzubieten, wie sie Programmierern eines 6502, Z80 oder
&auml;hnlichem eher vertraut sein d&uuml;rfte. In der folgenden
Tabelle sind die Syntax-Unterschiede gegen&uuml;ber gestellt:
<P>
<CENTER>
<P><CENTER>Tabelle 4.10: KENBAK-Befehlssyntax<A NAME="ref_TabKENBAKSyntax"></A>
</CENTER><P>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Stockly</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Alternativ</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bemerkung</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=3 ALIGN=LEFT><B> Arithmetisch/Logisch (ADD/SUB/LOAD/STORE/AND/OR/LNEG)</B></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><I> instr</I><TT> Constant</TT>,<I> Reg</I>,<I> Wert</I>,<BR>
<I> instr</I><TT> Memory</TT>,<I> Reg</I>,<I> Addr</I>,<BR>
<I> instr</I><TT> Indirect</TT>,<I> Reg</I>,<I> Addr</I>,<BR>
<I> instr</I><TT> Indexed</TT>,<I> Reg</I>,<I> Addr</I>,<BR>
<I> instr</I><TT> Indirect-Indexed</TT>,<I> Reg</I>,<I> Addr</I>,</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><I> instr</I><I> Reg</I>,<I> #Wert</I><BR>
<I> instr</I><I> Reg</I>,<I> Addr</I><BR>
<I> instr</I><I> Reg</I>,<I> (Addr)</I><BR>
<I> instr</I><I> Reg</I>,<I> Addr</I>,X<BR>
<I> instr</I><I> Reg</I>,<I> (Addr)</I>,X</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>immediate<BR>
direkt<BR>
direkt<BR>
indiziert<BR>
indirekt-indiziert</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=3 ALIGN=LEFT><B> Spr&uuml;nge</B></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> JPD</TT><I> Reg</I>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JPI</TT><I> Reg</I>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JMD</TT><I> Reg</I>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JMI</TT><I> Reg</I>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JPD</TT><TT> Unconditional</TT>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JPI</TT><TT> Unconditional</TT>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JMD</TT><TT> Unconditional</TT>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JMI</TT><TT> Unconditional</TT>,<I> Cond</I>,<I> Addr</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> JP</TT><I> Reg</I>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JP</TT><I> Reg</I>,<I> Cond</I>,<I> (Addr)</I><BR>
<TT> JM</TT><I> Reg</I>,<I> Cond</I>,<I> Addr</I><BR>
<TT> JM</TT><I> Reg</I>,<I> Cond</I>,<I> (Addr)</I><BR>
<TT> JP</TT><I> Addr</I><BR>
<TT> JP</TT><I> (Addr)</I><BR>
<TT> JM</TT><I> Addr</I><BR>
<TT> JM</TT><I> (Addr)</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>bedingt-direkt<BR>
bedingt-indirekt<BR>
bedingt-direkt<BR>
bedingt-indirekt<BR>
unbedingt-direkt<BR>
unbedingt-indirekt<BR>
unbedingt-direkt<BR>
unbedingt-indirekt</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=3 ALIGN=LEFT><B> Sprungbedingungen</B></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> Non-zero</TT><BR>
<TT> Zero</TT><BR>
<TT> Negative</TT><BR>
<TT> Positive</TT><BR>
<TT> Positve-Non-zero</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> NZ</TT><BR>
<TT> Z</TT><BR>
<TT> N</TT><BR>
<TT> P</TT><BR>
<TT> PNZ</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>&ne; 0<BR>
= 0<BR>
&lt; 0<BR>
&ge; 0<BR>
&gt; 0</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=3 ALIGN=LEFT><B> Skips</B></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SKP 0</TT>,<I> bit</I>,<I> Addr</I><BR>
<TT> SKP 1</TT>,<I> bit</I>,<I> Addr</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SKP0</TT><I> bit</I>,<I> Addr</I><I> [,Dest]</I><BR>
<TT> SKP1</TT><I> bit</I>,<I> Addr</I><I> [,Dest]</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=3 ALIGN=LEFT><B> Bitmanipulation</B></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SET 0</TT>,<I> bit</I>,<I> Addr</I><BR>
<TT> SET 1</TT>,<I> bit</I>,<I> Addr</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SET0</TT><I> bit</I>,<I> Addr</I><BR>
<TT> SET1</TT><I> bit</I>,<I> Addr</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=3 ALIGN=LEFT><B> Schiebe/Rotierbefehle</B></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SHIFT LEFT</TT>,<I> cnt</I>,<I> Reg</I><BR>
<TT> SHIFT RIGHT</TT>,<I> cnt</I>,<I> Reg</I><BR>
<TT> ROTATE LEFT</TT>,<I> cnt</I>,<I> Reg</I><BR>
<TT> ROTATE RIGHT</TT>,<I> cnt</I>,<I> Reg</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SFTL</TT><I> [cnt,]</I><I> Reg</I><BR>
<TT> SFTR</TT><I> [cnt,]</I><I> Reg</I><BR>
<TT> ROTL</TT><I> [cnt,]</I><I> Reg</I><BR>
<TT> ROTR</TT><I> [cnt,]</I><I> Reg</I></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><BR>
arithm. Shift<BR>
<BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>
Es gibt keinen Pseudobefehl, um zwischen diesen beiden
Syntax-Varianten umzuschalten. Beide d&uuml;rfen jederzeit und auch
in beliebiger Mischung genutzt werden.
<P>
Die Zieladresse<I> [Dest]</I>, die man optional bei den Skip-Befehlen
angeben kann, geht nicht in den erzeugten Code ein. Der Assembler
&uuml;berpr&uuml;ft lediglich, ob der Prozessor zur Laufzeit wirklich
zur angegebene Adresse springen w&uuml;rde. Dadurch kann z.B.
gepr&uuml;ft werden, ob man nicht versehentlich versucht, einen
einzelnen Ein-Byte-Befehl zu &uuml;berspringen. Ein weggelassenes
Schiebeargument<I> [cnt]</I> bedeutet, da&szlig; um eine Stelle
geschoben werden soll.
<P>

<H2><A NAME="sect_4_71_">4.71. HP Nanoprocessor</A></H2>
<P>
Der HP Nanoprocessor verf&uuml;gt &uuml;ber keinerlei Befehle, Daten
aus dem ROM- Adre&szlig;raum zu lesen und in ein Register zu
transferieren. Die diesbez&uuml;glichen Befehle<TT> LDR</TT> und<TT>
STR</TT> sind eher das, was man bei anderen Prozessoren als
,,immediate-Adressierung'' bezeichnen w&uuml;rde. Aus diesen Grund
sind f&uuml;r den HP Nanoprocessor keinerlei Pseudobefehen definiert,
mit denen sich Konstanten im ROM ablegen oder Platz reservieren
l&auml;&szlig;t.
<P>

<H2><A NAME="sect_4_72_">4.72. IM61x0</A></H2>
<P>
Dieser Mikroprozessor ist quasi eine Single-Chip-Implementierung
einer PDP/8E, weshalb als ,,Assembler-Referenz'' in
Quellcode-Beispielen &uuml;blicherweise der PAL-III von Digital
Equipment benutzt wird. Die AS-Implementierung weicht in einigen
Punkten von der PAL-III-Syntax ab, unter anderem auch, weil sich
manche Dinge nur mit gro&szlig;em Aufwand h&auml;tten bereit stellen
lassen. Hier einige Hinweise, wie sich bestehender Code anpassen
l&auml;&szlig;t:
<P>
<UL>
<LI> Bei PAL-III werden Label durch ein angeh&auml;ngtes Komma
    gekennzeichnet. Bei AS ist diese ein Doppelpunkt, bzw. gar
    nichts, wenn das Label in der ersten Spalte beginnt.</LI>
<LI> Die Ablage von Daten im Speicher erfolgt bei PAL-III einfach
    dadurch, da&szlig; man die Konstante in das Feld des Mnemonics
    schreibt. AS verwendet zur Datenablage die<TT> DC</TT>-Anweisung,
    die daf&uuml;r auch mehrere Worte auf einmal als Argument
    akzeptiert. Unter Umst&auml;nden kann man sich die Ablage von
    Konstanten durch den<TT> LTORG</TT>-Mechanismus aber auch
    teilweise ersparen.</LI>
<LI> Den Programmz&auml;hler setzt man mit<TT> ORG address</TT>
    anstelle*address.</LI>
</UL>
<P>

<H1><A NAME="sect_5_">5. Dateiformate</A></H1>
<P>
In diesem Kapitel sollen die Formate von von AS erzeugten Dateien
beschrieben werden, deren Format sich nicht direkt erschlie&szlig;t.
<P>

<H2><A NAME="sect_5_1_">5.1. Code-Dateien</A></H2>
<A NAME="ref_SectCodeFormat"></A>
<P>
Das vom Assembler ausgegebene Codedatenformat mu&szlig; in der Lage
sein, die Codeteile f&uuml;r unterschiedliche Prozessoren voneinander
zu trennen, und sieht daher etwas anders aus als g&auml;ngige
Formate. Obwohl dem Assembler Tools zur Bearbeitung der Codedateien
beiliegen, halte ich es f&uuml;r guten Stil, das Format hier kurz
offenzulegen:
<P>
Sofern in der Datei Mehrbyte-Integers gespeichert sind, werden sie im
Intelformat abgelegt, d.h. mit dem LSB zuerst. Diese Regel gilt
bereits f&uuml;r das 16-Bit-Kennungswort mit dem Wert $1489, d.h.
jede Codedatei beginnt mit den Bytes $89/$14.
<P>
Danach folgt eine Reihe beliebig vieler ,,Records'', wobei ein Record
entweder ein zusammenh&auml;ngendes Teilfeld des Codes darstellt oder
bestimmte Zusatzinformationen enth&auml;lt. Eine Datei kann auch ohne
Umschaltung des Prozessortyps mehrere Records enthalten, wenn Code-
oder Konstantenbereiche durch reservierte (und nicht zu
initialisierende) Speicherbereiche unterbrochen werden. Der Assembler
versucht auf diese Weise, die Datei nicht l&auml;nger als n&ouml;tig
werden zu lassen.
<P>
Allen Records ist gemein ist ein Header-Byte, das den Typ des Records
und die damit folgenden Datenstrukturen festlegt. In einer
Pascal-artigen Form l&auml;&szlig;t sich die Record-Struktur
folgenderma&szlig;en beschreiben:
<PRE>

FileRecord = RECORD CASE RecordTypeOrFamilyHdr : UInt8 OF
              $00:(Creator:ARRAY[] OF Char);
              $01..
              $7f:(StartAddress : UInt32;
                   Length       : UInt16;
                   Data         : ARRAY[0..Length-1] OF UInt8);
              $80:(EntryAddress : UInt32);
              $81:(FamilyHdr    : UInt8;
                   Segment      : UInt8;
                   Gran         : UInt8;
                   StartAddress : UInt32;
                   Length       : UInt16;
                   Data         : ARRAY[0..Length-1] OF UInt8);
             END

</PRE>
Was in dieser Schreibweise nicht ganz zum Ausdruck kommt, ist,
da&szlig; die L&auml;nge von Datenfeldern variabel ist und von<TT>
Length</TT> abh&auml;ngt.
<P>
Ein Record mit einem Header-Byte von $81 ist ein Record, der Code
oder Daten aus beliebigen Segmenten beinhalten kann. Das erste Byte
(Header) gibt an, f&uuml;r welche Prozessorfamilie die folgenden
Daten bzw. der folgende Code bestimmt ist (siehe Tabelle <A
HREF="#ref_TabHeader">5.1</A>).
<P>
<P>
<CENTER>
<P><CENTER>Tabelle 5.1: Headerbytes f&uuml;r die verschiedenen Prozessorfamilien
</CENTER><P>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>FamilyHdr</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Familie</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>FamilyHdr</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Familie</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$01<BR>
$03<BR>
$05<BR>
$07<BR>
$09<BR>
$0b<BR>
$0d<BR>
$0f<BR>
$11<BR>
$13<BR>
$15<BR>
$17<BR>
$19<BR>
$1b<BR>
$1d<BR>
$1f<BR>
$21<BR>
$23<BR>
$25<BR>
$27<BR>
$29<BR>
$2b<BR>
$32<BR>
$35<BR>
$36<BR>
$38<BR>
$3a<BR>
$3c<BR>
$3e<BR>
$40<BR>
$42<BR>
$44<BR>
$46<BR>
$48<BR>
$4a<BR>
$4c<BR>
$4e<BR>
$50<BR>
$52<BR>
$54<BR>
$56<BR>
$58<BR>
$5a<BR>
$5c<BR>
$5e<BR>
$60<BR>
$62<BR>
$64<BR>
$66<BR>
$68<BR>
$6a<BR>
$6c<BR>
$6e<BR>
$70<BR>
$72<BR>
$74<BR>
$76<BR>
$78<BR>
$7a<BR>
$7c<BR>
$7e<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>680x0, 6833x<BR>
M*Core<BR>
PowerPC<BR>
TMS1000<BR>
DSP56xxx<BR>
HP Nano Processor<BR>
NEC V60<BR>
CP-3F<BR>
65xx/MELPS-740<BR>
M16<BR>
F<SUP>2</SUP>MC8L<BR>
IMP-16<BR>
65816/MELPS-7700<BR>
PDK14<BR>
PDK16<BR>
SC61860<BR>
MCS-48<BR>
PDP-11<BR>
SYM53C8xx<BR>
KENBAK<BR>
29xxx<BR>
TLCS-42<BR>
ST9<BR>
Z8000<BR>
MN161x<BR>
1802/1805<BR>
8X30x<BR>
XA<BR>
8008<BR>
H16<BR>
8086..V35<BR>
F8<BR>
78K4<BR>
TMS9900<BR>
MSP430<BR>
80C166/167<BR>
OLMS-40<BR>
HMCS-400<BR>
TLCS-900<BR>
TLCS-870<BR>
TLCS-9000<BR>
NEC 78K3<BR>
TC9331<BR>
LatticeMico8<BR>
68RS08<BR>
78K2<BR>
6805/HC08<BR>
6804<BR>
68HC12<BR>
H8/300(H)<BR>
807x<BR>
SH7000<BR>
SC/MP<BR>
PIC16C8x<BR>
PIC17C4x<BR>
TMS3201x<BR>
TMS320C3x/C4x<BR>
ST6<BR>
&micro;PD78(C)10<BR>
78K0<BR>
&micro;PD7725<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$02<BR>
$04<BR>
$06<BR>
$08<BR>
$0a<BR>
$0c<BR>
$0e<BR>
$10<BR>
$12<BR>
$14<BR>
$16<BR>
$18<BR>
$1a<BR>
$1c<BR>
$1e<BR>
$20<BR>
$22<BR>
$24<BR>
$26<BR>
$28<BR>
$2a<BR>
$31<BR>
$33<BR>
$35<BR>
$37<BR>
$39<BR>
$3b<BR>
$3d<BR>
$3f<BR>
$41<BR>
$43<BR>
$45<BR>
$47<BR>
$49<BR>
$4b<BR>
$4d<BR>
$4f<BR>
$51<BR>
$53<BR>
$55<BR>
$57<BR>
$59<BR>
$5b<BR>
$5d<BR>
$5f<BR>
$61<BR>
$63<BR>
$65<BR>
$67<BR>
$69<BR>
$6b<BR>
$6d<BR>
$6f<BR>
$71<BR>
$73<BR>
$75<BR>
$77<BR>
$79<BR>
$7b<BR>
$7d<BR>
$7f<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>ATARI_VECTOR<BR>
XGATE<BR>
XCore<BR>
NS32xxx<BR>
CP-1600<BR>
IM6100/6120<BR>
IBM PALM<BR>
Rockwell PPS-4<BR>
MELPS-4500<BR>
M16C<BR>
F<SUP>2</SUP>MC16L<BR>
IPC-16/INS8900<BR>
PDK13<BR>
PDK15<BR>
Renesas RX<BR>
SC62015<BR>
Konami 052001<BR>
WD16<BR>
VAX<BR>
&micro;COM-43<BR>
i960<BR>
MCS-51<BR>
ST7<BR>
Super8<BR>
2650<BR>
MCS-96/196/296<BR>
AVR<BR>
AVR (8-Bit CSeg)<BR>
4004/4040<BR>
8080/8085<BR>
SX20<BR>
S12Z<BR>
TMS320C6x<BR>
TMS370xxx<BR>
TMS320C54x<BR>
OLMS-50<BR>
MIL STD 1750<BR>
Z80/180/380/eZ80<BR>
TLCS-90<BR>
TLCS-47<BR>
TLCS-870/C<BR>
eZ8<BR>
KCPSM3<BR>
NEC 75xx<BR>
COP4<BR>
6800, 6301, 6811<BR>
6809<BR>
68HC16<BR>
ACE<BR>
H8/500<BR>
KCPSM<BR>
SC14xxx<BR>
COP8<BR>
PIC16C5x<BR>
TMS-7000<BR>
TMS320C2x<BR>
TMS320C20x/C5x<BR>
Z8<BR>
75K0<BR>
&micro;PD7720<BR>
&micro;PD77230<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><A NAME="ref_TabHeader"></A></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>
Das Segment-Feld gibt an, in welchen Adre&szlig;raum des Prozessors
der folgende Code geh&ouml;rt. Dabei gilt die in Tabelle <A
HREF="#ref_TabSegments">5.1</A> angegeben Zuordnung.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Nummer</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Segment</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Nummer</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Segment</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$00<BR>
$02<BR>
$04<BR>
$06<BR>
$08</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>&lt;undefiniert&gt;<BR>
DATA<BR>
XDATA<BR>
BDATA<BR>
REG</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$01<BR>
$03<BR>
$05<BR>
$07<BR>
$09</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>CODE<BR>
IDATA<BR>
YDATA<BR>
IO<BR>
ROMDATA</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 5.1: Kodierungen des<TT> Segment</TT>-Feldes<A
             NAME="ref_TabSegments"></A><A
             NAME="ref_TabSegmentNums"></A>
</CENTER><P>

Das Gran-Feld gibt die ,,Granularit&auml;t'' des Codes an, d.h. die
Gr&ouml;&szlig;e der kleinsten, adressierbaren Einheit im folgenden
Datensatz. Dieser Wert ist eine Funktion von Prozessortyp und Segment
und ein wichtiges Detail f&uuml;r die Interpretation der beiden
folgenden Felder, die Startadresse und L&auml;nge angeben:
W&auml;hrend die Startadresse sich auf die Granularit&auml;t bezieht,
erfolgt die L&auml;ngenangabe immer in Bytes! W&auml;re die
Startadresse z.B. $300 und die L&auml;nge 12, so w&auml;re die sich
ergebende Endadresse bei einer Granularit&auml;t von 1 $30b, bei
einer Granularit&auml;t von z.B. 4 jedoch $303! Andere
Granularit&auml;ten als eins sind selten und treten in erster Linie
bei Signalprozessoren auf, die nicht auf Einzelbyteverarbeitung
ausgelegt sind deren Datenspeicher z.B. aus 64kWorten zu 16 Bit
besteht (DSP56K). Der sich ergebende Speicherplatz betr&auml;gt dann
zwar 128 KByte, er ist aber in 2<SUP> 16</SUP> Worten organisiert,
die mit Adressen von 0,1,2,...65535 adressiert werden!
<P>
Die Startadresse ist 32-bittig, unabh&auml;ngig von der
Adre&szlig;breite der jeweiligen Prozessorfamilie. Im Gegensatz dazu
ist die L&auml;ngenangabe nur 16 Bit lang, ein Record kann also
maximal (4+4+2+(64K-1)) = 65545 Byte lang werden.
<P>
Daten-Records mit den Header-Bytes $01..$7f stellen eine
Kurzschreibweise dar und stellen die Abw&auml;rtskompatibilit&auml;t
mit fr&uuml;heren Definitionen des Dateiformats her: Das Header-Byte
gibt direkt den Prozessortyp gem&auml;&szlig; der ersten Tabelle an,
das Zielsegment ist auf<TT> CODE</TT> festgelegt und die
Granularit&auml;t ergibt sich aus dem Prozessortyp, aufgerundet auf
eine Zweierpotenz von Bytes. AS bevorzugt diese Records, wenn Daten
bzw. Code f&uuml;r das<TT> CODE</TT>-Segment anstehen.
<P>
Der Record mit dem Typ-Byte $80 legt den Einsprungpunkt fest, d.h.
die Adresse, an der mit der Ausf&uuml;hrung des Programms begonnen
werden soll. Ein solcher Record ist das Ergebnis einer<TT>
END</TT>-Anweisung mit einer entsprechenden Adresse als Argument.
<P>
Der letzte Record in der Datei tr&auml;gt das Header-Byte $00 und
besitzt als einziges Datenfeld einen String, dessen Ende durch das
Dateiende definiert ist. Dieser String spezifiziert, von welchem
Programm diese Datei erzeugt wurde und hat keine weitere Bedeutung.
<P>

<H2><A NAME="sect_5_2_">5.2. Debug-Dateien</A></H2>
<A NAME="ref_SectDebugFormat"></A>
<P>
Debug-Dateien k&ouml;nnen optional von AS erzeugt werden und liefern
nachgeschalteten Werkzeugen wie Disassemblern oder Debuggern f&uuml;r
diese wichtige Informationen. AS kann Debug-Informationen in drei
Formaten ausgeben: Zum einen im Objekt-Format der AVR-Tools von Atmel
sowie eine zu NoICE kompatible Kommandodatei und zum anderen in einem
eigenen Format. Die ersten beiden werden in <A
HREF="#cite_AVRObj">[5]</A> bzw. der Dokumentation zu NoICE
ausf&uuml;hrlich beschrieben, deshalb beschr&auml;nkt sich die
folgende Beschreibung auf das AS-eigene MAP-Format:
<P>
Diese Informationen in einer MAP-Datei teilen sich in drei Gruppen:
<UL>
<LI> Symboltabelle</LI>
<LI> Speicherberlegung, auf Sektionen verteilt</LI>
<LI> Maschinenadressen von Quellzeilen</LI>
</UL>
Letzterer Teil findet sich zuerst in der Datei. Ein einzelner Eintrag
in dieser Liste besteht aus zwei, von einem Doppelpunkt getrennten
Zahlen:
<PRE>

 &lt;Zeilennummer&gt;:&lt;Adresse&gt;

</PRE>
Ein solcher Eintrag besagt, da&szlig; der aus einer bestimmten
Quellcodezeile erzeugte Maschinencode auf der angegebenen Adresse
(hexadezimal) zu liegen kam. Mit einer solchen Information kann ein
Debugger beim Durchsteppen des Programms die entsprechenden
Quellcodezeilen anzeigen. Da ein Programm aber auch aus mehreren
Include-Dateien bestehen kann, und viele Prozessoren mehr als nur
einen Adre&szlig;raum besitzen (von dem zugegebenerma&szlig;en nur in
einem Code liegt), m&uuml;ssen die oben beschriebenen Eintr&auml;ge
sortiert werden. AS tut dies in zwei Stufen: Das prim&auml;re
Sortierkriterium ist das Zielsegment, innerhalb dieser Segmente wird
noch einmal nach Dateien sortiert. Einzelne Abschnitte werden dabei
durch durch spezielle Zeilen der Form
<PRE>

Segment &lt;Segmentname&gt;

</PRE>
bzw.
<PRE>

File &lt;Dateiname&gt;

</PRE>
getrennt.
<P>
Die Symboltabelle folgt der Quellzeileninformation und ist wieder
prim&auml;r nach den Segmenten geordnet, aus denen die Symbole
stammen. Im Gegensatz zur Zeileninformation kommt hier allerdings
auch der Abschnitt<TT> NOTHING</TT> hinzu, der die Symbole
beinhaltet, die keinem speziellen Adre&szlig;raum zugeordnet sind
(z.B. Symbole, die einfach mit<TT> EQU</TT> definiert wurden). Die
Einleitung eines Abschnittes in der Symboltabelle erfolgt mit einer
Zeile der Form
<PRE>

Symbols in Segment &lt;Segmentname&gt;   .

</PRE>
Innerhalb eines Abschnittes sind die Symbole nach Namen sortiert, und
ein Symboleintrag belegt genau eine Zeile. Eine solche Zeile besteht
wiederum aus sechs Feldern, die durch jeweils mindestens ein
Leerzeichen getrennt sind:
<P>
Das erste Feld ist der Name des Symbols selber, eventuell erweitert
um eine in eckigen Klammern eingeschlossene Sektionsnummer, die den
G&uuml;ltigkeitsbereich des Symbols einschr&auml;nkt. Die zweite
Spalte bezeichnet den Typ des Symbols:<TT> Int</TT> f&uuml;r
Integerzahlen,<TT> Float</TT> f&uuml;r Gleitkommazahlen und<TT>
String</TT> f&uuml;r Zeichenketten. Die dritte Zeile
schlie&szlig;lich beinhaltet den eigentliche Wert des Symbols. Falls
das Symbol eine Zeichenkette beinhaltet, ist es notwendig, Steuer-
und Leerzeichen mit einer gesonderten Notation zu kennzeichnen, damit
ein im String enthaltenes Leerzeichen nicht eventuell als
Trennzeichen zur n&auml;chsten Spalte interpretiert werden kann. AS
bedient sich dazu der bereits der in Assemblerquellen &uuml;blichen
Schreibweise, den ASCII-Zahlenwert mit einem f&uuml;hrenden Backslash
(\) einzusetzen. Aus dem String
<PRE>

 Dies ist ein Test

</PRE>
wird also z.B.
<PRE>

 Dies\032ist\032ein\032Test

</PRE>
Die Zahlenangabe ist immer dezimal und dreistellig, und der Backslash
selber wird ebenfalls in dieser Schreibweise kodiert.
<P>
Das vierte Feld gibt - falls vorhanden - die Gr&ouml;&szlig;e der
Datenstruktur an, die an der durch das Symbol gekennzeichneten
Adresse abgelegt ist. Ein Debugger kann eine solche Information z.B.
nutzen, um symbolisch angesprochene Variablen direkt in der korrekten
L&auml;nge aufzulisten. Hat AS keine Informationen &uuml;ber die
Symbolgr&ouml;&szlig;e, so steht in diesem Feld eine schlichte -1.
<P>
Das f&uuml;nfte und letzte Feld gibt an, ob das Symbol w&auml;hrend
der Assemblierung jemals referenziert wurde. Ein Programm, da&szlig;
die Symboltabelle liest, kann auf diese Weise z.B. nicht benutzte
Symbole automatisch verwerfen, da sie beim folgenden Debugging oder
der Disassemblierung mit hoher Wahrscheinlichkeit auch nicht
ben&ouml;tigt werden.
<P>
das sechste und letzte Feld gibt schlu&szlig;endlich durch eine 0
oder 1 an, ob es sich bei dem Symbol um eine Konstante (0) oder
Variable (1) handelt. Konstanten bekommen einmalig einen Wert
zugewiesen (z.B. &uuml;ber die<TT> EQU</TT>-Anweisung oder ein
Label), Variablen k&ouml;nnen ihren Wert beliebig oft &auml;ndern. In
der MAP-Datei wird der letztg&uuml;ltige Wert aufgef&uuml;hrt.
<P>
Der dritte Abschnitt in einer Debug-Datei beschreibt die im Programm
benutzten Sektionen n&auml;her. Eine solche Beschreibung ist
erforderlich, da Sektionen den G&uuml;ltigkeitsbereich von Symbolen
einschr&auml;nken k&ouml;nnen. Je nach momentanem Stand des
Programmz&auml;hlers kann z.B. ein symbolischer Debugger einzelne
Symboldefinitionen f&uuml;r eine R&uuml;ck&uuml;bersetzung nicht
nutzen oder mu&szlig; Priorit&auml;ten bei der Symbolnutzung
beachten. Die Definition einer Sektion beginnt mit einer Zeile der
Form
<PRE>

Info for Section nn ssss pp     ,

</PRE>
wobei<TT> nn</TT> die Nummer der Sektion angibt (die Nummer, die als
Postfix f&uuml;r Symbolnamen in der Symboltabelle genutzt wird),<TT>
ssss</TT> der Name der Sektion ist und<TT> pp</TT> die Nummer der
Vatersektion darstellt. Letztere Information ben&ouml;tigt ein
R&uuml;ck&uuml;bersetzer, um sich bei der Auffindung eines Symbols
f&uuml;r einen Zahlenwert ausgehend von der aktuellen Sektion im Baum
bis zur Wurzel ,,durchhangeln'' kann, bis ein passendes Symbol
gefunden wird. Auf diese Zeile folgt eine Reihe weiterer Zeilen, die
den von dieser Sektion belegten Code-Bereich beschreiben. Jeder
einzelne Eintrag (genau einer pro Zeile) beschreibt entweder eine
einzelne Adresse oder einen durch zwei Grenzwerte beschriebenen
Bereich (Trennung von Anfangs-und Endwert durch ein Minuszeichen).
Die Grenzen sind dabei ,,inklusive'', d.h. die Grenzen geh&ouml;ren
auch zu dem Bereich. Wichtig ist, da&szlig; ein einer Sektion
zugeh&ouml;riger Bereich nicht nochmals f&uuml;r ihre Vatersektionen
aufgef&uuml;hrt wird (eine Ausnahme ist nat&uuml;rlich, wenn Bereiche
absichtlich mehrfach belegt werden, aber so etwas macht man ja auch
nicht, gelle?). Dies dient einer Optimierung der Bereichsspeicherung
w&auml;hrend der Assemblierung und sollte auch f&uuml;r eine
Symbolr&uuml;ck&uuml;bersetzung keine Probleme darstellen, da durch
die einfache Kennzeichnung bereits der Einstiegspunkt und damit der
Suchpfad im Sektionsbaum gegeben ist. Die Beschreibung einer Sektion
wird durch eine Leerzeile oder das Dateiende gekennzeichnet.
<P>
Programmteile, die au&szlig;erhalb aller Sektionen liegen, werden
nicht gesondert ausgewiesen. Diese ,,implizite Wurzelsektion''
tr&auml;gt die Nummer -1 und wird auch als Vatersektion f&uuml;r
Sektionen benutzt, die keine eigentliche Vatersektion besitzen.
<P>
Es ist m&ouml;glich, da&szlig; die Datei Leerzeilen oder
Kommentarzeilen (Semikolon am Zeilenanfang) beinhaltet. Diese sind
von einem Leseprogramm zu ignorieren.
<P>

<H1><A NAME="sect_6_">6. Hilfsprogramme</A></H1>
<A NAME="ref_ChapTools"></A>
<P>
Um die Arbeit mit dem Codeformat des Assemblers etwas zu erleichtern,
lege ich einige Progamme zu deren Bearbeitung bei. F&uuml;r diese
Programme gilt sinngem&auml;&szlig; das gleiche wie in <A
HREF="#ref_SectLicense">1.1</A>!
<P>
Allen Programmen gemeinsam sind die Returncodes, die sie liefern
(Tabelle <A HREF="#ref_TabToolReturns">6.1</A>).
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Returncode</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>tritt auf bei...</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>0<BR>
1<BR>
2<BR>
3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>kein Fehler<BR>
Kommandozeilenparameterfehler<BR>
I/O-Fehler<BR>
Dateiformatfehler</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 6.1: Returncodes der Dienstprogramme<A
             NAME="ref_TabToolReturns"></A>
</CENTER><P>

Ebenso eintr&auml;chtig wie AS lesen sie ihre Eingaben von STDIN und
schreiben Meldungen auf STDOUT (bzw. Fehlermeldungen auf STDERR).
Ein-und Ausgaben sollten sich daher problemlos umleiten lassen.
<P>
Sofern Programme im folgenden Zahlen-oder Adre&szlig;angaben von der
Kommandozeile lesen, d&uuml;rfen diese auch hexadezimal geschrieben
werden, indem man sie mit einem hintangestellten<TT> h</TT>, einem
voranstehenden Dollarzeichen oder<TT> 0x</TT> wie in C versieht (z.B.
$10, 10h oder 0x10 anstelle von 16).
<P>
Unix-Shells ordnen dem Dollarzeichen allerdings eine spezielle           
Bedeutung zu (Parameterexpansion), weshalb es n&ouml;tig ist, einem
Dollarzeichen direkt einen Backslash voranzustellen. Die<TT>
0x</TT>-Variante ist hier sicherlich angenehmer.
<P>
Ansonsten folgen die Aufrufkonventionen und -variationen (bis auf
PLIST und AS2MSG) denen von AS, d.h. man kann dauernd gebrauchte
Schalter in einer Environmentvariablen ablegen (deren Name sich aus
dem Anh&auml;ngen von CMD an den Programmnamen ergibt, z.B. BINDCMD
f&uuml;r BIND), Optionen negieren und Gro&szlig;-bzw. Kleinschreibung
erzwingen (n&auml;heres zu dem Wie in Abschnitt <A
HREF="#ref_SectCallConvention">2.4</A>).
<P>
Sofern Adre&szlig;angaben benutzt werden, beziehen sie sich immer auf
die Granularit&auml;t des Adre&szlig;raumes des jeweiligen
Prozessors; beim PIC bedeutet z.B. eine Adre&szlig;differenz von 1
nicht ein Byte, sondern ein Wort.
<P>

<H2><A NAME="sect_6_1_">6.1. PLIST</A></H2>
<P>
PLIST ist das einfachste Programm der vier mitgelieferten; es dient
einfach nur dazu, die in einer Codedatei gespeicherten Records
aufzulisten. Da das Programm nicht allzuviel bewirkt, ist der Aufruf
ziemlich simpel:
<PRE>

    PLIST $&lt;$Dateiname$&gt;$

</PRE>
Der Dateiname wird automatisch um die Endung P erweitert, falls keine
Endung vorhanden ist.
<P>
<B> ACHTUNG!</B> An dieser Stelle sind keine Jokerzeichen erlaubt!
Falls mit einem Befehl trotzdem mehrere Programmdateien gelistet
werden sollen, kann man sich mit folgendem ''Minibatch'' behelfen:
<PRE>

    for %n in (*.p) do plist %n

</PRE>
PLIST gibt den Inhalt der Codedatei in Tabellenform aus, wobei
f&uuml;r jeden Record genau eine Zeile ausgegeben wird. Die Spalten
haben dabei folgende Bedeutung:
<UL>
<LI> Codetyp: die Prozessorfamilie, f&uuml;r die der Code erzeugt
    wurde.</LI>
<LI> Startadresse: absolute Speicheradresse, an die der Code zu laden
    ist.</LI>
<LI> L&auml;nge: L&auml;nge des Codest&uuml;cks in Byte.</LI>
<LI> Endadresse: letzte absolute Adresse des Codest&uuml;cks. Diese
    berechnet sich als Startadresse+L&auml;nge-1.</LI>
</UL>
Alle Angaben sind als hexadezimal zu verstehen.
<P>
Zuletzt gibt PLIST noch einen Copyrightvermerk aus, sofern er einen
solchen in der Datei findet, und die Summe aller Codel&auml;ngen.
<P>
PLIST ist praktisch ein DIR f&uuml;r Codedateien. Man kann es
benutzen, um sich den Inhalt einer Datei auflisten zu lassen, bevor
man sie weiterbearbeitet.
<P>

<H2><A NAME="sect_6_2_">6.2. BIND</A></H2>
<P>
BIND ist ein Programm, mit dem man die Records mehrerer Codedateien
in eine Datei zusammenkopieren kann. Die dabei vorhandene
Filterfunktion erlaubt es aber auch, nur Records eines bestimmten
Typs zu &uuml;bernehmen. Auf diese Weise kann BIND auch dazu
verwendet werden, um eine Codedatei in mehrere aufzuspalten.
<P>
Die allgemeine Syntax von BIND lautet
<PRE>

   BIND &lt;Quelldatei(en)&gt; &lt;Zieldatei&gt; [Optionen]

</PRE>
Wie auch AS betrachtet BIND alle nicht mit einem +, - oder /
eingeleiteten Parameter als Dateiangaben, von denen die letzte die
Zieldatei angeben mu&szlig;. Alle anderen Dateiangaben bezeichnen
Quellen, diese Angaben d&uuml;rfen auch wieder Jokerzeichen
enthalten.
<P>
An Optionen definiert BIND momentan nur eine:
<UL>
<LI> <TT>f &lt;Header[,Header...]&gt;</TT>: gibt eine Liste von
    Header-IDs an, die kopiert werden sollen. Alle anderen Records
    werden nicht kopiert. Ohne diese Angabe werden alle Records
    kopiert. Die in der Liste angegebenen entsprechen dem Header-Feld
    in der Recordstruktur, wie es in Abschnitt <A
    HREF="#ref_SectCodeFormat">5.1</A> beschrieben wurden. Die
    einzelnen Header-Nummern in der Liste werden durch Kommas
    getrennt.</LI>
</UL>
Um z.B. alle MCS-51-Codeteile aus einer Programmdatei auszusieben,
benutzt man BIND folgenderma&szlig;en:
<PRE>

   BIND &lt;Quellname&gt; &lt;Zielname&gt; -f $31

</PRE>
Fehlt bei einer Dateiangabe eine Endung, so wird automatisch die
Endung P angef&uuml;gt.
<P>

<H2><A NAME="sect_6_3_">6.3. P2HEX</A></H2>
<P>
P2HEX ist eine Erweiterung von BIND. Es besitzt alle
Kommandozeilenoptionen von BIND und hat die gleichen Konventionen
bzgl. Dateinamen. Im Gegensatz zu BIND wird die Zieldatei aber als
Hexfile ausgegeben, d.h. als eine Folge von Zeilen, die den Code als
ASCII-Hexzahlen enthalten.
<P>
P2HEX kennt neun verschiedene Zielformate, die &uuml;ber den
Kommandozeilenparameter<B> F</B> ausgew&auml;hlt werden k&ouml;nnen:
<UL>
<LI> Motorola S-Record (<TT>-F Moto</TT>)</LI>
<LI> MOS Hex (<TT>-F MOS</TT>)</LI>
<LI> Intel-Hex (Intellec-8,<TT> -F Intel</TT>)</LI>
<LI> 16-Bit Intel-Hex (MCS-86,<TT> -F Intel16</TT>)</LI>
<LI> 32-Bit Intel-Hex (<TT>-F Intel32</TT>)</LI>
<LI> Tektronix Hex (<TT>-F Tek</TT>)</LI>
<LI> Texas Instruments DSK (<TT>-F DSK</TT>)</LI>
<LI> Atmel AVR Generic (<TT>-F Atmel</TT>, siehe <A
    HREF="#cite_AVRObj">[5]</A>)</LI>
<LI> Lattice Mico8 prom_init (<TT>-F Mico8</TT>)</LI>
<LI> C-Arrays, zum Inkludieren in C(++)-Quelldateien (<TT>-F C</TT>)</LI>
</UL>
Wird kein Zielformat explizit angegeben, so w&auml;hlt P2HEX anhand
des Prozessortyps automatisch eines aus, und zwar S-Records f&uuml;r
Motorola- Prozessoren, Hitachi und TLCS-900(0), MOS f&uuml;r
65xx/MELPS, DSK f&uuml;r die 16-Bit-Texas-Signalprozessoren, Atmel
Generic f&uuml;r die AVRs und Intel-Hex f&uuml;r den Rest. Je nach
Breite der Startadresse kommen bei S-Record Records der Typen 1,2
oder 3 zum Einsatz, jedoch nie in einer Gruppe gemischt. Diese
Automatik l&auml;&szlig;t sich mit der Kommandozeilenoption
<PRE>

  -M &lt;1|2|3&gt;

</PRE>
teilweise unterdr&uuml;cken: Ein Wert von 2 bzw. 3 sorgt daf&uuml;r,
da&szlig; S-Records mit einem Mindesttyp von 2 bzw. 3 benutzt werden,
w&auml;hrend ein Wert von 0 der vollen Automatik entspricht.
<P>
Normalerweise benutzt das AVR-Format immer eine Adre&szlig;l&auml;nge
von 3 Bytes. Manche Programme m&ouml;gen das leider nicht...deshalb
kann man mit dem Schalter
<PRE>

  -avrlen &lt;2|3&gt;

</PRE>
die L&auml;nge zur Not auf 2 Bytes reduzieren.
<P>
Das Mico8-Format unterscheidet sich insofern aus den anderen
Formaten, als da&szlig; es keine Adre&szlig;felder besitzt - es ist
eine schlichte Auflistung der Instruktionsw&ouml;rter im
Programmspeicher. Bei der Benutzung mu&szlig; darauf geachtet werden,
da&szlig; der belegte Adre&szlig;bereich (der sich z.B. mit PLIST
anzeigen l&auml;&szlig;t) bei Null beginnt und fortlaufend ist.
<P>
Die Intel-, Tektronix- und MOS-Formate sind auf 16 Bit-Adressen
beschr&auml;nkt, das 16-Bit Intel-Format reicht 4 Bit weiter.
L&auml;ngere Adressen werden von P2HEX mit einer Warnung gemeldet und
abgeschnitten(!). F&uuml;r die PICs k&ouml;nnen die drei von
Microchip spezifizierten Varianten des Intel-Hex-Formates erzeugt
werden, und zwar mit dem Schalter
<PRE>

  -m &lt;0..3&gt;

</PRE>
Das Format 0 ist INHX8M, in dem alle Bytes in Lo-Hi-Ordnung enthalten
sind. Die Adre&szlig;angaben verdoppeln sich, weil bei den PICs die
Adresse sich nur um 1 pro Wort erh&ouml;ht. Dieses Format ist
gleichzeitig die Vorgabe. Im Format 1 (INHX16M) werden alle Worte in
ihrer nat&uuml;rlichen Ordnung abgelegt. Dieses Format verwendet
Microchip f&uuml;r seine eigenen Programmierger&auml;te. Format 2
(INHX8L) und 3 (INHX8H) trennen die Worte in ihre oberen und unteren
Bytes auf. Um die komplette Information zu erhalten, mu&szlig; P2HEX
zweimal aufgerufen werden, z.B. so:
<PRE>

  p2hex test -m 2
  rename test.hex test.obl
  p2hex test -m 3
  rename test.hex test.obh

</PRE>
F&uuml;r das Motorola-Format verwendet P2HEX zus&auml;tzlich einen in
<A HREF="#cite_CPM68K">[12]</A> genannten Recordtyp mit der Nummer 5,
der die Zahl der folgenden Daten-Records (S1/S2/S3) bezeichnet. Da
dieser Typ vielleicht nicht jedem Programm bekannt ist, kann man ihn
mit der Option
<PRE>

 +5

</PRE>
unterdr&uuml;cken.
<P>
Das C-Format f&auml;llt insofern aus dem Rahmen, als da&szlig; es
immer explizit ausgew&auml;hlt werden mu&szlig;. Die Ausgabedatei
stellt im Prinzip ein vollst&auml;ndiges St&uuml;ck C- oder C++-Code
dar, das die Daten als eine Liste von C-Arrays enth&auml;lt. Neben
den eigentlichen Daten wird noch eine Liste von Deskriptoren
geschrieben, die Start, L&auml;nge und Ende der Datenbl&ouml;cke
beschreiben. Was diese Deskriptoren enthalten, kann mit der Option
<PRE>

 -cformat &lt;Format&gt;

</PRE>
bestimmt werden. Jeder Buchstabe in Format legt ein Element des
Deskriptors fest:
<UL>
<LI> Ein d oder D definiert einen Zeiger auf die Daten. &Uuml;ber den
    Gro&szlig;- oder Kleinbuchstaben wird festgelegt, ob die Hex-
    Konstanten Gro&szlig;- oder Kleinbuchstaben verwenden
    sollen.</LI>
<LI> Ein s oder S definiert die Startadresse der Daten, wahlweise vom
    Typ<EM> unsigned</EM> oder<EM> unsigned long</EM>.</LI>
<LI> Ein l oder L definiert die L&auml;nge der Daten, wahlweise vom
    Typ<EM> unsigned</EM> oder<EM> unsigned long</EM>.</LI>
<LI> Ein e oder E definiert die Endadresse der Daten, d.h. die letzte von
    den Daten benutzte Adresse, wahlweise vom Typ<EM> unsigned</EM>
    oder<EM> unsigned long</EM>.</LI>
</UL>
<P>
Finden sich Code-Records verschiedener Prozessoren in einer
Quelldatei, so erscheinen die verschiedenen Hexformate auch gemischt
in der Zieldatei --- es empfiehlt sich also dringend, von der
Filterfunktion Gebrauch zu machen, oder ein fixes Format &uuml;ber
die -F-Option festzulegen.
<P>
Neben dem Codetypenfilter kennt P2HEX noch ein Adre&szlig;filter, das
n&uuml;tzlich ist, falls der Code auf mehrere EPROMs verteilt werden
mu&szlig;:
<PRE>

  -r &lt;Startadresse&gt;-&lt;Endadresse&gt;

</PRE>
Die Startadresse ist dabei die erste Speicherzelle, die im Fenster
liegen soll, die Endadresse die der letzten Speicherzelle im
Fenster,<I> nicht</I> die der ersten au&szlig;erhalb. Um z.B. ein
8051-Programm in 4 2764-EPROMs aufzuteilen, geht man
folgenderma&szlig;en vor:
<PRE>

p2hex &lt;Quelldatei&gt; eprom1 -f $31 -r $0000-$1fff
p2hex &lt;Quelldatei&gt; eprom2 -f $31 -r $2000-$3fff
p2hex &lt;Quelldatei&gt; eprom3 -f $31 -r $4000-$5fff
p2hex &lt;Quelldatei&gt; eprom4 -f $31 -r $6000-$7fff

</PRE>
Anstelle einer festen Adresse kann man als Anfang bzw. Ende auch ein
einfaches Dollarzeichen oder ein '0x' angeben. Dies bedeutet,
da&szlig; die niedrigste bzw. h&ouml;chste in der Quelldatei
gefundene Adresse als Anfang bzw. Ende genommen wird. Der Default
f&uuml;r den Bereich ist '0x-0x', d.h. es werden alle Daten aus der
Quelldatei &uuml;bernommen.
<P>
<B> ACHTUNG!</B> Die Splittung &auml;ndert nichts an den absoluten
Adressen, die in den Hexfiles stehen! Sollen die Adressen im Hexfile
bei 0 beginnen, so kann man dies durch den zus&auml;tzlichen Schalter
<PRE>

 -a

</PRE>
erreichen. Um im Gegenteil die Adre&szlig;lage auf einen bestimmten
Wert zu verschieben, kann man den Schalter
<PRE>

 -R &lt;Wert&gt;

</PRE>
verwenden. Der dabei angegebene Wert ist ein<EM> Offset</EM>, d.h. er
wird auf die in der Code-Datei angegebenen Adressen aufaddiert.
<P>
Den Inhalt einer Datei kann man mit einem Offset auf eine beliebige
Position verschieben; diesen Offset h&auml;ngt man einfach in
Klammern an den Dateinamen an. Ist der Code in einer Datei z.B. auf
Adresse 0 in der P-Datei abgelegt, man m&ouml;chte ihn jedoch auf
Adresse 1000h verschieben, so h&auml;ngt man an<TT> ($1000)</TT> an
den Dateinamen (ohne Leerzeichen!) an.
<P>
Sofern die P-Datei nicht nur Daten aus dem Code-Segment enth&auml;lt,
kann man mit dem Schalter
<PRE>

 -segment &lt;name&gt;

</PRE>
ausw&auml;hlen, aus welchen Segment Daten extrahiert und ins
HEX-Format gewandelt werden sollen. Die als Argument anzugebenden
Segmentnamen sind die gleichen wie f&uuml;r den<TT>
SEGMENT</TT>-Befehl (<A HREF="#ref_SEGMENT">3.2.18</A>). Ein
Sonderfall ist das TI-DSK-Format, das als einziges Format vermerken
kann, ob Daten ins Code- oder Datensegment geh&ouml;ren. In diesem
Fall extrahiert P2HEX automatisch beide Segmente, solange kein
Segment explizit angegeben ist.
<P>
Analog zur -r Option kann man mit der Option
<PRE>

 -d &lt;Start&gt;-&lt;Ende&gt;

</PRE>
ein Filter f&uuml;r das Datensegment angeben.
<P>
F&uuml;r das DSK-, Intel- und Motorola-Format relevant ist die Option
<PRE>

 -e &lt;Adresse&gt; ,

</PRE>
mit der man die in die Hex-Datei einzutragende Startadresse festlegen
kann. Fehlt diese Angabe, so wird nach einen entsprechenden Eintrag
in der Code-Datei gesucht. Ist auch dort kein Hinweis auf einen
Einsprungpunkt zu finden, so wird kein Eintrag in die HEX-Datei
geschrieben (DSK/Intel) bzw. das entsprechende Feld wird auf 0
gesetzt (Motorola).
<P>
Leider ist sich die Literatur nicht ganz &uuml;ber die Endezeile
f&uuml;r Intel-Hexfiles einig. P2HEX kennt daher 3 Varianten,
einstellbar &uuml;ber den Parameter<B> i</B> mit einer nachfolgenden
Ziffer:
<DL COMPACT>
<DT>0<DD>:00000001FF</DD>
<DT>1<DD>:00000001</DD>
<DT>2<DD>:0000000000</DD>
</DL>
<P>
Defaultm&auml;&szlig;ig wird die Variante 0 benutzt, die die
gebr&auml;uchlichste zu sein scheint.
<P>
Fehlt der Zieldateiangabe eine Endung, so wird<TT> HEX</TT> als
Endung angenommen.
<P>
Defaultm&auml;&szlig;ig gibt P2HEX pro Zeile maximal 16 Datenbytes
aus, wie es auch die meisten anderen Tools tun, die Hex-Files
erzeugen. Wollen Sie dies &auml;ndern, so k&ouml;nnen Sie dies mit
dem Schalter
<PRE>

-l &lt;Anzahl&gt;

</PRE>
tun. Der erlaubte Wertebereich liegt dabei zwischen 2 und 254
Datenbytes; ungerade Werte werden implizit auf gerade Anzahlen
aufgerundet.
<P>
Meist werden die tempor&auml;ren, von AS erzeugten Code-Dateien nach
einer Umwandlung nicht mehr unbedingt gebraucht. Mit der
Kommandozeilen- option
<PRE>

-k

</PRE>
kann man P2HEX anweisen, diese automatisch nach der Konversion zu
l&ouml;schen.
<P>
Anders als BIND erzeugt P2HEX keine Leerdatei, wenn nur ein Dateiname
(=Zieldatei) angegeben wurde, sondern bearbeitet die
dazugeh&ouml;rige Codedatei. Es ist also ein Minimalaufruf &agrave;
la
<PRE>

 P2HEX &lt;Name&gt;

</PRE>
m&ouml;glich, um &lt;Name: &gt;.HEX aus &lt;Name: &gt;.P zu erzeugen.
<P>

<H2><A NAME="sect_6_4_">6.4. P2BIN</A></H2>
<P>
P2BIN funktioniert wie P2HEX und bietet die gleichen Optionen (bis
auf die a- und i- Optionen, die bei Bin&auml;rdateien keinen Sinn
ergeben), nur wird das Ergebnis nicht als Hexdatei, sondern als
einfache Bin&auml;rdatei abgelegt. Dies kann dann z.B. direkt in ein
EPROM gebrannt werden.
<P>
Zur Beeinflussung der Bin&auml;rdatei kennt P2BIN gegen&uuml;ber
P2HEX noch drei weitere Optionen:
<UL>
<LI> <TT>l &lt;8-Bit-Zahl&gt;</TT>: gibt den Wert an, mit dem unbenutzte
    Speicherstellen in der Datei gef&uuml;llt werden sollen.
    Defaultm&auml;&szlig;ig ist der Wert $ff, so da&szlig; ein
    halbwegs intelligenter EPROM-Brenner sie &uuml;berspringt. Man
    kann aber hiermit auch andere Werte einstellen, z.B. enthalten
    die gel&ouml;schten Speicherzellen der MCS-48-EPROM-Versionen
    Nullen. In einem solchen Falle w&auml;re 0 der richtige
    Wert.</LI>
<LI> <TT>s</TT>: weist das Programm an, eine Pr&uuml;fsumme &uuml;ber die
    Bin&auml;rdatei zu berechnen. Die Pr&uuml;fsumme wird einmal als
    32-Bit-Wert ausgegeben, zum anderen wird das Zweierkomplement der
    Bits 0..7 in der letzten Speicherstelle abgelegt, so da&szlig;
    die Modulo-256-Summe zu 0 wird.</LI>
<LI> <TT>m</TT>: f&uuml;r den Fall, da&szlig; ein Prozessor mit 16- oder
    32-Bit-Datenbus eingesetzt wird und die Bin&auml;rdatei f&uuml;r
    mehrere EPROMs aufgesplittet werden mu&szlig;. Das Argument kann
    folgende Werte annehmen:
<UL>
<LI>     <TT>ALL</TT>: alles kopieren</LI>
<LI>     <TT>ODD</TT>: alle Bytes mit ungerader Adresse kopieren</LI>
<LI>     <TT>EVEN</TT>: alle Bytes mit gerader Adresse kopieren</LI>
<LI>     <TT>BYTE0</TT>..<TT>BYTE3</TT>: nur alle Bytes kopieren, deren
        Adresse die Form 4n+0...4n+3 hat.</LI>
<LI>     <TT>WORD0</TT>,<TT>WORD1</TT>: nur das untere bzw. obere
        16-Bit-Wort der 32-Bit-Worte kopieren.</LI>
</UL>
    </LI>
</UL>
<P>
Nicht wundern: Bei letzteren Optionen ist die Bin&auml;rdatei um den
Faktor 2 oder 4 kleiner als bei<TT> ALL</TT>. Dies ist bei konstantem
Adre&szlig;fenster logisch!
<P>
Falls die Code-Datei keine Startadresse enth&auml;lt, kann man diese
analog zu P2HEX &uuml;ber die<TT> -e</TT>-Kommandozeilenoption
vorgeben. Auf Anforderung teilt P2BIN ihren Wert der Ergebnisdatei
voran. Mit der Kommandozeilenoption
<PRE>

-S

</PRE>
wird diese Funktion aktiviert. Sie erwartet als Argument eine
Zahlenangabe zwischen 1 und 4, die die L&auml;nge des Adressfeldes in
Bytes bestimmt. Optional kann dieser Angabe auch noch der Buchstabe L
oder B vorangestellt werden, um die Byte-Order dieser Adresse
festzulegen. So erzeugt z.B. die Angabe<TT> B4</TT> eine
4-Byte-Adresse in Big-Endian-Anordnung,<TT> L2</TT> oder nur '2' eine
2-Byte-Adresse in Little-Endian-Anordnung.
<P>

<H2><A NAME="sect_6_5_">6.5. AS2MSG</A></H2>
<P>
Bei AS2MSG handelt es sich eigentlich um kein Hilfsprogramm, sondern
um ein Filter, das (gl&uuml;cklichen) Besitzern von Borland-Pascal
7.0 das Arbeiten mit dem Assembler erleichtern soll. In den
DOS-Arbeitsumgebungen existiert ein ,,Tools''-Men&uuml;, das man um
eigene Programme, z.B. AS erweitern kann. Das Filter erlaubt, die von
AS gelieferten Fehlermeldungen mit Zeilenangabe direkt im
Editorfenster anzuzeigen. Dazu mu&szlig; im Tools-Men&uuml; ein neuer
Eintrag angelegt werden (<TT>Options/Tools/New</TT>). Tragen Sie in
die einzelnen Felder folgende Werte ein :
<UL>
<LI> Title:<TT> ~M~akroassembler</TT></LI>
<LI> Program path:<TT> AS</TT></LI>
<LI> Command line:<TT> -E !1 $EDNAME $CAP MSG(AS2MSG) $NOSWAP $SAVE
    ALL</TT></LI>
<LI> bei Bedarf einen Hotkey zuordnen (z.B. Shift-F7)</LI>
</UL>
Die Option<TT> -E</TT> sorgt daf&uuml;r, da&szlig; Turbo-Pascal nicht
mit STDOUT und STDERR durcheinander kommt.
<P>
Ich setze dabei voraus, da&szlig; sowohl AS als auch AS2MSG sich in
einem Verzeichnis befinden, welches in der Pfadliste aufgef&uuml;hrt
ist. Nach einem Druck auf dem passenden Hotkey (oder Auswahl aus dem
Tools-Men&uuml;) wird AS mit dem Namen der Textdatei im aktiven
Editorfenster aufgerufen. Die dabei aufgetretenen Fehler werden in
ein separates Fenster geleitet, durch das man nun ,,browsen'' kann.
Mit<B> Ctrl-Enter</B> springt man eine fehlerhafte Zeile an.
Zus&auml;tzlich enth&auml;lt das Fenster die Statistik, die AS am
Ende der Assemblierung ausgibt. Diese erhalten als Dummy-Zeilennummer
1.
<P>
F&uuml;r diese Arbeitsweise sind sowohl TURBO.EXE (Real Mode) als
auch BP.EXE (Protected Mode) geeignet. Ich empfehle BP, da in dieser
Variante beim Aufruf nicht erst der halbe DOS-Speicher
,,freigeswappt'' werden mu&szlig;.
<P>
<P>
<P>

<H1><A NAME="sect_A_">A. Fehlermeldungen von AS</A></H1>
<A NAME="ref_ChapErrMess"></A>
<P>
Im folgenden findet sich eine halb-tabellarische Auflistung der in AS
definierten Fehlermeldungen. Zu jeder Fehlermeldung finden sich
folgende Angaben:
<UL>
<LI> interne Fehlernummer (f&uuml;r den Anwender nur mit der<TT>
    n</TT>-Option sichtbar);</LI>
<LI> Fehlermeldung im Klartext;</LI>
<LI> Typ:
<UL>
<LI>     Warnung: zeigt m&ouml;gliche Fehler oder ineffizienten Code an.
        Assemblierung geht weiter.</LI>
<LI>     Fehler: echte Fehler. Assemblierung geht weiter, aber keine
        Code-Datei wird geschrieben.</LI>
<LI>     Fatal: schwerwiegende Fehler. Assemblierung wird
        abgebrochen.</LI>
</UL>
 </LI>
<LI> Ursache: die Situation(en), in denen der Fehler ausgegeben
    wird;</LI>
<LI> Argument: Die Ausgabe, die auf Wunsch als erweiterte Fehlermeldung
    erfolgt.</LI>
</UL>
<P>
<P>
<P>
<P>
<DL COMPACT>
<DT>5<DD>Displacement=0, &uuml;berfl&uuml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        bei 680x0-,6809- und COP8-Prozessoren: Das Displacement in
        einem Adre&szlig;ausdruck hat den Wert 0 ergeben. Es wird ein
        Adre&szlig;ausdruck ohne Displacement erzeugt. Um keine
        Phasenfehler zu erzeugen, werden NOP-Befehle
        eingef&uuml;gt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>10<DD>Kurzadressierung m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        bei 680x0-, 6502- und 68xx-Prozessoren k&ouml;nnen bestimmte
        Speicherbereiche mit kurzen Adressen erreicht werden. Um
        keine Phasenfehler zu erzeugen, wird zwar der k&uuml;rzere
        Ausdruck erzeugt, der freie Platz wird aber mit NOPs
        aufgef&uuml;llt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>20<DD>kurzer Sprung m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Bei 680x0 und 8086-Prozessoren kann der Sprung sowohl mit
        langem als auch kurzem Displacement ausgef&uuml;hrt werden.
        Da kein kurzer Sprung angefordert wurde, wurde im ersten Pass
        Platz f&uuml;r den langen Sprung freigehalten. Es wird ein
        kurzer Sprung erzeugt, der freie Platz wird</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>25<DD>relativer Sprung m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Spr&uuml;nge k&ouml;nnen beim Z80 sowohl absolut als auch
        relativ ausgef&uuml;hrt werden. In diesem Fall wurde ein
        absoluter Sprung angefordert, ein(k&uuml;rzerer) relativer
        w&auml;re aber m&ouml;glich.</DD>
<DT>Argument:<DD>     <BR>
        das Sprungargument</DD>
</DL>
</DD>
<DT>30<DD>kein Sharefile angelegt, SHARED ignoriert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde eine<TT> SHARED</TT>-Anweisung gefunden, es wurde
        aber keine Kommandozeilenoption angegeben, um eine
        Shared-Datei zu erzeugen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>40<DD>FPU liest Wert evtl. nicht korrekt ein (&gt;=1E1000)
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das BCD-Gleitkommaformat der 680x0-Koprozessoren erlaubt zwar
        vierstellige Exponenten, lt. Datenbuch k&ouml;nnen solche
        Werte aber nicht korrekt eingelesen werden. Der vierstellige
        Wert wird zwar erzeugt, eine Funktion ist aber nicht
        gew&auml;hleistet.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>50<DD>Privilegierte Anweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde eine Anweisung benutzt, die nur im Supervisor-Mode
        zul&auml;ssig ist, obwohl dieser nicht mittels<TT> SUPMODE
        ON</TT> vorher explizit angezeigt wurde.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>60<DD>Distanz 0 nicht bei Kurzsprung erlaubt (NOP erzeugt)
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein kurzer Sprung mit der Distanz 0 ist bei 680x0- bzw.
        COP8-Prozessoren nicht erlaubt, da dieser Sonderwert f&uuml;r
        lange Spr&uuml;nge ben&ouml;tigt wird. Stattdessen wurde ein
        NOP-Befehl eingef&uuml;gt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>70<DD>Symbol aus falschem Segment
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das in dem Operanden benutzte Symbol ist aus einem
        Adre&szlig;raum, der nicht mit dem benutzten Befehl
        bearbeitet werden kann.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>75<DD>Segment nicht adressierbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das in dem Operanden benutzte Symbol ist aus einem
        Adre&szlig;raum, der mit keinem der Segmentregister des 8086
        adressiert werden kann.</DD>
<DT>Argument:<DD>     <BR>
        Name des nicht adressierbaren Segments</DD>
</DL>
</DD>
<DT>80<DD>&Auml;nderung des Symbolwertes erzwingt zus&auml;tzlichen Pass
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Symbol hat einen anderen Wert zugewiesen bekommen als im
        vorhergehenden Pass. Diese Warnung wird nur ausgegeben, falls
        die<TT> r</TT>-Option angegeben wurde.</DD>
<DT>Argument:<DD>     <BR>
        Der Name des fraglichen Symbols</DD>
</DL>
</DD>
<DT>90<DD>&Uuml;berlappende Speicherbelegung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Bei der Bildung der Belegungsliste wurde festgestellt,
        da&szlig; ein Speicherbereich im Codesegment mehrfach benutzt
        wurde. Ursache k&ouml;nnen un&uuml;berlegte<TT>
        ORG</TT>-Anweisungen sein.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>95<DD>&Uuml;berlappende Registernutzung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        In der Anweisung wurden Register ganz oder teilweise mehrfach
        in nicht zul&auml;ssiger Weise verwendet.</DD>
<DT>Argument:<DD>     <BR>
        Das den Konflikt ausl&ouml;sende Argument</DD>
</DL>
</DD>
<DT>100<DD>keine CASE-Bedingung zugetroffen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        bei einem<TT> SWITCH</TT>..<TT>CASE</TT>-Konstrukt ohne<TT>
        ELSECASE</TT>-Zweig traf keiner der<TT> CASE</TT>-Zweige
        zu.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>110<DD>Seite m&ouml;glicherweise nicht adressierbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das in dem Operanden benutzte Symbol liegt nicht in der
        momentan mit<TT> ASSUME</TT> eingestellten Fenster
        (ST6,78(C)10).</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>120<DD>Registernummer mu&szlig; gerade sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die Hardware erlaubt nur ein Registerpaar zu verketten,
        dessen Startadresse gerade ist (RR0, RR2..., nur Z8).</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>130<DD>veralteter Befehl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Der verwendete Befehl ist zwar noch definiert, ist in seiner
        Funktion aber durch andere, neue Befehle ersetzbar und daher
        in zuk&uuml;nftigen Prozessorversionen eventuell nicht mehr
        vorhanden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>140<DD>Nicht vorhersagbare Ausf&uuml;hrung dieser Anweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die verwendete Adressierungsart ist bei diesem Befehl zwar
        prinzipiell erlaubt, ein Register wird jedoch in einer Weise
        doppelt verwendet, da&szlig; je nach
        Aus&uuml;hrungsreihenfolge sich unterschiedliche Ergebnisse
        einstellen k&ouml;nnen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>150<DD>Lokaloperator au&szlig;erhalb einer Sektion &uuml;berfl&uuml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein vorangestellter Klammeraffe dient dazu, sich explizit auf
        zu der Sektion lokale Symbole zu beziehen. Wenn man sich
        au&szlig;erhalb einer Sektion befindet, gibt es keine lokalen
        Symbole, weshalb dieser Operator &uuml;berfl&uuml;ssig
        ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>160<DD>sinnlose Operation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die Anweisung ergibt entweder &uuml;berhaupt keinen Sinn oder
        kann auf andere Weise schneller und k&uuml;rzer
        ausgef&uuml;hrt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>170<DD>unbekannter Symbolwert erzwingt zus&auml;tzlichen Pass
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        AS vermutet eine Vorw&auml;rtsreferenz eines Symbols, d.h.
        das Symbol wird benutzt, bevor es definiert wurde, und
        h&auml;lt einen weiteren Pass f&uuml;r unumg&auml;nglich.
        Diese Warnung wird nur ausgegeben, falls die<TT>
        r</TT>-Option angegeben wurde.</DD>
<DT>Argument:<DD>     <BR>
        Der Name des fraglichen Symbols</DD>
</DL>
</DD>
<DT>180<DD>Adresse nicht ausgerichtet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Eine Adresse ist nicht ein mehrfaches der
        Operandengr&ouml;&szlig;e. Das Datenbuch verbietet zwar
        solche Zugriffe, im Instruktionswort ist aber Platz f&uuml;r
        diese Adresse, so da&szlig; AS es bei einer Warnung belassen
        hat.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>190<DD>I/O-Adresse darf nicht verwendet werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Der verwendete Adressierungsmodus oder die angesprochene
        Adresse sind zwar prinzipiell erlaubt, die Adresse liegt aber
        im Bereich der Peripherieregister, die in diesem Zusammenhang
        nicht verwendet werden d&uuml;rfen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>200<DD>m&ouml;gliche Pipeline-Effekte
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Register wird in einer Befehlsfolge so verwendet,
        da&szlig; die Befehlsausf&uuml;hrung m&ouml;glicherweise
        nicht in der hingeschriebenen Form ablaufen wird.
        &Uuml;blicherweise wird ein Register benutzt, bevor der neue
        Wert zur Verf&uuml;gung steht.</DD>
<DT>Argument:<DD>     <BR>
        das die Verklemmung verursachende Register</DD>
</DL>
</DD>
<DT>210<DD>mehrfache Adre&szlig;registerbenutzung in einer Anweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Adre&szlig;register wird in mehreren
        Adre&szlig;ausdr&uuml;cken eines Befehls benutzt. Sofern
        einer der beiden Ausdr&uuml;cke das Register modifiziert,
        sind die Ergebnisadressen nicht eindeutig festgelegt.</DD>
<DT>Argument:<DD>     <BR>
        das mehrfach verwendete Register</DD>
</DL>
</DD>
<DT>220<DD>Speicherstelle ist nicht bitadressierbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Mit einer<TT> SFRB</TT>-Anweisung wurde versucht, eine
        Speicherstelle als bitadressierbar zu deklarieren, die
        aufgrund der Architektur des 8051 nicht bitadressierbar
        ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>230<DD>Stack ist nicht leer
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Am Ende eines Durchlaufes ist ein vom Programm definierter
        Stack nicht leer.</DD>
<DT>Argument:<DD>     <BR>
        der Name des Stacks sowie seine Resttiefe</DD>
</DL>
</DD>
<DT>240<DD>NUL-Zeichen in Strings, Ergebnis undefiniert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Eine String-Konstante enth&auml;lt ein NUL-Zeichen. Dies
        funktioniert zwar mit der Pascal-Version, in Hinblick auf die
        C-Version von AS ist dies aber ein Problem, da C Strings mit
        einem NUL-Zeichen terminiert, d.h. der String w&auml;re
        f&uuml;r C an dieser Stelle zu Ende...</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>250<DD>Befehl &uuml;berschreitet Seitengrenze
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Befehl steht zu Teilen auf verschiedenen Seiten. Da der
        Programmz&auml;hler des Prozessors aber nicht &uuml;ber
        Seitengrenzen hinweg inkrementiert wird, w&uuml;rde zur
        Laufzeit anstelle des Instruktionsbytes von der Folgeseite
        wieder das erste Byte der alten Seite geholt; das</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>255<DD>Bereichsunterschreitung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Zahlenwert lag unterhalb des erlaubten Bereichs. AS hat
        den Wert durch ein Abschneiden der oberen Bitstellen in den
        erlaubten Bereich gebracht, es ist jedoch nicht garantiert,
        da&szlig; sich durch diese Operation sinnvoller und korrekter
        Code ergibt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>260<DD>Bereichs&uuml;berschreitung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Zahlenwert lag oberhalb des erlaubten Bereichs. AS hat
        den Wert durch ein Abschneiden der oberen Bitstellen in den
        erlaubten Bereich gebracht, es ist jedoch nicht garantiert,
        da&szlig; sich durch diese Operation sinnvoller und korrekter
        Code ergibt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>270<DD>negatives Argument f&uuml;r DUP
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das Wiederholungsargument einer<TT> DUP</TT>-Direktive war
        kleiner als 0. Es werden (analog zu einem Argument von genau
        0) keine Daten abgelegt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>280<DD>einzelner X-Operand wird als indizierte und nicht als implizite
    Adressierung interpretiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein einzelner X-Operand kann sowohl als Register X als auch
        X-indizierte Adressierung mit Null-Displacement interpretiert
        werden, da sich Motorola hier nicht festlegt. AS w&auml;hlt
        die letztere Variante, was m&ouml;glicherweise nicht das
        erwartete ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
    </DD>
<DT>300<DD>Bit-Nummer wird abgeschnitten werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die Instruktion arbeitet nur auf Byte- bzw.
        Langwort-Operanden, Bitnummern jenseits 7 bzw. 31 werden von
        der CPU modulo-8 bzw. modulo-32 behandelt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>310<DD>Ung&uuml;ltiger Wert f&uuml;r Registerzeiger
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        G&uuml;ltige bzw. sinnvolle Werte f&uuml;r den Registerzeiger
        sind nur Werte von 0x00...0x70 bzw. 0xf0, weil die anderen
        Registerbereiche unbelegt sind.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>320<DD>Makro-Argument umdefiniert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Einem Makroparameter wurden zwei oder mehr verschiedene Werte
        zugewiesen. Dies kann bei der Verwendung von
        Schl&uuml;sselwortparametern auftreten. Das zuletzt
        angegebene Argument wird benutzt.</DD>
<DT>Argument:<DD>     <BR>
        Name des Makroparameters</DD>
</DL>
</DD>
<DT>330<DD>veraltete Anweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Dies Anweisung ist veraltet und sollte nicht mehr in neuen
        Programmen verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        Die Anweisung, die stattdessen verwendet werden sollte.</DD>
</DL>
</DD>
<DT>340<DD>Quelloperand l&auml;nger oder gleich Zieloperand
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Der Quelloperand ist l&auml;nger oder gleich gro&szlig; wie
        der Zieloperand, gemessen in Bits. Eine Null- oder
        Vorzeichenerweiterung ergibt keinen Sinn mit diesen
        Argumenten. Schlagen Sie im Referenzhandbuch der CPU das
        Verhalten in diesem Fall nach.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>350<DD>TRAP-Nummer ist g&uuml;ltige Instruktion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein TRAP mit dieser Nummer benutzt den gleichen Maschinencode
        wie ein von der CPU unterst&uuml;tzter Maschinenbefehl.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>360<DD>Padding hinzugef&uuml;gt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die Menge abgelegter Bytes ist ungerade; eine H&auml;lfte des
        letzten 16-Bit-Wortes bleibt ungenutzt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>370<DD>Registernummer-Umlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die Startregisternummer plus die Anzahl der Register ergibt
        ein letztes Register jenseits des Endes der
        Registerbank.</DD>
<DT>Argument:<DD>     <BR>
        das Argument mit der Registeranzahl</DD>
</DL>
</DD>
<DT>380<DD>verwende indizierte anstelle indirekter Adressierung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Indirekte Adressierung ist an dieser Stelle nicht erlaubt. Es
        wird stattdessen indizierte Adressierung mit einem
        (Dummy-)Displacement von Null verwendet.</DD>
<DT>Argument:<DD>     <BR>
        das Argument mit dem Adressierungsausdruck</DD>
</DL>
</DD>
<DT>390<DD>nicht im Normal-Modus erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Dieser Maschinenbefehl ist nur im Panel-Modus und nicht im
        ,,Normalbetrieb'' erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Instruktion</DD>
</DL>
</DD>
<DT>400<DD>nicht im Panel-Modus erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Dieser Maschinenbefehl ist nur im ,,Nornalbetrieb'' und nicht
        im Panel-Modus erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Instruktion</DD>
</DL>
</DD>
<DT>410<DD>Argument ausserhalb erlauben Bereichs
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das Argument oder die Summe zweier Argumente liegt
        au&szlig;erhalb des f&uuml;r diesen Befehls erlaubten
        Bereichs, obwohl in der Instruktion prinzipiell Raum f&uuml;r
        gr&ouml;&szlig;ere Werte ist.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>420<DD>Versuch, eine Mehrwort-Instruktion zu &uuml;berspringen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die vorherige Anweisung war eine Skip-Anweisung, die nur ein
        Maschinenwort im Code &uuml;berspringen kann. Da die aktuelle
        Anweisung l&auml;nger als ein Maschinenwort ist, w&uuml;rde
        der Skip mitten in die Anweisung springen.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Anweisung</DD>
</DL>
</DD>
<DT>430<DD>implizite Vorzeichenerweiterung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Der Prozessor f&uuml;hrt bei diesem Befehl eine
        Vorzeichenerweiterung auf die volle Registerbreite aus. Das
        bedeutet, dass die oberen Bits f&uuml;r das gegebene Argument
        mit 1 und nicht mit 0 gef&uuml;llt werden. Je nach folgender
        Nutzung kann dies irrelevant sein, mu&szlig; aber nicht.</DD>
<DT>Argument:<DD>     <BR>
        der fragliche Wert</DD>
</DL>
</DD>
<DT>440<DD>numerischer Wert -128 bedeutet Nutzung des E-Registers (Literal 'E'
    verwenden, um diese Warnung zu vermeiden)
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Displacement von -128 bedeutet beim SC/MP in diesem Fall,
        dass das Displacement aus dem E-Register genommen wird. Der
        Assembler kann in diesem Fall nicht sicher entscheiden, ob
        das gewollt ist oder der Wert -128 sich unbeabsichtigt aus
        einer Berechnung ergeben hat. Verwenden Sie</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Displacement-Argument</DD>
</DL>
    </DD>
<DT>450<DD>I/O-Adresse mu&szlig; mit INS/OUTS angesprochen werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        I/O-Adressen im Bereich des Prozessormoduls (0..3)
        k&ouml;nnen nur &uuml;ber die Befehle<TT> INS</TT> und<TT>
        OUTS</TT> erreicht werden, nicht &uuml;ber<TT> IN</TT>
        und<TT> OUT</TT>.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Adress-Argument</DD>
</DL>
</DD>
<DT>460<DD>CASE-Limit passt nicht zur Anzahl der Sprungadressen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die CASE-Anweisung erwartet eine Sprungtabelle mit so vielen
        Eintr&auml;gen, wie das Limit-Argument plus eins angibt.
        Limit-Wert und Anzahl der Sprungadressen passen nicht
        zueinander.</DD>
<DT>Argument:<DD>     <BR>
        das Limit-Argument</DD>
</DL>
</DD>
<DT>470<DD>Befehl als NOP assembliert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Der dieser Anweisung eigentlich zugewiesene Opcode wird
        anderweitig verwendet. Da die Anweisung ohnehin nichts
        bewirkt, wird sie stattdessen als NOP assembliert.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>480<DD>Argument wird als Vektor behandelt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Anhand des Arguments kann nicht zweifelsfrei entschieden
        werden, ob es sich um eine Adresse oder einen Vektor handelt.
        Da das Argument eine reine Zahl und keinem Segment zugeordnet
        ist, wird es als Vektor behandelt.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>490<DD>Zu grosse Integer-Konstante wird als Gleitkomma interpretiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das Argument ist zwar eine syntaktisch korrekte
        Ganzzahl-Konstante, ihr Wert ist aber au&szlig;erhalb dessen,
        was intern als Ganzzahl dargestellt werden kann. Die Zahl
        wird deswegen als Gleitkomma-Zahl gespeichert.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>500<DD>Code-Erzeugung ausserhalb des CODE-Segments
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Maschinencode kann nur innerhalb des CODE-Segments erzeugt
        werden. Die anderen Adressr&auml;ume verf&uuml;gen nicht
        &uuml;ber die daf&uuml;r erforderliche Wortbreite.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1000<DD>Symbol doppelt definiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Einem Symbol wurde durch ein Label oder<TT> EQU</TT>,<TT>
        PORT</TT>,<TT> SFR</TT>,<TT> LABEL</TT>,<TT> SFRB</TT>
        oder<TT> BIT</TT> ein neuer Wert zugewiesen, dies ist aber
        nur bei<TT> SET/EVAL</TT> erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        Name des fraglichen Symbols, bei eingeschalteter
        Querverweisliste zus&auml;tzlich die Zeile der ersten
        Definition</DD>
</DL>
</DD>
<DT>1010<DD>Symbol nicht definiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein benutztes Symbol ist auch im 2.Pass noch nicht in der
        Symboltabelle enthalten.</DD>
<DT>Argument:<DD>     <BR>
        Name des nicht gefundenen Symbols</DD>
</DL>
</DD>
<DT>1020<DD>ung&uuml;ltiger Symbolname
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Symbolname entspricht nicht den Bedingungen f&uuml;r
        einen g&uuml;ltigen Symbolnamen. Beachten Sie, da&szlig;
        f&uuml;r Makro-und Funktionsparameter strengere Regeln
        gelten!</DD>
<DT>Argument:<DD>     <BR>
        der fehlerhafte Symbolname</DD>
</DL>
</DD>
<DT>1030<DD>reservierter Symbolname
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Symbolname ist zwar an sich g&uuml;ltig, dieser spezielle
        Name ist aber f&uuml;r andere Zwecke reserviert, und kann
        nicht f&uuml;r selbst definierte Symbole verwendet
        werden.</DD>
<DT>Argument:<DD>     <BR>
        der reservierte Symbolname</DD>
</DL>
</DD>
<DT>1090<DD>Ung&uuml;ltiges Format
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das benutzte Befehlsformat existiert bei diesem Befehl
        nicht.</DD>
<DT>Argument:<DD>     <BR>
        Der Kennbuchstabe des verwendeten Formates</DD>
</DL>
</DD>
<DT>1100<DD>&Uuml;berfl&uuml;ssiges Attribut
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl (Prozessor oder Pseudo) darf kein mit
        einem Punkt angeh&auml;ngtes Attribut haben.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1105<DD>Attribut darf nur 1 Zeichen lang sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das mit einem Punkt an einen Befehl angeh&auml;ngte Attribut
        mu&szlig; genau ein Zeichen lang sein; weder mehr noch
        weniger ist erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1107<DD>undefiniertes Attribut
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das an einem Befehl angef&uuml;gte Attribut ist
        ung&uuml;ltig.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1110<DD>Unpassende Operandenzahl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die bei einem Befehl (Prozessor oder Pseudo) angegebene
        Operandenzahl liegt nicht in dem f&uuml;r diesen Befehl
        erlaubten Bereich.</DD>
<DT>Argument:<DD>     <BR>
        Die erwartete Anzahl Argumente bzw. Operanden</DD>
</DL>
</DD>
<DT>1112<DD>Kann Argument nicht in Teile aufspaltenl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Bei bestimmten Prozessoren (z.B. DSP56000) m&uuml;ssen die
        kommaseparierten Argumente weiter in Einzeloperanden
        aufgespalten werden, diese ist fehlgeschlagen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1115<DD>Unpassende Optionenzahl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die bei diesem Befehl angegebene Zahl von Optionen liegt
        nicht in dem f&uuml;r diesen Befehl erlaubten Bereich.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1120<DD>nur immediate-Adressierung erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl l&auml;&szlig;t nur immediate-Operanden
        (mit vorangestelltem #) zu.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1130<DD>Unpassende Operandengr&ouml;&szlig;e
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Operand hat zwar einen f&uuml;r den Befehl zugelassenen
        Typ, jedoch nicht die richtige L&auml;nge (in Bits).</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1131<DD>Widersprechende Operandengr&ouml;&szlig;en
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebenen Operanden haben unterschiedliche L&auml;ngen
        (in Bit).</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1132<DD>Undefinierte Operandengr&ouml;&szlig;e
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Aus Opcode und Operanden l&auml;&szlig;t sich die
        Operandengr&ouml;&szlig;e nicht eindeutig bestimmen (ein
        Problem des 8086-Assemblers). Sie m&uuml;ssen die
        Operandengr&ouml;&szlig;e durch einen<TT> BYTE</TT>,<TT>
        WORD</TT>, usw.<TT> PTR</TT>-Pr&auml;fix festlegen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1133<DD>Ganzzahl oder String erwartet, aber Gleitkommazahl erhalten
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann keine Gleitkommazahl als Argument
        verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1134<DD>Ganzzahl erwartet, aber Gleitkommazahl erhalten
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann keine Gleitkommazahl als Argument
        verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1136<DD>Gleitkommazahl erwartet, aber String erhalten
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann kein String als Argument verwendet
        werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1137<DD>Operandentyp-Diskrepanz
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die beiden Argumente eines Operanden haben nicht den gleichen
        Datentyp (Integer/Gleitkomma/String).</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1138<DD>String erwartet, aber Ganzzahl erhalten
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann keine Ganzzahl als Argument verwendet
        werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1139<DD>String erwartet, aber Gleitkommazahl erhalten
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann keine Gleitkommazahl als Argument
        verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1140<DD>zu viele Argumente
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Einem Befehl wurden mehr als die unter AS zul&auml;ssigen 20
        Parameter &uuml;bergeben.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1141<DD>Ganzzahl erwartet, aber String erhalten
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann kein String als Argument verwendet
        werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1142<DD>Ganz- oder Gleitkommazahl erwartet, aber String erhalten
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann kein String als Argument verwendet
        werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1143<DD>String erwartet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann nur ein (in einfachen Hochkommas
        eingeschlossener) String als Argument verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1144<DD>Ganzzahl erwartet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann nur eine ganze Zahl als Argument
        verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1145<DD>Ganz-, Gleitkommazahl oder String erwartet, aber Register bekommen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann kein Registersymbol als Argument
        verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1146<DD>Ganzzahl oder String erwartet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann keine Gleitkommazahl oder
        Registersymbol als Argument verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1147<DD>Register erwartet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann nur ein Register als Argument verwendet
        werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1148<DD>Registersymbol f&uuml;r anderes Ziel
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angesprochene Registersymbol wurde f&uuml;r einen anderen
        Zielprozessor als den aktuell verwendeten definiert und ist
        nicht kompatibel.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1149<DD>Gleitkomma-Argument erwartet, aber Ganzzahl bekommen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann kein Ganzzahl-, sondern nur ein
        Gleitkomma- Argument verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1151<DD>Ganz- oder Gleitkommazahl erwartet, aber Register bekommen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann kein Register, sondern nur eine Ganz-
        oder Gleitkommazahl als Argument verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1152<DD>Ganzzahl oder String erwartet, aber Register bekommen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann kein Register, sondern nur eine
        Ganzzahl oder ein String als Argument verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1153<DD>Ganzzahl erwartet, aber Register bekommen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle kann kein Register, sondern nur eine
        Ganzzahl als Argument verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1154<DD>String zu lang
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieser String ist zu lang, als da&szlig; er mit
        vorangestelltem L&auml;ngen-Byte dargestellt werden
        k&ouml;nnte.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>1200<DD>Unbekannter Befehl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl ist weder ein Pseudobefehl von AS noch
        ein Befehl des momentan eingestellten Prozessors.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1300<DD>Klammerfehler
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Formelparser ist auf einen (Teil-)Ausdruck
        gesto&szlig;en, in dem die Summe &ouml;ffnender und
        schlie&szlig;ender Klammern nicht &uuml;bereinstimmt.</DD>
<DT>Argument:<DD>     <BR>
        der beanstandete (Teil-)Ausdruck</DD>
</DL>
</DD>
<DT>1310<DD>Division durch 0
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Bei einer Division oder Modulooperation ergab die Auswertung
        des rechten Teilausdruckes 0.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1315<DD>Bereichsunterschreitung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene Integer-Wert unterschreitet den
        zul&auml;ssigen Bereich.</DD>
<DT>Argument:<DD>     <BR>
        aktueller Wert und zul&auml;ssiges Minimum (manchmal, ich
        stelle das seit Jahren um...)</DD>
</DL>
</DD>
<DT>1320<DD>Bereichs&uuml;berschreitung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene Integer-Wert &uuml;berschreitet den
        zul&auml;ssigen Bereich.</DD>
<DT>Argument:<DD>     <BR>
        aktueller Wert und zul&auml;ssiges Maximum (manchmal, ich
        stelle das seit Jahren um...)</DD>
</DL>
</DD>
<DT>1322<DD>keine Zweierpotenz
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Hier sind nur Zweierpotenzen (1,2,4,8...) als Wert
        erlaubt</DD>
<DT>Argument:<DD>     <BR>
        der fragliche Wert</DD>
</DL>
</DD>
<DT>1323<DD>ung&uuml;ltige Dezimalstelle
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein String als Argument zu<TT> PACKED</TT> darf nur die
        Ziffern 0 bis 9 enthalten, sowie ein Plus- oder Minuszeiche
        nzu Anfang.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>1324<DD>Dezimalstring zu lang
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine gepackte Dezimalzahl darf maximal 31 Stellen lang
        sein.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>1325<DD>Adresse nicht ausgerichtet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebene direkte Speicheradresse entspricht nicht den
        Anspr&uuml;chen des Datentransfers, d.h. ist nicht ein
        mehrfaches der Operandengr&ouml;&szlig;e. Nicht alle
        Prozessoren erlauben unausgerichtete Datenzugriffe.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1330<DD>Distanz zu gro&szlig;
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der in einem Adre&szlig;ausdruck enthaltene Displacement-Wert
        ist zu gro&szlig;.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1331<DD>Ziel nicht auf gleicher Seite
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Befehl und Operandenadresse m&uuml;ssen auf der gleichen
        Seite liegen.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Adre&szlig;-Argument</DD>
</DL>
</DD>
<DT>1340<DD>Kurzadressierung nicht m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Adresse des Operanden liegt au&szlig;erhalb des
        Speicherbereiches, in dem Kurzadressierung m&ouml;glich
        ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1350<DD>Unerlaubter Adressierungsmodus
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Adressierungsmodus existiert generell zwar, ist
        an dieser Stelle aber nicht erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1351<DD>Adresse mu&szlig; gerade sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle sind nur gerade Adressen erlaubt, da das
        unterste Bit f&uuml;r andere Zwecke verwendet wird oder
        reserviert ist.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>1352<DD>Adresse mu&szlig; ausgerichtet sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle sind nur ausgerichtete (d.h glatt durch 2,
        4, 8... teilbare) Adressen erlaubt, da die untersten Bits
        f&uuml;r andere Zwecke verwendet werden oder reserviert
        sind.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>1355<DD>Adressierungsmodus im Parallelbetrieb nicht erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die verwendeten Adressierungsmodi sind zwar im sequentiellen
        Modus zul&auml;ssig, jedoch nicht bei parallelen
        Instruktionen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1360<DD>undefinierte Bedingung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die benutzte Bedingung f&uuml;r bedingte Spr&uuml;nge
        existiert nicht.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1365<DD>inkompatible Bedingungen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die benutzte Kombination von Bedingungen kann nicht in einem
        Befehl verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        die Bedingung, bei der die Unvertr&auml;glichkeit entdeckt
        wurde.</DD>
</DL>
</DD>
<DT>1366<DD>unbekanntes Flag
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Flag existiert nicht.</DD>
<DT>Argument:<DD>     <BR>
        Das Argument mit dem fraglichen Flag</DD>
</DL>
</DD>
<DT>1367<DD>doppeltes Flag
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Flag wurde mehrfach in der Liste
        verwendet.</DD>
<DT>Argument:<DD>     <BR>
        Das Argument mit dem doppelten Flag</DD>
</DL>
</DD>
<DT>1368<DD>unbekannter Interrupt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene Interrupt existiert nicht.</DD>
<DT>Argument:<DD>     <BR>
        Das Argument mit dem fraglichen Interrupt</DD>
</DL>
</DD>
<DT>1369<DD>doppelter Interrupt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene Interrupt wurde mehrfach in der Liste
        verwendet.</DD>
<DT>Argument:<DD>     <BR>
        Das Argument mit dem doppelten Interrupt</DD>
</DL>
</DD>
<DT>1370<DD>Sprungdistanz zu gro&szlig;
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Sprungbefehl und Sprungziel liegen zu weit auseinander, um
        mit einem Sprung der benutzten L&auml;nge
        &uuml;berbr&uuml;ckt werden zu k&ouml;nnen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1371<DD>Sprungdistanz ist Null
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Sprungbefehl und Sprungziel liegen direkt hintereinander, und
        eine Sprungdistanz von null kann nicht kodiert werden.</DD>
<DT>Argument:<DD>     <BR>
        Die Zieladresse im Quellcode</DD>
</DL>
</DD>
<DT>1375<DD>Sprungdistanz ist ungerade
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Da Befehle nur auf geraden Adressen liegen d&uuml;rfen,
        mu&szlig; eine Sprungdistanz zwischen zwei Befehlen auch
        immer gerade sein, das Bit 0 der Distanz wird anderweitig
        verwendet. Diese Bedingung ist verletzt worden. Grund ist
        &uuml;blicherweise die Ablage einer ungeraden Anzah</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1376<DD>Skip-Ziel passt nicht
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Sprungziel ist nicht die Adresse, die der
        Prozessor bei Ausf&uuml;hrung der Skip-Anweisung anspringen
        w&uuml;rde.</DD>
<DT>Argument:<DD>     <BR>
        die angegebene (beabsichtigte) Sprungadresse</DD>
</DL>
</DD>
<DT>1380<DD>ung&uuml;ltiges Schiebeargument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        als Argument f&uuml;r die Schiebeamplitude darf nur eine
        Konstante oder ein Datenregister verwendet werden. (nur
        680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1390<DD>Nur Bereich 1..8 erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Konstanten f&uuml;r Schiebeamplituden oder<TT>
        ADDQ</TT>-Argumente d&uuml;rfen nur im Bereich 1..8 liegen.
        (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1400<DD>Schiebezahl zu gro&szlig;
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        (nicht mehr verwendet)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1410<DD>Ung&uuml;ltige Registerliste
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Registerlisten-Argument von<TT> MOVEM</TT> oder<TT>
        FMOVEM</TT> hat ein falsches Format. (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1420<DD>Ung&uuml;ltiger Modus mit CMP
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die verwendete Operandenkombination von<TT> CMP</TT> ist
        nicht erlaubt. (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1430<DD>Ung&uuml;ltiger Prozessortyp
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Den mit<TT> CPU</TT> angeforderten Zielprozessor kennt AS
        nicht.</DD>
<DT>Argument:<DD>     <BR>
        der unbekannte Prozessortyp</DD>
</DL>
</DD>
<DT>1431<DD>Ung&uuml;ltiger FPU-Typ
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Den mit<TT> FPU</TT> angeforderten numerischen Koprozessor
        kennt AS nicht.</DD>
<DT>Argument:<DD>     <BR>
        der unbekannte FPU-Typ</DD>
</DL>
</DD>
<DT>1432<DD>Ung&uuml;ltiger PMMU-Typ
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die mit<TT> PMMU</TT> angeforderte MMU kennt AS nicht.</DD>
<DT>Argument:<DD>     <BR>
        der unbekannte PMMU-Typ</DD>
</DL>
</DD>
<DT>1440<DD>Ung&uuml;ltiges Kontrollregister
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das bei z.B.<TT> MOVEC</TT> benutzte Kontrollregister kennt
        der mit CPU gesetzte Prozessor (noch) nicht.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1445<DD>Ung&uuml;ltiges Register
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das benutzte Register ist zwar prinzipiell vorhanden, hier
        aber nicht erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1446<DD>Register mehr als einmal gelistet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Register taucht in der Liste der zu sichernden bzw.
        wiederherzustellenden Register mehrfach auf.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1447<DD>Register-Bank-Diskrepanz
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        In einem Adre&szlig;ausdruck werden Register aus
        unterschiedlichen B&auml;nken verwendet.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Register</DD>
</DL>
</DD>
<DT>1448<DD>Registerl&auml;nge undefiniert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle k&ouml;nnen Register verschiedener
        L&auml;nge verwendet werden, und die Registerl&auml;nge ist
        nicht alleine aus der Adresse ableitbar.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>1449<DD>ung&uuml;ltige Operation auf Register
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Diese Operation kann auf dieses Register nicht angewendet
        werden, z.B. weil das Register nur gelesen oder nur
        geschrieben werden darf.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Register</DD>
</DL>
</DD>
<DT>1450<DD>RESTORE ohne SAVE
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde ein<TT> RESTORE</TT>-Befehl gefunden, obwohl kein
        mit<TT> SAVE</TT> gespeicherter Zustand (mehr) auf dem Stapel
        vorhanden ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1460<DD>fehlendes RESTORE
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Nach der Assemblierung sind nicht alle<TT> SAVE</TT>-Befehle
        wieder aufgel&ouml;st worden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1465<DD>unbekannte Makro-Steueranweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine beim<TT> MACRO</TT>-Befehl zus&auml;tzlich angegebene
        Steueranweisung ist AS unbekannt.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Anweisung</DD>
</DL>
</DD>
<DT>1470<DD>fehlendes ENDIF/ENDCASE
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Nach der Assemblierung sind nicht alle Konstrukte zur
        bedingten Assemblierung aufgel&ouml;st worden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1480<DD>ung&uuml;ltiges IF-Konstrukt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Reihenfolge der Befehle in einem<TT> IF</TT>- oder<TT>
        SWITCH</TT>-Konstrukt stimmt nicht.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1482<DD>FORWARD-Anweisung mu&szlig; sich auf aktuelle Sektion beziehen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        <TT>FORWARD</TT>-Direktiven d&uuml;rfen sich nicht auf
        Symbole in einer anderen (h&ouml;heren) Sektion
        beziehen.</DD>
<DT>Argument:<DD>     <BR>
        der fragliche Symbolname</DD>
</DL>
</DD>
<DT>1483<DD>doppelter Sektionsname
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es existiert bereits eine Sektion gleichen Namens auf dieser
        Ebene.</DD>
<DT>Argument:<DD>     <BR>
        der doppelte Name</DD>
</DL>
</DD>
<DT>1484<DD>unbekannte Sektion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Im momentanen Sichtbarkeitsbereich existiert keine Sektion
        dieses Namens.</DD>
<DT>Argument:<DD>     <BR>
        der unbekannte Name</DD>
</DL>
</DD>
<DT>1485<DD>fehlendes ENDSECTION
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Nach Ende eines Durchganges sind nicht alle Sektionen wieder
        geschlossen worden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1486<DD>falsches ENDSECTION
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        die bei<TT> ENDSECTION</TT> angegebene Sektion ist nicht die
        innerste offene.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1487<DD>ENDSECTION ohne SECTION
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde ein<TT> ENDSECTION</TT>-Befehl gegeben, obwohl gar
        keine Sektion offen war.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1488<DD>nicht aufgel&ouml;ste Vorw&auml;rtsdeklaration
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        ein mit<TT> FORWARD</TT> oder<TT> PUBLIC</TT>
        angek&uuml;ndigtes Symbol wurde nicht in der Sektion
        definiert.</DD>
<DT>Argument:<DD>     <BR>
        der Name des fraglichen Symbols, plus die Position der
        Vorw&auml;rts-Deklaration im Quelltext</DD>
</DL>
</DD>
<DT>1489<DD>widersprechende FORWARD &harr;PUBLIC-Deklaration
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Symbol wurde sowohl als privat als auch global
        definiert.</DD>
<DT>Argument:<DD>     <BR>
        der Name des Symbols</DD>
</DL>
</DD>
<DT>1490<DD>falsche Argumentzahl f&uuml;r Funktion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Anzahl der Argumente f&uuml;r eine selbst definierte
        Funktion stimmt nicht mit der geforderten Anzahl
        &uuml;berein.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1491<DD>doppelter Funktions-Argumentenname
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Zwei oder mehrere Argumente einer Funktion haben den gleichen
        Namen</DD>
<DT>Argument:<DD>     <BR>
        das Argument mit dem doppelten Namen</DD>
</DL>
</DD>
<DT>1495<DD>unaufgel&ouml;ste Literale (LTORG fehlt)
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Am Programmende oder beim Umachalten zu einem anderen
        Zielprozessor blieben noch nicht abgelegte Literale
        &uuml;brig.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1500<DD>Befehl auf dem ... nicht vorhanden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl existiert zwar grunds&auml;tzlich, das
        eingestellte Mitglied der Prozessorfamilie beherrscht ihn
        aber noch nicht.</DD>
<DT>Argument:<DD>     <BR>
        Die Prozessorvarianten, die diesen Befehl unterst&uuml;tzen
        w&uuml;rden.</DD>
</DL>
</DD>
<DT>1501<DD>FPU-Befehle nicht freigeschaltet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die FPU-Befehlssatzerweiterungen m&uuml;ssen erlaubt werden,
        um diesen Befehl zu benutzen</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1502<DD>PMMU-Befehle nicht freigeschaltet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die PMMU-Befehlssatzerweiterungen m&uuml;ssen erlaubt werden,
        um diesen Befehl zu benutzen</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1503<DD>voller PMMU-Befehlssatz nicht freigeschaltet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieser Befehl ist nur im Befehlssatz der 68851-PMMU
        enthalten, nicht im reduzierten Befehlssatz der integrierten
        PMMU.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1504<DD>Z80-Syntax nicht erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieser Befehl ist nur erlaubt, wenn die Z80-Syntax f&uuml;r
        8080/8085-Befehle freigeschaltet wurde.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1505<DD>Adressierungsart auf dem ... nicht vorhanden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Adressierungsmodus existiert zwar
        grunds&auml;tzlich, das eingestellte Mitglied der
        Prozessorfamilie beherrscht ihn aber noch nicht.</DD>
<DT>Argument:<DD>     <BR>
        Die Prozessorvarianten, die diesen Adressierungsmodus
        unterst&uuml;tzen w&uuml;rden.</DD>
</DL>
</DD>
<DT>1506<DD>nicht im Z80-Syntax Exklusiv-Modus erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieser Befehl ist nicht (mehr) erlaubt, wenn nur noch
        Z80-Syntax f&uuml;r 8080/8085-Befehle erlaubt wurde.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1507<DD>FPU-Befehl auf dem ... nicht unterst&uuml;tzt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte FPU-Befehl existiert zwar grunds&auml;tzlich,
        der eingestellte FPU-Typ beherrscht ihn aber noch nicht.</DD>
<DT>Argument:<DD>     <BR>
        Der fragliche Befehl</DD>
</DL>
</DD>
<DT>1508<DD>Custom-Befehle nicht freigeschaltet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die benutzerdefinierten Befehlssatzerweiterungen m&uuml;ssen
        erlaubt werden, um diesen Befehl zu benutzen.</DD>
<DT>Argument:<DD>     <BR>
        Der fragliche Befehl</DD>
</DL>
</DD>
<DT>1509<DD>Befehls-Erweiterung nicht freigeschaltet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieser Befehl ist Teil einer Befehlssatz-Erweiterung, deren
        Benutzung nicht erlaubt wurde.</DD>
<DT>Argument:<DD>     <BR>
        Der Name der Erweiterung</DD>
</DL>
</DD>
<DT>1510<DD>Ung&uuml;ltige Bitstelle
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebene Bitnummer ist nicht erlaubt oder eine Angabe
        fehlt komplett.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1520<DD>nur ON/OFF erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieser Pseudobefehl darf als Argument nur<TT> ON</TT>
        oder<TT> OFF</TT> haben.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1530<DD>Stack ist leer oder nicht definiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde bei einem<TT> POPV</TT> einen Stack anzusprechen,
        der entweder nie definiert oder bereits leerger&auml;umt
        wurde.</DD>
<DT>Argument:<DD>     <BR>
        der Name des fraglichen Stacks</DD>
</DL>
</DD>
<DT>1540<DD>Nicht genau ein Bit gesetzt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        In einer Bitmaske, die der<TT> BITPOS</TT>- Funktion
        &uuml;bergeben wurde, war nicht genau ein Bit gesetzt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1550<DD>ENDSTRUCT ohne STRUCT
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine<TT> ENDSTRUCT</TT>-Anweisung wurde gegeben, obwohl
        momentan keine Strukturdefinition in Gange war.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1551<DD>offene Strukturdefinition
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Nach Ende der Assemblierung waren noch nicht alle<TT>
        STRUCT</TT>-Anweisungen durch passende<TT> ENDSTRUCT</TT>s
        abgeschlossen.</DD>
<DT>Argument:<DD>     <BR>
        die innerste, noch nicht abgeschlossene
        Strukturdefinition</DD>
</DL>
</DD>
<DT>1552<DD>falsches ENDSTRUCT
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Namensparameter einer<TT> ENDSTRUCT</TT>-Anweisung
        entspricht nicht der innersten, offenen
        Strukturdefinition.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1553<DD>Phasendefinition nicht in Strukturen erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Was gibt es dazu zu sagen?<TT> PHASE</TT> in einem Record
        ergibt einfach keinen Sinn und nur Verwirrung...</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1554<DD>ung&uuml;ltige<TT> STRUCT</TT>-Direktive
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Als Direktive f&uuml;r<TT> STRUCT</TT> ist nur<TT>
        EXTNAMES</TT>,<TT> NOEXTNAMES</TT>,<TT> DOTS</TT> und<TT>
        NODOTS</TT> zugelassen.</DD>
<DT>Argument:<DD>     <BR>
        die unbekannte Direktive</DD>
</DL>
</DD>
<DT>1555<DD>Struktur redefiniert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine Struktur dieses Namens wurde bereits definiert.</DD>
<DT>Argument:<DD>     <BR>
        der Name der Struktur</DD>
</DL>
</DD>
<DT>1556<DD>nicht aufl&ouml;sbare Strukturelement-Referenz
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Element bezieht sich auf ein anderes Element in einer
        Strukturdefintions, dieses ist aber nicht definiert oder
        dessen Referenz selber is nicht aufl&ouml;sbar.</DD>
<DT>Argument:<DD>     <BR>
        Name des Elements und seine Referenz</DD>
</DL>
</DD>
<DT>1557<DD>Strukturelement doppelt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Element dieses Namens ist bereits in der Struktur
        enthalten.</DD>
<DT>Argument:<DD>     <BR>
        Name des Elements</DD>
</DL>
</DD>
<DT>1560<DD>Anweisung nicht wiederholbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Diese Maschinenanweisung kann nicht mit Hilfe eines<TT>
        RPT</TT>-Konstruktes wiederholt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1600<DD>vorzeitiges Dateiende
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde mit einem<TT> BINCLUDE</TT>-Befehl versucht,
        &uuml;ber das Ende einer Datei hinauszulesen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1700<DD>ROM-Offset geht nur von 0..63
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Konstanten-ROM der 680x0-Koprozessoren hat nur max. 63
        Eintr&auml;ge.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1710<DD>Ung&uuml;ltiger Funktionscode
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Als Funktionscodeargument darf nur SFC, DFC, ein
        Datenregister oder eine Konstante von 0..15 verwendet werden.
        (nur 680x0-MMU)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1720<DD>Ung&uuml;ltige Funktionscodemaske
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Als Funktionscodemaske darf nur ein Wert von 0..15 verwendet
        werden. (nur 680x0-MMU)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1730<DD>Ung&uuml;ltiges MMU-Register
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die MMU hat kein Register mit dem angegebenen Namen. (nur
        680x0-MMU)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1740<DD>Level nur von 0..7
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Ebene f&uuml;r<TT> PTESTW</TT> und<TT> PTESTR</TT>
        mu&szlig; eine Konstante von 0..7 sein. (nur 680x0-MMU)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1750<DD>ung&uuml;ltige Bitmaske
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die bei den Bit-Feld-Befehlen angegebene Bitmaske hat ein
        falsches Format. (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1760<DD>ung&uuml;ltiges Registerpaar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Registerpaar ist hier nicht verwendbar oder
        syntaktisch falsch. (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1800<DD>offene Makrodefinition
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine Makrodefinition war am Dateiende nicht abgeschlossen.
        Vermutlich fehlt ein<TT> ENDM</TT>.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1801<DD>IRP ohne ENDM
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein IRP-Block war am Dateiende nicht abgeschlossen.
        Vermutlich fehlt ein<TT> ENDM</TT>.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1802<DD>IRPC ohne ENDM
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein IRPC-Block war am Dateiende nicht abgeschlossen.
        Vermutlich fehlt ein<TT> ENDM</TT>.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1803<DD>REPT ohne ENDM
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein REPT-Block war am Dateiende nicht abgeschlossen.
        Vermutlich fehlt ein<TT> ENDM</TT>.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1804<DD>WHILE ohne ENDM
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein WHILE-Block war am Dateiende nicht abgeschlossen.
        Vermutlich fehlt ein<TT> ENDM</TT>.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1805<DD>EXITM au&szlig;erhalb eines Makrorumpfes
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        <TT>EXITM</TT> bricht die Expansion von Makro-Konstrukten ab.
        Dieser Befehl macht nur innerhalb von Makros Sinn und es
        wurde versucht, ihn au&szlig;erhalb aufzurufen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1810<DD>mehr als 10 Makroparameter
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Makro darf h&ouml;chstens 10 Parameter haben.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1811<DD>Schl&uuml;sselwortargument nicht in Makro definiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Schl&uuml;sselwortargument bezog sich auf einen
        Parameter, den das aufgerufene Makro gar nicht besitzt.</DD>
<DT>Argument:<DD>     <BR>
        verwendetes Schl&uuml;sselwort bzw. Makroparameter</DD>
</DL>
</DD>
<DT>1812<DD>Positionsargument nach Schl&uuml;sselwortargumenten nicht mehr
    erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Positions- und Schl&uuml;sselwortargumente d&uuml;rfen in
        einem Makroaufruf gemischt werden, aber nach dem ersten
        Schl&uuml;sselwortargument sind nur noch solche
        zugelassen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
    </DD>
<DT>1815<DD>doppelte Makrodefinition
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Makronamne wurde in einer Sektion doppelt vergeben.</DD>
<DT>Argument:<DD>     <BR>
        der doppelt verwendete Name</DD>
</DL>
</DD>
<DT>1820<DD>Ausdruck mu&szlig; im ersten Pass berechenbar sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl beeinflu&szlig;t die Codel&auml;nge,
        daher sind Vorw&auml;rtsreferenzen hier nicht erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1830<DD>zu viele verschachtelte IFs
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        (nicht mehr verwendet)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1840<DD>ELSEIF/ENDIF ohne ENDIF
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        es wurde ein<TT> ELSEIF</TT>- oder<TT> ENDIF</TT>-Befehl
        gefunden, obwohl kein offener<TT> IF</TT>-Befehl vorhanden
        ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1850<DD>verschachtelter/rekursiver Makroaufruf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        (nicht mehr verwendet)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1860<DD>unbekannte Funktion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angesprochene Funktion ist weder eingebaut noch
        nachtr&auml;glich definiert worden.</DD>
<DT>Argument:<DD>     <BR>
        der Funktionsname</DD>
</DL>
</DD>
<DT>1870<DD>Funktionsargument au&szlig;erhalb Definitionsbereich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Argument liegt nicht im Bereich der angesprochenen
        transzendenten Funktion.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1880<DD>Gleitkomma&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Argument liegt zwar im Bereich der angesprochenen
        transzendenten Funktion, das Ergebnis w&auml;re aber nicht
        mehr darstellbar.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1890<DD>ung&uuml;ltiges Wertepaar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das benutzte P&auml;rchen aus Basis und Exponent kann nicht
        berechnet werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1900<DD>Befehl darf nicht auf dieser Adresse liegen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Prozessorhardware erlaubt keine Spr&uuml;nge von dieser
        Adresse.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1905<DD>ung&uuml;ltiges Sprungziel
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Prozessorhardware erlaubt keine Spr&uuml;nge zu dieser
        Adresse.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1910<DD>Sprungziel nicht auf gleicher Seite
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Sprungbefehl und Sprungziel m&uuml;ssen bei diesem Befehl auf
        der gleichen Seite liegen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1911<DD>Sprungziel nicht in gleicher Sektion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Sprungbefehl und Sprungziel m&uuml;ssen bei diesem Befehl in
        der gleichen (64K-)Sektion liegen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1920<DD>Code&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde versucht, mehr als 1024 Bytes Code oder Daten in
        einer Zeile zu erzeugen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1925<DD>Adre&szlig;&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Adre&szlig;raum dieses Prozessors wurde
        &uuml;berschritten.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1930<DD>Konstanten und Platzhalter nicht mischbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Anweisungen, die Speicher reservieren und solche, die ihn mit
        Konstanten belegen, d&uuml;rfen nicht in einer
        Pseudoanweisung gemischt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1940<DD>Codeerzeugung in Strukturdefinition nicht zul&auml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein<TT> STRUCT</TT>-Konstrukt dient nur der Beschreibung
        einer Datenstruktur und nicht dem Anlegen einer solchen, es
        sind daher keine Befehle zugelassen, die Code erzeugen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1950<DD>Paralleles Konstrukt nicht m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Entweder sind die beiden Instruktionen prinzipiell nicht
        parallel ausf&uuml;hrbar, oder sie stehen nicht unmittelbar
        untereinander.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1960<DD>ung&uuml;ltiges Segment
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Segment ist an dieser Stelle nicht
        anwendbar.</DD>
<DT>Argument:<DD>     <BR>
        der benutzte Segmentname</DD>
</DL>
</DD>
<DT>1961<DD>unbekanntes Segment
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Segment existiert bei diesem Prozessor
        nicht.</DD>
<DT>Argument:<DD>     <BR>
        der benutzte Segmentname</DD>
</DL>
</DD>
<DT>1962<DD>unbekanntes Segmentregister
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Segmentregister existiert nicht (nur
        8086).</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1970<DD>ung&uuml;ltiger String
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene String hat ein ung&uuml;ltiges Format.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1980<DD>ung&uuml;ltiger Registername
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Register existiert nicht oder darf hier nicht
        verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1985<DD>ung&uuml;ltiges Argument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene Befehl darf nicht mit einem<TT>
        REP</TT>-Pr&auml;fix versehen werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1990<DD>keine Indirektion erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        in dieser Kombination ist keine indirekte Adressierung
        erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1995<DD>nicht im aktuellen Segment erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        (nicht mehr verwendet)</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1996<DD>nicht im Maximum-Modus zul&auml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieses Register ist nur im Minimum-Modus definiert.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>1997<DD>nicht im Minimum-Modus zul&auml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieses Register ist nur im Maximum-Modus definiert.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2000<DD>Anweisungspaket &uuml;berschreitet Adre&szlig;grenze
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Anweisungspaket darf nicht &uuml;ber eine
        32-Byte-Adre&szlig;grenze reichen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2001<DD>Ausf&uuml;hrungseinheit mehrfach benutzt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine der Ausf&uuml;hrungseinheiten des Prozessors wurde in
        einem Anweisungspaket mehrfach benutzt.</DD>
<DT>Argument:<DD>     <BR>
        der Name der Funktionseinheit</DD>
</DL>
</DD>
<DT>2002<DD>mehrfache Lang-Leseoperation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Ausf&uuml;hrungspaket enth&auml;lt mehr als eine
        Lang-Leseoperation, was nicht erlaubt ist.</DD>
<DT>Argument:<DD>     <BR>
        eine der Funktionseinheiten, auf denen eine
        Lang-Leseoperation ausgef&uuml;hrt wird</DD>
</DL>
</DD>
<DT>2003<DD>mehrfache Lang-Schreiboperation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Ausf&uuml;hrungspaket enth&auml;lt mehr als eine
        Lang-Schreiboperation, was nicht erlaubt ist.</DD>
<DT>Argument:<DD>     <BR>
        eine der Funktionseinheiten, auf denen eine
        Lang-Schreiboperation ausgef&uuml;hrt wird</DD>
</DL>
</DD>
<DT>2004<DD>Lang-Lese- mit Schreiboperation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Ausf&uuml;hrungspaket enth&auml;lt sowohl eine
        Lang-Leseoperation als auch eine Schreiboperation, was nicht
        erlaubt ist.</DD>
<DT>Argument:<DD>     <BR>
        eine der Funktionseinheiten, deren Operationen im Konflikt
        stehen.</DD>
</DL>
</DD>
<DT>2005<DD>zu viele Lesezugriffe auf ein Register
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Auf das gleiche Register wurde mehr als viermal im gleichen
        Anweisungspaket Bezug genommen.</DD>
<DT>Argument:<DD>     <BR>
        der Name des Registers, das zu oft referenziert wurde</DD>
</DL>
</DD>
<DT>2006<DD>&uuml;berlappende Ziele
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Auf das gleiche Register wurde mehrfach im gleichen
        Ausf&uuml;hrungspaket geschrieben, was nicht erlaubt
        ist.</DD>
<DT>Argument:<DD>     <BR>
        der Name der fraglichen Registers</DD>
</DL>
</DD>
<DT>2008<DD>zu viele absolute Spr&uuml;nge in einem Anweisungspaket
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Anweisungspaket beinhaltet mehr als einen direkten
        Sprung, was nicht erlaubt ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2009<DD>Anweisung nicht auf diese Funktionseinheit ausf&uuml;hrbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Diese Anweisung kann nicht auf dieser Funktionseinheit
        ausgef&uuml;hrt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2010<DD>Ung&uuml;ltige Escape-Sequenz
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das mit einem Backslash eingeleitete Sonderzeichen ist nicht
        definiert.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2020<DD>ung&uuml;ltige Pr&auml;fix-Kombination
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebene Kombination von Pr&auml;fixen ist nicht
        zul&auml;ssig oder nicht im Maschinenkode darstellbar.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2030<DD>Konstante kann nicht als Variable redefiniert werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein einmal mit<TT> EQU</TT> als Konstante<BR>
        definiertes Symbol kann nicht nachtr&auml;glich mit<BR>
        <TT> SET</TT> ver&auml;ndert werden.</DD>
<DT>Argument:<DD>     <BR>
        der Name des fraglichen Symbols</DD>
</DL>
</DD>
<DT>2035<DD>Variable kann nicht als Konstante redefiniert werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein einmal mit<TT> SET</TT> als Variable<BR>
        definiertes Symbol kann nicht nachtr&auml;glich als<BR>
        Konstante deklariert werden (z.B. mit<TT> EQU</TT>.</DD>
<DT>Argument:<DD>     <BR>
        der Name des fraglichen Symbols</DD>
</DL>
</DD>
<DT>2040<DD>Strukturname fehlt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Bei einer Strukturdefinition fehlt der zugeh&ouml;rende Name
        f&uuml;r die Struktur.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2050<DD>leeres Argument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        In der Argumentenliste dieser Anweisung d&uuml;rfen keine
        Leerstrings benutzt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2060<DD>nicht implementierte Anweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Maschinenbefehl ist dem Assembler zwar bekannt,
        ist aber aufgrund fehlender Dokumentation seitens des
        Prozessorherstellers momentan nicht implementiert.</DD>
<DT>Argument:<DD>     <BR>
        Der benutzte Befehl</DD>
</DL>
</DD>
<DT>2070<DD>namenlose Struktur nicht Teil einer anderen Struktur
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine Struktur oder Union, die keinen Namen hat, mu&szlig;
        immer Teil einer anderen, benamten Struktur oder Union
        sein.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2080<DD>STRUCT durch ENDUNION beendet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        ENDUNION darf nur zum Beenden der Definition einer Union
        benutzt werden, nicht einer Struktur.</DD>
<DT>Argument:<DD>     <BR>
        Name der Struktur (falls vorhanden)</DD>
</DL>
</DD>
<DT>2090<DD>Speicheradresse nicht auf aktiver Seite
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Zieladresse befindet sich nicht in der durch das
        Seitenregister aktuell adressierbaren Speicherseite.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2100<DD>unbekanntes Makro-Expansions-Argument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein<TT> MACEXP_DFT/OVR</TT> gegebenes Argument konnte nicht
        interpretiert werden.</DD>
<DT>Argument:<DD>     <BR>
        das unbekannte Argument</DD>
</DL>
</DD>
<DT>2105<DD>zu viele Makro-Expansions-Argumente
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Anzahl der Argument zur Makro-Expansion hat ihre
        Maximalzahl &uuml;berschritten</DD>
<DT>Argument:<DD>     <BR>
        das Argument, das zu viel ist</DD>
</DL>
</DD>
<DT>2110<DD>widerspr&uuml;chliche Angaben zur Makro-Expansion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine Angabe zur Makroexpansion und ihr genaues Gegenteil
        d&uuml;rfen nicht gleichzeitig als Argument von<TT>
        MACEXP_DFT/OVR</TT> verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2130<DD>erwarteter Fehler nicht eingetreten
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein per<TT> EXPECT</TT> angek&uuml;ndigter Fehler oder
        Warnung ist in dem durch<TT> ENDEXPECT</TT> abgeschlossenen
        Block nicht aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Der erwartete Fehler</DD>
</DL>
</DD>
<DT>2140<DD>Verschachtelung von EXPECT/ENDEXPECT nicht erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Durch<TT> EXPECT/ENDEXPECT</TT> eingerahmte Bl&ouml;cke
        d&uuml;rfen keine geschachtelten<TT>
        EXPECT/ENDEXPECT</TT>-Bl&ouml;cke enthalten.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2150<DD>fehlendes ENDEXPECT
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein per<TT> EXPECT</TT> ge&ouml;ffneter Block wurde nicht
        per<TT> ENDEXPECT</TT> abgeschlossen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2160<DD>ENDEXPECT ohne EXPECT
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Zu einem<TT> ENDEXPECT</TT> gibt es kein vorhergehendes<TT>
        EXPECT</TT>.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2170<DD>kein Default-Checkpoint-Register definiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Bei einer Typ-12-Instruktion wurde kein Checkpoint-Register
        angegeben und es wurde auch keines &uuml;ber die<TT>
        CKPT</TT>-Anweisung vorher definiert.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2180<DD>ung&uuml;ltiges Bitfeld
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Bitfeld entspricht nicht der erwarteten<TT>
        (start,count)</TT>-Syntax.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2190<DD>Argument-Wert fehlt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Argumente m&uuml;ssen die Form 'variable=wert' haben.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2200<DD>unbekanntes Argument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieses Variable wird von der gew&auml;hlten Zielplattform
        nicht unterst&uuml;tzt.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2210<DD>Indexregister muss 16 Bit sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Indexregister beim Z8000 m&uuml;ssen eine L&auml;nge von 16
        Bit (Rn) haben.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2211<DD>I/O Adressregister muss 16 Bit sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Z8000-Register, um I/O-Adressen zu adressieren, m&uuml;ssen
        eine L&auml;nge von 16 Bit (Rn) haben.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2212<DD>Adressregister im segmentierten Modus muss 32 Bit sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Z8000-Register, um Speicheradressen im segmentierten Modus zu
        adressieren, m&uuml;ssen eine L&auml;nge von 32 Bit (RRn)
        haben.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2213<DD>Adressregister im nicht-segmentierten Modus muss 16 Bit sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Z8000-Register, um Speicheradressen im nicht-segmentierten
        Modus zu adressieren, m&uuml;ssen eine L&auml;nge von 16 Bit
        (Rn) haben.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2220<DD>ung&uuml;ltiges Strukturargument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Argument entspricht keinem der Argumente, die bei der
        Expansion einer Struktur erlaubt sind.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2221<DD>zu viele Array-Dimensionen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Arrays von Strukturen d&uuml;rfen maximal drei Dimensionen
        haben.</DD>
<DT>Argument:<DD>     <BR>
        die Dimension, die zu viel ist</DD>
</DL>
</DD>
<DT>2230<DD>unbekannte Integer-Notation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebene Integer-Notation existiert nicht, oder es
        fehlt das f&uuml;hrende Plus/Minuszeichen.</DD>
<DT>Argument:<DD>     <BR>
        das fehlerhafte Argument</DD>
</DL>
</DD>
<DT>2231<DD>ung&uuml;ltige Liste an Integer-Schreibweisen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die geforderte &Auml;nderung der Liste von benutzbaren
        Integer-Schreibweisen kann nicht vorgenommen werden, weil sie
        zu einem Widerspruch f&uuml;hren w&uuml;rde. Aktuell betrifft
        dies lediglich 0hex und 0oct, die nicht gleichzeitig
        verwendet werden d&uuml;rfen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2240<DD>ung&uuml;ltige Skalierung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Argument kann nicht als Skalierungsfaktor
        benutzt werden.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2250<DD>widerspr&uuml;chliche String-Optionen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene String-Option steht im Widerspruch zu einer
        vorherigen in der Liste.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Option</DD>
</DL>
</DD>
<DT>2251<DD>unbekannte String-Option
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene String-Option gibt es nicht.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Option</DD>
</DL>
</DD>
<DT>2252<DD>ung&uuml;ltiger Cache-Invalidierungs-Modus
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es k&ouml;nnen nur Daten-, Instruktions- oder beide Caches
        invalidiert werden.</DD>
<DT>Argument:<DD>     <BR>
        das fragliche Argument</DD>
</DL>
</DD>
<DT>2253<DD>ung&uuml;ltige Config-Liste
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Konfigurationsliste ist entweder insgesamt syntaktisch
        falsch oder enth&auml;lt ung&uuml;ltige Elemente.</DD>
<DT>Argument:<DD>     <BR>
        Die fragliche Liste oder ein Element daraus.</DD>
</DL>
</DD>
<DT>2254<DD>widerspr&uuml;chliche Konfig-Optionen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Option steht im Widerspruch zu einer
        vorherigen in der Liste oder ist dazu identisch.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Option</DD>
</DL>
</DD>
<DT>2255<DD>unbekannte Konfig-Option
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Option gibt es nicht.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Option</DD>
</DL>
</DD>
<DT>2260<DD>ung&uuml;ltiger Wert f&uuml;r CBAR
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieser CBAR-Wert ist nicht erlaubt (CA mu&szlig;
        gr&ouml;&szlig;er als BA sein).</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2270<DD>Seite nicht zugreifbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Zieladresse liegt auf einer Speicherseite, die aktuell
        nicht zugreifbar ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2271<DD>aktueller Programmz&auml;hler in nicht-zugreifbarer Seiter
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die aktuell assemblierte Instruktion liegt auf einer
        physischen Adresse, die nicht in den logischen
        Adre&szlig;raum der CPU gemappt ist. Dies ist ein Problem bei
        PC-relativer Adressierung, weil f&uuml;r die Berechnung der
        Distanz die logische Adresse gebraucht wird.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2280<DD>Feld nicht zugreifbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Zieladresse liegt in einem Speicherfeld, das aktuell
        nicht zugreifbar ist.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2281<DD>Ziel nicht in gleichem Feld
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Befehl und Operandenadresse m&uuml;ssen im gleichen
        Speicherfeld liegen.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2290<DD>Ung&uuml;ltige Instruktions-Kombination
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Diese Befehle k&ouml;nnen nicht miteinander kombiniert
        werden.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2300<DD>nicht-gemapptes Zeichen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Zeichenkette enth&auml;lt einen nicht abbildbares
        Zeichen.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Zeichenkette</DD>
</DL>
keines </DD>
<DT>2310<DD>Multi-Zeichenkonstante mit ung&uuml;ltiger L&auml;nge
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Multi-Zeichenkonstanten m&uuml;ssen zwischen ein und vier
        Zeichen lang sein.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2320<DD>kein Target gesetzt ('CPU ...' oder '-cpu ...', um eines zu setzen)
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde noch kein Target gesetzt, der Assembler wei&szlig;
        daher nicht, f&uuml;r welche CPU Code erzeugt werden
        soll.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>2330<DD>Ung&uuml;ltige Displacement-L&auml;nge
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Bei diesem Adressierungsmodus kann das Displacement diese
        L&auml;nge nicht haben.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>10001<DD>Fehler bein &Ouml;ffnen der Datei
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Beim Versuch, eine Datei zu &ouml;ffnen, ist ein Fehler
        aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Beschreibung des E/A-Fehlers</DD>
</DL>
</DD>
<DT>10002<DD>Listingschreibfehler
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Beim Schreiben des Assemblerlistings ist ein Fehler
        aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Beschreibung des E/A-Fehlers</DD>
</DL>
</DD>
<DT>10003<DD>Dateilesefehler
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Beim Lesen aus einer Quelldatei ist ein Fehler
        aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Beschreibung des E/A-Fehlers</DD>
</DL>
</DD>
<DT>10004<DD>Dateischreibfehler
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Beim Schreiben von Code- oder Share-Datei ist ein Fehler
        aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Beschreibung des E/A-Fehlers</DD>
</DL>
</DD>
<DT>10006<DD>Speicher&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Der verf&uuml;gbare Speicher reicht nicht mehr, alle
        Datenstrukturen aufzunehmen. Weichen Sie auf die DPMI- oder
        OS/2-Version von AS aus.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>10007<DD>Stapel&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Der Programmstapel ist wegen zu komplizierter
        Formelausdr&uuml;cke oder einer ung&uuml;nstigen Anlage der
        Symbol- oder Makrotabelle &uuml;bergelaufen. Versuchen Sie es
        noch einmal mit der<TT> -A</TT>-Option.</DD>
<DT>Argument:<DD>     <BR>
        keines</DD>
</DL>
</DD>
<DT>10008<DD>INCLUDE zu tief verschachtelt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Die Include-Verschachtelungstiefe hat das gegebene Limit (im
        Default 200) &uuml;berschritten. Dieses Limit kann &uuml;ber
        den<TT> -maxinclevel</TT>-Schalter herauf gesetzt werden,
        eine fehlerhafte (rekusive) Verschachtelung ist aber die
        wahrscheinlichere Ursache.</DD>
<DT>Argument:<DD>     <BR>
        Die INCLUDE-Anweisung, mit der das Limit &uuml;berschritten
        wurde.</DD>
</DL>
</DD>
<DT>10010<DD>ung&uuml;ltiger Platzhalter in Listing Pro-Zeile-Pr&auml;fix Format
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Als Platzhalter sind nur %i, %n oder %a zul&auml;ssig.</DD>
<DT>Argument:<DD>     <BR>
        das ung&uuml;ltige Format</DD>
</DL>
</DD>
<DT>10011<DD>zu oft verwendeter Platzhalter in Listing Pro-Zeile-Pr&auml;fix
    Format
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Die Platzhalter %i und %n d&uuml;rfen jeweils nur maximal
        dreimal im Formatstring enthalten sein. Gen&uuml;gt das
        nicht?</DD>
<DT>Argument:<DD>     <BR>
        das mehrfach verwendete Format</DD>
</DL>
    </DD>
</DL>
<P>

<H1><A NAME="sect_B_">B. E/A-Fehlermeldungen</A></H1>
<P>
Die hier aufgelisteten Fehlermeldungen werden nicht nur von AS bei
E/A- Fehlern ausgegeben, sondern auch von den Hilfsprogrammen PLIST,
BIND, P2HEX und P2BIN. Es sind nur die Fehler n&auml;her
erkl&auml;rt, die m.E. bei der Arbeit auftreten k&ouml;nnen. Sollte
doch einmal ein nicht erl&auml;uterter E/A-Fehler auftreten, so
d&uuml;rfte der Grund in einem Programmfehler liegen. Melden Sie dies
unbedingt!!
<P>
<DL COMPACT>
<DT>2<DD>Datei nicht gefunden<BR>
    Die angegebene Datei existiert nicht oder liegt auf einem anderen
    Laufwerk.</DD>
<DT>3<DD>Pfad nicht gefunden<BR>
    Der Pfad eines Dateinamens existiert nicht oder liegt auf einem
    anderen Laufwerk.</DD>
<DT>4<DD>zu viele offene Dateien<BR>
    DOS sind die Dateihandles ausgegangen. Erh&ouml;hen Sie die<TT>
    FILES=</TT>-Angabe in der CONFIG.SYS.</DD>
<DT>5<DD>Dateizugriff verweigert<BR>
    Entweder reichen die Netzwerkrechte f&uuml;r einen Dateizugriff
    nicht, oder es wurde versucht, eine schreibgesch&uuml;tzte Datei
    zu &uuml;berschreiben oder zu ver&auml;ndern. Bei Benutzung in
    DOS- Fenstern von Multitasking- Systemen ist es &uuml;berdies
    m&ouml;glich, da&szlig; ein andere Proze&szlig; die Datei in
    exklusivem Zugriff hat.</DD>
<DT>6<DD>ung&uuml;ltiger Dateihandle</DD>
<DT>12<DD>ung&uuml;ltiger Zugriffsmodus</DD>
<DT>15<DD>ung&uuml;ltiger Laufwerksbuchstabe<BR>
    Das angesprochene Laufwerk existiert nicht.</DD>
<DT>16<DD>aktuelles Verzeichnis kann nicht gel&ouml;scht werden</DD>
<DT>17<DD>RENAME geht nicht &uuml;ber Laufwerke</DD>
<DT>100<DD>vorzeitiges Dateiende<BR>
    Eine Datei war zuende, obwohl sie es aufgrund ihrer Struktur noch
    nicht sein d&uuml;rfte. Vermutlich ist sie besch&auml;digt.</DD>
<DT>101<DD>Diskette/Platte voll<BR>
    Das spricht wohl f&uuml;r sich! Aufr&auml;umen!!</DD>
<DT>102<DD>ASSIGN fehlt</DD>
<DT>103<DD>Datei nicht offen</DD>
<DT>104<DD>Datei nicht f&uuml;r Einlesen offen</DD>
<DT>105<DD>Datei nicht f&uuml;r Ausgaben offen</DD>
<DT>106<DD>Ung&uuml;ltiges numerisches Format</DD>
<DT>150<DD>Diskette ist schreibgesch&uuml;tzt<BR>
    Wenn Sie schon keine Festplatte als Arbeitsmedium verwenden, so
    sollten Sie wenigstens den Schreibschutz entfernen!</DD>
<DT>151<DD>Unbekanntes Ger&auml;t<BR>
    Sie haben versucht, ein Peripherieger&auml;t anzusprechen,
    welches DOS unbekannt ist. Dies sollte normalerweise nicht
    auftreten, da der Name dann automatisch als Datei interpretiert
    wird.</DD>
<DT>152<DD>Laufwerk nicht bereit<BR>
    Schlie&szlig;en Sie die Klappe des Diskettenlaufwerks.</DD>
<DT>153<DD>unbekannte DOS-Funktion</DD>
<DT>154<DD>Pr&uuml;fsummenfehler auf Diskette/Platte<BR>
    Ein harter Lesefehler auf der Diskette. Nochmal versuchen; wenn
    immer noch vorhanden, Diskette neu formatieren bzw. ernste Sorgen
    um Festplatte machen!</DD>
<DT>155<DD>ung&uuml;ltiger DPB</DD>
<DT>156<DD>Positionierfehler<BR>
    Der Platten/Disketten-Controller hat eine bestimmte Spur nicht
    gefunden. Siehe Nr. 154!</DD>
<DT>157<DD>unbekanntes Sektorformat<BR>
    DOS kann mit dem Format der Diskette nichts anfangen.</DD>
<DT>158<DD>Sektor nicht gefunden<BR>
    Analog zu Nr. 158, nur da&szlig; hier der angeforderte Sektor auf
    der Spur nicht gefunden werden konnte.</DD>
<DT>159<DD>Papierende<BR>
    Offensichtlich haben Sie die Ausgaben von AS direkt auf einen
    Drucker umgeleitet. Assemblerlistings k&ouml;nnen seeehr lang
    sein...</DD>
<DT>160<DD>Ger&auml;telesefehler<BR>
    Nicht n&auml;her vom Ger&auml;tetreiber klassifizierter
    Lesefehler.</DD>
<DT>161<DD>Ger&auml;teschreibfehler<BR>
    Nicht n&auml;her vom Ger&auml;tetreiber klassifizierter
    Schreibfehler.</DD>
<DT>162<DD>allgemeiner Ger&auml;tefehler<BR>
    Hier ist der Ger&auml;tetreiber v&ouml;llig ratlos, was passiert
    sein k&ouml;nnte.</DD>
</DL>
<P>

<H1><A NAME="sect_C_">C. Programmierbeispiele</A></H1>
<P>
Manche Fragen, wie man dieses oder jenes realisiert, werden
h&auml;ufiger gestellt, und es ist vielleicht wert, sie in einer
'Tipps und Tricks' Ecke zu dokumentieren. Hier in diesem Kapitel
werde ich sie sammeln und vorstellen:
<P>

<H2><A NAME="sect_C_1_">C.1. 16-Bit-Befehle per Makro</A></H2>
<P>
Viele 8-Bit-Prozessoren k&ouml;nnen - wie der Name schon sagt - immer
nur acht Bit auf einmal verarbeiten. Oft sind jedoch genug Register
vorhanden, um zwei davon zu einem virtuellen '16 Bit Akkumulator'
zusammenzufassen. Nun soll dieser per Makro definierte Befehlssatz
m&ouml;glichst die gleichen Adressierungsarten wie die
Hardware-Befehle unterst&uuml;tzen. Dazu m&uuml;&szlig;te man die
Makro-Argumente irgendwie parsen - aber wie?
<P>
Der Motorola 6800 hat zum Beispiel zwei Akkumulatoren A und B, und es
liegt nahe, diese als einem 16-Bit-Akku zu behandeln. Die
Adressierungsarten sollten die gleichen sein wie bei
8-Bit-Operationen:
<UL>
<LI> immediate</LI>
<LI> direkt (Adresse innerhalb der ersten 256 Byte)</LI>
<LI> erweitert (beliebige Adresse)</LI>
<LI> indiziert</LI>
</UL>
Ein Makro, das so einen virtuellen 16-Bit-Befehl implementiert,
mu&szlig; die ein oder zwei Argumente also analysieren:
<OL>
<LI>Indizierte Adressierung hat als einzige zwei Argumente.</LI>
<LI>Immediate-Adressierung ist am f&uuml;hrenden Hash-Zeichen zu
    erkennen.</LI>
<LI>Ob eine Adresse in den ersten 256 Byte liegt oder nicht, kann man
    wieder dem Assembler &uuml;berlassen.</LI>
</OL>
Um Punkt 2 auszuf&uuml;hren, mu&szlig; ein Argument in einen String
&uuml;berf&uuml;hrt werden. Von diesem kann das f&uuml;hrende
Hash-Zeichen dann auch entfernt werden, um den eigentlichen Wert zu
evaluieren. Komplett ausgeschrieben sieht das Makro dann so aus:
<PRE>

subd    macro   ARG1,ARG2
  if      "ARG2" != ""            ; indexed?
   suba    (ARG1)+1,ARG2
   sbcb    ARG1,ARG2
  elseif                          ; not indexed?
_SARG1   set     "ARG1"           ; convert to string
  if      substr(_SARG1,0,1)='#' ; immediate?
_SARG1    set     substr(_SARG1,1,strlen(_SARG1)-1) ; yes-&gt;remove #
   suba    #lo(VAL(_SARG1))      ; ...and subtract lo/hi bytes
   sbcb    #hi(VAL(_SARG1))
  elseif                         ; no immediate-&gt;ext. or direct
   suba    (ARG1)+1              ; and subtract lo/hi bytes
   sbcb    ARG1
  endif
  endif
  endm

</PRE>
Makroargumente wurden bewusst in Gro&szlig;buchstaben geschrieben, so
dass das Makro unabh&auml;ngig davon funktioniert, ob der
case-sensitve Modus eingeschaltet ist oder nicht. Verwendet werden
kann das Makro z.B. so:
<PRE>

        subd    $0007                   ; direct
        subd    $1234                   ; absolute
        subd    #$55aa                  ; immediate
        subd    $12,x                   ; indexed

</PRE>
Jetzt ist es aber so, dass man nicht nur 16-bittig subtrahieren
m&ouml;chte. Man k&ouml;nnte f&uuml;r jede Operation eine eigene
Version des Makros hinschreiben, es geht aber auch eleganter. Ein
Makro kann selber wieder eine Makro-Definition enthalten. Man kann
also ein 'Meta-Makro' definieren, das die Befehlsnamen als Argumente
erh&auml;lt:
<PRE>

def16   macro   NEWINST,LOINST,HIINST
NEWINST macro   ARG1,ARG2
  if      "ARG2" != ""            ; indexed?
   LOINST  (ARG1)+1,ARG2
   HIINST  ARG1,ARG2
  elseif                          ; not indexed?
_SARG1   set     "ARG1"                 ; convert to string
  if      substr(_SARG1,0,1)='#' ; immediate?
_SARG1    set     substr(_SARG1,1,strlen(_SARG1)-1) ; yes-&gt;remove #
   LOINST  #lo(VAL(_SARG1))      ; ...and subtract lo/hi bytes
   HIINST  #hi(VAL(_SARG1))
  elseif                         ; no immediate-&gt;ext. or direct
   LOINST  (ARG1)+1              ; ...and subtract lo/hi bytes
   HIINST  ARG1
  endif
  endif
  endm
  endm

</PRE>
Dann sind die restlichen Definitionen Einzeiler:
<PRE>

        def16   addd,adda,adcb
        def16   subd,suba,sbcb
        def16   andd,anda,andb
        def16   ord,ora,orb
        def16   eord,eora,eorb

</PRE>
<P>

<H1><A NAME="sect_D_">D. H&auml;ufig gestellte Fragen</A></H1>
<P>
In diesem Kapitel habe ich versucht, einige besonders h&auml;ufig
gestellte Fragen mit den passenden Antworten zu sammeln. Die
Antworten auf die hier auftauchenden Probleme finden sich zwar auch
an anderer Stelle in der Anleitung, jedoch findet man sie vielleicht
nicht auf den ersten Blick...
<P>
<DL COMPACT>
<DT>F:<DD>Ich bin DOS leid. F&uuml;r welche Plattformen gibt es AS sonst ?</DD>
<DT>A:<DD>Neben der Protected-Mode-Version, die AS unter DOS mehr Speicher zur
    Verf&uuml;gung stellt, existieren Portierungen f&uuml;r OS/2 und
    Unix-Systeme wie z.B. Linux (im Teststadium). An Versionen, die
    Softwareherstellern in Redmond beim Geldscheffeln zuarbeiten
    w&uuml;rden, ist momentan nicht gedacht. Sofern jemand anders in
    dieser Hinsicht aktiv werden will, stelle ich ihm aber gerne die
    AS-Quellen zur Verf&uuml;gung, von denen sich die C-Variante
    insbesondere eignen d&uuml;rfte. &Uuml;ber Fragen zu diesen
    Quellen hinaus sollte er sich aber nicht viel von mir erwarten...
    </DD>
<DT>F:<DD>Ist eine Unterst&uuml;tzung des XYZ-Prozessors f&uuml;r AS
    geplant?</DD>
<DT>A:<DD>Es kommen immer neue Prozessoren heraus, und ich bem&uuml;he mich,
    bei Erweiterung von AS Schritt zu halten. Der Stapel mit der
    Aufschrift ,,Unerledigt'' auf meinem Schreibtisch unterschreitet
    aber selten die 10cm-Grenze... Bei der Planung, welche Kandidaten
    zuerst abgearbeitet werden, spielen W&uuml;nsche von Anwendern
    nat&uuml;rlich eine gro&szlig;e Rolle. Das Internet und die
    steigende Zahl elektronisch publizierter Dokumentation
    erleichtern die Beschaffung von Unterlagen, speziell bei
    ausgefallenen oder &auml;lteren Architekturen wird es aber immer
    wieder schwierig. Wenn sich die fragliche Prozessorfamilie nicht
    in der Liste in Planung befindlicher Prozessoren befindet (siehe
    Kapitel 1), macht es sich sehr gut, der Anfrage auch gleich ein
    passendes Datenbuch hinzuzupacken (zur Not auch leihweise!).
    </DD>
<DT>F:<DD>Ein freier Assembler ist ja eine feine Sache, aber eigentlich
    br&auml;uchte ich jetzt auch noch einen Disassembler...und einen
    Debugger...ein Simulator w&auml;re auch ganz nett..</DD>
<DT>A:<DD>AS ist ein Freizeitprojekt von mir, d.h. etwas, was ich in der Zeit
    tue, wenn ich mich nicht gerade um den Broterwerb k&uuml;mmere.
    Von dieser Zeit nimmt AS schon einen ganz erheblichen Teil ein,
    und ab und zu genehmige ich mir auch mal eine Auszeit, um den
    L&ouml;tkolben zu schwingen, mal wieder eine Tangerine
    Dream-Platte bewu&szlig;t zu h&ouml;ren, mich vor den Fernseher
    zu hocken oder einfach nur dringenden menschlichen
    Bed&uuml;rfnissen nachzugehen. Ich habe einmal angefangen, einen
    Disassembler zu konzipieren, der wieder voll reassemblierbaren
    Code erzeugt und automatisch Daten- und Code-Bereiche trennt,
    habe das Projekt aber relativ schnell wieder eingestellt, weil
    die restliche Zeit f&uuml;r so etwas einfach nicht mehr reicht.
    Ich mache lieber eine Sache gut als ein halbes Dutzend
    m&auml;&szlig;ig. Von daher mu&szlig; die Antwort also wohl
    ,,nein'' hei&szlig;en...
    </DD>
<DT>F:<DD>In den Bildschirmausgaben von AS tauchen seltsame Zeichen auf, z.B.
    Pfeile und eckige Klammern. Warum?</DD>
<DT>A:<DD>AS verwendet zur Bildschirmsteuerung defaultm&auml;&szlig;ig einige
    ANSI-Terminal-Steuersequenzen. Haben Sie keinen ANSI-Treiber
    installiert, so kommen diese Steuerzeichen ungefiltert auf Ihrem
    Bildschirm heraus. Installieren Sie entweder einen ANSI-Treiber
    oder schalten Sie die Steuersequenzen mit dem DOS-Befehl<TT> SET
    USEANSI=N</TT> ab.
    </DD>
<DT>F:<DD>W&auml;hrend der Assemblierung bricht AS pl&ouml;tzlich mit der
    Meldung eines Stapel&uuml;berlaufes ab. Ist mein Programm zu
    kompliziert?</DD>
<DT>A:<DD>Ja und Nein. Die Symboltabelle f&uuml;r Ihr Programm ist nur etwas
    unregelm&auml;&szlig;ig gewachsen, was zu zu hohen
    Rekursionstiefen im Zugriff auf die Tabelle gef&uuml;hrt hat.
    Diese Fehler treten insbesondere bei der 16-Bit-OS/2-Version von
    AS auf, die nur &uuml;ber einen relativ kleinen Stack
    verf&uuml;gt. Starten Sie AS noch einmal mit dem<TT>
    -A</TT>-Kommandozeilenschalter. Hilft dies auch nicht, so kommen
    als m&ouml;gliche Problemstellen noch zu komplizierte
    Formelausdr&uuml;cke in Frage. Versuchen Sie in einem solchen
    Fall, die Formel in Zwischenschritte aufzuspalten.
    </DD>
<DT>F:<DD>AS scheint mein Programm nicht bis zum Ende zu assemblieren. Mit
    einer &auml;lteren Version von AS (1.39) hat es dagegen
    funktioniert.</DD>
<DT>A:<DD>Neuere Versionen von AS ignorieren das<TT> END</TT>-Statement nicht
    mehr, sondern beenden danach wirklich die Assemblierung.
    Insbesondere bei Include-Dateien ist es fr&uuml;her vorgekommen,
    da&szlig; Anwender jede Datei mit einem<TT> END</TT>-Statement
    beendet haben. Entfernen Sie die &uuml;berfl&uuml;ssigen<TT>
    END</TT>s.
    </DD>
<DT>F:<DD>Weil ich noch ein paar kompliziertere Assemblierfehler im Programm
    hatte, habe ich mir ein Listing gemacht und es einmal genauer
    angeschaut. Dabei ist mir aufgefallen, da&szlig; einige
    Spr&uuml;nge nicht auf das gew&uuml;nschte Ziel, sondern auf sich
    selbst zeigen!</DD>
<DT>A:<DD>Dieser Effekt tritt bei Vorw&auml;rtsspr&uuml;ngen auf, bei denen der
    Formelparser von AS im ersten Pass die Zieladresse noch nicht
    kennen kann. Da der Formelparser ein unabh&auml;ngiges Modul ist,
    mu&szlig; er sich in einem solchen Fall einen Wert ausdenken, der
    auch relativen Spr&uuml;ngen mit kurzer Reichweite nicht wehtut,
    und dies ist nun einmal die aktuelle Programmz&auml;hleradresse
    selber...im zweiten Pass w&auml;ren die korrekten Werte
    erschienen, aber zu diesem ist es nicht gekommen, da schon im
    ersten Pass Fehler auftraten. Korrigieren Sie die anderen Fehler
    zuerst, so da&szlig; AS zum zweiten Pass kommt, und das Listing
    sollte wieder vern&uuml;nftiger aussehen.
    </DD>
<DT>F:<DD>Mein Programm wird zwar korrekt assembliert, bei der Umwandlung mit
    P2BIN oder P2HEX erhalte ich aber nur eine leere Datei.</DD>
<DT>A:<DD>Dann haben Sie wahrscheinlich das Adre&szlig;filter nicht korrekt
    eingestellt. Defaultm&auml;&szlig;ig ist der Filter abgeschaltet,
    d.h. alle Daten werden &uuml;bernommen, wenn ein manuell
    eingestellter Bereichsfilter nicht zu den benutzten Adressen
    pa&szlig;t, kann man mit der '-r' Option aber (versehentlich)
    auch leere Dateien erzeugen.
    </DD>
<DT>F:<DD>Ich bekomme unter Unix bei der Benutzung von P2BIN oder P2HEX das
    Dollarzeichen nicht eingegeben. Die automatische
    Bereichsfestlegung funktioniert nicht, stattdessen gibt es
    eigenartige Fehlermeldungen.</DD>
<DT>A:<DD>Unix-Shells benutzen das Dollarzeichen zur Expansion von
    Shell-Variablen. Wollen Sie ein Dollarzeichen an eine Anwendung
    durchreichen, stellen Sie einen Backslash (\) voran. Im Falle der
    Adre&szlig;angabe bei P2BIN und P2HEX darf aber auch<TT> 0x</TT>
    anstelle des Dollarzeichens benutzt werden, was dieses Problem
    von vornherein vermeidet.
    </DD>
<DT>F:<DD>Ich nutze AS auf einem Linux-System, das Ladeprogramm f&uuml;r mein
    Zielsystem l&auml;uft aber auf einem Windows-Rechner. Um das zu
    vereinfachen, greifen beide System auf das gleiche
    Netzwerklaufwerk zu. Leider will die Windows-Seite aber die von
    der Linux-Seite erzeugten Hex-Dateien nicht lesen :-(</DD>
<DT>A:<DD>Windows- und Linux-Systeme benutzen ein etwas abweichendes Format
    f&uuml;r Textdateien, unter die auch Hex-Dateien fallen.
    W&auml;hrend Windows jede Zeile mit den Zeichen CR (Carriage
    Return) und LF (Linefeed) abschlie&szlig;t, verwendet Linux nur
    ein Linefeed. Es h&auml;ngt nun von der ''Gutm&uuml;tigkeit''
    eines Windows-Programms ab, ob es die Dateien im Linux-Format
    akzeptiert. Falls nicht, kann man die Dateien anstelle &uuml;ber
    ein Netzwerklaufwerk &uuml;ber FTP im ASCII-Modus
    &uuml;bertragen, oder man konvertiert die Dateien unter ins
    Windows-Format. Das Programm<EM> unix2dos</EM> kann dazu z.B.
    verwendet werden, oder unter Linux ein kleines Script:
<PRE>

          awk '{print $0"\r"}' test.hex &gt;test_cr.hex

</PRE>
    </DD>
<DT>F:<DD>Ich habe in meinem Programm eine 16-bittige Adresse und mu&szlig; die
    obere und untere H&auml;lfte in getrennte CPU-Register laden. Wie
    extrahiere ich diese H&auml;lften? Bei anderen Assemblern gibt es
    daf&uuml;r eingebaute Funktionen.</DD>
<DT>A:<DD>Das geht zum einen ,,zu Fu&szlig;'' mit den logischen und
    Schiebeoperatoren, zum anderen bekommt man die Funktionen<TT>
    lo()</TT> und<TT> hi()</TT>, indem man die mitgelieferte
    Datei<TT> bitfuncs.inc</TT> in das Programm inkludiert.</DD>
</DL>
<P>

<H1><A NAME="sect_E_">E. Pseudobefehle und Integer-Syntax, gesammelt</A></H1>
<A NAME="ref_SectPseudoInst"></A>
<P>
In diesem Anhang finden sich noch einmal als schnelle Referenz alle
von AS zur Verf&uuml;gung gestellten Pseudobefehle. Die Liste ist in
zwei Teile gegliedert: Im ersten Teil finden sich Befehle, die
unabh&auml;ngig vom eingestellten Zielprozessor vorhanden sind,
danach folgen f&uuml;r jede Prozessorfamilie die zus&auml;tzlich
vorhandenen Befehle:
<P>

<H4>Immer vorhandene Befehle</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> =</TT></TD><TD NOWRAP><TT> :=</TT></TD><TD NOWRAP><TT> ALIGN</TT></TD><TD NOWRAP><TT> BINCLUDE</TT></TD><TD NOWRAP><TT> CASE</TT></TD></TR>
<TR><TD NOWRAP><TT> CHARSET</TT></TD><TD NOWRAP><TT> CPU</TT></TD><TD NOWRAP><TT> DEPHASE</TT></TD><TD NOWRAP><TT> DOTTEDSTRUCTS</TT></TD><TD NOWRAP><TT> ELSE</TT></TD></TR>
<TR><TD NOWRAP><TT> ELSECASE</TT></TD><TD NOWRAP><TT> ELSEIF</TT></TD><TD NOWRAP><TT> END</TT></TD><TD NOWRAP><TT> ENDCASE</TT></TD><TD NOWRAP><TT> ENDIF</TT></TD></TR>
<TR><TD NOWRAP><TT> ENDM</TT></TD><TD NOWRAP><TT> ENDS</TT></TD><TD NOWRAP><TT> ENDSECTION</TT></TD><TD NOWRAP><TT> ENDSTRUCT</TT></TD><TD NOWRAP><TT> ENUM</TT></TD></TR>
<TR><TD NOWRAP><TT> ENUMCONF</TT></TD><TD NOWRAP><TT> ERROR</TT></TD><TD NOWRAP><TT> EQU</TT></TD><TD NOWRAP><TT> .EQU</TT></TD><TD NOWRAP><TT> EVAL</TT></TD></TR>
<TR><TD NOWRAP><TT> EXITM</TT></TD><TD NOWRAP><TT> FATAL</TT></TD><TD NOWRAP><TT> FORWARD</TT></TD><TD NOWRAP><TT> FUNCTION</TT></TD><TD NOWRAP><TT> GLOBAL</TT></TD></TR>
<TR><TD NOWRAP><TT> IF</TT></TD><TD NOWRAP><TT> IFB</TT></TD><TD NOWRAP><TT> IFDEF</TT></TD><TD NOWRAP><TT> IFEXIST</TT></TD><TD NOWRAP><TT> IFNB</TT></TD></TR>
<TR><TD NOWRAP><TT> IFNDEF</TT></TD><TD NOWRAP><TT> IFNEXIST</TT></TD><TD NOWRAP><TT> IFNSYMEXIST</TT></TD><TD NOWRAP><TT> IFNUSED</TT></TD><TD NOWRAP><TT> IFSYMEXIST</TT></TD></TR>
<TR><TD NOWRAP><TT> IFUSED</TT></TD><TD NOWRAP><TT> INCLUDE</TT></TD><TD NOWRAP><TT> INTSYNTAX</TT></TD><TD NOWRAP><TT> IRP</TT></TD><TD NOWRAP><TT> LABEL</TT></TD></TR>
<TR><TD NOWRAP><TT> LISTING</TT></TD><TD NOWRAP><TT> MACEXP</TT></TD><TD NOWRAP><TT> MACECP_DFT</TT></TD><TD NOWRAP><TT> MACEXP_OVR</TT></TD><TD NOWRAP><TT> MACRO</TT></TD></TR>
<TR><TD NOWRAP><TT> MESSAGE</TT></TD><TD NOWRAP><TT> NEWPAGE</TT></TD><TD NOWRAP><TT> NEXTENUM</TT></TD><TD NOWRAP><TT> ORG</TT></TD><TD NOWRAP><TT> .PAGE</TT></TD></TR>
<TR><TD NOWRAP><TT> PHASE</TT></TD><TD NOWRAP><TT> POPV</TT></TD><TD NOWRAP><TT> PUSHV</TT></TD><TD NOWRAP><TT> PRTEXIT</TT></TD><TD NOWRAP><TT> PRTINIT</TT></TD></TR>
<TR><TD NOWRAP><TT> PUBLIC</TT></TD><TD NOWRAP><TT> READ</TT></TD><TD NOWRAP><TT> RELAXED</TT></TD><TD NOWRAP><TT> REPT</TT></TD><TD NOWRAP><TT> .RESTORE</TT></TD></TR>
<TR><TD NOWRAP><TT> RESTOREENV</TT></TD><TD NOWRAP><TT> RORG</TT></TD><TD NOWRAP><TT> .SAVE</TT></TD><TD NOWRAP><TT> SAVEENV</TT></TD><TD NOWRAP><TT> SECTION</TT></TD></TR>
<TR><TD NOWRAP><TT> SEGMENT</TT></TD><TD NOWRAP><TT> .SET</TT></TD><TD NOWRAP><TT> SHARED</TT></TD><TD NOWRAP><TT> .SHIFT</TT></TD><TD NOWRAP><TT> STRUC</TT></TD></TR>
<TR><TD NOWRAP><TT> STRUCT</TT></TD><TD NOWRAP><TT> .SWITCH</TT></TD><TD NOWRAP><TT> TITLE</TT></TD><TD NOWRAP><TT> UNION</TT></TD><TD NOWRAP><TT> WARNING</TT></TD></TR>
<TR><TD NOWRAP><TT> WHILE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT> Zus&auml;tzlich existieren:
<UL>
<LI> <TT>SET</TT> als Alias zu<TT> EVAL</TT>, falls<TT> SET</TT> nicht
    bereits ein Prozessorbefehl ist.</LI>
<LI> <TT>SHIFT</TT> bzw.<TT> SHFT</TT>, falls<TT> SHIFT</TT> bereits ein
    Prozessorbefehl ist.</LI>
<LI> <TT>RESTORE</TT> als Alias zu<TT> RESTOREENV</TT>, falls<TT>
    RESTORE</TT> nicht bereits ein Prozessorbefehl ist.</LI>
<LI> <TT>SAVE</TT> als Alias zu<TT> SAVEENV</TT>, falls<TT> SAVE</TT>
    nicht bereits ein Prozessorbefehl ist.</LI>
<LI> <TT>PAGE</TT> bzw.<TT> PAGESIZE</TT>, falls<TT> PAGE</TT> bereits
    ein Prozessorbefehl ist.</LI>
<LI> <TT>SWITCH</TT> bzw.<TT> SELECT</TT>, falls<TT> SWITCH</TT> bereits
    ein Prozessorbefehl ist.</LI>
</UL>
<P>

<H4>Motorola 680x0/MCF5xxx</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> FULLPMMU</TT></TD><TD NOWRAP><TT> FPU</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT> PMMU</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 56xxx</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> PACKING</TT></TD><TD NOWRAP><TT> XSFR</TT></TD><TD NOWRAP><TT> YSFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>PowerPC</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIGENDIAN</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>IBM PALM</H4>
<P>
<EM> Default Integer Syntax: IBM</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola M-Core</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola XGATE</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD></TR>
<TR><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 68xx/Hitachi 63xx</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DFS</TT></TD></TR>
<TR><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD></TR>
<TR><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> PRWINS(68HC11K4)</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola/Freescale 6805/68HC(S)08</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DFS</TT></TD></TR>
<TR><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD></TR>
<TR><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 6809/Hitachi 6309</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD></TR>
<TR><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD></TR>
<TR><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> PLAINBASE</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Konami 052001</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;] DFS</TT></TD></TR>
<TR><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD></TR>
<TR><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 68HC12</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DFS</TT></TD></TR>
<TR><TD NOWRAP><TT> DS[.&lt;size&gt;] DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD></TR>
<TR><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NXP S12Z</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DEFBIT</TT></TD></TR>
<TR><TD NOWRAP><TT> DEFBITFIELD</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD></TR>
<TR><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 68HC16</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD></TR>
<TR><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD></TR>
<TR><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Freescale 68RS08</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD></TR>
<TR><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD></TR>
<TR><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Hitachi H8/300(L/H)</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> MAXMODE</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Hitachi H8/500</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> COMPMODE</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD></TR>
<TR><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> MAXMODE</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Hitachi SH7x00</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> COMPLITERALS</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> LTORG</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Hitachi HMCS400</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Hitachi H16</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>65xx/MELPS-740</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DCB</TT></TD></TR>
<TR><TD NOWRAP><TT> DDB</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD></TR>
<TR><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>65816/MELPS-7700</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DDB</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD></TR>
<TR><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Mitsubishi MELPS-4500</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Rockwell PPS-4</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> RES</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Mitsubishi M16</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Mitsubishi M16C</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>DEC PDP-11</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> CIS</TT></TD><TD NOWRAP><TT> EIS</TT></TD><TD NOWRAP><TT> FIS</TT></TD><TD NOWRAP><TT> FLT2</TT></TD></TR>
<TR><TD NOWRAP><TT> FLT4</TT></TD><TD NOWRAP><TT> FP11</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>WD16</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASCII</TT></TD><TD NOWRAP><TT> ASCIZ</TT></TD><TD NOWRAP><TT>BYTE</TT></TD><TD NOWRAP><TT> FLT3</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>DEC VAX</H4>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ACCMODE</TT></TD><TD NOWRAP><TT> ASCIC</TT></TD><TD NOWRAP><TT> ASCII</TT></TD><TD NOWRAP><TT> ASCIZ</TT></TD><TD NOWRAP><TT> BLKB</TT></TD></TR>
<TR><TD NOWRAP><TT> BLKD</TT></TD><TD NOWRAP><TT> BLKF</TT></TD><TD NOWRAP><TT> BLKG</TT></TD><TD NOWRAP><TT> BLKH</TT></TD><TD NOWRAP><TT> BLKL</TT></TD></TR>
<TR><TD NOWRAP><TT> BLKO</TT></TD><TD NOWRAP><TT> BLKQ</TT></TD><TD NOWRAP><TT> BLKW</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> D_FLOATING</TT></TD></TR>
<TR><TD NOWRAP><TT> DOUBLE</TT></TD><TD NOWRAP><TT> F_FLOATING</TT></TD><TD NOWRAP><TT> FLOAT</TT></TD><TD NOWRAP><TT> G_FLOATING</TT></TD><TD NOWRAP><TT> H_FLOATING</TT></TD></TR>
<TR><TD NOWRAP><TT> LONG</TT></TD><TD NOWRAP><TT> OCTA</TT></TD><TD NOWRAP><TT> QUAD</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Olympia CP-3F/GI LP8000/SGS M380</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel 4004/4040</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel 8008</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DFB</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT> Z80SYNTAX</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel MCS-48</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel MCS-(2)51</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIGENDIAN</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> SFRB</TT></TD><TD NOWRAP><TT> SRCMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel MCS-96</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>

<H4>Intel 8080/8085</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel 8086/80186/NEC V20...V5x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel i960</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FPU</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT> SPACE</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Signetics 8X30x</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> LIV</TT></TD><TD NOWRAP><TT> RIV</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Signetics 2650</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ACON</TT></TD><TD NOWRAP><TT> BIGENDIAN</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT> RES</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Philips XA</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Atmel AVR</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT> PACKING</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>AMD 29K</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> EMULATED</TT></TD></TR>
<TR><TD NOWRAP><TT> ERG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Siemens 80C166/167</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Zilog Zx80</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DEFB</TT></TD><TD NOWRAP><TT> DEFW</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT> EXTMODE</TT></TD><TD NOWRAP><TT> LWORDMODE</TT></TD><TD NOWRAP><TT> PRWINS(Z(1,2)80)</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE (Z280)</TT></TD></TR>
<TR><TD NOWRAP><TT> WARNRELATIVE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Zilog Z8</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DEFBIT</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Zilog Z8000</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DEFBIT</TT></TD><TD NOWRAP><TT> DEFBITB</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Xilinx KCPSM</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> CONSTANT</TT></TD><TD NOWRAP><TT> NAMEREG</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Xilinx KCPSM3</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> CONSTANT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> NAMEREG</TT></TD></TR>
<TR><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>LatticeMico8</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-900</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> MAXIMUM</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-90</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-870(/C)</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-47(0(A))</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-42</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-9000</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TC9331</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Microchip PIC16C5x</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Microchip PIC16C8x</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Microchip PIC17C42</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Parallax SX20</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>SGS-Thomson ST6</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASCII</TT></TD><TD NOWRAP><TT> ASCIZ</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> BYTE</TT></TD></TR>
<TR><TD NOWRAP><TT> BLOCK</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>SGS-Thomson ST7/STM8</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>SGS-Thomson ST9</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>6804</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments TMS3201x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> RES</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments TMS32C02x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BFLOAT</TT></TD><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DOUBLE</TT></TD></TR>
<TR><TD NOWRAP><TT> EFLOAT</TT></TD><TD NOWRAP><TT> TFLOAT</TT></TD><TD NOWRAP><TT> LONG</TT></TD><TD NOWRAP><TT> LQxx</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT> Qxx</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> RSTRING</TT></TD><TD NOWRAP><TT> STRING</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments TMS320C3x/C4x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> EXTENDED</TT></TD><TD NOWRAP><TT> PACKING</TT></TD></TR>
<TR><TD NOWRAP><TT> SINGLE</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments TM32C020x/TM32C05x/TM32C054x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BFLOAT</TT></TD><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DOUBLE</TT></TD></TR>
<TR><TD NOWRAP><TT> EFLOAT</TT></TD><TD NOWRAP><TT> TFLOAT</TT></TD><TD NOWRAP><TT> LONG</TT></TD><TD NOWRAP><TT> LQxx</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT> Qxx</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> RSTRING</TT></TD><TD NOWRAP><TT> STRING</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments TMS320C6x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DOUBLE</TT></TD><TD NOWRAP><TT> PACKING</TT></TD><TD NOWRAP><TT> SINGLE</TT></TD></TR>
<TR><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments TMS99xx</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DOUBLE</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> SINGLE</TT></TD></TR>
<TR><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments Instruments TMS1000</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments TMS70Cxx</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments TMS370</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DBIT</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas Instruments MSP430</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National IMP-16</H4>
<P>
<EM> Default Integer Syntax: IBM</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASCII</TT></TD><TD NOWRAP><TT> LTORG</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National IPC-16/INS8900</H4>
<P>
<EM> Default Integer Syntax: IBM</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASCII</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> LTORG</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National SC/MP</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASCII</TT></TD><TD NOWRAP><TT> BIGENDIAN</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DBYTE</TT></TD></TR>
<TR><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>

<H4>National INS807x</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>

<H4>National COP4</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADDR</TT></TD><TD NOWRAP><TT> ADDRW</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DSB</TT></TD><TD NOWRAP><TT> DSW</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FB</TT></TD><TD NOWRAP><TT> FW</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National COP8</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADDR</TT></TD><TD NOWRAP><TT> ADDRW</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DSB</TT></TD><TD NOWRAP><TT> DSW</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FB</TT></TD><TD NOWRAP><TT> FW</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National SC14xxx</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DC8</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DS8</TT></TD><TD NOWRAP><TT> DS16</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> DW16</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National NS32xxx</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIGENDIAN</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> CUSTOM</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DOUBLE</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FLOAT</TT></TD><TD NOWRAP><TT> FPU</TT></TD><TD NOWRAP><TT> LONG</TT></TD><TD NOWRAP><TT> PMMU</TT></TD></TR>
<TR><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Fairchild ACE</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Fairchild F8</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC &micro;PD7800...&micro;PD7806, &micro;PD78(C)1x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> Z80SYNTAX</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC &micro;PD7807...&micro;PD7809</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DEFBIT</TT></TD><TD NOWRAP><TT>DD</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 75xx</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC &micro;COM-43</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 75K0</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD></TR>
<TR><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 78K0</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 78K2</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 78K3</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 78K4</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC &micro;PD772x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> PACKING</TT></TD><TD NOWRAP><TT> RES</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC &micro;PD77230</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PACKING</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC V60</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Symbios Logic SYM53C8xx</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Fujitsu F<SUP>2</SUP>MC8L</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Fujitsu F<SUP>2</SUP>MC16L</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>OKI OLMS-40</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>OKI OLMS-50</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Panafacom MN161x</H4>
<P>
<EM> Default Integer Syntax: IBM</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> PACKING</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Padauk PMC/PMS/PFSxxx</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intersil 180x</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>XMOS XS1</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>ATARI Vector</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>MIL STD 1750</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> EXTENDED</TT></TD><TD NOWRAP><TT> FLOAT</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>KENBAK</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DO</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>CP-1600</H4>
<P>
<EM> Default Integer Syntax: IBM (hex), C (oct)</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> PACKING</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> TEXT</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>HP Nano Processor</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>IM61x0</H4>
<P>
<EM> Default Integer Syntax: C</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DECIMAL</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> LTORG</TT></TD><TD NOWRAP><TT> OCTAL</TT></TD></TR>
<TR><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Renesas RX</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BLKB</TT></TD><TD NOWRAP><TT> BLKW</TT></TD><TD NOWRAP><TT> BLKL</TT></TD><TD NOWRAP><TT> BLKD</TT></TD><TD NOWRAP><TT> BYTE</TT></TD></TR>
<TR><TD NOWRAP><TT> DOUBLE</TT></TD><TD NOWRAP><TT> ENDIAN</TT></TD><TD NOWRAP><TT> FLOAT</TT></TD><TD NOWRAP><TT> LWORD</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Sharp SC61860</H4>
<P>
<EM> Default Integer Syntax: Motorola</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DFS</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD></TR>
<TR><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Sharp SC62015</H4>
<P>
<EM> Default Integer Syntax: Intel</EM>
<P>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DN</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DO</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H1><A NAME="sect_F_">F. Vordefinierte Symbole</A></H1>
<A NAME="ref_AppInternSyms"></A>
<P>
<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datentyp</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Definition</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ARCHITECTURE</TT><BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Zielplattform, f&uuml;r die AS<BR>
&uuml;bersetzt wurde, in der Form<BR>
Prozesor-Hersteller-Betriebs-<BR>
system</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> BIGENDIAN</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>normal<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Konstantenablage mit MSB<BR>
first ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> CASESENSITIVE</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>normal<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Unterscheidung von Gro&szlig;-<BR>
und Kleinbuchstaben in<BR>
Symbolnamen ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> CONSTPI</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Gleitkomma</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>normal</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Kreiszahl Pi (3.1415.....)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DATE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Datum des Beginns der<BR>
Assemblierung (1.Pass)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> FALSE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0 = logisch ,,falsch''</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> HASFPU</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Koprozessor-Befehle<BR>
freigeschaltet ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> HASPMMU</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>MMU-Befehle frei-<BR>
geschaltet ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INEXTMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>XM-Flag f&uuml;r 4 Gbyte<BR>
Adre&szlig;raum gesetzt ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INLWORDMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LW-Flag f&uuml;r 32-Bit-Befehle<BR>
gesetzt ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INMAXMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Prozessor im Maximum-<BR>
Modus ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INSUPMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Prozessor im Supervisor-<BR>
Modus ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INSRCMODE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Prozessor im Quellmodus ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> FULLPMMU</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0/1)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>voller PMMU-Befehlssatz ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LISTON</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(1)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Listing freigeschaltet ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MACEXP</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(1)<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Expansion von Makrokon-<BR>
strukten im Listing<BR>
freigeschaltet ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMCPU</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.<BR>
(68008)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Nummer der momentan<BR>
gesetzten Ziel-CPU</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMCPUNAME</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.<BR>
(68008)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Name der momentan<BR>
gesetzten Ziel-CPU</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMFILE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>augenblickliche Quelldatei<BR>
(schlie&szlig;t Includes ein)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMLINE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>aktuelle Zeilennummer in<BR>
der Quelldatei</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMPASS</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Nummer des laufenden<BR>
Durchgangs</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMSECTION</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Name der aktuellen Sektion<BR>
oder Leerstring, fall au&szlig;er-<BR>
halb aller Sektionen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMSEGMENT</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Name des mit<TT> SEGMENT</TT> ein-<BR>
gestellten Adre&szlig;raumes</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> NESTMAX</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(256)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>maximale Verschachtelungs-<BR>
tiefe f&uuml;r Makros</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> PADDING</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(1)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Auff&uuml;llen von Bytefeldern<BR>
auf ganze Anzahl ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> RELAXED</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Schreibweise von Integer-Kon-<BR>
stanten in beliebiger Syntax<BR>
erlaubt ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> PC</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>mom. Programmz&auml;hler<BR>
(Thomson)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> TIME</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Zeit des Beginns der Assem-<BR>
blierung (1. Pass)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> TRUE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1 = logisch ,,wahr''</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> VERSION</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Version von AS in BCD-Kodie-<BR>
rung, z.B. 1331 hex f&uuml;r<BR>
Version 1.33p1</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> WRAPMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>verk&uuml;rzter Programmz&auml;hler<BR>
angenommen?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT> *<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>mom. Programmz&auml;hler<BR>
(Motorola, Rockwell,<BR>
Microchip, Hitachi)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>.<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>mom. Programmz&auml;hler<BR>
(IM61x0)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>mom. Programmz&auml;hler (Intel,<BR>
Zilog, Texas, Toshiba, NEC,<BR>
Siemens, AMD)</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>
Boolean-Symbole sind eigentlich normale normale Integer-Symbole, mit
dem Unterschied, da&szlig; ihnen von AS nur zwei verschiedene Werte
(0 oder 1, entsprechend FALSE oder TRUE) zugewiesen werden.
Spezialsymbole werden von AS nicht in der Symboltabelle abgelegt,
sondern aus Geschwindigkeitsgr&uuml;nden direkt im Parser abgefragt.
Sie tauchen daher auch nicht in der Symboltabelle des Listings auf.
W&auml;hrend vordefinierte Symbole nur einmal am Anfang eines Passes
besetzt werden, k&ouml;nnen sich die Werte dynamischer Symbole
w&auml;hrend der Assemblierung mehrfach &auml;ndern, da sie mit
anderen Befehlen vorgenommene Einstellungen widerspiegeln.
<P>
Die hier aufgelistete Schreibweise ist diejenige, mit der man die
Symbole auch im case-sensitiven Modus erreicht.
<P>
Die hier aufgef&uuml;hrten Namen sollte man f&uuml;r eigene Symbole
meiden; entweder kann man sie zwar definieren, aber nicht darauf
zugreifen (bei Spezialsymbolen), oder man erh&auml;lt eine
Fehlermeldung wegen eines doppelt definierten Symboles. Im gemeinsten
Fall f&uuml;hrt die Neubelegung durch AS zu Beginn eines Passes zu
einem Phasenfehler und einer Endlosschleife...
<P>

<H1><A NAME="sect_G_">G. Mitgelieferte Includes</A></H1>
<P>
Der Distribution von AS liegen eine Reihe von Include-Dateien bei.
Neben Includes, die sich nur auf eine Prozessorfamilie beziehen (und
deren Funktion sich demjenigen unmittelbar erschlie&szlig;t, der mit
dieser Familie arbeitet), existieren aber auch ein paar Dateien, die
prozessorunabh&auml;ngig sind und die eine Reihe n&uuml;tzlicher
Funktionen implementieren. Die definierten Funktionen sollen hier
kurz beschrieben werden:
<P>

<H2><A NAME="sect_G_1_">G.1. BITFUNCS.INC</A></H2>
<P>
Diese Datei definiert eine Reihe bitorientierter Operationen, wie man
sie bei anderen Assemblern vielleicht fest eingebaut sind. Bei AS
werden sie jedoch mit Hilfe benutzerdefinierter Funktionen
implementiert:
<P>
<UL>
<LI> <EM> mask(start,bits)</EM> liefert einen Integer, in dem ab
    Stelle<EM> start</EM><EM> bits</EM> Bits gesetzt sind;</LI>
<LI> <EM> invmask(start,bits)</EM> liefert das Einerkomplement zu<EM>
    mask()</EM>;</LI>
<LI> <EM> cutout(x,start,bits)</EM> liefert ausmaskierte<EM> bits</EM>
    Bits ab Stelle<EM> start</EM> aus<EM> x</EM>, ohne sie auf Stelle
    0 zu verschieben;</LI>
<LI> <EM> hi(x)</EM> liefert das zweitniedrigste Byte (Bit 8..15) aus<EM>
    x</EM>;</LI>
<LI> <EM> lo(x)</EM> liefert das niederwertigste Byte (Bit 0..7) aus<EM>
    x</EM>;</LI>
<LI> <EM> hiword(x)</EM> liefert das zweitniedrigste Wort (Bit 16..31)
    aus<EM> x</EM>;</LI>
<LI> <EM> loword(x)</EM> liefert das niederwertigste Wort (Bit 0..15)
    aus<EM> x</EM>;</LI>
<LI> <EM> odd(x)</EM> liefert TRUE, falls<EM> x</EM> ungerade ist;</LI>
<LI> <EM> even(x)</EM> liefert TRUE, falls<EM> x</EM> gerade ist;</LI>
<LI> <EM> getbit(x,n)</EM> extrahiert das Bit<EM> n</EM> aus<EM> x</EM>
    und liefert es als 0 oder 1;</LI>
<LI> <EM> shln(x,size,n)</EM> schiebt ein Wort<EM> x</EM> der
    L&auml;nge<EM> size</EM> Bits um<EM> n</EM> Stellen nach
    links;</LI>
<LI> <EM> shrn(x,size,n)</EM> schiebt ein Wort<EM> x</EM> der
    L&auml;nge<EM> size</EM> Bits um<EM> n</EM> Stellen nach
    rechts;</LI>
<LI> <EM> rotln(x,size,n)</EM> rotiert die untersten<EM> size</EM> Bits
    eines Integers<EM> x</EM> um<EM> n</EM> Stellen nach links;</LI>
<LI> <EM> rotrn(x,size,n)</EM> rotiert die untersten<EM> size</EM> Bits
    eines Integers<EM> x</EM> um<EM> n</EM> Stellen nach rechts;</LI>
</UL>
<P>

<H2><A NAME="sect_G_2_">G.2. CTYPE.INC</A></H2>
<P>
Dieser Include ist das Pendant zu dem bei C vorhandenen Header<TT>
ctype.h</TT>, der Makros zur Klassifizierung von Zeichen anbietet.
Alle Funktionen liefern entweder TRUE oder FALSE:
<P>
<UL>
<LI> <EM> isdigit(ch)</EM> ist TRUE, falls<EM> ch</EM> eine Ziffer (0..9)
    ist;</LI>
<LI> <EM> isxdigit(ch)</EM> ist TRUE, falls<EM> ch</EM> eine g&uuml;ltige
    Hexadezimal-Ziffer (0..9, A..F, a..f) ist;</LI>
<LI> <EM> isascii(ch)</EM> ist TRUE, falls<EM> ch</EM> sich im Bereich
    normaler ASCII-Zeichen ohne gesetztes Bit 7 bewegt;</LI>
<LI> <EM> isupper(ch)</EM> ist TRUE, falls<EM> ch</EM> ein
    Gro&szlig;buchstabe ist (Sonderzeichen ausgenommen);</LI>
<LI> <EM> islower(ch)</EM> ist TRUE, falls<EM> ch</EM> ein Kleinbuchstabe
    ist (Sonderzeichen ausgenommen);</LI>
<LI> <EM> isalpha(ch)</EM> ist TRUE, falls<EM> ch</EM> ein Buchstabe ist
    (Sonderzeichen ausgenommen);</LI>
<LI> <EM> isalnum(ch)</EM> ist TRUE, falls<EM> ch</EM> ein Buchstabe oder
    eine Ziffer ist);</LI>
<LI> <EM> isspace(ch)</EM> ist TRUE, falls<EM> ch</EM> ein 'Leerzeichen'
    (Space, Formfeed, Zeilenvorschub, Wagenr&uuml;cklauf, Tabulator)
    ist);</LI>
<LI> <EM> isprint(ch)</EM> ist TRUE, falls<EM> ch</EM> ein druckbares
    Zeichen ist (also kein Steuerzeichen bis Code 31);</LI>
<LI> <EM> iscntrl(ch)</EM> ist das Gegenteil zu<EM> isprint()</EM>;</LI>
<LI> <EM> isgraph(ch)</EM> ist TRUE, falls<EM> ch</EM> ein druckbares
    und<I> sichtbares</I> Zeichen ist;</LI>
<LI> <EM> ispunct(ch)</EM> ist TRUE, falls<EM> ch</EM> ein druckbares
    Sonderzeichen ist (d.h. weder Space, Buchstabe noch Ziffer);</LI>
</UL>
<P>

<H1><A NAME="sect_H_">H. Danksagungen</A></H1>
<P>
<BLOCKQUOTE>
    <I> ''If I have seen farther than other men,<BR>
    it is because I stood on the shoulders of giants.''<BR>
              --Sir Isaac Newton</I>
</BLOCKQUOTE>
<BLOCKQUOTE>
    <I> ''If I haven't seen farther than other men,<BR>
    it is because I stood in the footsteps of giants.''<BR>
              --unknown</I>
</BLOCKQUOTE>
<P>
Es hei&szlig;t ja bisweilen, die Programme, die man schreibe,
w&auml;ren so etwas wie eigene Kinder, die man in die Welt setzt. Ich
arbeite an diesem Assembler seit &uuml;ber 30 Jahren, und bin
mittlerweile der Ansicht, so ein Projekt ist viel mehr eine Reise,
auf die man sich begibt: Die Begegnungen mit Menschen, die man auf
den Stationen dieses Weges trifft, sind mindestens eben so wichtig
wie das vermeintliche Ziel selber. Man lernt Neues kennen, und
versteht im besten Falle, da&szlig; man Dinge auch aus einer ganz
anderen Warte sehen kann. Wenn es gut l&auml;uft, bringt das dann
beide Seiten weiter.
<P>
Einige Menschen sind mir auf diesem Weg besonders in Erinnerung
geblieben, weil sie auf ihre Weise dazu beigetragen haben, dieses
Projekt dorthin zu bringen, wo es jetzt ist. Die folgende
Aufz&auml;hlung ist notwendigerweise unvollst&auml;ndig, einfach weil
ich mich nach den Jahren nicht mehr an jede Begebenheit erinnere. Der
zuvorderste Dank gent daher an all die Personen, deren Namen ich in
diesem Kapitel unabsichtlich unterschlagen habe. Die Reise geht immer
noch weiter, und vielleicht kreuzen sich die Wege wieder!
<P>
AS als Universalassembler, wie er jetzt besteht, ist auf Anregung von
Bernhard (C.) Zschocke entstanden, der einen
,,studentenfreundlichen'', d.h. kostenlosen 8051-Assembler f&uuml;r
sein Mikroprozessorpraktikum brauchte und mich dazu bewegt hat, einen
bereits bestehenden 68000-Assembler zu erweitern. Von dortan nahm die
Sache ihren Lauf... Das Mikroprozessorpraktikum an der RWTH Aachen
hat auch immer die eifrigsten Nutzer der neuesten AS-Features (und
damit Bug-Sucher) gestellt und damit einiges zur jetzigen
Qualit&auml;t von AS beigetragen.
<P>
Das Internet und FTP haben sich als gro&szlig;e Hilfe bei der Meldung
von Bugs und der Verbreitung von AS erwiesen. Ein Dank geht daher an
die FTP-Administratoren (Bernd Casimir in Stuttgart, Norbert Breidohr
in Aachen und J&uuml;rgen Mei&szlig;burger in J&uuml;lich).
Insbesondere letzterer hat sich sehr engagiert, um eine praxisnahe
L&ouml;sung im ZAM zu finden.
<P>
Ach ja, wo wir schon im ZAM sind: Wolfgang E. Nagel hat zwar nichts
direkt mit AS zu tun, immerhin war er aber mein Betreuer und
Vorgesetzter und warf st&auml;ndig vier Augen auf das, was ich tue.
Bei AS scheint zumindest ein lachendes dabei zu sein...
<P>
Ein Projekt wie AS ist ohne Input und Informationen nicht zu leisten,
sei es zu den unterst&uuml;tzten Prozessoren selber, zu
Programmiertechniken oder wie Dinge implementiert werden sollten. Ich
habe von einer enormen Anzahl von Menschen R&uuml;ckmeldungen
bekommen, die von einem kleinen Tip bis zu ganzen Datenb&uuml;chern
reichen. Hier eine Aufz&auml;hlung (wie wie oben gesagt, mit
Sicherheit unvollst&auml;ndig ist!):
<P>
Ernst Ahlers, Charles Altmann, Marco Awater, Len Bayles, Andreas
Bolsch, Rolf Buchholz, Bernd Casimir, Nils Eilers, Gunther Ewald,
Daniel E. Germann Michael Haardt, Stephan Hruschka, Fred van Kempen,
Peter Kliegelh&ouml;fer, Ulf Meinke, Udo M&ouml;ller, Matthias Paul,
Norbert Rosch, Curt J. Sampson, Steffen Schmid, Leonhard Schneider,
Ernst Schwab, Michael Schwingen, Oliver Sellke, Christian Stelter,
Patrik Str&ouml;mdahl, Tadashi G. Takaoka, Oliver Thamm, Thorsten
Thiele, Leszek Ulman, Rob Warmelink, Andreas Wassatsch, John
Weinrich,
<P>
...und ein leicht ironischer Dank geht an Rolf-Dieter-Klein und
Tobias Thiel, die mich mit ihren ASM68K dazu angeregt haben,
&uuml;berhaupt einen eigenen Assembler zu schreiben. einige Dinge
darin funktionierten nicht so, wie ich es mir vorgestellt hatte, und
das war der Anlass, es besser oder zumindest anders zu machen.
<P>
So ganz allein habe ich AS auch nicht geschrieben. Die DOS-Version
von AS enthielt die OverXMS-Routinen von Wilbert van Leijen, um die
Overlay-Module ins Extended Memory verlagern zu k&ouml;nnen. Eine
wirklich feine Sache, einfach und problemlos anzuwenden!
<P>
Die TMS320C2x/5x-Codegeneratoren sowie die Datei<TT>
STDDEF2x.INC</TT> stammen von Thomas Sailer, ETH Z&uuml;rich.
Erstaunlich, an einem Wochenende hat er es geschafft, durch meinen
Code durchzusteigen und den neuen Generator zu implementieren.
Entweder waren das reichliche Nachtschichten oder ich werde langsam
alt...gleiches Lob geb&uuml;hrt Haruo Asano f&uuml;r die Targets
MN1610/MN1613, IM6100, CP1600, Renesas RX und HP NanoProcessor.
<P>

<H1><A NAME="sect_I_">I. &Auml;nderungen seit Version 1.3</A></H1>
<P>
<UL>
<LI> Version 1.31:
<UL>
<LI>     zus&auml;tzlicher MCS-51-Prozessortyp 80515. Die Nummer wird
        wiederum nur vom Assembler verwaltet. Die Datei STDDEF51.INC
        wurde um die dazugeh&ouml;rigen SFRs erweitert.<B>
        ACHTUNG!</B> Einige 80515-SFRs haben sich
        adre&szlig;m&auml;&szlig;ig verschoben!</LI>
<LI>     zus&auml;tzlich Prozessor Z80 unterst&uuml;tzt;</LI>
<LI>     schnellerer 680x0-Codegenerator.</LI>
</UL>
 </LI>
<LI> Version 1.32:
<UL>
<LI>     Schreibweise von Zeropageadressen f&uuml;r 65xx nicht mehr als
        Adr.z, sondern wie beim 68xx als &lt;Adr;</LI>
<LI>     unterst&uuml;tzt die Prozessoren 6800, 6805, 6301 und 6811;</LI>
<LI>     der 8051-Teil versteht jetzt auch<TT> DJNZ</TT>,<TT> PUSH</TT>
        und<TT> POP</TT> (sorry);</LI>
<LI>     im Listing werden neben den Symbolen jetzt auch die definierten
        Makros aufgelistet;</LI>
<LI>     Befehle<TT> IFDEF</TT>/<TT>IFNDEF</TT> f&uuml;r bedingte
        Assemblierung, mit denen sich die Existenz eines Symboles
        abfragen l&auml;&szlig;t;</LI>
<LI>     Befehle<TT> PHASE</TT>/<TT>DEPHASE</TT> zur Unterst&uuml;tzung
        von Code, der zur Laufzeit auf eine andere Adresse verschoben
        werden soll;</LI>
<LI>     Befehle<TT> WARNING</TT>/<TT>ERROR</TT>/<TT>FATAL</TT>, um
        anwenderspezifische Fehlermeldungen ausgeben zu
        k&ouml;nnen;</LI>
<LI>     Die Datei STDDEF51.INC enth&auml;lt zus&auml;tzlich das
        Makro<TT> USING</TT> zur einfacheren Handhabung der
        Registerb&auml;nke der MCS-51er;</LI>
<LI>     Kommandozeilenoption<TT> u</TT>, um Segmentbelegung
        anzuzeigen.</LI>
</UL>
 </LI>
<LI> Version 1.33:
<UL>
<LI>     unterst&uuml;tzt den 6809;</LI>
<LI>     zus&auml;tzlich Stringvariablen;</LI>
<LI>     Die Befehle<TT> TITLE</TT>,<TT> PRTINIT</TT>,<TT>
        PRTEXIT</TT>,<TT> ERROR</TT>,<TT> WARNING</TT> und<TT>
        FATAL</TT> erwarten jetzt einen Stringausdruck als Parameter,
        Konstanten m&uuml;ssen demzufolge nicht mehr in Hochkommas,
        sondern in G&auml;nsef&uuml;&szlig;chen eingeschlossen
        werden. Analoges gilt f&uuml;r<TT> DB</TT>,<TT> DC.B</TT>
        und<TT> BYT</TT>;</LI>
<LI>     Befehl<TT> ALIGN</TT> zur Ausrichtung des Programmz&auml;hlers
        bei Intel- Prozessoren;</LI>
<LI>     Befehl<TT> LISTING</TT>, um die Erzeugung eines Listings ein-
        und ausschalten zu k&ouml;nnen;</LI>
<LI>     Befehl<TT> CHARSET</TT> zur Definition eigener
        Zeichens&auml;tze.</LI>
</UL>
 </LI>
<LI> Version 1.34:
<UL>
<LI>     Wenn im ersten Pass Fehler auftreten, wird gar kein zweiter Pass
        mehr durchgef&uuml;hrt;</LI>
<LI>     neues vordefiniertes Symbol<TT> VERSION</TT>, welches die
        Version von AS enth&auml;lt;</LI>
<LI>     Befehl<TT> MESSAGE</TT>, um Durchsagen und Meldungen
        programmgesteuert zu erzeugen;</LI>
<LI>     Formelparser &uuml;ber Stringkonstanten zug&auml;nglich;</LI>
<LI>     Bei Fehler in Makroexpansionen wird zus&auml;tzlich die laufende
        Zeile im Makro angezeigt;</LI>
<LI>     Funktion<TT> UPSTRING</TT>, um einen String in
        Gro&szlig;buchstaben zu wandeln.</LI>
</UL>
 </LI>
<LI> Version 1.35:
<UL>
<LI>     Funktion<TT> TOUPPER</TT>, um ein einzelnes Zeichen in
        Gro&szlig;buchstaben zu wandeln;</LI>
<LI>     Befehl<TT> FUNCTION</TT>, um eigene Funktionen definieren zu
        k&ouml;nnen;</LI>
<LI>     Kommandozeilenoption<TT> D</TT>, um Symbole von au&szlig;en
        definieren zu k&ouml;nnen;</LI>
<LI>     Fragt die Environment-Variable<TT> ASCMD</TT> f&uuml;r
        h&auml;ufig gebrauchte Optionen ab;</LI>
<LI>     bei gesetzter<TT> u</TT>-Option wird das Programm
        zus&auml;tzlich auf doppelt belegte Speicherbereiche
        abgepr&uuml;ft;</LI>
<LI>     Kommandozeilenoption<TT> C</TT>, um eine Querverweisliste zu
        erzeugen.</LI>
</UL>
 </LI>
<LI> Version 1.36:
<UL>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Familien PIC 16C5x und
        PIC17C4x;</LI>
<LI>     im Listing wird zus&auml;tzlich die Verschachtelungsebene bei
        Include-Dateien angezeigt;</LI>
<LI>     in der Querverweisliste wird zus&auml;tzlich die Stelle
        angezeigt, an der ein Symbol definiert wurde;</LI>
<LI>     Kommandozeilenoption<TT> A</TT>, um eine kompaktere Ablage der
        Symboltabelle zu erzwingen.</LI>
</UL>
 </LI>
<LI> Version 1.37:
<UL>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Prozessoren 8086, 80186,
        V30, V35, 8087 und Z180;</LI>
<LI>     Befehle<TT> SAVE</TT> und<TT> RESTORE</TT> zur besseren
        Umschaltung von Flags;</LI>
<LI>     Operatoren zur logischen Verschiebung und Bitspiegelung;</LI>
<LI>     Kommandozeilenoptionen k&ouml;nnen mit einem Pluszeichen negiert
        werden;</LI>
<LI>     Filter<TT> AS2MSG</TT> zur bequemen Arbeit mit AS unter
        Turbo-Pascal 7.0;</LI>
<LI>     <TT>ELSEIF</TT> darf ein Argument zur Bildung von<TT>
        IF-THEN-ELSE</TT>-Leitern haben;</LI>
<LI>     Zur bequemeren bedingten Assemblierung zus&auml;tzlich ein<TT>
        CASE</TT>-Konstrukt;</LI>
<LI>     Selbst definierte Funktionen d&uuml;rfen mehr als ein Argument
        haben;</LI>
<LI>     P2HEX kann nun auch Hexfiles f&uuml;r 65er-Prozessoren
        erzeugen;</LI>
<LI>     BIND, P2HEX und P2BIN haben jetzt die gleichen
        Variationsm&ouml;glichkeiten in der Kommandozeile wie
        AS;</LI>
<LI>     Schalter<TT> i</TT> bei P2HEX, um 3 Varianten f&uuml;r den
        Ende-Record einzustellen;</LI>
<LI>     Neue Funktionen<TT> ABS</TT> und<TT> SGN</TT>;</LI>
<LI>     Neue Pseudovariablen<TT> MOMFILE</TT> und<TT> MOMLINE</TT>;</LI>
<LI>     Ausgabem&ouml;glichkeit erweiterter Fehlermeldungen;</LI>
<LI>     Befehle<TT> IFUSED</TT> und<TT> IFNUSED</TT>, um abzufragen, ob
        ein Symbol bisher benutzt wurde;</LI>
<LI>     Die Environment-Variablen<TT> ASCMD</TT>,<TT> BINDCMD</TT> usw.
        k&ouml;nnen auch einen Dateinamen enthalten, in dem f&uuml;r
        die Optionen mehr Platz ist;</LI>
<LI>     P2HEX erzeugt nun die von Microchip vorgegebenen Hex-Formate
        (p4);</LI>
<LI>     mit der Seitenl&auml;ngenangabe 0 k&ouml;nnen automatische
        Seitenvorsch&uuml;be im Listing vollst&auml;ndig
        unterdr&uuml;ckt werden (p4);</LI>
<LI>     neue Kommandozeilenoption<TT> P</TT>, um die Ausgabe des
        Makroprozessors in eine Datei zu schreiben (p4);</LI>
<LI>     in der Kommandozeile definierte Symbole d&uuml;rfen nun auch mit
        einem frei w&auml;hlbaren Wert belegt werden (p5).</LI>
</UL>
 </LI>
<LI> Version 1.38:
<UL>
<LI>     Umstellung auf Mehrpass-Betrieb. Damit kann AS auch bei
        Vorw&auml;rtsreferenzen immer den optimalen Code
        erzeugen;</LI>
<LI>     Der 8051-Teil kennt nun auch die Befehle<TT> JMP</TT> und<TT>
        CALL</TT>;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Toshiba TLCS-900-Reihe
        (p1);</LI>
<LI>     Befehl<TT> ASSUME</TT>, um dem Assembler die Belegung der
        Segmentregister des 8086 mitzuteilen (p2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ST6-Reihe von SGS-Thomson
        (p2);</LI>
<LI>     ..sowie die 3201x-Signalprozessoren von Texas Instruments
        (p2);</LI>
<LI>     Option<TT> F</TT> bei P2HEX, um die automatische Formatwahl
        &uuml;bersteuern zu k&ouml;nnen (p2);</LI>
<LI>     P2BIN kann nun auch durch Angabe von Dollarzeichen Anfang und
        Ende des Adre&szlig;fensters selbstst&auml;ndig festlegen
        (p2);</LI>
<LI>     Der 8048-Codegenerator kennt nun auch die 8041/42-
        Befehlserweiterungen(p2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Zilog
        Z8-Mikrokontroller(p3).</LI>
</UL>
 </LI>
<LI> Version 1.39:
<UL>
<LI>     Definitionsm&ouml;glichkeit von Sektionen und lokalen
        Labels;</LI>
<LI>     Kommandozeilenschalter<TT> h</TT>, um Hexadezimalzahlenausgabe
        mit Kleinbuchstaben zu erzwingen;</LI>
<LI>     Variable<TT> MOMPASS</TT>, um die Nummer des augenblicklichen
        Durchganges abfragen zu k&ouml;nnen;</LI>
<LI>     Kommandozeilenschalter<TT> t</TT>, um einzelne Teile des
        Assemblerlistings ausblenden zu k&ouml;nnen;</LI>
<LI>     kennt zus&auml;tzlich die L-Variante der TLCS-900-Reihe von
        Toshiba und die MELPS-7700-Reihe von Mitsubishi (p1);</LI>
<LI>     P2HEX akzeptiert nun auch Dollarzeichen f&uuml;r Start-und
        Endadresse (p2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TLCS90-Familie von Toshiba
        (p2);</LI>
<LI>     P2HEX kann Daten zus&auml;tzlich im Tektronix- und 16-Bit
        Intel-Hex-Format ausgeben (p2);</LI>
<LI>     bei Adre&szlig;&uuml;berschreitungen gibt P2HEX Warnungen aus
        (p2);</LI>
<LI>     Include-Datei STDDEF96.INC mit Adre&szlig;definitionen f&uuml;r
        die TLCS-900-Reihe (p3);</LI>
<LI>     Befehl<TT> READ</TT>, um Werte w&auml;hrend der Assemblierung
        interaktiv einlesen zu k&ouml;nnen (p3);</LI>
<LI>     Fehlermeldungen werden nicht mehr einfach auf die
        Standardausgabe, sondern auf den von DOS daf&uuml;r
        vorgesehenen Kanal (STDERR) geschrieben (p3);</LI>
<LI>     Der beim 6811-Teil fehlende<TT> STOP</TT>-Befehl ist nun da
        (scusi,p3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die &micro;PD78(C)1x-Familie
        von NEC (p3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den PIC16C84 von Microchip
        (p3);</LI>
<LI>     Kommandozeilenschalter<TT> E</TT>, um die Fehlermeldungen in
        eine Datei umleiten zu k&ouml;nnen (p3);</LI>
<LI>     Die Unklarheiten im 78(C)1x-Teil sind beseitigt (p4);</LI>
<LI>     neben dem MELPS-7700 ist nun auch das ,,Vorbild'' 65816
        vorhanden (p4);</LI>
<LI>     Die ST6-Pseudoanweisung<TT> ROMWIN</TT> wurde entfernt und mit
        in den<TT> ASSUME</TT>-Befehl eingegliedert (p4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 6804 von SGS-Thomson
        (p4);</LI>
<LI>     durch die<TT> NOEXPORT</TT>-Option in der Makrodefinition kann
        nun f&uuml;r jedes Makro einzeln festgelegt werden, ob es in
        der MAC-Datei erscheinen soll oder nicht (p4);</LI>
<LI>     Die Bedeutung von<TT> MACEXP</TT> f&uuml;r Expansionen von
        Makros hat sich wegen der zus&auml;tzlichen<TT>
        NOEXPAND</TT>-Option in der Makrodefinition leicht
        ge&auml;ndert (p4);</LI>
<LI>     Durch die<TT> GLOBAL</TT>-Option in der Makrodefinition
        k&ouml;nnen nun zus&auml;tzlich Makros definiert werden, die
        durch ihren Sektionsnamen eindeutig gekennzeichnet sind
        (p4).</LI>
</UL>
 </LI>
<LI> Version 1.40:
<UL>
<LI>     unterst&uuml;tzt zus&auml;tzlich den DSP56000 von Motorola;</LI>
<LI>     P2BIN kann nun auch das untere bzw. obere Wort aus
        32-Bit-W&ouml;rtern abtrennen;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TLCS-870- und
        TLCS-47-Familie von Toshiba(p1);</LI>
<LI>     mit einem vorangestelltem ! kann man durch Makros ,,verdeckte''
        Maschinenbefehle wieder erreichen(p1);</LI>
<LI>     mit der<TT> GLOBAL</TT>-Anweisung lassen sich Symbolnamen nun
        auch qualifiziert exportieren(p1);</LI>
<LI>     mit der<TT> r</TT>-Option kann man sich nun eine Liste der
        Stellen erzeugen lassen, die zus&auml;tzliche Durchl&auml;ufe
        erzwangen(p1);</LI>
<LI>     bei der<TT> E</TT>-Option kann nun die Dateiangabe weggelassen
        werden, so da&szlig; ein passender Default gew&auml;hlt
        wird(p1);</LI>
<LI>     mit der<TT> t</TT>-Option kann nun die Zeilennumerierung im
        Listing abgeschaltet werden(p1);</LI>
<LI>     Escapesequenzen sind nun auch in in ASCII geschriebenen
        Integerkonstanten zul&auml;ssig(p1);</LI>
<LI>     Mit dem Pseudobefehl<TT> PADDING</TT> kann das Einf&uuml;gen von
        F&uuml;llbytes im 680x0-Modus ein- und ausgeschaltet werden
        (p2);</LI>
<LI>     <TT>ALIGN</TT> ist nun f&uuml;r alle Zielplattformen erlaubt
        (p2);</LI>
<LI>     kennt zus&auml;tzlich die PIC16C64-SFRs (p2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 8096 von Intel (p2);</LI>
<LI>     Bei<TT> DC</TT> kann zus&auml;tzlich ein Wiederholungsfaktor
        angegeben werden (r3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS320C2x-Familie von Texas
        Instruments (Implementierung von Thomas Sailer, ETH
        Z&uuml;rich, r3); P2HEX ist auch entsprechend erweitert;</LI>
<LI>     statt<TT> EQU</TT> darf nun auch einfach ein Gleichheitszeichen
        benutzt werden (r3);</LI>
<LI>     zur Definition von Aufz&auml;hlungen zus&auml;tzlich ein<TT>
        ENUM</TT>-Befehl (r3);</LI>
<LI>     <TT>END</TT> hat jetzt auch eine Wirkung (r3);</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> n</TT>, um zu
        Fehlermeldungen zus&auml;tzlich die internen Fehlernummern zu
        erhalten (r3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TLCS-9000er von Toshiba
        (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS370xxx-Reihe von Texas
        Instuments, wobei als neuer Pseudobefehl<TT> DBIT</TT>
        hinzukam (r5);</LI>
<LI>     kennt zus&auml;tzlich die DS80C320-SFRs (r5);</LI>
<LI>     der Makroprozessor kann nun auch Includes aus Makros heraus
        einbinden, wozu das Format von Fehlermeldungen aber leicht
        ge&auml;ndert werden mu&szlig;te. Falls Sie AS2MSG verwenden,
        ersetzen Sie es unbedingt durch die neue Version! (r5)</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 80C166 von Siemens
        (r5);</LI>
<LI>     zus&auml;tzlich eine<TT> VAL</TT>-Funktion, um
        Stringausdr&uuml;cke auswerten zu k&ouml;nnen (r5);</LI>
<LI>     Mithilfe von in geschweiften Klammern eingeschlossenen
        Stringvariablen lassen sich nun selber Symbole definieren
        (r5);</LI>
<LI>     kennt zus&auml;tzlich die Eigenheiten des 80C167 von Siemens
        (r6);</LI>
<LI>     jetzt gibt es f&uuml;r die MELPS740-Reihe auch die
        special-page-Adressierung (r6);</LI>
<LI>     mit eckigen Klammern kann man explizit Symbole aus einer
        bestimmten Sektion ansprechen. Die Hilfskonstruktion mit dem
        Klammeraffen gibt es nicht mehr (r6)!</LI>
<LI>     kennt zus&auml;tzlich die MELPS-4500-Reihe von Mitsubishi
        (r7);</LI>
<LI>     kennt zus&auml;tzlich die H8/300 und H8/300H-Prozessoren von
        Hitachi (r7);</LI>
<LI>     die mit<TT> LISTING</TT> und<TT> MACEXP</TT> gemachten
        Einstellungen lassen sich nun auch wieder aus gleichnamigen
        Symbolen auslesen (r7);</LI>
<LI>     kennt zus&auml;tzlich den TMS320C3x von Texas Instruments
        (r8);</LI>
<LI>     kennt zus&auml;tzlich den SH7000 von Hitachi (r8);</LI>
<LI>     der Z80-Teil wurde um die Unterst&uuml;tzung des Z380 erweitert
        (r9);</LI>
<LI>     der 68K-Teil wurde um die feinen Unterschiede der
        683xx-Mikrokontroller erweitert (r9);</LI>
<LI>     ein Label mu&szlig; nun nicht mehr in der ersten Spalte
        beginnen, wenn man es mit einem Doppelpunkt versieht
        (r9);</LI>
<LI>     kennt zus&auml;tzlich die 75K0-Reihe von NEC (r9);</LI>
<LI>     mit dem neuen Kommandozeilenschalter o kann der Name der
        Code-Datei neu festgelegt werden (r9);</LI>
<LI>     der ~~-Operator ist in der Rangfolge auf einen sinnvolleren
        Platz gerutscht (r9);</LI>
<LI>     <TT>ASSUME</TT> ber&uuml;cksichtigt f&uuml;r den 6809 jetzt auch
        das DPR-Register und seine Auswirkungen (pardon, r9);</LI>
<LI>     Der 6809-Teil kennt nun auch die versteckten Erweiterungen des
        6309 (r9);</LI>
<LI>     Bin&auml;rkonstanten k&ouml;nnen jetzt auch in C-artiger
        Notation geschrieben werden (r9).</LI>
</UL>
 </LI>
<LI> Version 1.41:
<UL>
<LI>     &uuml;ber das Symbol<TT> MOMSEGMENT</TT> kann der momentan
        gesetzte Adre&szlig;raum abgefragt werden;</LI>
<LI>     anstelle von<TT> SET</TT> bzw.<TT> EVAL</TT> kann jetzt auch
        einfach<TT> :=</TT> geschrieben werden;</LI>
<LI>     mit der neuen Kommandozeilenoption<TT> q</TT> kann ein
        ,,stiller'' Assemblerlauf erzwungen werden;</LI>
<LI>     das Schl&uuml;sselwort<TT> PARENT</TT> zum Ansprechen der
        Vatersektion wurde um<TT> PARENT0...PARENT9</TT>
        erweitert;</LI>
<LI>     der PowerPC-Teil wurde um die Mikrokontroller-Versionen MPC505
        und PPC403 erweitert;</LI>
<LI>     mit<TT> SET</TT> oder<TT> EQU</TT> definierte Symbole
        k&ouml;nnen nun einem bestimmten Adre&szlig;raum zugeordnet
        werden;</LI>
<LI>     mit<TT> SET</TT> oder<TT> EQU</TT> definierte Symbole
        k&ouml;nnen nun einem bestimmten Adre&szlig;raum zugeordnet
        werden;</LI>
<LI>     durch das Setzen der Environment-Variablen<TT> USEANSI</TT> kann
        die Verwendung von ANSI-Bildschirmsteuersequenzen an-und
        ausgeschaltet werden (r1);</LI>
<LI>     der SH7000-Teil kennt jetzt auch die SH7600-Befehlserweiterungen
        (und sollte jetzt korrekte Displacements berechnen...)
        (r1).</LI>
<LI>     im 65XX-Teil wird jetzt zwischen 65C02 und 65SC02 unterschieden
        (r1);</LI>
<LI>     neben der Variablen<TT> MOMCPU</TT> gibt es jetzt auch den
        String<TT> MOMCPUNAME</TT>, der den Prozessornamen im
        Volltext enth&auml;lt (r1).</LI>
<LI>     P2HEX kennt jetzt auch die 32-Bit-Variante des
        Intel-Hex-Formates (r1);</LI>
<LI>     kennt jetzt auch die Einschr&auml;nkungen des 87C750 (r2);</LI>
<LI>     die Nummern f&uuml;r fatale Fehlermeldungen wurden auf den
        Bereich ab 10000 verschoben, um Platz f&uuml;r normale
        Fehlermeldungen zu schaffen (r2);</LI>
<LI>     unbenutzte Symbole werden in der Symboltabelle jetzt mit einem
        Stern gekennzeichnet (r2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 29K-Familie von AMD
        (r2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die M16-Familie von Mitsubishi
        (r2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die H8/500-Familie von Hitachi
        (r3);</LI>
<LI>     die Anzahl von Datenbytes, die P2HEX pro Zeile ausgibt, ist
        jetzt variierbar (r3);</LI>
<LI>     der Pass, ab dem durch die<TT> -r</TT>-Option erzeugte Warnungen
        ausgegeben werden, ist einstellbar (r3);</LI>
<LI>     der Makroprozessor kennt jetzt ein<TT> WHILE</TT>-Statement, mit
        dem ein Code-St&uuml;ck eine variable Anzahl wiederholt
        werden kann (r3);</LI>
<LI>     der<TT> PAGE</TT>-Befehl erlaubt es nun auch, die Breite des
        Ausgabemediums f&uuml;rs Listing anzugeben (r3);</LI>
<LI>     Um neue Pseudo-Prozessortypen einf&uuml;hren zu k&ouml;nnen,
        lassen sich jetzt CPU-Aliasse definieren (r3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die MCS/251-Familie von Intel
        (r3);</LI>
<LI>     bei eingeschalteter Querverweisliste wird bei doppelt
        definierten Symbolen die Stelle der ersten Definition
        angezeigt (r3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS320C5x-Familie von Texas
        Instruments (Implementierung von Thomas Sailer, ETH
        Z&uuml;rich, r3);</LI>
<LI>     die OS/2-Version sollte jetzt auch mit langen Dateinamen
        klarkommen. Wenn man nicht jeden Mist selber kontrolliert...
        (r3)</LI>
<LI>     &uuml;ber den Befehl<TT> BIGENDIAN</TT> kann im MCS-51/251-Modus
        jetzt gew&auml;hlt werden, ob die Ablage von Konstanten im
        Big- oder Little-Endian-Format erfolgen soll (r3);</LI>
<LI>     es wird beim 680x0 jetzt zwischen dem vollen und
        eingeschr&auml;nkten MMU-Befehlssatz unterschieden; eine
        manuelle Umschaltung ist mit dem<TT> FULLPMMU</TT>-Befehl
        m&ouml;glich (r3);</LI>
<LI>     &uuml;ber die neue Kommandozeilenoption<TT> I</TT> kann eine
        Liste aller eingezogenen Include-Files mit ihrer
        Verschachtelung ausgegeben werden (r3);</LI>
<LI>     Beim<TT> END</TT>-Statement kann jetzt zus&auml;tzlich ein
        Einsprungpunkt f&uuml;r das Programm angegeben werden
        (r3).</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 68HC16-Familie von Motorola
        (r3);</LI>
<LI>     P2HEX und P2BIN erlauben es jetzt, den Inhalt einer Code-Datei
        adre&szlig;m&auml;&szlig;ig zu verschieben (r4);</LI>
<LI>     einem<TT> SHARED</TT>-Befehl anh&auml;ngende Kommentare werden
        jetzt in die Share-Datei mit &uuml;bertragen (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 68HC12-Familie von Motorola
        (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die XA-Familie von Philips
        (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 68HC08-Familie von Motorola
        (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die AVR-Familie von Atmel
        (r4);</LI>
<LI>     aus Kompatibilit&auml;t zum AS11 von Motorola existieren
        zus&auml;tzlich die Befehle<TT> FCB</TT>,<TT> FDB</TT>,<TT>
        FCC</TT> und<TT> RMB</TT> (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den M16C von Mitsubishi
        (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den COP8 von National
        Semiconductor (r5);</LI>
<LI>     zwei neue Befehle zur bedingten Assemblierung:<TT> IFB</TT>
        und<TT> IFNB</TT> (r5);</LI>
<LI>     Mit dem<TT> EXITM</TT>-Befehl ist es nun m&ouml;glich, eine
        Makroexpansion vorzeitig abzubrechen (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den MSP430 von Texas
        Instruments (r5);</LI>
<LI>     <TT>LISTING</TT> kennt zus&auml;tzlich die Varianten<TT>
        NOSKIPPED</TT> und<TT> PURECODE</TT>, um nicht assemblierten
        Code aus dem Listing auszublenden (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 78K0-Familie von NEC
        (r5);</LI>
<LI>     BIGENDIAN ist jetzt auch im PowerPC-Modus verf&uuml;gbar
        (r5);</LI>
<LI>     zus&auml;tzlich ein<TT> BINCLUDE</TT>-Befehl, um Bin&auml;rdaten
        einbinden zu k&ouml;nnen (r5);</LI>
<LI>     zus&auml;tzliche TOLOWER- und LOWSTRING-Funktionen, um
        Gro&szlig;- in Kleinbuchstaben umzuwandeln (r5);</LI>
<LI>     es ist jetzt m&ouml;glich, auch in anderen Segmenten als CODE
        Daten abzulegen. Das Dateiformat wurde entsprechend erweitert
        (r5);</LI>
<LI>     der<TT> DS</TT>-Befehl, mit dem man Speicherbereiche reservieren
        kann, ist jetzt auch im Intel-Modus zul&auml;ssig (r5);</LI>
<LI>     Mit der Kommandozeilenoption<TT> U</TT> ist es jetzt
        m&ouml;glich, AS in einen case-sensitiven Modus umzuschalten,
        in dem Namen von Symbolen, selbst definierten Funktionen,
        Makros, Makroparametern sowie Sektionen nach Gro&szlig;- und
        Kleinschreibung unterschieden werden (r5);</LI>
<LI>     <TT>SFRB</TT> ber&uuml;cksichtigt jetzt auch die Bildungsregeln
        f&uuml;r Bitadressen im RAM-Bereich; werden nicht
        bitadressierbare Speicherstellen angesprochen, erfolgt eine
        Warnung (r5);</LI>
<LI>     zus&auml;tzliche Pseudobefehle<TT> PUSHV</TT> und<TT> POPV</TT>,
        um Symbolwerte tempor&auml;r zu sichern (r5);</LI>
<LI>     zus&auml;tzliche Funktionen<TT> BITCNT, FIRSTBIT, LASTBIT</TT>
        und<TT> BITPOS</TT> zur Bitverarbeitung (r5);</LI>
<LI>     bei den CPU32-Prozessoren ist jetzt auch der 68360
        ber&uuml;cksichtigt (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ST9-Familie von SGS-Thomson
        (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den SC/MP von National
        Semiconductor (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS70Cxx-Familie von Texas
        Instruments (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS9900-Familie von Texas
        Instruments (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Befehlssatzerweiterungen
        des 80296 (r6);</LI>
<LI>     die unterst&uuml;tzten Z8-Derivate wurden erweitert (r6);</LI>
<LI>     ber&uuml;cksichtigt zus&auml;tzlich die Maskenfehler des 80C504
        von Siemens (r6);</LI>
<LI>     zus&auml;tzliche Registerdefinitionsdatei f&uuml;r die
        C50x-Prozessoren von Siemens (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ST7-Familie von SGS-Thomson
        (r6);</LI>
<LI>     die Intel-Pseudobefehle zur Datenablage sind jetzt auch f&uuml;r
        65816 bzw. MELPS-7700 zul&auml;ssig (r6);</LI>
<LI>     f&uuml;r 65816/MELPS-7700 kann die Adre&szlig;l&auml;nge jetzt
        durch Pr&auml;fixe explizit festgelegt werden (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 8X30x-Familie von Signetics
        (r6);</LI>
<LI>     <TT>PADDING</TT> ist nur noch f&uuml;r die 680x0-Familie
        defaultm&auml;&szlig;ig eingeschaltet (r7);</LI>
<LI>     &uuml;ber das neu eingef&uuml;hrte, vordefinierte Symbol<TT>
        ARCHITECTURE</TT> kann ausgelesen werden, f&uuml;r welche
        Plattform AS &uuml;bersetzt wurde (r7);</LI>
<LI>     Zus&auml;tzliche Anweisungen<TT> STRUCT</TT> und<TT>
        ENDSTRUCT</TT> zur Definition von Datenstrukturen (r7);</LI>
<LI>     Hex- und Objekt-Dateien f&uuml;r die AVR-Tools k&ouml;nnen jetzt
        direkt erzeugt werden (r7);</LI>
<LI>     <TT>MOVEC</TT> kennt jetzt auch die 68040-Steuerregister
        (r7);</LI>
<LI>     zus&auml;tzliche<TT> STRLEN</TT>-Funktion, um die L&auml;nge
        eines Strings zu ermitteln (r7);</LI>
<LI>     M&ouml;glichkeit zur Definition von Registersymbolen (r7,
        momentan nur Atmel AVR);</LI>
<LI>     kennt zus&auml;tzlich die undokumentierten 6502-Befehle
        (r7);</LI>
<LI>     P2HEX und P2BIN k&ouml;nnen jetzt optional die Eingabedateien
        automatisch l&ouml;schen (r7);</LI>
<LI>     P2BIN kann der Ergebnisdatei optional zus&auml;tzlich die
        Startadresse voranstellen (r7);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ColdFire-Familie von
        Motorola als Variation des 680x0-Kerns (r7);</LI>
<LI>     <TT>BYT/FCB, ADR/FDB</TT> und<TT> FCC</TT> erlauben jetzt auch
        den von<TT> DC</TT> her bekannten Wiederholungsfaktor
        (r7);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den M*Core von Motorola
        (r7);</LI>
<LI>     der SH7000-Teil kennt jetzt auch die SH7700-Befehlserweiterungen
        (r7);</LI>
<LI>     der 680x0-Teil kennt jetzt auch die zus&auml;tzlichen Befehle
        des 68040 (r7);</LI>
<LI>     der 56K-Teil kennt jetzt auch die Befehlserweiterungen bis zum
        56300 (r7).</LI>
<LI>     Mit der neuen<TT> CODEPAGE</TT>-Anweisung k&ouml;nnen jetzt auch
        mehrere Zeichentabellen gleichzeitig verwaltet werden
        (r8);</LI>
<LI>     Die Argumentvarianten f&uuml;r<TT> CHARSET</TT> wurden erweitert
        (r8);</LI>
<LI>     Neue String-Funktionen<TT> SUBSTR</TT> und<TT> STRSTR</TT>
        (r8);</LI>
<LI>     zus&auml;tzliches<TT> IRPC</TT>-Statement im Makroprozessor
        (r8);</LI>
<LI>     zus&auml;tzlicher<TT> RADIX</TT>-Befehl, um das
        Default-Zahlensystem f&uuml;r Integer-Konstanten festzulegen
        (r8);</LI>
<LI>     statt<TT> ELSEIF</TT> darf auch einfach<TT> ELSE</TT>
        geschrieben werden (r8);</LI>
<LI>     statt = darf als Gleichheitsoperator auch == geschrieben werden
        (r8);</LI>
<LI>     <TT>BRANCHEXT</TT> erlaubt es beim Philips XA jetzt, die
        Sprungweite von kurzen Spr&uuml;ngen automatisch zu erweitern
        (r8);</LI>
<LI>     Debug-Ausgaben sind jetzt auch im NoICE-Format m&ouml;glich
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die i960-Familie von Intel
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die
        &micro;PD7720/7725-Signalprozssoren von NEC (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den
        &micro;PD77230-Signalprozssor von NEC (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die SYM53C8xx-SCSI-Prozessoren
        von Symbios Logic (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 4004 von Intel (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die SC14xxx-Serie von National
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Befehlserweiterungen des
        PPC403GC (r8);</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> cpu</TT>, um den
        Zielprozessor-Default zu setzen (r8);</LI>
<LI>     Key-Files k&ouml;nnen jetzt auch von der Kommandozeile aus
        referenziert werden (r8);</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> shareout</TT>, um die
        Ausgabedatei f&uuml;r SHARED-Definitionen zu setzen
        (r8);</LI>
<LI>     neuer Pseudobefehl<TT> WRAPMODE</TT>, um AVR-Prozessoren mit
        verk&uuml;rztem Programmz&auml;hler zu unterst&uuml;tzen
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die C20x-Befehlsuntermenge im
        C5x-Teil (r8);</LI>
<LI>     hexadezimale Adre&szlig;angaben der Hilfsprogamme k&ouml;nnen
        jetzt auch in C-Notation gemacht werden (r8);</LI>
<LI>     Das Zahlensystem f&uuml;r Integerergebnisse in \{...}-
        Ausdr&uuml;cken ist jetzt per<TT> OUTRADIX</TT> setzbar
        (r8);</LI>
<LI>     Die Registersyntax f&uuml;r 4004-Registerpaare wurde korrigiert
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die F<SUP>2</SUP>MC8L-Familie
        von Fujitsu (r8);</LI>
<LI>     f&uuml;r P2HEX kann jetzt die Minimall&auml;nge f&uuml;r
        S-Record-Adressen angegeben werden (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ACE-Familie von Fairchild
        (r8);</LI>
<LI>     <TT> REG</TT> ist jetzt auch f&uuml;r PowerPCs erlaubt
        (r8);</LI>
<LI>     zus&auml;tzlicher Schalter in P2HEX, um alle Adressen zu
        verschieben (r8);</LI>
<LI>     Mit dem Schalter<TT> x</TT> kann man jetzt zus&auml;tzlich in
        einer zweiten Stufe bie betroffene Quellzeile ausgeben
        (r8).</LI>
</UL>
 </LI>
<LI> Version 1.42:
<UL>
<LI>     Die Default-Zahlensyntax f&uuml;r Atmel AVR ist jetzt
        C-Syntax;</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> olist</TT>, um die
        Listing-Ausgabedatei zu setzen;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die F<SUP>2</SUP>MC16L-Familie
        von Fujitsu;</LI>
<LI>     zus&auml;tzlicher Befehl<TT> PACKING</TT> f&uuml;r die
        AVR-Familie;</LI>
<LI>     zus&auml;tzliche implizite Makroparameter<TT> ALLARGS</TT>
        und<TT> ARGCOUNT</TT>;</LI>
<LI>     zus&auml;tzlicher Befehl<TT> SHIFT</TT> zum Abarbeiten variabler
        Argumentlisten von Makros;</LI>
<LI>     unterst&uuml;tzt tempor&auml;re Symbole;</LI>
<LI>     zus&auml;tzlicher Befehl<TT> MAXNEST</TT> zum Einstellen der
        maximalen Verschachtelungstiefe von Makroexpansionen;</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> noicemask</TT>, um die
        Menge der in einem NoICE-Debuginfofile gelisteten Segmente zu
        steuern;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 180x-Familie von
        Intersil;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich das address windowing des
        68HC11K4;</LI>
<LI>     P2HEX kann jetzt die Adre&szlig;feldl&auml;nge von
        AVR-Hex-Dateien variieren;</LI>
<LI>     mit der neuen Kommandozeilenoption<TT> -gnuerrors</TT>
        k&ouml;nnen Fehlermeldungen in einem GNU-C-artigen Format
        ausgegeben werden;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS320C54x-Familie von
        Texas Instruments;</LI>
<LI>     Neue Makro-Option<TT> INTLABEL</TT>;</LI>
<LI>     die neuen Instruktionen und Register der MEGA-AVRs 8/16 wurden
        hinzugef&uuml;gt;</LI>
<LI>     <TT> ENDIF/ENDCASE</TT> zeigen im Listing die Zeilennummer des
        zugeh&ouml;rigen &ouml;ffnenden Befehls an;</LI>
<LI>     der 8051-Teil unterst&uuml;tzt jetzt auch den erweiterten
        Adre&szlig;raum des Dallas DS80C390;</LI>
<LI>     namenlose tempor&auml;re Symbole hinzugef&uuml;gt;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die undokumentierten
        8085-Befehle;</LI>
<LI>     verbesserte Behandlung von Strukturen;</LI>
<LI>     Funktion EXPRTYPE() hinzugef&uuml;gt;</LI>
<LI>     Zeilenfortsetzungszeichen zulassen;</LI>
<LI>     Unterst&uuml;tzung f&uuml;r KCPSM/PicoBlaze von Andreass
        Wassatsch integriert;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 807x-Familie von National
        Semiconductor;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 4040 von Intel;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den eZ8 von Zilog;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 78K2-Familie von NEC;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die KCPSM3-Variante von
        Xilinx;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den LatticeMico8;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 12X-Befehlserweiterungen
        und den XGATE-Kern der 68HC12-Familie;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den Signetics 2650;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die COP4-Familie von National
        Semiconductor;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die HCS08-Erweiterungen von
        Freescale;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die RS08-Familie von
        Freescale;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 8008 von Intel;</LI>
<LI>     weitere Syntax f&uuml;r Integer-Konstanten;</LI>
<LI>     Funktion<TT> CHARFROMSTR</TT> hinzugef&uuml;gt;</LI>
<LI>     Q f&uuml;r Oktalkonstanten im Intel-Modus hinzugef&uuml;gt;</LI>
<LI>     weitere Variante f&uuml;r tempor&auml;re Symbole
        hinzugef&uuml;gt;</LI>
<LI>     der PowerPC-Teil wurde um Unterst&uuml;tzung f&uuml;r den MPC821
        erweitert (Beitrag von Marcin Cieslak);</LI>
<LI>     implizite Makro-Parameter sind immer case-insensitiv;</LI>
<LI>     das<TT> REG</TT>-Statement ist jetzt auch f&uuml;r den MSP430
        erlaubt;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den XS1 von XMOS;</LI>
<LI>     zus&auml;tzliche Parameter<TT> GLOBALSYMBOLS</TT> und<TT>
        NOGLOBALSYMBOLS</TT> um zu steuern, ob Labels in Makros lokal
        sind oder nicht;</LI>
<LI>     kennt zus&auml;tzlich die 75xx-Reihe von NEC;</LI>
<LI>     kennt zus&auml;tzlich die TMS1000-Controller von TI;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 78K2-Familie von NEC;</LI>
<LI>     alle neueren Anderungen werden nur noch in der separaten
        changelog-Datei dokumentiert.</LI>
</UL>
 </LI>
</UL>
<P>

<H1><A NAME="sect_J_">J. Hinweise zum Quellcode von AS</A></H1>
<A NAME="ref_ChapSource"></A>
<P>
Wie in der Einleitung erw&auml;hnt, gebe ich nach R&uuml;cksprache
den Quellcode von AS heraus. Im folgenden sollen einige Hinweise zu
dessen Handhabung gegeben werden.
<P>

<H2><A NAME="sect_J_1_">J.1. Verwendete Sprache</A></H2>
<P>
Urspr&uuml;nglich war AS ein in Turbo-Pascal geschriebenes Programm.
F&uuml;r diese Entscheidung gab es Ende der 80er Jahre eine Reihe von
Gr&uuml;nden: Zum einen war ich damit wesentlich vertrauter als mit
jedem C-Compiler, zum anderen waren alle C-Compiler unter DOS
verglichen mit der IDE von Turbo-Pascal ziemliche Schnecken. Anfang
1997 zeichnete sich jedoch ab, da&szlig; sich das Blatt gewendet
hatte: Zum einen hatte Borland beschlossen, die DOS-Entwickler im
Stich zu lassen (nochmals ausdr&uuml;cklich keinen sch&ouml;nen Dank,
Ihr Pappnasen von Borland!), und Version 7.0 etwas namens 'Delphi'
nachfolgen lie&szlig;en, was zwar wohl wunderbar f&uuml;r
Windows-Programme geeignet ist, die zu 90% aus Oberfl&auml;che und
zuf&auml;llig auch ein bi&szlig;chen Funktion bestehen, f&uuml;r
kommandozeilenorientierte Progamme wie AS aber reichlich unbrauchbar
ist. Zum anderen hatte sich bereits vor diesem Zeitpunkt mein
betriebssystemm&auml;&szlig;iger Schwerpunkt deutlich in Richtung
Unix verschoben, und auf ein Borland-Pascal f&uuml;r Linux h&auml;tte
ich wohl beliebig lange warten k&ouml;nnen (an alle die, die jetzt
sagen, Borland w&uuml;rde ja an soetwas neuerdings basteln: Leute,
das ist<EM> Vapourware</EM>, und glaubt den Firmen nichts, solange
Ihr nicht wirklich in den Laden gehen und es kaufen k&ouml;nnt!). Von
daher war also klar, da&szlig; der Weg in Richtung C gehen
mu&szlig;te.
<P>
Nach der Erfahrung, wohin die Verwendung von Inselsystemen
f&uuml;hrt, habe ich bei der Umsetzung auf C Wert auf eine
m&ouml;glichst gro&szlig;e Portabilit&auml;t gelegt; da AS jedoch
z.B. Bin&auml;rdateien in einem bestimmten Format erzeugen mu&szlig;
und an einigen Stellen betriebssystemspezifische Funktionen nutzt,
gibt es einige Stellen, an denen man anpassen mu&szlig;, wenn man AS
zum ersten Mal auf einer neuen Plattform &uuml;bersetzt.
<P>
AS ist auf einen C-Compiler ausgelegt, der dem ANSI-Standard
entspricht; C++ ist ausdr&uuml;cklich nicht erforderlich. Wenn Sie
nur einen Compiler nach dem veralteten Kernighan&amp;Ritchie-Standard
besitzen, sollten Sie sich nach einem neuen Compiler umsehen; der
ANSI-Standard ist seit 1989 verabschiedet und f&uuml;r jede aktuelle
Plattform sollte ein ANSI-Compiler verf&uuml;gbar sein, zur Not,
indem man mit dem alten Compiler GNU-C baut. Im Quellcode sind zwar
einige Schalter vorhanden, um den Code K&amp;R-n&auml;her zu machen,
aber dies ist ein nicht offiziell unterst&uuml;tztes Feature, das ich
nur intern f&uuml;r ein ziemlich antikes Unix benutze. Alles weitere
zum 'Thema K&amp;R' steht in der Datei<TT> README.KR</TT>.
<P>
Der Sourcenbaum ist durch einige in der Pascal-Version nicht
vorhandene Features (z.B. dynamisch ladbare Nachrichtendateien,
Testsuite, automatische Generierung der Dokumentation aus<EM>
einem</EM> Quellformat) deutlich komplizierter geworden. Ich werde
versuchen, die Sache Schritt f&uuml;r Schritt aufzudr&ouml;seln:
<P>

<H2><A NAME="sect_J_2_">J.2. Abfangen von Systemabh&auml;ngigkeiten</A></H2>
<P>
Wie ich schon andeutete, ist AS (glaube ich jedenfalls...) auf
Plattformunabh&auml;ngigkeit und leichte Portierbarkeit getrimmt.
Dies bedeutet, da&szlig; man die Plattformunabh&auml;ngigkeiten in
m&ouml;glichst wenige Dateien zusammenzieht. Auf diese Dateien werde
ich im folgenden eingehen, und dieser Abschnitt steht ganz vorne,
weil es sicher eines der wichtigsten ist:
<P>
Die Generierung aller Komponenten von AS erfolgt &uuml;ber ein
zentrales<TT> Makefile</TT>. Damit dies funktioniert, mu&szlig; man
ihm ein passendes<TT> Makefile.def</TT> anbieten, das die
plattformabh&auml;ngigen Einstellungen wie z.B. Compilerflags
vorgibt. Im Unterverzeichnis<TT> Makefile.def-samples</TT> finden
sich eine Reihe von Includes, die f&uuml;r g&auml;ngige Plattformen
funktionieren (aber nicht zwangsweise optimal sein m&uuml;ssen...).
Wenn die von Ihnen benutzte Plattform nicht dabei ist, k&ouml;nnen
Sie die Beispieldatei<TT> Makefile.def.tmpl</TT> als Ausgangspunkt
verwenden (und das Ergebnis mir zukommen lassen!).
<P>
Ein weiterer Anlaufpunkt zum Abfangen von Systemabh&auml;ngigkeiten
ist die Datei<TT> sysdefs.h</TT>. Praktisch alle Compiler definieren
eine Reihe von Pr&auml;prozessorsymbolen vor, die den benutzten
Zielprozessor sowie das benutzte Betriebsystem beschreiben. Auf einer
Sun Sparc unter Solaris mit den GNU-Compiler sind dies z.B. die
Symbole __sparc und __SVR4. In<TT> sysdefs.h</TT> werden diese
Symbole genutzt, um f&uuml;r die restlichen, systemunabh&auml;ngigen
Dateien eine einheitliche Umgebung bereitzustellen. Insbesondere
betrifft dies Integer-Datentypen einer bekannten L&auml;nge, es kann
aber auch die Nach- oder Redefinition von C-Funktionen betreffen, die
auf einer bestimmten Plattform nicht oder nicht
standardgem&auml;&szlig; vorhanden sind. Was da so an Sachen
anf&auml;llt, liest man am besten selber nach. Generell sind die
#ifdef-Statements in zwei Ebenen gegliedert: Zuerst wird eine
bestimmte Prozessorplattform ausgew&auml;hlt, dann werden in diesem
Abschnitt die Betriebssysteme auseinandersortiert.
<P>
Wenn Sie AS auf eine neue Plattform portieren, m&uuml;ssen Sie zwei
f&uuml;r diese Plattform typische Symbole finden und<TT>
sysdefs.h</TT> passend erweitern (und wieder bin ich an dem Ergebnis
interessiert...).
<P>

<H2><A NAME="sect_J_3_">J.3. Systemunabh&auml;ngige Dateien</A></H2>
<P>
...stellen den g&ouml;&szlig;ten Teil aller Module dar. Alle
Funktionen im Detail zu beschreiben, w&uuml;rde den Rahmen dieser
Beschreibung sprengen (wer hier mehr wissen will, steigt am besten
selbst in das Studium der Quellen ein, so katastrophal ist mein
Programmierstil nun auch wieder nicht...), deshalb hier nur eine
kurze Auflistung, welche Module vorhanden sind und was f&uuml;r
Funktionen sie beinhalten:
<P>

<H3><A NAME="sect_J_3_1_">J.3.1. Von AS genutzte Module</A></H3>
<P>

<H4>as.c</H4>
<P>
Diese Datei ist die Wurzel von AS: Sie enth&auml;lt die<EM>
main()</EM>-Funktion von AS, die Verarbeitung aller
Kommandozeilenoptionen, die &uuml;bergeordnete Steuerung aller
Durchl&auml;ufe durch die Quelldateien sowie Teile des
Makroprozessors.
<P>

<H4>asmallg.c</H4>
<P>
In diesem Modul werden all die Befehle bearbeitet, die f&uuml;r alle
Prozessoren definiert sind, z.B.<TT> EQU</TT> und<TT> ORG</TT>. Hier
findet sich auch der<TT> CPU</TT>-Befehl, mit dem zwischen den
einzelnen Prozessoren hin- und hergeschaltet wird.
<P>

<H4>asmcode.c</H4>
<P>
In diesem Modul befindet sich die Verwaltung der Code-Ausgabedatei.
Exportiert wird ein Interface, mit dem sich eine Code-Datei
&ouml;ffnen und schlie&szlig;en l&auml;&szlig;t, und das Routinen zum
Einschreiben (und Zur&uuml;cknehmen) von Code anbietet. Eine wichtige
Aufgabe dieses Moduls ist die Pufferung des Schreibvorgangs, die die
Ausgabegeschwindigkeit erh&ouml;ht, indem der erzeugte Code in
gr&ouml;&szlig;eren Bl&ouml;cken geschrieben wird.
<P>

<H4>asmdebug.c</H4>
<P>
Optional kann AS Debug-Informationen f&uuml;r andere Tools wie
Simulatoren oder Debugger erzeugen, die einen R&uuml;ckbezug auf den
Quellcode erlauben, in diesem Modul gesammelt und nach Ende der
Assemblierung in einem von mehreren Formaten ausgegeben werden
k&ouml;nnen.
<P>

<H4>asmdef.c</H4>
<P>
Dieses Modul enth&auml;lt lediglich Deklarationen von &uuml;berall
ben&ouml;tigten Konstanten und gemeinsam benutzten Variablen.
<P>

<H4>asmfnums.c</H4>
<P>
Intern vergibt AS f&uuml;r jede benutzte Quelldatei eine fortlaufende
Nummer, die zur schnellen Referenzierung benutzt wird. Die Vergabe
dieser Nummern und die Umwandlung zwischen Nummer und Dateinamen
passiert hier.
<P>

<H4>asmif.c</H4>
<P>
Hier befinden sich alle Routinen, die die bedingte Assemblierung
steuern. Exportiert wird als wichtigste Variable das Flag<TT>
IfAsm</TT>, welches anzeigt, ob Codeerzeugung momentan ein- oder
ausgeschaltet ist.
<P>

<H4>asminclist.c</H4>
<P>
In diesem Modul ist die Listenstruktur definiert, &uuml;ber die AS
die Verschachtelung von Include-Dateien im Listing ausgeben kann.
<P>

<H4>asmitree.c</H4>
<P>
Wenn man in einer Code-Zeile das benutzende Mnemonic ermitteln will,
ist das einfache Durchvergleichen mit allen vorhandenen Befehlen (wie
es noch in vielen Codegeneratoren aus Einfachheit und Faulheit
passiert) nicht unbedingt die effizienteste Variante. In diesem Modul
sind zwei verbesserte Strukturen (Bin&auml;rbaum und Hash-Tabelle)
definiert, die eine effizientere Suche erm&ouml;glichen und die
einfache lineare Suche nach und nach abl&ouml;sen
sollen...Priorit&auml;t nach Bedarf...
<P>

<H4>asmmac.c</H4>
<P>
In diesem Modul finden sich die Routinen zur Speicherung und Abfrage
von Makros. Der eigentliche Makroprozessor befindet sich (wie bereits
erw&auml;hnt) in<TT> as.c</TT>.
<P>

<H4>asmpars.c</H4>
<P>
Hier geht es ins Eingemachte: In diesem Modul werden die
Symboltabellen (global und lokal) in zwei Bin&auml;rb&auml;umen
verwaltet. Au&szlig;erdem findet sich hier eine ziemlich gro&szlig;e
Prozedur<TT> EvalExpression</TT>, welche einen (Formel-)ausdruck
analysiert und auswertet. Die Prozedur liefert das Ergebnis (Integer,
Gleitkomma oder String) in einem varianten Record zur&uuml;ck. Zur
Auswertung von Ausdr&uuml;cken bei der Codeerzeugung sollten
allerdings eher die Funktionen<TT> EvalIntExpression,
EvalFloatExpression</TT> und<TT> EvalStringExpression</TT> verwendet
werden. &Auml;nderungen zum Einf&uuml;gen neuer Prozessoren sind hier
nicht erforderlich und sollten auch nur mit &auml;u&szlig;erster
&Uuml;berlegung erfolgen, da man hier sozusagen an ,,die Wurzel'' von
AS greift.
<P>

<H4>asmsub.c</H4>
<P>
Hier finden sich gesammelt einige h&auml;ufig gebrauchte
Unterroutinen, welche in erster Linie die Bereiche Fehlerbehandlung
und 'gehobene' Stringverarbeitung abdecken.
<P>

<H4>bpemu.c</H4>
<P>
Wie am Anfang erw&auml;hnt, war AS urspr&uuml;nglich ein in
Borland-Pascal geschriebenes Programm. Bei einigen intrinsischen
Funktionen des Compilers war es einfacher, diese zu emulieren,
anstatt alle betroffenen Stelle im Quellcode zu &auml;ndern. Na ja...
<P>

<H4>chunks.c</H4>
<P>
Dieses Modul definiert einen Datentyp, mit dem eine Liste von
Adre&szlig;bereichen verwaltet werden kann. Diese Funktion wird von
AS f&uuml;r die Belegungslisten ben&ouml;tigt, au&szlig;erdem
benutzten P2BIN und P2HEX diese Listen, um vor &Uuml;berlappungen zu
warnen.
<P>

<H4>cmdarg.c</H4>
<P>
Dieses Modul implementiert den Mechanismus der Kommdozeilenparameter.
Es ben&ouml;tigt eine Spezifikation der erlaubten Parameter, zerlegt
die Kommadozeile und ruft die entsprechenden Callbacks auf. Der
Mechanismus leistet im einzelnen folgendes:
<UL>
<LI> Mitbearbeitung von Optionen in einer Environment-Variablen oder
    entsprechenden Datei;</LI>
<LI> R&uuml;ckgabe einer Menge, welche die noch nicht bearbeiteten
    Kommandozeilenparameter beschreibt;</LI>
<LI> Trenunng von positiven und negativen Schaltern;</LI>
<LI> Eine Hintert&uuml;r, falls die dar&uuml;berliegende
    Entwicklungsumgebung die Kommandozeile nur in Gro&szlig;- oder
    Kleinschreibung &uuml;bergibt.</LI>
</UL>
Dieses Modul wird nicht nur von AS, sondern auch von den
Hilfsprogrammen<TT> BIND, P2HEX und P2BIN</TT> verwendet.
<P>

<H4>codepseudo.c</H4>
<P>
Hier finden sich Pseudobefehle, die von mehreren Codegeneratoren
verwendet werden. Dies ist einmal die Intel-Gruppe mit der<TT>
DB..DO</TT>-Gruppe, zum anderen die Pendants f&uuml;r die 8/16-Bitter
von Motorola oder Rockwell. Wer in diesem Bereich um einen Prozessor
erweitern will, kann mit einem Aufruf den gr&ouml;&szlig;ten Teil der
Pseudobefehle erschlagen.
<P>

<H4>codevars.c</H4>
<P>
Aus Speicherersparnisgr&uuml;nden sind hier einige von diversen
Codegeneratoren benutzen Variablen gesammelt.
<P>

<H4>endian.c</H4>
<P>
Doch noch ein bi&szlig;chen Maschinenabh&auml;ngigkeit, jedoch ein
Teil, um den man sich nicht zu k&uuml;mmern braucht: Ob eine Maschine
Little- oder Big-Endianess benutzt, wird in diesem Modul beim
Programmstart automatisch bestimmt. Weiterhin wird gepr&uuml;ft, ob
die in<TT> sysdefs.h</TT> gemachten Typfestlegungen f&uuml;r
Integervariablen auch wirklich die korrekten L&auml;ngen ergeben.
<P>

<H4>headids.c</H4>
<P>
Gesammelt sind hier alle von AS unterst&uuml;tzten
Zielprozessorfamilien, die daf&uuml;r in Code-Dateien verwendeten
Kennzahlen (siehe Kapitel <A HREF="#ref_SectCodeFormat">5.1</A>)
sowie das von P2HEX defaultm&auml;&szlig;ig zu verwendende
Ausgabeformat. Ziel dieser Tabelle ist es, Das Hinzuf&uuml;gen eines
neuen Prozessors m&ouml;glichst zu zentralisieren, d.h. es sind im
Gegensatz zu fr&uuml;her keine weiteren Modifikationen an den Quellen
der Hilfsprogramme mehr erforderlich.
<P>

<H4>ioerrs.c</H4>
<P>
Hier ist die Umwandlung von Fehlernummern in Klartextmeldungen
abgelegt. Hoffentlich treffe ich nie auf ein System, auf dem die
Nummern nicht als Makros definiert sind, dann kann ich n&auml;mlich
dieses Modul komplett umschreiben...
<P>

<H4>nlmessages.c</H4>
<P>
Die C-Version von AS liest alle Meldungen zur Laufzeit aus Dateien,
nachdem die zu benutzende Sprache ermittelt wurde. Das Format der
Nachrichtendateien ist kein einfaches, sondern ein spezielles,
kompaktes, vorindiziertes Format, das zur &Uuml;bersetzungszeit von
einem Programm namens 'rescomp' (dazu kommen wir noch) erzeugt wird.
Dieses Modul ist das Gegenst&uuml;ck zu rescomp, die den korrekten
Sprachenanteil einer Datei in ein Zeichenfeld einliest und
Zugriffsfunktionen anbietet.
<P>

<H4>nls.c</H4>
<P>
In diesem Modul wird ermittelt, welche nationalen Einstellungen
(Datums- und Zeitformat, L&auml;ndercode) zur Laufzeit vorliegen. Das
ist leider eine hochgradig systemspezifische Sache, und momentan sind
nur drei Methoden definiert: Die von MS-DOS, die von OS/2 und die
typische Unix-Methode &uuml;ber die<EM> locale</EM>-Funktionen.
F&uuml;r alle anderen Systeme ist leider NO_NLS angesagt...
<P>

<H4>stdhandl.c</H4>
<P>
Zum einen ist hier eine spezielle open-Funktion gelandet, die die
Sonderstrings<TT> !0...!2</TT> als Dateinamen kennt und daf&uuml;r
Duplikate der Standard-Dateihandles<EM> stdin, stdout</EM> und<EM>
stderr</EM> erzeugt, zum anderen wird hier festgestellt, ob die
Standardausgabe auf ein Ger&auml;t oder eine Datei umgeleitet wurde.
Das bedingt auf nicht-Unix-Systemen leider auch einige
Speziall&ouml;sungen.
<P>

<H4>stringlists.c</H4>
<P>
Dies ist nur ein kleiner ,,Hack'', der Routinen zur Verwaltung von
linearen Listen mit Strings als Inhalt definiert, welche z.B. im
Makroprozessor von AS gebraucht werden.
<P>

<H4>strutil.c</H4>
<P>
Hier sind einige h&auml;ufig genutzte String-Operationen gelandet.
<P>

<H4>version.c</H4>
<P>
Die momentan g&uuml;ltige Version ist f&uuml;r AS und alle anderen
Hilfsprogramme hier zentral gespeichert.
<P>

<H4>code????.c</H4>
<P>
Dies Module bilden den Hauptteil der AS-Quellen: jedes Modul
beinhaltet den Codegenerator f&uuml;r eine bestimmte
Prozessorfamilie.
<P>

<H3><A NAME="sect_J_3_2_">J.3.2. Zus&auml;tzliche Module f&uuml;r die Hilfsprogramme</A></H3>
<P>

<H4>hex.c</H4>
<P>
Ein kleines Modul zur Umwandlung von Integerzahlen in
Hexadezimaldarstellung. In C nicht mehr unbedingt erforderlich
(au&szlig;er zur Wandlung von<EM> long long</EM>-Variablen, was
leider nicht alle<TT> printf()</TT>'s unterst&uuml;tzen), aber es ist
im Rahmen der Portierung eben auch stehengeblieben.
<P>

<H4>p2bin.c</H4>
<P>
Die Quellen von P2BIN.
<P>

<H4>p2hex.c</H4>
<P>
Die Quellen von P2HEX.
<P>

<H4>pbind.c</H4>
<P>
Die Quellen von BIND.
<P>

<H4>plist.c</H4>
<P>
Die Quellen von PLIST.
<P>

<H4>toolutils.c</H4>
<P>
Hier sind gesammelt die Unterroutinen, die von allen Hilfsprogrammen
ben&ouml;tigt werden, z.B. f&uuml;r das Lesen von Code-Dateien.
<P>

<H2><A NAME="sect_J_4_">J.4. W&auml;hrend der Erzeugung von AS gebrauchte Module</A></H2>
<P>

<H4>a2k.c</H4>
<P>
Dies ist ein Minimalfilter, das ANSI-C-Files in Kernighan-Ritchie
umwandelt. Um es genau zu sagen: es werden nur die
Funktionsk&ouml;pfe umgewandelt, und auch nur dann, wenn sie
ungef&auml;hr so formatiert sind, wie es mein Schreibstil eben ist.
Es komme also keiner auf die Idee, das w&auml;re ein universeller
C-Parser!
<P>

<H4>addcr.c</H4>
<P>
Ein kleiner Filter, der bei der Installation auf DOS- oder
OS/2-Systemen gebraucht wird. Da DOS und OS/2 den Zeilenvorschub mit
CR/LF vornehmen, Unix-Systeme jedoch nur mit LF, werden
s&auml;mtliche mitgelieferten Assembler-Includes bei der Installation
durch diesen Filter geschickt.
<P>

<H4>bincmp.c</H4>
<P>
F&uuml;r DOS und OS/2 &uuml;bernimmt dieses Modul die Funktion die
Funktion des<EM> cmp</EM>-Befehls, d.h. den bin&auml;ren Vergleich
von Dateien w&auml;hrend des Testlaufes. W&auml;hrend dies
prinzipiell auch mit dem mitgelieferten<EM> comp</EM> m&ouml;glich
w&auml;re, hat<EM> bincmp</EM> keine l&auml;stigen interaktiven
Abfragen (bei denen man erst einmal herausfinden mu&szlig;, wie man
sie auf allen Betriebssystemversionen abstellt...)
<P>

<H4>findhyphen.c</H4>
<P>
Dies ist das Untermodul in<EM> tex2doc</EM>, da&szlig; f&uuml;r die
Silbentrennung von Worten sorgt. Der verwendete Algorithmus is
schamlos von TeX abgekupfert.
<P>

<H4>grhyph.c</H4>
<P>
Die Definition der Silbentrennungsregeln f&uuml;r die deutsche
Sprache.
<P>

<H4>rescomp.c</H4>
<P>
Dies ist der 'Resourcencompiler' von AS, d.h. das Werkzeug, das die
lesbaren Dateien mit Stringresourcen in ein schnelles, indiziertes
Format umsetzt.
<P>

<H4>tex2doc.c</H4>
<P>
Ein Werkzeug, da&szlig; die LaTeX-Dokumentation von AS in ein
ASCII-Format umsetzt.
<P>

<H4>tex2html.c</H4>
<P>
Ein Werkzeug, da&szlig; die LaTeX-Dokumentation von AS in ein
HTML-Dokument umsetzt.
<P>

<H4>umlaut.c und unumlaut.c</H4>
<P>
Diese Progr&auml;mmchen besorgen die Wandlung zwischen
Sonderzeichenkodierung im ISO-Format (alle AS-Dateien verwenden im
Auslieferungszustand die ISO8859-1-Kodierung f&uuml;r Sonderzeichen)
und Sonderzeichenkodierung im systemspezifischen Format. Neben einer
Plain-ASCII7-Variante sind dies im Augenblick die
IBM-Zeichens&auml;tze 437 und 850.
<P>

<H4>ushyph.c</H4>
<P>
Die Definition der Silbentrennungsregeln f&uuml;r die englische
Sprache.
<P>

<H2><A NAME="sect_J_5_">J.5. Generierung der Nachrichtendateien</A></H2>
<P>
Wie bereits erw&auml;hnt, verwendet der C-Quellenbaum von AS ein
dynamisches Ladeverfahren f&uuml;r alle (Fehler-)Meldungen.
Gegen&uuml;ber den Pascal-Quellen, in denen alle Meldungen in einem
Include-File geb&uuml;ndelt waren und so in die Programme
hinein&uuml;bersetzt wurden, macht es dieses Verfahren
&uuml;berfl&uuml;ssig, mehrere sprachliche Varianten von AS zur
Verf&uuml;gung zu stellen: es gibt nur noch eine Version, die beim
Programmstart die zu benutzende Variante ermittelt und aus den
Nachrichtendateien die entsprechende Komponente l&auml;dt. Kurz zur
Erinnerung: Unter DOS und OS/2 wird dazu die gew&auml;hlte<TT>
COUNTRY</TT>-Einstellung zu Rate gezogen, unter Unix werden die
Environment-Variablen<TT> LC_MESSAGES, LC_ALL</TT> und<TT> LANG</TT>
befragt.
<P>

<H3><A NAME="sect_J_5_1_">J.5.1. Format der Quelldateien</A></H3>
<P>
Eine Quelldatei f&uuml;r den Message-Compiler<EM> rescomp</EM> hat
&uuml;blicherweise die Endung<TT> .res</TT>. Der Message-Compiler
erzeugt aus dieser Datei ein oder zwei Dateien:
<UL>
<LI> eine bin&auml;re Datei, die zur Laufzeit von AS bzw. den
    Hilfsprogrammen gelesen wird;</LI>
<LI> optional eine weitere C-Header-Datei, die allen vorhandenen
    Nachrichten eine Indexnummer zuweist. &Uuml;ber diese
    Indexnummern und eine Indextabelle in der bin&auml;ren Datei kann
    zur Laufzeit schnell auf einzelne Meldungen zugegriffen
    werden.</LI>
</UL>
<P>
Die Quelldatei f&uuml;r den Message-Compiler ist eine reine
ASCII-Datei, also mit jedem beliebigen Editor bearbeitbar, und
besteht aus einer Reihe von Steueranweisungen mit Parametern.
Leerzeilen sowie Zeilen, die mit einem Semikolon beginnen, werden
ignoriert. Das Inkludieren anderer Dateien ist &uuml;ber das<TT>
Include</TT>-Statement m&ouml;glich:
<PRE>

Include &lt;Datei&gt;

</PRE>
<P>
Am Anfang jeder Quelldatei m&uuml;ssen zwei Statements stehen, die
die im folgenden definierten Sprachen beschreiben. Das wichtigere der
beiden Statements ist<TT> Langs</TT>, z.B.:
<PRE>

Langs DE(049) EN(001,061)

</PRE>
beschreibt, da&szlig; zwei Sprachen im folgenden definiert werden.
Der erste Nachrichtensatz soll benutzt werden, wenn unter Unix die
Sprache per Environment-Variablen auf<TT> DE</TT> gestellt wurde bzw.
unter DOS bzw. OS/2 der Landescode 049 eingestellt wurde. Der zweite
Satz kommt dementsprechend bei den Einstellungen<TT> EN</TT> bzw. 061
oder 001 zum Einsatz. W&auml;hrend bei den 'Telefonnummern' mehrere
Codes auf einen Nachrichtensatz verweisen k&ouml;nnen, ist die
Zuordnung zu den Unix-Landescodes eineindeutig. Dies ist in der
Praxis aber kein Beinbruch, weil die<TT> LANG</TT>-Variablen unter
Unix Unterversionen einer Sprache als Anh&auml;ngsel beschreiben,
z.B. so:
<PRE>

de.de
de.ch
en.us

</PRE>
AS vergleicht nur den Anfang der Strings und kommt so trotzdem zur
richtigen Entscheidung. Das<TT> Default</TT>-Statement gibt vor,
welcher Sprachensatz verwendet werden soll, wenn entweder
&uuml;berhaupt keine Sprache gesetzt wurde oder eine Kennung
verwendet wird, die nicht in der Liste von<TT> Langs</TT> vorhanden
ist. Typischerweise ist dies Englisch:
<PRE>

Default EN

</PRE>
Nach diesen beiden Definitionen folgt eine beliebige Menge von<TT>
Message</TT>-Statements, d.h. Definitionen von Meldungen:
<PRE>

Message ErrName
 ": Fehler "
 ": error "

</PRE>
Wurden<EM> n</EM> Sprachen im<TT> Langs</TT>-Statement
angek&uuml;ndigt, so nimmt der Message-Compiler<B> genau</B> die
folgenden<EM> n</EM> Zeilen als die zu speichernden Strings. Es ist
also nicht m&ouml;glich, bei einzelnen Nachrichten bestimmte Sprachen
fortzulassen, und eine auf die Strings folgende Leerzeile ist
keinesfalls als Endemarkierung f&uuml;r die Liste
mi&szlig;zuverstehen; eingef&uuml;gte Leerzeilen dienen einzig und
allein der besseren Lesbarkeit. Was allerdings erlaubt ist, ist,
einzelne Meldungen &uuml;ber mehrere Zeilen in der Quelldatei zu
verteilen; alle Zeilen bis auf die letzte m&uuml;ssen dann mit einem
Backslash als Fortsetzungszeichen enden:
<PRE>

Message TestMessage2
 "Dies ist eine" \
 "zweizeilige Nachricht"
 "This is a" \
 "two-line message"

</PRE>
Wie bereits erw&auml;hnt, handelt es sich bei den Quelldateien um
reine ASCII-Dateien; Sonderzeichen k&ouml;nnen in den Meldungstexten
zwar eingetragen werden (und der Compiler wird sie auch so
durchreichen), der gravierende Nachteil ist aber, da&szlig; eine
solche Datei nicht mehr voll portabel ist: Wird sie auf ein anderes
System gebracht, das z.B. eine andere Kodierung f&uuml;r Umlaute
verwendet, bekommt der Anwender zur Laufzeit nur merkw&uuml;rdige
Zeichen zu sehen...Sonderzeichern sollten daher immer mit Hilfe von
speziellen Sequenzen geschrieben werden, die von HTML bzw. SGML
entlehnt wurden (siehe Tabelle <A HREF="#ref_TabSpecChars">J.1</A>).
Zeilenvorsch&uuml;be k&ouml;nnen in eine Zeile wie von C her gewohnt
mit \n eingebracht werden.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Sequenz...</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>ergibt...</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT> &amp;auml; &amp;ouml; &amp;uuml;<BR>
 &amp;Auml; &amp;Ouml; &amp;Uuml;<BR>
 &amp;szlig;<BR>
 &amp;agrave; &amp;egrave; &amp;igrave; &amp;ograve; &amp;ugrave;<BR>
 &amp;Agrave; &amp;Egrave; &amp;Igrave; &amp;Ograve; &amp;Ugrave;<BR>
 &amp;aacute; &amp;eacute; &amp;iacute; &amp;oacute; &amp;uacute;<BR>
 &amp;Aacute; &amp;Eacute; &amp;Iacute; &amp;Oacute; &amp;Uacute;<BR>
 &amp;acirc; &amp;ecirc; &amp;icirc; &amp;ocirc; &amp;ucirc;<BR>
 &amp;Acirc; &amp;Ecirc; &amp;Icirc; &amp;Ocirc; &amp;Ucirc;<BR>
 &amp;ccedil; &amp;Ccedil;<BR>
 &amp;ntilde; &amp;Ntilde;<BR>
 &amp;aring; &amp;Aring;<BR>
 &amp;aelig; &amp;Aelig;<BR>
 &amp;iquest; &amp;iexcl;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>&auml; &ouml; &uuml; (Umlaute)<BR>
&Auml; &Ouml; &Uuml;<BR>
&szlig; (scharfes s)<BR>
&aacute; &eacute; &iacute; &oacute; &uacute; (Accent<BR>
&Aacute; &Eacute; &Iacute; &Oacute; &Uacute; grave)<BR>
&agrave; &egrave; &igrave; &ograve; &ugrave; (Accent<BR>
&Agrave; &Egrave; &Igrave; &Ograve; &Ugrave; agiu)<BR>
&acirc; &ecirc; &icirc; &ocirc; &ucirc; (Accent<BR>
&Acirc; &Ecirc; &Icirc; &Ocirc; &Ucirc; circonflex)<BR>
&ccedil; &Ccedil;(Cedilla)<BR>
&ntilde; &Ntilde;<BR>
&aring; &Aring;<BR>
&aelig; &AElig;<BR>
umgedrehtes ! oder ?</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle J.1: Sonderzeichenschreibweise des<EM> rescomp</EM><A
             NAME="ref_TabSpecChars"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_J_6_">J.6. Dokumentationserzeugung</A></H2>
<P>
In einer Quellcodedistribution von AS ist diese Dokumentation nur als
LaTeX-Dokument enthalten. Andere Formate werden aus dieser mit Hilfe
von mitgelieferten Werkzeugen automatisch erzeugt. Zum einen
reduziert dies den Umfang einer Quellcodedistribution, zum anderen
m&uuml;ssen &Auml;nderungen nicht an allen Formatversionen eines
Dokumentes parallel vorgenommen werden, mit all den Gefahren von
Inkonsistenzen.
<P>
Als Quellformat wurde LaTeX verwendet, weil...weil...weil es eben
schon immer vorhanden war. Zudem ist TeX fast beliebig portierbar und
pa&szlig;t damit recht gut zum Anspruch von AS. Eine
Standard-Distribution erlaubt damit eine 'ordentliche' Ausgabe auf so
ziemlich jedem Drucker; f&uuml;r eine Konvertierung in die
fr&uuml;her immer vorhandene ASCII-Version liegt der Konverter<EM>
tex2doc</EM> bei; zus&auml;tzlich einen Konverter<EM> tex2html</EM>,
so da&szlig; man die Anleitung direkt ins Internet stellen kann.
<P>
Die Erzeugung der Dokumentation wird mit einem schlichten
<PRE>

make docs

</PRE>
angesto&szlig;en; daraufhin werden die beiden erw&auml;hnten
Hilfstools erzeugt, auf die TeX-Dokumentation angewandt und
schlu&szlig;endlich wird noch LaTeX selber aufgerufen. Dies
nat&uuml;rlich f&uuml;r alle Sprachen nacheinander...
<P>

<H2><A NAME="sect_J_7_">J.7. Testsuite</A></H2>
<P>
Da AS mit bin&auml;ren Daten von genau vorgegebener Struktur umgeht,
ist er naturgem&auml;&szlig; etwas empfindlich f&uuml;r System- und
Compilerabh&auml;ngigkeiten. Um wenigstens eine gewisse Sicherheit zu
geben, da&szlig; alles korrekt durchgelaufen ist, liegt dem Assembler
im Unterverzeichnis<TT> tests</TT> eine Menge von
Test-Assemblerquellen bei, mit denen man den frisch gebauten
Assembler testen kann. Diese Testprogramme sind in erster Linie
darauf getrimmt, Fehler in der Umsetzung des Maschinenbefehlssatzes
zu finden, die besonders gern bei variierenden Wortl&auml;ngen
auftreten. Maschinenunabh&auml;ngige Features wie der Makroprozessor
oder bedingte Assemblierung werden eher beil&auml;ufig getestet, weil
ich davon ausgehe, da&szlig; sie &uuml;berall funktionieren, wenn sie
bei mir funktionieren...
<P>
Der Testlauf wird mit einem einfachen<EM> make test</EM>
angesto&szlig;en. Jedes Testprogramm wird assembliert, in eine
Bin&auml;rdatei gewandelt und mit einem Referenz-Image verglichen.
Ein Test gilt als bestanden, wenn Referenz und die neu erzeugte Datei
Bit f&uuml;r Bit identisch sind. Am Ende wird summarisch die
Assemblierungszeit f&uuml;r jeden Test ausgegeben (wer will, kann mit
diesen Ergebnissen die Datei<TT> BENCHES</TT> erg&auml;nzen),
zusammen mit dem Erfolg oder Mi&szlig;erfolg. Jedem Fehler ist auf
den Grund zu gehen, selbst wenn er bei einem Zielprozessor auftritt,
den Sie nie nutzen werden! Es ist immer m&ouml;glich, da&szlig; dies
auf einen Fehler hinweist, der auch bei anderen Zielprozessoren
auftritt, nur zuf&auml;llig nicht in den Testf&auml;llen.
<P>

<H2><A NAME="sect_J_8_">J.8. Einh&auml;ngen eines neuen Zielprozessors</A></H2>
<P>
Der mit Abstand h&auml;ufigste Grund, im Quellcode von AS etwas zu
ver&auml;ndern, d&uuml;rfte wohl die Erweiterung um einen neuen
Zielprozessor sein. Neben der Erg&auml;nzung der Makefiles um das
neue Modul ist lediglich eine Modifikation der Quellen an wenigen
Stellen erforderlich, den Rest erledigt das neue Modul, indem es sich
in der Liste der Codegeneratoren registriert. Im folgenden will ich
kochbuchartig die zum Einh&auml;ngen erforderlichen Schritte
beschreiben:
<P>

<H4>Festlegung des Prozessornamens</H4>
<P>
Der f&uuml;r den Prozessor zu w&auml;hlende Name mu&szlig; zwei
Kriterien erf&uuml;llen:
<OL>
<LI>Der Name darf noch nicht von einem anderen Prozessor belegt sein.
    Beim Aufruf von AS ohne Parameter erh&auml;lt man eine Liste der
    bereits vorhandenen Namen.</LI>
<LI>Soll der Prozessorname vollst&auml;ndig in der Variablen<TT>
    MOMCPU</TT> auftauchen, so darf er au&szlig;er am Anfang keine
    Buchstaben au&szlig;erhalb des Bereiches von A..F enthalten. In
    der Variablen<TT> MOMCPUNAME</TT> liegt aber zur Assemblierzeit
    immer der volle Name vor. Sonderzeichen sind generell nicht
    erlaubt, Kleinbuchstaben werden vom CPU-Befehl bei der Eingabe in
    Gro&szlig;buchstaben umgewandelt und sind daher auch nicht im
    Prozessornamen sinnvoll.</LI>
</OL>
<P>
Der erste Schritt der Registrierung ist die Eintragung des Prozessors
oder der Prozessorfamilie in der Datei<TT> headids.c</TT>. Wie
bereits erw&auml;hnt, wird diese Datei von den Hilfsprogrammen
mitbenutzt und spezifiziert die einer Prozessorfamilie zugeordnete
Kenn-ID in Codedateien sowie das zu verwendende Hex-Format. Bei der
Wahl der Kenn-ID w&uuml;rde ich mir etwas Absprache w&uuml;nschen...
<P>

<H4>Definition des Codegeneratormoduls</H4>
<P>
Das Modul, das f&uuml;r den neuen Prozessor zust&auml;ndig sein soll,
sollte einer gewissen Einheitlichkeit wegen den Namen<TT>
code....</TT> tragen, wobei<TT> .....</TT> etwas mit dem
Prozessornamen zu tun haben sollte. Den Kopf mit den Includes
&uuml;bernimmt man am besten direkt aus einem bereits vorhandenen
Codegenerator.
<P>
Mit Ausnahme einer Initialisierungsfunktion, die zu Anfang der<TT>
main()</TT>-Funktion im Modul<TT> as.c</TT> aufgerufen werden
mu&szlig;, braucht das neue Modul keinerlei Funktionen oder Variablen
zu exportieren, da die ganze Kommunikation zur Laufzeit &uuml;ber
indirekte Spr&uuml;nge abgewickelt wird. Die dazu erforderlichen
Registrierungen m&uuml;ssen in der Initialisierungsfunktion des
Moduls vorgenommen werden, indem f&uuml;r jeden von der Unit zu
behandelnden Prozessortyp ein Aufruf der Funktion<TT> AddCPU</TT>
erfolgt:
<PRE>

   CPUxxxx = AddCPU("XXXX", SwitchTo_xxxx);

</PRE>
<TT>'XXXX'</TT> ist dabei der f&uuml;r den Prozessor festgelegte
Name, der sp&auml;ter im Assemblerprogramm verwendet werden
mu&szlig;, um AS auf diesen Zielprozessor umzuschalten.<TT>
SwitchTo_xxxx</TT> (im folgenden kurz als ,,Umschalter'' bezeichnet)
ist eine parameterlose Prozedur, die von AS aufgerufen wird, sobald
auf diesen Prozessor umgeschaltet werden soll. Als Ergebnis
liefert<TT> AddCPU</TT> eine Zahlenwert, der als interne ,,Kennung''
f&uuml;r diesen Prozessor fungiert. In der globalen Variablen<TT>
MomCPU</TT> wird st&auml;ndig die Kennung des momentan gesetzten
Zielprozessors mitgef&uuml;hrt. Der von<TT> AddCPU</TT> gelieferte
Wert sollte in einer privaten Variable des Typs<TT> CPUVar</TT>
(hier<TT> CPUxxxx</TT> genannt) abgelegt werden. Falls ein
Codegeneratormodul verschiedene Prozessoren (z.B. einer Familie)
verwaltet, kann es so durch Vergleich von<TT> MomCPU</TT> gegen diese
Werte feststellen, welche Befehlsuntermenge momentan zugelassen ist.
<P>
Dem Umschalter obliegt es, AS auf den neuen Zielprozessor
,,umzupolen''. Dazu m&uuml;ssen im Umschalter einige globale
Variablen besetzt werden:
<UL>
<LI> <TT>ValidSegs</TT> : Nicht alle Prozessoren definieren alle von AS
    unterst&uuml;tzten Adre&szlig;r&auml;ume. Mit dieser Menge legt
    man fest, welche Untermenge f&uuml;r den jeweiligen Prozessor
    von<TT> SEGMENT</TT>-Befehl zugelassen wird. Im mindesten
    mu&szlig; das Code-Segment freigeschaltet werden. Die Gesamtmenge
    aller vorhandenen Segmenttypen kann in der Datei<TT>
    fileformat.h</TT> nachgelesen werden
    (<TT>Seg</TT>.....-Konstanten).</LI>
<LI> <TT>SegInits</TT> : Dieses Feld speichert die initialen (ohne<TT>
    ORG</TT>-Befehl) Startadressen in den einzelnen Segmenten. Nur in
    Ausnahmef&auml;llen (physikalisch &uuml;berlappende, aber logisch
    getrennte Adre&szlig;r&auml;ume) sind hier andere Werte als 0
    sinnvoll.</LI>
<LI> <TT>Grans</TT> : Hiermit kann f&uuml;r jedes Segment die
    Gr&ouml;&szlig;e des kleinsten adressierbaren Elements in Bytes
    festgelegt werden, d.h. die Gr&ouml;&szlig;e des Elements,
    f&uuml;r das eine Adresse um eins erh&ouml;ht wird. Bei den
    allermeisten Prozessoren (auch 16 oder 32 Bit) ist dies ein Byte,
    nur z.B. Signalprozessoren und die PICs fallen aus dem
    Rahmen.</LI>
<LI> <TT>ListGrans</TT> : Hiermit kann wieder f&uuml;r alle Segmente
    getrennt festgelegt werden, in was f&uuml;r Gruppen die Bytes im
    Assemblerlisting dargestellt werden sollen. Beim 68000 sind z.B.
    Befehle immer ein mehrfaches von 2 Bytes lang, weshalb die
    entsprechende Variable auf 2 gesetzt ist.</LI>
<LI> <TT>SegLimits</TT> : Dieses Feld legt die h&ouml;chste Adresse
    f&uuml;r jedes Segment fest, z.B. 65535 f&uuml;r einen
    16-Bit-Adre&szlig;raum. Dieses Feld braucht nicht ausgef&uuml;llt
    zu werden, wenn der Codegenerator die<TT> ChkPC</TT>-Methode
    selber &uuml;bernimmt.</LI>
<LI> <TT>ConstMode</TT> : Diese Variable kann die Werte<TT>
    ConstModeIntel</TT>,<TT> ConstModeMoto</TT> oder<TT>
    ConstModeC</TT> haben und bestimmt, in welcher Form Zahlensysteme
    bei Integerkonstanten spezifiziert werden sollen (sofern das
    Programm nicht vom Relaxed-Modus Gebrauch macht).</LI>
<LI> <TT>PCSymbol</TT> : Diese Variable enth&auml;lt den String, mit dem
    aus dem Assembler-Programm heraus der momentane Stand des
    Programmz&auml;hlers abgefragt werden kann. F&uuml;r
    Intel-Prozessoren ist dies z.B. ein Dollarzeichen.</LI>
<LI> <TT>TurnWords</TT> : Falls der Prozessor ein Big-Endian-Prozessor
    sein sollte und eines der Elemente von<TT> ListGrans</TT>
    ungleich eins ist, sollte dieses Flag auf True gesetzt werden, um
    korrekte Code-Dateien zu erhalten.</LI>
<LI> <TT>SetIsOccupiedFnc</TT> : Einige Prozessoren verwenden<TT>
    SET</TT> als Maschinenbefehl. Ist dieser Callback gesetzt, so
    kann der Codegenerator dar&uuml;ber melden, da&szlig;<TT>
    SET</TT> nicht als Pseudo-Befehl interpretiert werden soll. Der
    R&uuml;ckgabewert kann konstant<TT> True</TT> sein, die
    Entscheidung kann aber auch z.B. anhand der Anzahl der Argumente
    fallen.</LI>
<LI> <TT>HeaderID</TT> : Dieses Byte enth&auml;lt die Kennung, mit der in
    der Codedatei die Prozessorfamilie gekennzeichnet wird (siehe
    Abschnitt <A HREF="#ref_SectCodeFormat">5.1</A>). Um
    Zweideutigkeiten zu vermeiden, bitte ich, den Wert mit mir
    abzusprechen. Bis auf weiteres sollten keine Werte
    au&szlig;erhalb des Bereiches $01..$7f benutzt werden, diese sind
    f&uuml;r Sonderzwecke (wie z.B. eine zuk&uuml;nftige Erweiterung
    um einen Linker) reserviert. Auch wenn dieser Wert in den meisten
    &auml;lteren Codegeneratoren hart gesetzt wird, ist es die heute
    bevorzugte Methode, den Wert aus<TT> headids.h</TT> per<TT>
    FindFamilyByName</TT> zu holen.</LI>
<LI> <TT>NOPCode</TT> : In bestimmten Situationen kann es sein, da&szlig;
    AS unbenutzte Bereiche im Code mit NOPs auff&uuml;llen mu&szlig;.
    Diese Variable beinhaltet den dazu erforderlichen Code.</LI>
<LI> <TT>DivideChars</TT> : Dieser String enth&auml;lt all jene Zeichen,
    die als Trennzeichen f&uuml;r die Parameter eines
    Assemblerbefehls zugelassen sind. Nur f&uuml;r extreme
    Ausrei&szlig;er (wie den DSP56) sollte sich in diesem String
    etwas anderes finden als ein Komma.</LI>
<LI> <TT>HasAttrs</TT> : Einige Prozessoren wie die 68k-Reihe teilen
    einen Maschinenbefehl durch einen Punkt noch weiter in Mnemonic
    und Attribut auf. Ist dies beim neuen Prozessor auch der Fall, so
    ist dieses Flag auf True zu setzen. AS liefert dann die
    Einzelteile in den Variablen<TT> OpPart</TT> und<TT>
    AttrPart</TT>. Setzt man es dagegen auf False, so bleibt der
    Befehl in<TT> OpPart</TT> zusammen, und<TT> AttrPart</TT> ist
    immer leer. Sofern der Prozessor keine Attribute verwendet,
    sollte man<TT> HasAttrs</TT> auf jeden Fall auf False setzen, da
    man sich sonst die M&ouml;glichkeit nimmt, Makros mit einem Punkt
    im Namen (z.B. zur Emulation anderer Assembler) zu
    definieren.</LI>
<LI> <TT>AttrChars</TT> : Falls<TT> HasAttrs</TT> gesetzt wurde,
    m&uuml;ssen in diesem String alle Zeichen eingetragen werden, die
    das Attribut vom Befehl trennen k&ouml;nnen. Meist ist dies nur
    der Punkt.</LI>
</UL>
Gehen Sie nicht davon aus, da&szlig; eine dieser Variablen einen
vordefinierten Wert hat, sondern besetzen Sie<B> ALLE</B> Felder
neu!!
<P>
Neben diesen Variablen m&uuml;ssen noch einige Funktionszeiger
besetzt wird, mit denen der Codegenerator sich in AS einbindet:
<UL>
<LI> <TT>MakeCode</TT> : Diese Routine wird nach der Zerlegung einer
    Zeile in Mnemonic und Parameter aufgerufen. Das Mnemonic liegt in
    der Variablen<TT> OpPart</TT>, die Parameter in dem Feld<TT>
    ArgStr</TT>. Die Zahl der Parameter kann aus der Variablen<TT>
    ArgCnt</TT> ausgelesen werden. Das bin&auml;re Ergebnis mu&szlig;
    in dem Byte-Feld<TT> BAsmCode</TT> abgelegt werden, dessen
    L&auml;nge in der Variablen<TT> CodeLen</TT>. Falls der Prozessor
    wortorientiert wie der 68000 oder viele Signalprozessoren ist,
    kann Feld auch wortweise als<TT> WAsmCode</TT> adressiert werden.
    F&uuml;r ganz extreme F&auml;lle gibt es auch noch<TT>
    DAsmCode</TT>... Die Codel&auml;nge wird ebenfalls in solchen
    Einheiten angegeben.</LI>
<LI> <TT>SwitchFrom</TT>: Diese parameterlose Prozedur erlaubt dem
    Codegeneratormodul, noch ,,Aufr&auml;umarbeiten''
    durchzuf&uuml;hren, wenn auf einen anderen Zielprozessor
    umgeschaltet wird. So kann man an dieser Stelle z.B. Speicher
    freigeben, der im Umschalter belegt wurde und nur ben&ouml;tigt
    wird, w&auml;hrend dieses Codegeneratormodul aktiv ist. Im
    einfachsten Fall zeigt diese Prozedurvariable auf eine leere
    Prozedur. Ein Beispiel f&uuml;r die Anwendung dieser Prozedur
    finden Sie im Modul<TT> CODE370</TT>, das seine Codetabellen
    dynamisch erzeugt und wieder freigibt.</LI>
<LI> <TT>IsDef</TT> : Bestimmte Prozessoren kennen neben<TT> EQU</TT>
    noch weitere Pseudobefehle, bei denen ein in der ersten Spalte
    stehender Symbolname kein Label darstellt, z.B.<TT> BIT</TT> beim
    8051. Diese Funktion mu&szlig; TRUE zur&uuml;ckliefern, falls ein
    solcher, zus&auml;tzlicher Befehl vorliegt. Im einfachsten Fall
    braucht nur FALSE zur&uuml;ck geliefert zu werden.</LI>
</UL>
<P>
Optional kann ein Codegenerator auch noch folgende weitere
Funktionszeiger besetzen:
<UL>
<LI> <TT>ChkPC</TT> : Obwohl AS die Programmz&auml;hler intern
    durchg&auml;ngig mit 32 oder 64 Bit verwaltet, benutzen die
    meisten Prozessoren nur einen kleineren Adre&szlig;raum. Diese
    Funktion liefert AS Informationen, ob der momentane
    Programmz&auml;hler den erlaubten Bereich &uuml;berschritten hat.
    Bei Prozessoren mit mehreren Adre&szlig;r&auml;umen kann diese
    Routine nat&uuml;rlich deutlich komplizierter ausfallen. Ein
    Beispiel daf&uuml;r findet sich z.B. im Modul<TT>
    code16c8x.c</TT>. Falls alles in Ordnung ist, mu&szlig; die
    Funktion TRUE zur&uuml;ckliefern, ansonsten FALSE. Diese Funktion
    mu&szlig; ein Codegenerator nur implementieren, wenn er das
    Feld<TT> SegLimits</TT> nicht belegt. Das kann z.B. notwendig
    werden, wenn der g&uuml;ltige Adre&szlig;bereich eines Segments
    nicht zusammenh&auml;ngend ist.</LI>
<LI> <TT>InternSymbol</TT> : Manche Prozessoren, z.B. solche mit einer
    Registerbank im internen RAM, defineren diese 'Register' als
    Symbole vor, und es w&uuml;rde wenig Sinn machen, diese in einer
    separaten Include-Datei mit 256 oder m&ouml;glicherweise noch
    mehr<TT> EQU</TT>s zu definieren. Mit dieser Funktion erh&auml;lt
    man Zugang zum Formel- Parser von AS: Sie erh&auml;lt den
    Ausdruck als ASCII-String, und wenn sie eines der 'eingebauten
    Symbole' erkennt, besetzt sie die &uuml;bergebene Struktur des
    Typs<EM> TempResult</EM> entsprechend. Falls die
    &Uuml;berpr&uuml;fung nicht erfolgreich war, mu&szlig; deren
    Element<TT> Typ</TT> auf<TT> TempNone</TT> gesetzt werden. Die
    Routine sollte im Falle eines Mi&szlig;erfolges<EM> keine</EM>
    Fehlermeldungen ausgeben, weil dies immer noch anderweitig
    g&uuml;ltige Symbole sein k&ouml;nnen. Seien Sie extrem
    vorsichtig mit dieser Routine, da sie einen Eingriff in den
    Parser darstellt!</LI>
<LI> <TT>DissectBit</TT> : Falls die Zielplattform Bit-Objekte
    unterst&uuml;tzt, d.h. Objekte, die sowohl eine
    Register/Speicheradresse als auch eine Bitposition in einer
    einzelnen Integer-Zahl gepackt abspeichern, ist dies der
    Callback, &uuml;ber den solche gepackten Objekte f&uuml;rs
    Listing wieder in eine Quellcode-artige Form
    r&uuml;ck&uuml;bersetzt werden.</LI>
<LI> <TT>DissectReg</TT> : Falls die Zielplattform Registersymbole
    unterst&uuml;tzt, ist dies der Callback, &uuml;ber den
    Registernummer und -l&auml;nge f&uuml;rs Listing wieder in eine
    Quellcode-artige Form r&uuml;ck&uuml;bersetzt werden. Falls
    Registersymbole unterst&uuml;tzt werden, ist &uuml;blicherweise
    auch der<TT> InternSymbol</TT>-Callback auszuf&uuml;llen.</LI>
<LI> <TT>QualifyQuote</TT> : &Uuml;ber diesen optionalen Callback kann
    f&uuml;r eine bestimmte Zielplattform von Fall zu Fall festgelegt
    werden, da&szlig; ein einzelnes Hochkomma<EM> keine</EM>
    Zeichenkette einleitet. Ein Beispiel daf&uuml;r ist die als<TT>
    AF'</TT> geschriebene alternative Registerbank beim Z80, oder die
    Hexadezimal-Syntax<TT> H'...</TT> bei manchen
    Hitachi-Prozessoren.</LI>
</UL>
<P>
Wer will, kann sich &uuml;brigens auch mit einem Copyright-Eintrag
verewigen, indem er in der Initialisierung des Moduls (bei den<TT>
AddCPU</TT>-Befehlen) einen Aufruf der Prozedur<TT> AddCopyright</TT>
einf&uuml;gt, in der folgenden Art:
<PRE>

    AddCopyright("Intel 80986-Codegenerator (C) 2010 Hubert Simpel");

</PRE>
Der &uuml;bergebene String wird dann nach dem Programmstart
zus&auml;tzlich zu der Standardmeldung ausgegeben.
<P>
Bei Bedarf kann sich das Modul im Initialisierungsteil noch in die
Kette aller Funktionen eintragen, die vor Beginn eines Durchlaufes
durch den Quelltext ausgef&uuml;hrt werden. Dies ist z.B. immer dann
der Fall, wenn die Code-Erzeugung im Modul abh&auml;ngig vom Stand
bestimmter, durch Pseudobefehle beeinflu&szlig;barer Flags ist. Ein
h&auml;ufig auftretender Fall ist z.B., da&szlig; ein Prozessor im
User- oder Supervisor-Modus arbeiten kann, wobei im User-Modus
bestimmte Befehle gesperrt sind. Im Assembler-Quelltext k&ouml;nnte
dieses Flag, das angibt, in welchem Modus der folgende Code
ausgef&uuml;hrt wird, durch einen Pseudobefehl umgeschaltet werden.
Es ist aber dann immer noch eine Initialisierung erforderlich, die
sicherstellt, da&szlig; in allen Durchl&auml;ufen ein identischer
Ausgangszustand vorliegt. Der &uuml;ber die Funktion<TT>
AddInitPassProc</TT> angebotene Haken bietet die M&ouml;glichkeit,
derartige Initialisierungen vorzunehmen. Die &uuml;bergebene
Callback-Funktion wird vor Beginn eines Durchgangs aufgerufen.
<P>
Analog zu<TT> AddInitPassProc</TT> funktioniert die &uuml;ber<TT>
AddCleanUpProc</TT> aufgebaute Funktionsliste, die es den
Codegeneratoren erlaubt, nach dem Abschlu&szlig; der Assemblierung
noch Aufr&auml;umarbeiten (z.B. das Freigeben von Literaltabellen
o.&auml;.) durchzuf&uuml;hren. Dies ist sinnvoll, wenn mehrere
Dateien mit einem Aufruf assembliert werden, sonst h&auml;tte man
noch ,,M&uuml;ll'' aus einem vorigen Lauf in den Tabellen. Momentan
nutzt kein Modul diese M&ouml;glichkeit.
<P>

<H4>Schreiben des Codegenerators selber</H4>
<P>
Nach diesen Pr&auml;liminarien ist nun endlich eigene
Kreativit&auml;t gefragt: Wie Sie es schaffen, aus dem Mnemonic und
den Argumenten die Code-Bytes zu erzeugen, ist weitgehend Ihnen
&uuml;berlassen. Zur Verf&uuml;gung stehen daf&uuml;r nat&uuml;rlich
&uuml;ber den Formelparser die Symboltabellen sowie die Routinen
aus<TT> asmsub.c</TT> und<TT> asmpars.c</TT>. Ich kann hier nur
einige generelle Hinweise geben:
<UL>
<LI> Versuchen Sie, die Prozessorbefehle in Gruppen aufzusplitten, die
    gleiche Operanden erwarten und sich nur in einigen Kennbits
    unterscheiden. Alle argumentlosen Befehle kann man z.B. so in
    einer Tabelle abhandeln.</LI>
<LI> Die meisten Prozessoren haben ein festes Repertoire von
    Adressierungsarten. Verlagern Sie das Parsing eines
    Adre&szlig;ausdrucks in eine getrennte Unterroutine.</LI>
<LI> Die Routine<TT> WrError</TT> definiert eine Vielzahl von
    m&ouml;glichen Fehlermeldungen und ist bei Bedarf leicht
    erweiterbar. Nutzen Sie das! Bei allen Fehler nur lapidar einen
    ,,Syntaxfehler'' zu melden, n&uuml;tzt niemandem!</LI>
</UL>
Mit Sicherheit wird auch das Studium der vorhandenen Module
weiterhelfen.
<P>

<H4>&Auml;nderungen f&uuml;r die Dienstprogramme</H4>
<P>
Eine winzige &Auml;nderung ist auch noch an den Quellen der
Dienstprogramme n&ouml;tig, und zwar in der Routine<TT>
Granularity()</TT> in<TT> toolutils.c</TT>: Falls eines der
Adre&szlig;r&auml;ume dieses Prozessors eine andere Granularit&auml;t
als 1 hat, mu&szlig; dort die Abfrage passend erg&auml;nzt werden,
sonst verz&auml;hlen sich PLIST, P2BIN und P2HEX...
<P>

<H2><A NAME="sect_J_9_">J.9. Lokalisierung auf eine neue Sprache</A></H2>
<P>
Sie haben Interesse an diesem Thema? Wunderbar! Das ist eine Sache,
die von Programmierern gerne au&szlig;en vor gelassen wird,
insbesondere, wenn sie aus dem Land der unbegrenzten
M&ouml;glichkeiten kommen...
<P>
Die Lokalisierung auf eine neue Sprache gliedert sich in zwei Teile:
Die Anpassung der Programmmeldungen sowie die &Uuml;bersetzung der
Anleitung. Letzteres ist sicherlich eine Aufgabe herkulischen
Ausma&szlig;es, aber die Anpassung der Programmeldungen sollte in ein
bis zwei Nachmittagen &uuml;ber die B&uuml;hne zu bekommen sein, wenn
man sowohl die neue als auch eine der bisher vorhandenen Sprachen gut
kennt. Leider ist die &Uuml;bersetzung auch nichts, was man
St&uuml;ck f&uuml;r St&uuml;ck machen kann, denn der
Ressourcencompiler kann im Moment nicht mit einer variablen Zahl von
Sprachen in den verschiedenen Meldungen umgehen, es hei&szlig;t also
'alles oder nichts'.
<P>
Als erstes erg&auml;nzt man in<TT> header.res</TT> die neue Sprache.
Die f&uuml;r die Sprache passende zweibuchstabige Abk&uuml;rzung holt
man sich vom n&auml;chsten Unix-System (wenn man nicht ohnehin darauf
arbeitet...), die internationale Vorwahl aus dem n&auml;chsten
DOS-Handbuch.
<P>
Im zweiten Schritt geht man jetzt durch alle anderen<TT>
.res</TT>-Dateien und erg&auml;nzt die<TT> Message</TT>-Statements.
Nocheinmal sei darauf hingewiesen, Sonderzeichen in der HTML-artigen
Schreibweise und nicht direkt einzusetzen!
<P>
Wenn dies geschafft ist, kann man mit einem<EM> make</EM> alle
betroffenen Teile neu bauen und erh&auml;lt danach einen Assembler,
der eine Sprache mehr schickt. Bitte nicht vergessen, die Ergebnisse
an mich weiterzuleiten, damit mit der n&auml;chsten Release alle
etwas davon haben :-)
<P>
<P>
<P>
<H1><A NAME="sect_bib">Literaturverzeichnis</A></H1>
<DL COMPACT>
<DT><A NAME="cite_Williams">[ 1] </A><DD>Steve Williams:<BR>
     <EM> 68030 Assembly Language Reference.</EM><BR>
     Addison-Wesley, Reading, Massachusetts, 1989
<DT><A NAME="cite_AMD29K">[ 2] </A><DD>Advanced Micro Devices:<BR>
     <EM> AM29240, AM29245, and AM29243 RISC
     Microcontrollers.</EM><BR>
     1993
<DT><A NAME="cite_AppleFloat">[ 3] </A><DD>Apple Corporation::<BR>
     <EM> 6502 Floating Point Routines.</EM><BR>
     Apple II Reference Manual (Red Book), January 1978, pages
     94-95<BR>
     http://www.6502.org/source/floats/wozfp3.txt
<DT><A NAME="cite_AtAVR">[ 4] </A><DD>Atmel Corp.:<BR>
     <EM> AVR Enhanced RISC Microcontroller Data Book.</EM><BR>
     May 1996
<DT><A NAME="cite_AVRObj">[ 5] </A><DD>Atmel Corp.:<BR>
     <EM> 8-Bit AVR Assembler and Simulator Object File Formats
     (Preliminary).</EM><BR>
     (part of the AVR tools documentation)
<DT><A NAME="cite_CSG65CE02">[ 6] </A><DD>Commodore Semiconductor
     Group:<BR>
     <EM> 65CE02 Microprocessor Preliminary Data Sheet.</EM>
<DT><A NAME="cite_CMD816">[ 7] </A><DD>CMD Microcircuits:<BR>
     <EM> G65SC802/G65SC816 CMOS 8/16-Bit Microprocessor.</EM><BR>
     Family Data Sheet.
<DT><A NAME="cite_CFMAC">[ 8] </A><DD>Freescale Semiconductor:<BR>
     <EM> Digital Signal Processing Libraries Using the ColdFire eMAC
     and MAC User's Manual.</EM> DSPLIBUM, Rev. 1.2, 03/2006
<DT><A NAME="cite_COP4">[ 9] </A><DD>National Semiconductor:<BR>
     <EM> COP410L/COP411L/COP310L/COP311L Single-Chip N-Channel
     Microcontrollers.</EM> RRD-B30M105, March 1992
<DT><A NAME="cite_COPS">[10] </A><DD>National Semiconductor:<BR>
     <EM> COPS Family User's Guide.</EM>
<DT><A NAME="cite_CP1600">[11] </A><DD>General Instrument
     Microelectronics:<BR>
     <EM> Series 1600 Microprocessor System Documentation..</EM><BR>
     S16DOC-CP-1600-04, May 1975<BR>
     http://www.bitsavers.org/components/gi/CP1600/<BR>
     CP-1600_Microprocessor_Users_Manual_May75.pdf
<DT><A NAME="cite_CPM68K">[12] </A><DD>Digital Research:<BR>
     <EM> CP/M 68K Operating System User's Guide.</EM><BR>
     1983
<DT><A NAME="cite_Cyrix">[13] </A><DD>Cyrix Corp.:<BR>
     <EM> FasMath 83D87 User's Manual.</EM><BR>
     1990
<DT><A NAME="cite_Dallas320">[14] </A><DD>Dallas Semiconductor:<BR>
     <EM> DS80C320 High-Speed Micro User's Guide.</EM><BR>
     Version 1.30, 1/94
<DT><A NAME="cite_Fair1101">[15] </A><DD>Fairchild Semiconductor:<BR>
     <EM> ACE1101 Data Sheet.</EM><BR>
     Preliminary, May 1999
<DT><A NAME="cite_Fair1202">[16] </A><DD>Fairchild Semiconductor:<BR>
     <EM> ACE1202 Data Sheet.</EM><BR>
     Preliminary, May 1999
<DT><A NAME="cite_Fair8004">[17] </A><DD>Fairchild Semiconductor:<BR>
     <EM> ACEx Guide to Developer Tools.</EM> AN-8004, Version 1.3
     September 1998
<DT><A NAME="cite_FairF8UG">[18] </A><DD>Fairchild Micro Systems:<BR>
     <EM> F8 User's Guide.</EM> 67095665, 02-13-1976
<DT><A NAME="cite_FairF8GP">[19] </A><DD>Fairchild Micro Systems:<BR>
     <EM> F8 Guide to Programming</EM> 67095664, 1976
<DT><A NAME="cite_Free12X">[20] </A><DD>Freescale Semiconductor:<BR>
     <EM> S12XCPUV1 Reference Manual.</EM> S12XCPUV1, v01.01, 03/2005
<DT><A NAME="cite_FreeRS08">[21] </A><DD>Freescale Semiconductor:<BR>
     <EM> RS08 Core Reference Manual.</EM> RS08RM, Rev. 1.0, 04/2006
<DT><A NAME="cite_FreeXGATE">[22] </A><DD>Freescale
     Semiconductor:<BR>
     <EM> MC9S12XDP512 Data Sheet.</EM> MC9S12XDP512, Rev. 2.11,
     5/2005
<DT><A NAME="cite_FujitsuCD">[23] </A><DD>Fujitsu Limited:<BR>
     <EM> June 1998 Semiconductor Data Book.</EM><BR>
     CD00-00981-1E
<DT><A NAME="cite_Fujitsu16">[24] </A><DD>Fujitsu Semiconductor:<BR>
     <EM> F&sup2;MC16LX 16-Bit Microcontroller MB90500 Series
     Programming Manual.</EM><BR>
     CM44-00201-1E, 1998
<DT><A NAME="cite_GBZ80">[25] </A><DD><EM> CPU Comparison with
     Z80.</EM><BR>
     https://gbdev.io/pandocs/CPU_Comparison_with_Z80.html
<DT><A NAME="cite_Hit180">[26] </A><DD>Hitachi Ltd.:<BR>
     <EM> 8-/16-Bit Microprocessor Data Book.</EM><BR>
     1986
<DT><A NAME="cite_Hit63">[27] </A><DD>Trevor J.Terrel &amp; Robert J.
     Simpson:<BR>
     <EM> Understanding HD6301X/03X CMOS Microprocessor
     Systems.</EM><BR>
     published by Hitachi
<DT><A NAME="cite_HitH8_3">[28] </A><DD>Hitachi Microcomputer:<BR>
     <EM> H8/300H Series Programming Manual.</EM><BR>
     (21-032, no year of release given)
<DT><A NAME="cite_HitH16">[29] </A><DD>Hitachi America, Ltd.:<BR>
     <EM> HD641016 User's Manual.</EM><BR>
     ADE-602-003A, September 1989
<DT><A NAME="cite_HuC6280">[30] </A><DD><EM> HuC6280 CMOS 8-bit
     Microprocessor Software Manual.</EM>
<DT><A NAME="cite_Rock6519">[31] </A><DD>Rockwell:<BR>
     <EM> R65C19 Microcomputer Data Sheet.</EM><BR>
     Document Number 29400N10, January 1992
<DT><A NAME="cite_SH7000">[32] </A><DD>Hitachi Semiconductor Design
     &amp; Development Center:<BR>
     <EM> SH Microcomputer Hardware Manual (Preliminary).</EM>
<DT><A NAME="cite_SH7700">[33] </A><DD>Hitachi Semiconductor and IC
     Div.:<BR>
     <EM> SH7700 Series Programming Manual.</EM><BR>
     1st Edition, September 1995
<DT><A NAME="cite_HMCS400">[34] </A><DD>Hitachi America Ltd.:<EM>
     HMCS400 Series Handbook: Users Manual</EM> AD-E00078, March 1988
<DT><A NAME="cite_HitH8_5">[35] </A><DD>Hitachi Semiconductor and IC
     Div.:<BR>
     <EM> H8/500 Series Programming Manual.</EM><BR>
     (21-20, 1st Edition Feb. 1989)
<DT><A NAME="cite_HitH8_532">[36] </A><DD>Hitachi Ltd.:<BR>
     <EM> H8/532 Hardware Manual.</EM><BR>
     (21-30, no year of release given)
<DT><A NAME="cite_HitH8_534">[37] </A><DD>Hitachi Ltd.:<BR>
     <EM> H8/534,H8/536 Hardware Manual.</EM><BR>
     (21-19A, no year of release given)
<DT><A NAME="cite_HPNano">[38] </A><DD>Hewlett Packard:<BR>
     <EM> Nano Processor's Users Guide.</EM><BR>
     Drawing Number A-5955-0331-1<BR>
     https://www.hp9845.net/9845/downloads/manuals/Nanoprocessor.pdf
<DT><A NAME="cite_PPC403">[39] </A><DD>IBM Corp.:<BR>
     <EM> PPC403GA Embedded Controller User's Manual.</EM><BR>
     First Edition, September 1994
<DT><A NAME="cite_IBMPalm">[40] </A><DD>IBM Corp.:<BR>
     <EM> IBM5100 ISA Opcodes Micro Instruction Set.</EM><BR>
     https://github.com/voidstar78/IBM_5100_DOCS/blob/main/<BR>
     PDFs_5100/IBM5100_ISA_opcodes_micro-instruction_set.pdf
<DT><A NAME="cite_IBMBASIC5110">[41] </A><DD>IBM Corp.:<BR>
     <EM> IBM5110 BASIC Reference Manual.</EM><BR>
     SA21-9306-0, First Edition, January 1978<BR>
     http://www.bitsavers.org/pdf/ibm/5110/<BR>
     SA21-9308-0_IBM_5110_BASIC_Reference_Manual_Jan1978.pdf
<DT><A NAME="cite_IBMMaint5100">[42] </A><DD>IBM Corp.:<BR>
     <EM> IBM5100 Maintenance Information Manual.</EM><BR>
     SY31-0405-3, October 1979
<DT><A NAME="cite_CortPalm">[43] </A><DD>Dokumentation zum
     IBM5110:<BR>
     http://computermuseum.informatik.uni-stuttgart.de/dev/<BR>
     ibm_5110/technik/5110.html
<DT><A NAME="cite_IntEmb">[44] </A><DD>Intel Corp.:<BR>
     <EM> Embedded Controller Handbook.</EM><BR>
     1987
<DT><A NAME="cite_IntMic">[45] </A><DD>Intel Corp.:<BR>
     <EM> Microprocessor and Peripheral Handbook, Volume I
     Microprocessor.</EM><BR>
     1988
<DT><A NAME="cite_Int48">[46] </A><DD>Intel Corp. :<BR>
     <EM> MCS-48 Family of Single Chip Microcomputers User's
     Manual.</EM><BR>
     September 1980
<DT><A NAME="cite_Int960">[47] </A><DD>Intel Corp. :<BR>
     <EM> 80960SA/SB Reference Manual.</EM><BR>
     1991
<DT><A NAME="cite_Int196">[48] </A><DD>Intel Corp.:<BR>
     <EM> 8XC196NT Microcontroller User's Manual.</EM><BR>
     June 1995
<DT><A NAME="cite_Int251">[49] </A><DD>Intel Corp.:<BR>
     <EM> 8XC251SB High Performance CHMOS Single-Chip
     Microcontroller.</EM><BR>
     Sept. 1995, Order Number 272616-003
<DT><A NAME="cite_Int296">[50] </A><DD>Intel Corp.:<BR>
     <EM> 80296SA Microcontroller User's Manual.</EM><BR>
     Sept. 1996
<DT><A NAME="cite_Int4040">[51] </A><DD>Intel Corp.:<BR>
     <EM> 4040: Single-Chip 4-Bit P-Channel Microprocessor.</EM><BR>
     (no year of release given)
<DT><A NAME="cite_Inters02">[52] </A><DD>Intersil:<BR>
     <EM> CDP1802A, CDP1802AC, CDP1802BC CMOS 8-Bit
     Microprocessors.</EM><BR>
     March 1997
<DT><A NAME="cite_RCA1804">[53] </A><DD>: RCA Inc.:<EM> CDP1804,
     CDP1804C Types Objective Data.</EM><BR>
     (no year of release given)
<DT><A NAME="cite_Inters05">[54] </A><DD>Intersil:<BR>
     <EM> CDP1805AC, CDP1806AC CMOS 8-Bit Microprocessor with On-Chip
     RAM and Counter/Timer.</EM><BR>
     March 1997
<DT><A NAME="cite_Inters6100">[55] </A><DD>Intersil:<BR>
     <EM> IM6100 CMOS 12 Bit Microprocessor.</EM><BR>
     (no year of release given)
<DT><A NAME="cite_Kaku">[56] </A><DD>Hirotsugu Kakugawa:<BR>
     <EM> A memo on the secret features of 6309.</EM><BR>
     (available via World Wide Web:<BR>
     http://www.cs.umd.edu/users/fms/comp/CPUs/6309.txt)
<DT><A NAME="cite_Kenbak">[57] </A><DD>KENBAK:<BR>
     <EM> Programming Reference Manual KENBAK-1 Computer.</EM><BR>
     4/1/1971
<DT><A NAME="cite_LatMico8">[58] </A><DD>Lattice Semiconductor
     Corporation:<BR>
     LatticeMico8 Microcontroller Users Guide.<BR>
     Reference Design RD1026, February 2008
<DT><A NAME="cite_MicroChip">[59] </A><DD>Microchip Technology
     Inc.:<BR>
     <EM> Microchip Data Book.</EM><BR>
     1993 Edition
<DT><A NAME="cite_Mil1750">[60] </A><DD>US Department Of Defense:<BR>
     <EM> Military Standard Sixteen-Bit Computer Instruction Set
     Architecture.</EM><BR>
     MIL-STD-1750A (USAF), 2 July 1980
<DT><A NAME="cite_Mit41">[61] </A><DD>Mitsubishi Electric:<BR>
     <EM> Single-Chip 8-Bit Microcomputers.</EM><BR>
     Vol.2, 1987
<DT><A NAME="cite_Mit16">[62] </A><DD>Mitsubishi Electric:<BR>
     <EM> Single-Chip 16-Bit Microcomputers.</EM><BR>
     Enlarged edition, 1991
<DT><A NAME="cite_Mit8">[63] </A><DD>Mitsubishi Electric:<BR>
     <EM> Single-Chip 8 Bit Microcomputers.</EM><BR>
     Vol.2, 1992
<DT><A NAME="cite_Mit4500">[64] </A><DD>Mitsubishi Electric:<BR>
     <EM> M34550Mx-XXXFP Users's Manual.</EM><BR>
     Jan. 1994
<DT><A NAME="cite_Mit7751">[65] </A><DD>Mitsubishi Electric:<BR>
     7751 Series Software Manual.<BR>
     Rev. 1.01, 980731
<DT><A NAME="cite_MitM16">[66] </A><DD>Mitsubishi Electric:<BR>
     <EM> M16 Family Software Manual.</EM><BR>
     First Edition, Sept. 1994
<DT><A NAME="cite_MitM16C">[67] </A><DD>Mitsubishi Electric:<BR>
     <EM> M16C Software Manual.</EM><BR>
     First Edition, Rev. C, 1996
<DT><A NAME="cite_Mit30600">[68] </A><DD>Mitsubishi Electric:<BR>
     <EM> M30600-XXXFP Data Sheet.</EM><BR>
     First Edition, April 1996
<DT><A NAME="cite_GreenM16">[69] </A><DD>documentation about the
     M16/M32-developer's package from Green Hills Software
<DT><A NAME="cite_Mostek1980">[70] </A><DD>Mostek Corporation:<BR>
     <EM> Circuits and Systems Product Guide.</EM><BR>
     1980, STD No 01009
<DT><A NAME="cite_Mostek3870">[71] </A><DD>Mostek Corporation:<BR>
     <EM> 3870/F8 Microcomputer Data Book.</EM><BR>
     1981, Publication Number MK79602
<DT><A NAME="cite_MotMic">[72] </A><DD>Motorola Inc.:<BR>
     <EM> Microprocessor, Microcontroller and Peripheral
     Data.</EM><BR>
     Vol. I+II, 1988
<DT><A NAME="cite_Mot81">[73] </A><DD>Motorola Inc.:<BR>
     <EM> MC68881/882 Floating Point Coprocessor User's
     Manual.</EM><BR>
     Second Edition, Prentice-Hall, Englewood Cliffs 1989
<DT><A NAME="cite_Mot51">[74] </A><DD>Motorola Inc.:<BR>
     <EM> MC68851 Paged Memory Management Unit User's
     Manual.</EM><BR>
     Second Edition, Prentice-Hall, Englewood Cliffs 1989,1988
<DT><A NAME="cite_Mot32">[75] </A><DD>Motorola Inc.:<BR>
     <EM> CPU32 Reference Manual.</EM><BR>
     Rev. 1, 1990
<DT><A NAME="cite_Mot56">[76] </A><DD>Motorola Inc.:<BR>
     <EM> DSP56000/DSP56001 Digital Signal Processor User's
     Manual.</EM><BR>
     Rev. 2, 1990
<DT><A NAME="cite_Mot340">[77] </A><DD>Motorola Inc.:<BR>
     <EM> MC68340 Technical Summary.</EM><BR>
     Rev. 2, 1991
<DT><A NAME="cite_Mot16">[78] </A><DD>Motorola Inc.:<BR>
     <EM> CPU16 Reference Manual.</EM><BR>
     Rev. 1, 1991
<DT><A NAME="cite_Mot68K">[79] </A><DD>Motorola Inc.:<BR>
     <EM> Motorola M68000 Family Programmer's Reference
     Manual.</EM><BR>
     1992
<DT><A NAME="cite_Mot332">[80] </A><DD>Motorola Inc.:<BR>
     <EM> MC68332 Technical Summary.</EM><BR>
     Rev. 2, 1993
<DT><A NAME="cite_Mot601">[81] </A><DD>Motorola Inc.:<BR>
     <EM> PowerPC 601 RISC Microprocessor User's Manual.</EM><BR>
     1993
<DT><A NAME="cite_Mot505">[82] </A><DD>Motorola Inc.:<BR>
     <EM> PowerPC(tm) MPC505 RISC Microcontroller Technical
     Summary.</EM><BR>
     1994
<DT><A NAME="cite_Mot821">[83] </A><DD>Motorola Inc.:<BR>
     <EM> PowerPC(tm) MPC821 Portable Microprocessor User's
     Manual.</EM><BR>
     1996
<DT><A NAME="cite_Mot12">[84] </A><DD>Motorola Inc.:<BR>
     <EM> CPU12 Reference Manual.</EM><BR>
     1st edition, 1996
<DT><A NAME="cite_Mot08">[85] </A><DD>Motorola Inc.:<BR>
     <EM> CPU08 Reference Manual.</EM><BR>
     Rev. 1 (no year of release given im PDF-File)
<DT><A NAME="cite_Mot360">[86] </A><DD>Motorola Inc.:<BR>
     <EM> MC68360 User's Manual.</EM>
<DT><A NAME="cite_MotCold">[87] </A><DD>Motorola Inc.:<BR>
     <EM> MCF 5200 ColdFire Family Programmer's Reference
     Manual.</EM><BR>
     1995
<DT><A NAME="cite_MotMCore">[88] </A><DD>Motorola Inc.:<BR>
     <EM> M*Core Programmer's Reference Manual.</EM><BR>
     1997
<DT><A NAME="cite_Mot56300">[89] </A><DD>Motorola Inc.:<BR>
     <EM> DSP56300 24-Bit Digital Signal Processor Family
     Manual.</EM><BR>
     Rev. 0 (no year of release given im PDF-File)
<DT><A NAME="cite_MotK4">[90] </A><DD>Motorola Inc.:<BR>
     <EM> MC68HC11K4 Technical Data.</EM> 1992
<DT><A NAME="cite_SCMP">[91] </A><DD>National Semiconductor:<BR>
     <EM> SC/MP Programmier- und Assembler-Handbuch.</EM><BR>
     Publication Number 4200094A, Aug. 1976
<DT><A NAME="cite_AsmCop">[92] </A><DD>National Semiconductor:<BR>
     <EM> COP800 Assembler/Linker/Librarian User's Manual.</EM><BR>
     Customer Order Number COP8-ASMLNK-MAN<BR>
     NSC Publication Number 424421632-001B<BR>
     August 1993
<DT><A NAME="cite_Cop87L84">[93] </A><DD>National Semiconductor:<BR>
     <EM> COP87L84BC microCMOS One-Time-Programmable (OTP)
     Microcontroller.</EM><BR>
     Preliminary, March 1996
<DT><A NAME="cite_IMP16Pgm">[94] </A><DD>National Semiconductor:<BR>
     <EM> IMP-16 Programming and Assembler Manual.</EM><BR>
     Order No. IMP-16S/102YB, Pub. No 4200002B, November 1973
<DT><A NAME="cite_IMP16LUM">[95] </A><DD>National Semiconductor:<BR>
     <EM> IMP-16L Users Manual.</EM><BR>
     Order No. IMP-16L/928X, Pub. No 4200028X, April 1974
<DT><A NAME="cite_PACEDS">[96] </A><DD>National Semiconductor:<BR>
     <EM> IPC-16A/520D MOS/LSI Single Chip Microprocessor
     (PACE).</EM>
<DT><A NAME="cite_PACEASM">[97] </A><DD>National Semiconductor:<BR>
     <EM> PACE Microprocessor Assembly Language Programming
     Manual.</EM><BR>
     Order No. IPC-16S/969Y, Pub. No 4200130A, January 1977
<DT><A NAME="cite_INS8900DS">[98] </A><DD>National Semiconductor:<BR>
     <EM> INS8900 Single-Chip 16-Bit N-Channel
     Microprocessor.</EM><BR>
     1977
<DT><A NAME="cite_Nat14xxx">[99] </A><DD>National Semiconductor:<BR>
     <EM> SC14xxx DIP commands Reference guide.</EM><BR>
     Application Note AN-D-031, Version 0.4, 12-28-1998
<DT><A NAME="cite_Nat8070">[100] </A><DD>National Semiconductor:<BR>
     <EM> INS8070-Series Microprocessor Family.</EM> October 1980
<DT><A NAME="cite_Nat32000">[101] </A><DD>National Semiconductor:<BR>
     <EM> Series 32000 Databook.</EM><BR>
     1986
<DT><A NAME="cite_Nat32CG16">[102] </A><DD>National
     Semiconductor:<BR>
     <EM> NS32CG16-10/NS32CG16-15 High Performance Printer/Display
     Processor.</EM><BR>
     Preliminary, November 1995
<DT><A NAME="cite_Instr32000">[103] </A><DD>National Semiconductor
     and Udo M&ouml;ller:<BR>
     <EM> Series 32000 Instruction Set Manual.</EM><BR>
     6. September 2017, available via www.cpu.ns32k.net
<DT><A NAME="cite_NECV">[104] </A><DD>NEC Corp.:<BR>
     <EM>
     &micro;pD70108/&micro;pD70116/&micro;pD70208/&micro;pD70216/&micro;
     pD72091 Data Book.</EM><BR>
     (no year of release given)
<DT><A NAME="cite_NEC78K0">[105] </A><DD>NEC Electronics Europe
     GmbH:<BR>
     <EM> User's Manual &micro;COM-87 AD Family.</EM><BR>
     (no year of release given)
<DT><A NAME="cite_NEC75">[106] </A><DD>NEC Corp.:<BR>
     <EM> &micro;COM-75x Family 4-bit CMOS Microcomputer User's
     Manual.</EM><BR>
     Vol. I+II (no year of release given)
<DT><A NAME="cite_NEC78K2">[107] </A><DD>NEC Corp.:<BR>
     <EM> 78K/II Series 8-Bit Single-Chip Microcontroller User's
     Manual - Instructions.</EM><BR>
     Document No. U10228EJ6V0UM00 (6th edition), December 1995
<DT><A NAME="cite_NEC78K3">[108] </A><DD>NEC Corp.:<BR>
     <EM> uPD78310/312CW/G 8 Bit CMOS Microcomputer Product
     Description.</EM>
<DT><A NAME="cite_NECSig">[109] </A><DD>NEC Corp.:<BR>
     <EM> Digital Signal Processor Product Description.</EM><BR>
     PDDSP.....067V20 (no year of release given)
<DT><A NAME="cite_NEC78">[110] </A><DD>NEC Corp.:<BR>
     <EM> &micro;PD78070A, 78070AY 8-Bit Single-Chip Microcontroller
     User's Manual.</EM><BR>
     Document No. U10200EJ1V0UM00 (1st edition), August 1995
<DT><A NAME="cite_NEC7814">[111] </A><DD>NEC Corp.:<BR>
     <EM> Data Sheet &micro;PD78014.</EM>
<DT><A NAME="cite_NECV60">[112] </A><DD>NEC Corp.:<BR>
     <EM> &micro;PD70616 Programmer's Reference Manual.</EM><BR>
     Preliminary Information, November 1986
<DT><A NAME="cite_NEC43">[113] </A><DD>NEC Corp.:<BR>
     <EM> &micro;COM-43 Single Chip Microcomputer Users'
     Manual.</EM><BR>
     January 1978
<DT><A NAME="cite_NXPS12ZCore">[114] </A><DD>NXP/Freescale:<BR>
     <EM> CPU S12Z Reference Manual.</EM><BR>
     CPUS12ZRM, Rev. 1.01, 01/2013
<DT><A NAME="cite_NXPS12ZVC">[115] </A><DD>NXP:<BR>
     <EM> MC9S12ZVC-Family Reference Manual and Datasheet.</EM><BR>
     MC9S12ZVCRMV1, Rev. 1.9, 29-January-2018
<DT><A NAME="cite_ParaSX20">[116] </A><DD>Parallax Inc.<BR>
     SX20AC/SX28AC Data Sheet. Revision 1.7, 4/23/2008
<DT><A NAME="cite_PDP11Arch">[117] </A><DD>Digital Equipment
     Corporation:<BR>
     PDP-11 Architecture Handbook. 1983 Edition, EB-23657-18
<DT><A NAME="cite_MACRO11">[118] </A><DD>Digital Equipment
     Corporation:<BR>
     PDP-11 MACRO-11 Language Reference Manual. March 1983,
     AA-V027A-TC
<DT><A NAME="cite_OKIMicro">[119] </A><DD>OKI Semiconductor:<BR>
     <EM> Microcontroller Data Book.</EM> Second Edition, December
     1986
<DT><A NAME="cite_Phil84X1">[120] </A><DD>Philips Semiconductor:<BR>
     <EM> MAB84X1, MAF84X1, MAF84AX1 Family Datasheet.</EM><BR>
     August 1990
<DT><A NAME="cite_PhilXA">[121] </A><DD>Philips Semiconductor:<BR>
     <EM> 16-bit 80C51XA Microcontrollers (eXtended
     Architecture).</EM><BR>
     Data Handbook IC25, 1996
<DT><A NAME="cite_RockPPS4">[122] </A><DD>Rockwell International
     Corporation:<BR>
     <EM> Parallel Processing System (PPS-4) Microcomputer Data
     Sheet.</EM> Document No. 29003 N11, 1973
<DT><A NAME="cite_RxOverview">[123] </A><DD>RX Family Product
     Page,<BR>
     https://www.renesas.com/us/en/products/<BR>
     microcontrollers-microprocessors/<BR>
     rx-32-bit-performance-efficiency-mcus
<DT><A NAME="cite_RxManual">[124] </A><DD>RX Family Compiler and
     Assembler Manual:<BR>
     https://www.renesas.com/us/en/document/mat/<BR>
     high-performance-embedded-workshop-rx-family-<BR>
     cc-compiler-package-v101-users-manual-includes-v102
<DT><A NAME="cite_Sharp1350">[125] </A><DD>Sharp:<BR>
     <EM> Pocket Computer PC-1350 Machine Language Reference
     Manual.</EM><BR>
     https://pockemul.com/wp-content/uploads/2022/12/<BR>
     PC1350_ML_EN.pdf
<DT><A NAME="cite_SharpEsrL0">[126] </A><DD>Sharp Corporation:<BR>
     <EM> ESR-L Instruction Manual.</EM><BR>
     https://web.archive.org/web/20060521205349if_/http://<BR>
     www.sarnau.info:80/files/ESR-LInstructionManual.pdf
<DT><A NAME="cite_Sig2650">[127] </A><DD>Signetics Corporation:<BR>
     <EM> Signetics 2650 Microprocessor.</EM><BR>
     1975
<DT><A NAME="cite_UM2650">[128] </A><DD>Signetics Corporation:<BR>
     <EM> 2650 User's Manual.</EM>
<DT><A NAME="cite_SGS3870">[129] </A><DD>SGS-Ates:<BR>
     <EM> M3870 Microcomputer Family Databook.</EM><BR>
     1st edition, issued January 1983
<DT><A NAME="cite_SGS04">[130] </A><DD>SGS-Thomson
     Microelectronics:<BR>
     <EM> 8 Bit MCU Families EF6801/04/05 Databook.</EM><BR>
     1st edition, 1989
<DT><A NAME="cite_SGS62">[131] </A><DD>SGS-Thomson
     Microelectronics:<BR>
     <EM> ST6210/ST6215/ST6220/ST6225 Databook.</EM><BR>
     1st edition, 1991
<DT><A NAME="cite_SGSM38">[132] </A><DD>SGS-Ates:<EM> M380 uP System
     and Instruction Set.</EM><BR>
     6.4.1976
<DT><A NAME="cite_ST7Man">[133] </A><DD>SGS-Thomson
     Microelectronics:<BR>
     <EM> ST7 Family Programming Manual.</EM><BR>
     June 1995
<DT><A NAME="cite_SGS9">[134] </A><DD>SGS-Thomson
     Microelectronics:<BR>
     <EM> ST9 Programming Manual.</EM><BR>
     3rd edition, 1993
<DT><A NAME="cite_Siem166">[135] </A><DD>Siemens AG:<BR>
     <EM> SAB80C166/83C166 User's Manual.</EM><BR>
     Edition 6.90
<DT><A NAME="cite_Siem167">[136] </A><DD>Siemens AG:<BR>
     <EM> SAB C167 Preliminary User's Manual.</EM><BR>
     Revision 1.0, July 1992
<DT><A NAME="cite_Siem382">[137] </A><DD>Siemens AG:<BR>
     <EM> Telephone Controller (Single-Chip 8-Bit<BR>
     CMOS Microcontroller) SAB80C382/SAB80C482.</EM><BR>
     May 1987
<DT><A NAME="cite_Siem502">[138] </A><DD>Siemens AG:<BR>
     <EM> SAB-C502 8-Bit Single-Chip Microcontroller User's
     Manual.</EM><BR>
     Edition 8.94
<DT><A NAME="cite_Siem501">[139] </A><DD>Siemens AG:<BR>
     <EM> SAB-C501 8-Bit Single-Chip Microcontroller User's
     Manual.</EM><BR>
     Edition 2.96
<DT><A NAME="cite_Siem504">[140] </A><DD>Siemens AG:<BR>
     <EM> C504 8-Bit CMOS Microcontroller User's Manual.</EM><BR>
     Edition 5.96
<DT><A NAME="cite_STM8ProgMan">[141] </A><DD>ST Microelectronics:<BR>
     <EM> STM8 CPU Programming Manual.</EM><BR>
     PM0044, Doc ID 13590 Rev 3, September 2011
<DT><A NAME="cite_STM8SRefMan">[142] </A><DD>ST Microelectronics:<BR>
     <EM> STM8S Series and STM8AF Series 8-bit Microcontrollers
     Reference Manual.</EM><BR>
     RM0016, DocID14587 Rev 14, October 2017
<DT><A NAME="cite_STM8S003F3Sheet">[143] </A><DD>ST
     Microelectronics:<BR>
     <EM> STM8S003F3 STM8S003K3 Data Sheet.</EM><BR>
     DS7147 Rev 10, August 2018
<DT><A NAME="cite_Syb68K">[144] </A><DD>C.Vieillefond:<BR>
     <EM> Programmierung des 68000.</EM><BR>
     Sybex-Verlag D&uuml;sseldorf, 1985
<DT><A NAME="cite_Sym8xx">[145] </A><DD>Symbios Logic Inc:<BR>
     <EM> Symbios Logic PCI-SCSI-I/O Processors Programming
     Guide.</EM><BR>
     Version 2.0, 1995/96
<DT><A NAME="cite_Ti990">[146] </A><DD>Texas Instruments:<BR>
     <EM> Model 990 Computer/TMS9900 Microprocessor Assembly Language
     Programmer's Guide.</EM><BR>
     1977, Manual No. 943441-9701
<DT><A NAME="cite_Ti9900">[147] </A><DD>Texas Instruments:<BR>
     <EM> TMS9995 16-Bit Microcomputer.</EM><BR>
     Preliminary Data Manual 1981
<DT><A NAME="cite_Ti99000">[148] </A><DD>Texas Instruments:<BR>
     <EM> TMS99105 and TMS99110A 16-Bit Microprocessors.</EM><BR>
     Preliminary Data Manual 1982
<DT><A NAME="cite_TiC10">[149] </A><DD>Texas Instruments:<BR>
     <EM> First-Generation TMS320 User's Guide.</EM><BR>
     1988, ISBN 2-86886-024-9
<DT><A NAME="cite_Ti7000">[150] </A><DD>Texas Instruments:<BR>
     <EM> TMS7000 Family Data Manual.</EM><BR>
     1991, DB103
<DT><A NAME="cite_TiC30">[151] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C3x User's Guide.</EM><BR>
     Revision E, 1991
<DT><A NAME="cite_TiC20">[152] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C2x User's Guide.</EM><BR>
     Revision C, Jan. 1993
<DT><A NAME="cite_TiC40">[153] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C4x User's Guide.</EM><BR>
     SPRU063C, May 1999
<DT><A NAME="cite_Ti370">[154] </A><DD>Texas Instruments:<BR>
     <EM> TMS370 Family Data Manual.</EM><BR>
     1994, SPNS014B
<DT><A NAME="cite_Ti430FamSoft">[155] </A><DD>Texas Instruments:<BR>
     <EM> MSP430 Family Software User's Guide.</EM><BR>
     1994, SLAUE11
<DT><A NAME="cite_Ti430Met">[156] </A><DD>Texas Instruments:<BR>
     <EM> MSP430 Metering Application.</EM><BR>
     1996, SLAAE10A
<DT><A NAME="cite_Ti430FamArch">[157] </A><DD>Texas Instruments:<BR>
     <EM> MSP430 Family Architecture User's Guide.</EM><BR>
     1995, SLAUE10A
<DT><A NAME="cite_Ti430X">[158] </A><DD>Texas Instruments:<BR>
     <EM> MSP430 MSP430x5xx and MSP430x6xx Family User's
     Guide.</EM><BR>
     October 2016, SLAU208
<DT><A NAME="cite_TiC60">[159] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C62xx CPU and Instruction Set Reference
     Manual.</EM><BR>
     Jan. 1997, SPRU189A
<DT><A NAME="cite_TiC20x">[160] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C20x User's Guide.</EM><BR>
     April 1999, SPRU127C
<DT><A NAME="cite_Tispru131g">[161] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C54x DSP Reference Set; Volume 1: CPU and
     Peripherals.</EM><BR>
     March 2001, SPRU172C
<DT><A NAME="cite_Tispru172c">[162] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C54x DSP; Volume 2: Mnemonic Instruction
     Set.</EM><BR>
     March 2001, SPRU172C
<DT><A NAME="cite_TMS1000PGMRef">[163] </A><DD>Texas Instruments:<BR>
     <EM> TMS 1000 Series MOS/LSI One-Chip Microcomputers
     Programmer's Reference Manual.</EM><BR>
     CM122-1 1275, 1975
<DT><A NAME="cite_Tosh90">[164] </A><DD>Toshiba Corp.:<BR>
     <EM> 8-Bit Microcontroller TLCS-90 Development System
     Manual.</EM><BR>
     1990
<DT><A NAME="cite_Tosh870">[165] </A><DD>Toshiba Corp.:<BR>
     <EM> 8-Bit Microcontroller TLCS-870 Series Data Book.</EM><BR>
     1992
<DT><A NAME="cite_Tosh900">[166] </A><DD>Toshiba Corp.:<BR>
     <EM> 16-Bit Microcontroller TLCS-900 Series Users
     Manual.</EM><BR>
     1992
<DT><A NAME="cite_Tosh900L">[167] </A><DD>Toshiba Corp.:<BR>
     <EM> 16-Bit Microcontroller TLCS-900 Series Data Book:<BR>
     TMP93CM40F/ TMP93CM41F.</EM><BR>
     1993
<DT><A NAME="cite_Tosh47">[168] </A><DD>Toshiba Corp.:<BR>
     <EM> 4-Bit Microcontroller TLCS-47E/47/470/470A Development
     System Manual.</EM><BR>
     1993
<DT><A NAME="cite_Tosh9000">[169] </A><DD>Toshiba Corp.:<BR>
     <EM> TLCS-9000/16 Instruction Set Manual Version 2.2.</EM><BR>
     10. Feb 1994
<DT><A NAME="cite_Tosh9331">[170] </A><DD>Toshiba Corp.:<BR>
     <EM> TC9331 Digital Audio Signal Processor Application
     Information.</EM>
<DT><A NAME="cite_ToshMicro">[171] </A><DD>Toshiba Corp.:<BR>
     <EM> Microcomputer LSI Data Book.</EM> July 1984
<DT><A NAME="cite_Val8X">[172] </A><DD>Valvo GmbH:<BR>
     <EM> Bipolare Mikroprozessoren und bipolare
     LSI-Schaltungen.</EM><BR>
     Datenbuch, 1985, ISBN 3-87095-186-9
<DT><A NAME="cite_VAXArch">[173] </A><DD>Digital Equipment
     Corporation:<BR>
     <EM> VAX Architecture Reference Manual.</EM><BR>
     Order Number EY-3459E-DP, 1987
<DT><A NAME="cite_WD16">[174] </A><DD>Western Digital
     Corporation:<BR>
     <EM> WD16 Microcomputer Programmer's Reference Manual.</EM><BR>
     4 October 1976
<DT><A NAME="cite_Xil213">[175] </A><DD>Ken Chapman (Xilinx
     Inc.):<BR>
     <EM> PicoBlaze 8-Bit Microcontroller for Virtex-E and
     Spartan-II/IIE Devices.</EM><BR>
     Application Note XAPP213, Version 2.1, February 2003
<DT><A NAME="cite_Xil129">[176] </A><DD>Xilinx Inc.:<BR>
     <EM> PicoBlaze 8-bit Embedded Microcontroller User Guide for
     Spartan-3, Virtex-II, and Virtex-II Pro FPGAs.</EM><BR>
     UG129 (v1.1) June 10, 2004
<DT><A NAME="cite_XMOS">[177] </A><DD>David May::<BR>
     <EM> The XMOS XS1 Architecture.</EM><BR>
     Publication Date: 2009/10/19, Copyright 2009 XMOS Ltd.
<DT><A NAME="cite_Zilog">[178] </A><DD>data sheets from Zilog about
     the Z80 family
<DT><A NAME="cite_ZilZ8">[179] </A><DD>Zilog Inc.:<BR>
     <EM> Z8 Microcontrollers Databook.</EM><BR>
     1992
<DT><A NAME="cite_ZilZ8_2">[180] </A><DD>Zilog Inc.:<BR>
     <EM> Discrete Z8 Microcontrollers Databook.</EM><BR>
     (no year of release given)
<DT><A NAME="cite_ZilZ280">[181] </A><DD>Zilog Inc.:<BR>
     <EM> Z280 MPU Microprocessor Unit Technical Manual.</EM><BR>
     July 1987
<DT><A NAME="cite_ZilZ380">[182] </A><DD>Zilog Inc.:<BR>
     <EM> Z380 CPU Central Processing Unit User's Manual.</EM><BR>
     (no year of release given)
<DT><A NAME="cite_ZileZ8">[183] </A><DD>Zilog Inc.:<BR>
     <EM> eZ8 CPU User Manual.</EM><BR>
     UM01285-0503
<DT><A NAME="cite_ZilSuper8">[184] </A><DD>Zilog Inc.:<BR>
     <EM> Z88C00 CMOS Super8 ROMless MCU Product
     Specification</EM><BR>
     2003, PS014602-0103
<DT><A NAME="cite_ZilF0830">[185] </A><DD>Zilog Inc.:<BR>
     <EM> Z8 Encore! F0830 Series Product Specification</EM><BR>
     2012, PS025113-1212
<DT><A NAME="cite_Zil8000">[186] </A><DD>Zilog Inc.:<BR>
     <EM> Z8000 Technical Manual</EM><BR>
     January 1983
<DT><A NAME="cite_ZileZ80UMAN">[187] </A><DD>Zilog Inc.:<BR>
     <EM> eZ80 CPU User Manual</EM><BR>
     2015, UM007715-0415
<DT><A NAME="cite_eZ80190">[188] </A><DD>Zilog Inc.:<BR>
     <EM> eZ80190 Product Specification</EM><BR>
     2008, PS006614-1208
<DT><A NAME="cite_eZ80F91">[189] </A><DD>Zilog Inc.:<BR>
     <EM> eZ80F91 MCU Product Specification</EM><BR>
     2022, PS019217-1222
<DT><A NAME="cite_eZ80F92">[190] </A><DD>Zilog Inc.:<BR>
     <EM> eZ80F92/eZ80F93 Product Specification</EM><BR>
     2020, PS015317-0120
<DT><A NAME="cite_eZ80L92">[191] </A><DD>Zilog Inc.:<BR>
     <EM> eZ80L92 MCU Product Specification</EM><BR>
     2016, PS013015-0316
</DL>
<P>
<P>
<BLOCKQUOTE>
    <I> ''Ich schlage vor, dem Parlament ein Gesetz vorzulegen,<BR>
    das einem Autor, der ein Buch ohne Index publiziert,<BR>
    das Copyright entzieht und ihn au&szlig;erdem f&uuml;r sein
    Vergehen<BR>
    mit einer Geldstrafe belegt.''<BR>
              --Lord John Campbell</I>
</BLOCKQUOTE>
<P>
<H1><A NAME="sect_index">Index</A></H1>
<TABLE SUMMARY="Index" BORDER=0 CELLPADDING=5>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>.EQU <A HREF="#index_.EQU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>.PAGE <A HREF="#index_.PAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>.RESTORE <A HREF="#index_.RESTORE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>.SAVE <A HREF="#index_.SAVE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>.SET <A HREF="#index_.SET_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>.SHIFT <A HREF="#index_.SHIFT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>.SWITCH <A HREF="#index_.SWITCH_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ACCMODE <A HREF="#index_ACCMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ACON <A HREF="#index_ACON_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ADDR <A HREF="#index_ADDR_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>ADDRW <A HREF="#index_ADDRW_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ADR <A HREF="#index_ADR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ALIGN <A HREF="#index_ALIGN_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ASCIC <A HREF="#index_ASCIC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ASCII <A HREF="#index_ASCII_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>ASCIZ <A HREF="#index_ASCIZ_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ASSUME <A HREF="#index_ASSUME_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BFLOAT <A HREF="#index_BFLOAT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BIGENDIAN <A HREF="#index_BIGENDIAN_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BINCLUDE <A HREF="#index_BINCLUDE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>BIT <A HREF="#index_BIT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BLKB <A HREF="#index_BLKB_1">1</A> <A HREF="#index_BLKB_2">2</A></TD>
<TD VALIGN=TOP NOWRAP>BLKD <A HREF="#index_BLKD_1">1</A> <A HREF="#index_BLKD_2">2</A></TD>
<TD VALIGN=TOP NOWRAP>BLKF <A HREF="#index_BLKF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BLKG <A HREF="#index_BLKG_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>BLKH <A HREF="#index_BLKH_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BLKL <A HREF="#index_BLKL_1">1</A> <A HREF="#index_BLKL_2">2</A></TD>
<TD VALIGN=TOP NOWRAP>BLKO <A HREF="#index_BLKO_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BLKQ <A HREF="#index_BLKQ_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BLKW <A HREF="#index_BLKW_1">1</A> <A HREF="#index_BLKW_2">2</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>BLOCK <A HREF="#index_BLOCK_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BSS <A HREF="#index_BSS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BYT <A HREF="#index_BYT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BYTE <A HREF="#index_BYTE_1">1</A> <A HREF="#index_BYTE_2">2</A> <A HREF="#index_BYTE_3">3</A> <A HREF="#index_BYTE_4">4</A></TD>
<TD VALIGN=TOP NOWRAP>CASE <A HREF="#index_CASE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>CHARSET <A HREF="#index_CHARSET_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CIS <A HREF="#index_CIS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CKPT <A HREF="#index_CKPT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CODEPAGE <A HREF="#index_CODEPAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CODEPAGE\_VAL <A HREF="#index_CODEPAGE\_VAL_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>COMPMODE <A HREF="#index_COMPMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CONSTANT <A HREF="#index_CONSTANT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CPU <A HREF="#index_CPU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CUSTOM <A HREF="#index_CUSTOM_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DATA <A HREF="#index_DATA_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DB <A HREF="#index_DB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DBIT <A HREF="#index_DBIT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DC <A HREF="#index_DC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DC8 <A HREF="#index_DC8_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DCM <A HREF="#index_DCM_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DD <A HREF="#index_DD_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DDB <A HREF="#index_DDB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DECIMAL <A HREF="#index_DECIMAL_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DEFB <A HREF="#index_DEFB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DEFBIT <A HREF="#index_DEFBIT_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DEFBITB <A HREF="#index_DEFBITB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DEFBITFIELD <A HREF="#index_DEFBITFIELD_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DEFW <A HREF="#index_DEFW_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DEPHASE <A HREF="#index_DEPHASE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DFS <A HREF="#index_DFS_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DN <A HREF="#index_DN_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DO <A HREF="#index_DO_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DOTTEDSTRUCTS <A HREF="#index_DOTTEDSTRUCTS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DOUBLE <A HREF="#index_DOUBLE_1">1</A> <A HREF="#index_DOUBLE_2">2</A> <A HREF="#index_DOUBLE_3">3</A> <A HREF="#index_DOUBLE_4">4</A> <A HREF="#index_DOUBLE_5">5</A></TD>
<TD VALIGN=TOP NOWRAP>DQ <A HREF="#index_DQ_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DS <A HREF="#index_DS_1">1</A> <A HREF="#index_DS_2">2</A></TD>
<TD VALIGN=TOP NOWRAP>DS16 <A HREF="#index_DS16_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DS8 <A HREF="#index_DS8_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DSB <A HREF="#index_DSB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DSW <A HREF="#index_DSW_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DT <A HREF="#index_DT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DUP <A HREF="#index_DUP_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DW <A HREF="#index_DW_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DW16 <A HREF="#index_DW16_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>D\_FLOATING <A HREF="#index_D\_FLOATING_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>EFLOAT <A HREF="#index_EFLOAT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EIS <A HREF="#index_EIS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ELSE <A HREF="#index_ELSE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ELSECASE <A HREF="#index_ELSECASE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ELSEIF <A HREF="#index_ELSEIF_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>EMULATED <A HREF="#index_EMULATED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>END <A HREF="#index_END_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDCASE <A HREF="#index_ENDCASE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDEXPECT <A HREF="#index_ENDEXPECT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDIAN <A HREF="#index_ENDIAN_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>ENDIF <A HREF="#index_ENDIF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDM <A HREF="#index_ENDM_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDS <A HREF="#index_ENDS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDSTRUC <A HREF="#index_ENDSTRUC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDSTRUCT <A HREF="#index_ENDSTRUCT_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>ENDUNION <A HREF="#index_ENDUNION_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENUM <A HREF="#index_ENUM_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENUMCONF <A HREF="#index_ENUMCONF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EQU <A HREF="#index_EQU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ERROR <A HREF="#index_ERROR_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>EXITM <A HREF="#index_EXITM_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EXPECT <A HREF="#index_EXPECT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EXTENDED <A HREF="#index_EXTENDED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EXTMODE <A HREF="#index_EXTMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FATAL <A HREF="#index_FATAL_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>FB <A HREF="#index_FB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FCB <A HREF="#index_FCB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FCC <A HREF="#index_FCC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FDB <A HREF="#index_FDB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FIS <A HREF="#index_FIS_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>FLOAT <A HREF="#index_FLOAT_1">1</A> <A HREF="#index_FLOAT_2">2</A> <A HREF="#index_FLOAT_3">3</A></TD>
<TD VALIGN=TOP NOWRAP>FLT2 <A HREF="#index_FLT2_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FLT3 <A HREF="#index_FLT3_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FLT4 <A HREF="#index_FLT4_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FP11 <A HREF="#index_FP11_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>FPU <A HREF="#index_FPU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FULLPMMU <A HREF="#index_FULLPMMU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FUNCTION <A HREF="#index_FUNCTION_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FW <A HREF="#index_FW_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>F\_FLOATING <A HREF="#index_F\_FLOATING_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>G\_FLOATING <A HREF="#index_G\_FLOATING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>H\_FLOATING <A HREF="#index_H\_FLOATING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IF <A HREF="#index_IF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFB <A HREF="#index_IFB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFDEF <A HREF="#index_IFDEF_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>IFEXIST <A HREF="#index_IFEXIST_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFNB <A HREF="#index_IFNB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFNDEF <A HREF="#index_IFNDEF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFNEXIST <A HREF="#index_IFNEXIST_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFNSYMEXIST <A HREF="#index_IFNSYMEXIST_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>IFNUSED <A HREF="#index_IFNUSED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFSYMEXIST <A HREF="#index_IFSYMEXIST_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFUSED <A HREF="#index_IFUSED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>INCLUDE <A HREF="#index_INCLUDE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>INTSYNTAX <A HREF="#index_INTSYNTAX_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>IRP <A HREF="#index_IRP_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IRPC <A HREF="#index_IRPC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LABEL <A HREF="#index_LABEL_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LISTING <A HREF="#index_LISTING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LIV <A HREF="#index_LIV_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>LONG <A HREF="#index_LONG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LQxx <A HREF="#index_LQxx_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LTORG <A HREF="#index_LTORG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LWORD <A HREF="#index_LWORD_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LWORDMODE <A HREF="#index_LWORDMODE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>MACEXP <A HREF="#index_MACEXP_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MACEXP\_DFT <A HREF="#index_MACEXP\_DFT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MACEXP\_OVR <A HREF="#index_MACEXP\_OVR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MACRO <A HREF="#index_MACRO_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MAXMODE <A HREF="#index_MAXMODE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>MAXNEST <A HREF="#index_MAXNEST_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MESSAGE <A HREF="#index_MESSAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>NAMEREG <A HREF="#index_NAMEREG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>NEWPAGE <A HREF="#index_NEWPAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>NEXTENUM <A HREF="#index_NEXTENUM_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>OCTAL <A HREF="#index_OCTAL_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ORG <A HREF="#index_ORG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>OUTRADIX <A HREF="#index_OUTRADIX_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PACKED <A HREF="#index_PACKED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PACKING <A HREF="#index_PACKING_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>PADDING <A HREF="#index_PADDING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PAGE <A HREF="#index_PAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PAGESIZE <A HREF="#index_PAGESIZE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PANEL <A HREF="#index_PANEL_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PHASE <A HREF="#index_PHASE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>PLAINBASE <A HREF="#index_PLAINBASE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PMMU <A HREF="#index_PMMU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>POPV <A HREF="#index_POPV_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PORT <A HREF="#index_PORT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PRTEXIT <A HREF="#index_PRTEXIT_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>PRTINIT <A HREF="#index_PRTINIT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PUSHV <A HREF="#index_PUSHV_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>QUAD <A HREF="#index_QUAD_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>Qxx <A HREF="#index_Qxx_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RADIX <A HREF="#index_RADIX_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>RADIX50 <A HREF="#index_RADIX50_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>READ <A HREF="#index_READ_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>REG <A HREF="#index_REG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RELAXED <A HREF="#index_RELAXED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>REPT <A HREF="#index_REPT_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>RES <A HREF="#index_RES_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RESTORE <A HREF="#index_RESTORE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RESTOREENV <A HREF="#index_RESTOREENV_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RIV <A HREF="#index_RIV_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RMB <A HREF="#index_RMB_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>RORG <A HREF="#index_RORG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RSTRING <A HREF="#index_RSTRING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>Registersymbole <A HREF="#index_Registersymbole_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SAVE <A HREF="#index_SAVE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SAVEENV <A HREF="#index_SAVEENV_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>SEGMENT <A HREF="#index_SEGMENT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SELECT <A HREF="#index_SELECT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SET <A HREF="#index_SET_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SFR <A HREF="#index_SFR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SFRB <A HREF="#index_SFRB_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>SHARED <A HREF="#index_SHARED_1">1</A> <A HREF="#index_SHARED_2">2</A> <A HREF="#index_SHARED_3">3</A></TD>
<TD VALIGN=TOP NOWRAP>SHFT <A HREF="#index_SHFT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SHIFT <A HREF="#index_SHIFT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SINGLE <A HREF="#index_SINGLE_1">1</A> <A HREF="#index_SINGLE_2">2</A></TD>
<TD VALIGN=TOP NOWRAP>SPACE <A HREF="#index_SPACE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>SRCMODE <A HREF="#index_SRCMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>STRING <A HREF="#index_STRING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>STRUC <A HREF="#index_STRUC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>STRUCT <A HREF="#index_STRUCT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SUPMODE <A HREF="#index_SUPMODE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>SWITCH <A HREF="#index_SWITCH_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>TFLOAT <A HREF="#index_TFLOAT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>TITLE <A HREF="#index_TITLE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>UNION <A HREF="#index_UNION_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>WARNING <A HREF="#index_WARNING_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>WHILE <A HREF="#index_WHILE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>WORD <A HREF="#index_WORD_1">1</A> <A HREF="#index_WORD_2">2</A> <A HREF="#index_WORD_3">3</A> <A HREF="#index_WORD_4">4</A></TD>
<TD VALIGN=TOP NOWRAP>WRAPMODE <A HREF="#index_WRAPMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>XSFR <A HREF="#index_XSFR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>YSFR <A HREF="#index_YSFR_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>Z80SYNTAX <A HREF="#index_Z80SYNTAX_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ZERO <A HREF="#index_ZERO_1">1</A></TD>
</TR>
</TABLE>
<P>
</BODY>
</HTML>
