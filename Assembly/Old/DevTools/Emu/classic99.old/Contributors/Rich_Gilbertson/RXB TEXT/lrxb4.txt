99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0001 
Version 2.0 (Weiand 1985)     Options : LCSFPF                                  
[0001]               ***********************************************************
[0002]                      TITL 'RXB 2015'
[0003]                      GROM >8000
[0004]               ***********************************************************
[0005]                      TITL 'EQUATES FLMGR-359'
[0006]               ***********************************************************
[0007] A040          CPUBAS EQU  >A040             Expansion RAM base
[0008]               ***********************************************************
[0009]               *           GROM ADDRESSES
[0010] 6038          MZMSG  EQU  >6038             Start of message area
[0011]               ***********************************************************
[0012] 7A06          GTLIST EQU  >7A06             GKXB address
[0013] CB00          KEYTAB EQU  >CB00
[0014] CD77          ERRTAB EQU  >CD77
[0015] CE1F          TRACBK EQU  >CE1F
[0016] CF68          RETNOS EQU  >CF68
[0017] 76EB          EDTZZ0 EQU  >76EB             Edit a line or display it tab
[0018] 76F7          EDTZ00 EQU  >76F7             Edit a line or display it
[0019] 7795          SAVLIN EQU  >7795             Save input line address
[0020]               ***********************************************************
[0021]               *    EQUATES FOR ROUTINES FROM OTHER GROM SECTIONS
[0022]                
[0023] 6012          TOPL15 EQU  >6012             RETURN FROM OLD  or SAVE
[0024] 6014          INITPG EQU  >6014             Initialize program space
[0025] 601A          TOPL10 EQU  >601A             Return to main and re-init
[0026] 6022          KILSYM EQU  >6022             KILL SYMBOL TABLE ROUTINE
[0027] 602E          AUTO1  EQU  >602E             Get arguments for LIST comman
[0028] 6030          TOPL02 EQU  >6030             RTN address for failing AUTOL
[0029] 6032          EDITLN EQU  >6032             Edit a line into the program
[0030] 6036          GWSUB  EQU  >6036             Write a few bytes of data to
[0031] 6053          MSGTA  EQU  >6053             Message "try again"
[0032] 6A74          LLIST  EQU  >6A74             List a line
[0033] 6A76          READLN EQU  >6A76             Read a line from keyboard
[0034] 6A82          WARNZZ EQU  >6A82             WARNING MESSAGE ROUTINE
[0035] 6A84          ERRZZ  EQU  >6A84             ERROR MESSAGE ROUTINE
[0036] 6A84          ERRZ   EQU  >6A84             ERRor routine
[0037] 6A86          READL1 EQU  >6A86             Read a line from keyboard
[0038] A002          LITS05 EQU  >A002             Literal string common code
[0039] A004          EXEC   EQU  >A004
[0040] A006          LINE   EQU  >A006             GET LINE NUMBER ROUTINE
[0041] A008          DATAST EQU  >A008             SEARCH FOR NEXT "DATA" STATEM
[0042] A00A          ASC    EQU  >A00A
[0043] A00C          EXEC1  EQU  >A00C             EXECute a program statememt
[0044] A00E          EXEC6D EQU  >A00E
[0045] A010          DELINK EQU  >A010
[0046] A012          CONVER EQU  >A012             CONVERT WITH WARNING
[0047] A014          SQUISH EQU  >A014
[0048] A016          VALCD  EQU  >A016             CONVERT STRING TO NUMBER
[0049] A018          INTRND EQU  >A018             Initilize random number
[0050] A020          UBSUB  EQU  >A020             CLEAR BREAKPOINTS IN LN # TAB
[0051] A026          LINK1  EQU  >A026             LINK to subprogram
[0052] 0022          ATNZZ  EQU  >0022             Arctangent routine
[0053]               ***********************************************************
[0054]               *    Equates for routine in MONITOR
[0055] 0010          CALDSR EQU  >10               CALL DEVICE SERVICE ROUTINE
[0056] 0012          CFI    EQU  >12               CONVERT TO TWO BYTE INTEGER
[0057] 0034          TONE1  EQU  >34               ACCEPT TONE
[0058] 0036          TONE2  EQU  >36               BAD TONE
[0059] 0018          CHAR2Z EQU  >18               CHARACTER TABLE ADDRESS
[0060] 004A          CHAR3Z EQU  >4A               CHARACTER TABLE ADDRESS
[0061]               ***********************************************************
[0062]               *    Equates for XMLs
[0063] 0000          SYNCHK EQU  >00               SYNCHK XML selector
[0064] 0001          FILSPC EQU  >01               Fill-space utility
[0065] 0002          CSTRIN EQU  >02               Copy-string utility

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0002 
EQUATES FLMGR-359
[0066] 0003          SEETWO EQU  >03               SEETWO XML selector
[0067] 0070          COMPCT EQU  >70               PREFORM A GARBAGE COLLECTION
[0068] 0071          GETSTR EQU  >71               SYSTEM GET STRING
[0069] 0072          MEMCHK EQU  >72               MEMORY check routine: VDP
[0070] 0073          XCNS   EQU  >73               Convert number to string
[0071]               * Warning Default changed in >0073
[0072] 0074          PARSE  EQU  >74               Parse a value
[0073] 0075          CONT   EQU  >75               Continue parsing
[0074] 0077          VPUSH  EQU  >77               Push on value stack
[0075] 0078          VPOP   EQU  >78               Pop off value stack
[0076] 0079          PGMCHR EQU  >79               GET PROGRAM CHARACTER
[0077] 007A          SYM    EQU  >7A               Find SYMBOL entry
[0078] 007B          SMB    EQU  >7B               Also for ARRAYS
[0079] 007C          ASSGNV EQU  >7C               Assign VARIABLE
[0080] 007D          SCHSYM EQU  >7D               Search symbol table
[0081] 007E          SPEED  EQU  >7E               SPEED UP XML
[0082] 007F          CRUNCH EQU  >7F               Crunch an input line
[0083] 0080          CIF    EQU  >80               Convert INTEGER to FLOATING P
[0084] 0081          CONTIN EQU  >81               Continue after a break
[0085] 0083          SCROLL EQU  >83               SCROLL THE SCREEN
[0086] 0084          IO     EQU  >84               IO utility (KW table search)
[0087] 0085          GREAD  EQU  >85               READ DATA FROM ERAM
[0088] 0086          GWRITE EQU  >86               WRITE DATA TO ERAM
[0089] 0087          DELREP EQU  >87               REMOVE CONTENT FROM VDP/ERAM
[0090] 0088          MVDN   EQU  >88               MOVE DATA IN VDP/ERAM
[0091] 0089          MVUP   EQU  >89               MOVE DATA IN VDP/ERAM
[0092] 008A          VGWITE EQU  >8A               MOVE DATA FROM VDP TO ERAM
[0093] 008B          GVWITE EQU  >8B               WRITE DATA FROM GRAM TO VRAM
[0094] 008C          GREAD1 EQU  >8C               READ DATA FROM ERAM
[0095] 008E          GDTECT EQU  >8E               ERAM DETECT&ROM PAGE 1 ENABLE
[0096] 008F          SCNSMT EQU  >8F               SCAN STATEMENT FOR PRESCAN
[0097]               ***********************************************************
[0098]               *    Temporary workspaces in EDIT
[0099] 8300          VAR0   EQU  >8300            TEMPORARY
[0100] 8301          VARV   EQU  >8301            TEMPORARY
[0101] 8302          ACCUM  EQU  >8302            # OF BYTES ACCUMULATOR (4 BYTE
[0102] 8302          STPT   EQU  >8302            TWO BYTES
[0103] 8302          MNUM   EQU  >8302            Ussually a counter
[0104] 8302          AAA1   EQU  >8302
[0105] 8304          VARY   EQU  >8304
[0106] 8304          PABPTR EQU  >8304            Pointer to current PAB
[0107] 8306          VARY2  EQU  >8306            Use in MVDN only
[0108] 8306          DFLTLM EQU  >8306            Default array limit (10)
[0109] 8306          CCPPTR EQU  >8306            OFFSET WITHIN RECORED (1)
[0110]               *                             or Pointer to current column
[0111] 8307          RECLEN EQU  >8307            LENGTH OF CURRENT RECORD (1)
[0112] 8308          CCPADR EQU  >8308            RAM address of current refs
[0113]               *                             or Actual buffer address or c
[0114] 8308          VARC   EQU  >8308
[0115] 8308          CCPADD EQU  >8308            RAM address of current color
[0116] 8308          CCC1   EQU  >8308
[0117] 830A          CALIST EQU  >830A            Call list for resolving refs
[0118] 830A          RAMPTR EQU  >830A            Pointer for crunching
[0119] 830A          STADDR EQU  >830A            Start address - usually for co
[0120] 830C          BYTES  EQU  >830C            BYTE COUNTER
[0121]               *                             or String length for GETSTR
[0122] 830C          NMPTR  EQU  >830C            Pointer save for pscan
[0123] 830C          BBB1   EQU  >830C
[0124] 830E          CHSAV  EQU  >830E
[0125] 830E          CURINC EQU  >830E            Increment for auto-num mode
[0126] 830E          VAR4   EQU  >830E
[0127] 8310          TOPSTK EQU  >8310            Top of data stack pointer
[0128] 8310          VAR5   EQU  >8310
[0129] 8311          VAR6   EQU  >8311

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0003 
EQUATES FLMGR-359
[0130] 8312          LINUM  EQU  >8312            Used to determine end of scan
[0131] 8314          NMLEN  EQU  >8314            Current line for auto-num
[0132] 8314          CURLIN EQU  >8314            Current line for auto-num
[0133]               *                             or Starting line number for L
[0134] 8316          VAR9   EQU  >8316
[0135] 8316          XFLAG  EQU  >8316            SCAN FLAG-BITS USED AS BELOW
[0136] 8317          DSRFLG EQU  >8317            INTERNAL =60, EXTERNAL =0 (1)
[0137] 8317          OPTFLG EQU  >8317            Option flag byte during OPEN
[0138] 8317          FORNET EQU  >8317            Nesting level of for/next
[0139] 8317          FNUM   EQU  >8317            Current file number for search
[0140]               ***********************************************************
[0141]               *    Permanent workspace variables
[0142] 8318          STRSP  EQU  >8318            String space begining
[0143] 831A          STREND EQU  >831A            String space ending
[0144] 831C          SREF   EQU  >831C            Temporary string pointer
[0145] 831E          SMTSRT EQU  >831E            Start of current statement
[0146] 8320          VARW   EQU  >8320            Screen address (CURSOR)
[0147] 8322          ERRCOD EQU  >8322            Return error code from ALC
[0148] 8324          STVSPT EQU  >8324            Value-stack base
[0149] 8326          RTNG   EQU  >8326            Return vector from 9900 code
[0150] 8328          NUDTAB EQU  >8328            Start of NUD table
[0151] 832A          VARA   EQU  >832A            Ending display location
[0152] 832C          PGMPTR EQU  >832C            Program text pointer (TOKEN)
[0153] 832E          EXTRAM EQU  >832E            Line number table pointer
[0154] 8330          STLN   EQU  >8330            Start of line number table
[0155] 8332          ENLN   EQU  >8332            End of line number table
[0156] 8334          DATA   EQU  >8334            Data pointer for READ
[0157] 8336          LNBUF  EQU  >8336            Line table pointer for READ
[0158] 8338          INTRIN EQU  >8338            Add of intrinsic poly constant
[0159] 833A          SUBTAB EQU  >833A            Subprogram symbol table
[0160] 833C          IOSTRT EQU  >833C            PAB list/Start of I/O chain
[0161] 833E          SYMTAB EQU  >833E            Symbol table pointer
[0162] 8340          FREPTR EQU  >8340            Free space pointer
[0163] 8342          CHAT   EQU  >8342            Current charater/token
[0164] 8343          BASE   EQU  >8343            OPTION BASE value
[0165] 8344          PRGFLG EQU  >8344            Program/imperative flag
[0166] 8345          FLAG   EQU  >8345            General 8-bit flag
[0167] 8346          BUFLEV EQU  >8346            Crunch-buffer destruction leve
[0168] 8348          LSUBP  EQU  >8348            Last subprogram block on stack
[0169]               * FAC  EQU  >834A            Floating-point ACcurmulator
[0170] 834B          FAC1   EQU  FAC+1
[0171] 834C          FAC2   EQU  FAC+2
[0172] 834C          AAA    EQU  FAC+2
[0173] 834D          FAC3   EQU  FAC+3
[0174] 834E          FAC4   EQU  FAC+4
[0175] 834E          CCC    EQU  FAC+4
[0176] 834E          FFF    EQU  FAC+4
[0177] 834F          FAC5   EQU  FAC+5
[0178] 8350          FAC6   EQU  FAC+6
[0179] 8350          BBB    EQU  FAC+6
[0180] 8350          EEE    EQU  FAC+6
[0181] 8351          FAC7   EQU  FAC+7
[0182] 8352          FAC8   EQU  FAC+8
[0183] 8353          FAC9   EQU  FAC+9
[0184] 8354          FAC10  EQU  FAC+10
[0185] 8354          DDD1   EQU  FAC+10
[0186] 8355          FAC11  EQU  FAC+11
[0187] 8356          FAC12  EQU  FAC+12
[0188] 8356          FFF1   EQU  FAC+12
[0189] 8357          FAC13  EQU  FAC+13
[0190] 8358          FAC14  EQU  FAC+14
[0191] 8358          EEE1   EQU  FAC+14
[0192] 8359          FAC15  EQU  FAC+15
[0193] 835A          FAC16  EQU  FAC+16

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0004 
EQUATES FLMGR-359
[0194] 835B          FAC17  EQU  FAC+17
[0195]               * ARG  EQU  >835C             Floating-point ARGument
[0196] 835D          ARG1   EQU  ARG+1
[0197] 835E          ARG2   EQU  ARG+2
[0198] 835F          ARG3   EQU  ARG+3
[0199] 8360          ARG4   EQU  ARG+4
[0200] 8361          ARG5   EQU  ARG+5
[0201] 8362          ARG6   EQU  ARG+6
[0202] 8363          ARG7   EQU  ARG+7
[0203] 8364          ARG8   EQU  ARG+8
[0204] 8364          XSTLN  EQU  >8364            GKXB variable
[0205] 8366          TEMP5  EQU  >8366
[0206] 8367          ARG11  EQU  ARG+11
[0207] 836B          ARG15  EQU  ARG+15
[0208] 836C          ARG16  EQU  ARG+16
[0209]               * VSPTR  EQU  >836E          Value stack pointer
[0210]               ***********************************************************
[0211]               *    GPL Status Block
[0212] 8370          HIVDP  EQU  >8370             Highest VDP available
[0213] 8372          STACK  EQU  >8372             STACK FOR DATA
[0214] 8374          KEYBD  EQU  >8374             KEYBOARD SELCTION
[0215] 8375          RKEY   EQU  >8375             KEY CODE
[0216] 8376          EXPZ   EQU  >8376             Exponent in floating-point
[0217] 8378          RANDOM EQU  >8378             RANDOM NUMBER GENERATOR
[0218] 8379          TIMER  EQU  >8379             TIMING REGISTER
[0219] 837A          MOTION EQU  >837A             NUMBER OF MOVING SPRITES
[0220] 837B          VDPSTS EQU  >837B             VDP STATUS REGISTER
[0221] 837C          ERCODE EQU  >837C             STATUS REGISTER
[0222]               ***********************************************************
[0223] 8384          RAMTOP EQU  >8384            Highest address in ERAM
[0224] 8386          RAMFRE EQU  >8386            Free pointer in the ERAM
[0225] 8388          RSTK   EQU  >8388            Subroutine stack base
[0226]               *                             (Starts at >8A)
[0227] 8389          RAMFLG EQU  >8389            ERAM flag
[0228] 83AF          STKMIN EQU  >83AF            Base of data stack
[0229] 83BD          STKMAX EQU  >83BD            Top of data stack
[0230] 83CE          PRTNFN EQU  >83CE            Sound - previous tone finished
[0231]               ***********************************************************
[0232]               *    VDP addresses
[0233] 02E0          SCRNBS EQU  >02E0             Screen base addr for last lin
[0234] 02E2          NLNADD EQU  >02E2             New LiNe ADDress
[0235] 02FE          ENDSCR EQU  >02FE             END of SCReen address
[0236] 0371          LODFLG EQU  >0371             Auto-boot needed flag
[0237] 0372          START  EQU  >0372             Line to start execution at
[0238]               * Temporary
[0239] 0374          NOTONE EQU  >0374             NO-TONE for SIZE in ACCEPT us
[0240]               *                              in FLMGRS (4 bytes used)
[0241] 0376          SYMBOL EQU  >0376             Saved symbol table pointer
[0242] 0382          SPGMPT EQU  >0382             Saved PGMPTR for continue
[0243] 0384          SBUFLV EQU  >0384             Saved BUFLEV for contiue
[0244] 0386          SEXTRM EQU  >0386             Saved EXTRAM for continue
[0245] 0388          SAVEVP EQU  >0388             Saved VSPRT for continue
[0246] 038A          ERRLN  EQU  >038A             On-error line pointer
[0247] 038C          BUFSRT EQU  >038C             Edit recall start addr (VARW)
[0248] 038E          BUFEND EQU  >038E             Edit recall end addr (VARA)
[0249] 0390          CSNTMP EQU  >0390             Use as temporary stored place
[0250]               *                          or CSN TEMPORARY FOR FAC12
[0251] 0392          TABSAV EQU  >0392             Saved main symbol table ponte
[0252] 0394          AUTTMP EQU  >0394             AUTOLD TEMPORARY IN SIDE ERRZ
[0253] 0396          SLSUBP EQU  >0396             Saved LSUBP for continue
[0254] 0398          SFLAG  EQU  >0398             Saved on-warning/break bits
[0255] 039A          SSTEMP EQU  >039A             To save subprogram program ta
[0256] 039C          SSTMP2 EQU  >039C             Same as above. Used in SUBPRO
[0257] 039E          MRGPAB EQU  >039E             MERGEd temporary for pab ptr

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0005 
EQUATES FLMGR-359
[0258] 03AA          INPUTP EQU  >03AA             INPUT TEMPORARY FOR PTR TO PR
[0259] 03AC          ACCVRW EQU  >03AC             Temoporary used in ERRZZ, als
[0260]               *                              used in FLMGRS
[0261]               *                             or temporary for @VARW, @VARA
[0262] 03AE          ACCVRA EQU  >03AE             TRY AGAIN
[0263] 03B0          VALIDP EQU  >03B0             Use as two values passing fro
[0264]               *                          or PTR TO STANDARD STRING IN VAL
[0265] 03B2          VALIDL EQU  >03B2             VALIDATE code to READL1
[0266]               *                          or Length of string in validate
[0267] 03B4          SIZCCP EQU  >03B4             SIZE TEMPORARY FOR CCPADR
[0268] 03B6          SIZREC EQU  >03B6             SIZE TEMPORARY FOR RECLEN
[0269]               *                            Also used as temporary in RELO
[0270]               *----------------------------------------------------------
[0271]               * Added 6/8/81 for NOPSCAN feature
[0272] 03B7          PSCFG  EQU  >03B7
[0273]               *----------------------------------------------------------
[0274] 03B7          ACCTRY EQU  >03B7             ACCEPT "TRY AGAIN" FLAG
[0275] 03B8          SIZXPT EQU  >03B8             Save XPT in SIZE when "try ag
[0276] 03B9          SAPROT EQU  >03B9             PROTECTION flag in SAVE
[0277] 03BA          CSNTP1 EQU  >03BA             CSN TEMPORARY FOR FAC10
[0278]               *----------------------------------------------------------
[0279]               *    Flag 0:  99/4  console, 5/29/81
[0280]               *         1:  99/4A console
[0281] 03BB          CONFLG EQU  >03BB
[0282]               *----------------------------------------------------------
[0283] 03BC          OLDTOP EQU  >03BC             Temporary used in ERRZZ, also
[0284]               *                          or Old top of memory for RELOCA
[0285] 03BC          CPTEMP EQU  >03BC             CCPPTR, RECLEN temp in INPUT
[0286] 03BE          NEWTOP EQU  >03BE             New top of memory for RELOCA
[0287] 03C0          VROAZ  EQU  >03C0             Temporary VDP Roll Out Area
[0288] 0820          CRNBUF EQU  >0820             CRuNch BUFfer address
[0289] 08BE          CRNEND EQU  >08BE             CRuNch buffer END
[0290] 08C0          RECBUF EQU  >08C0             Edit RECall BUFfer
[0291] 0958          VRAMVS EQU  >0958             Default base of value stack
[0292]               ***********************************************************
[0293]               *    IMMEDITATE VALUES
[0294] 0000          NUMBR  EQU  >00               NUMERIC validate
[0295] 0002          LISTZ  EQU  >02
[0296] 0005          OLDZ   EQU  >05
[0297] 0006          RESEQZ EQU  >06
[0298] 0007          SAVEZ  EQU  >07
[0299] 0008          MERGEZ EQU  >08
[0300] 000A          DWNARR EQU  >0A
[0301] 000B          UPARR  EQU  >0B
[0302] 000D          CHRTN  EQU  >0D
[0303] 0020          BKGD   EQU  >20               BACKGROUND CHARACTER
[0304] 0060          OFFSET EQU  >60               OFFSET FOR VIDEO TABLES
[0305] 0065          STRVAL EQU  >65               Value in accum. is string val
[0306]               ***********************************************************
[0307]               * Editting command equates
[0308] 0002          BREAK  EQU  >02               Break key
[0309] 0003          DLETE  EQU  >03               Delete key
[0310] 0004          INSRT  EQU  >04               Insert key
[0311] 0006          RECALL EQU  >06               Edit-buffer recall
[0312] 0007          CLRLN  EQU  >07               Clear-line key
[0313] 0008          BACK   EQU  >08               Back-space key
[0314] 0009          FORW   EQU  >09               Forward-space key
[0315] 000A          DOWN   EQU  >0A               Down-arrow key
[0316] 000B          UPMV   EQU  >0B               Up-arrow key
[0317] 001C          VWIDTH EQU  >1C               Screen width (PRINT)
[0318] 0020          SPACE  EQU  >20               Space key
[0319] 0022          QUOTE  EQU  >22               "
[0320] 0024          DOLLAR EQU  >24               $
[0321] 007E          CURSOR EQU  >1E+OFFSET        CURSOR

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0006 
EQUATES FLMGR-359
[0322] 007F          EDGECH EQU  >1F+OFFSET        EDGE character
[0323] 002C          COMMA  EQU  >2C               ,
[0324] 002D          MINUS  EQU  >2D               -
[0325]               ***********************************************************
[0326]               * PAB offset
[0327] 0000          CZOPEN EQU  0                 OPEN CODE
[0328] 0001          CZCLOS EQU  1                 CLOSE CODE
[0329] 0002          FIL    EQU  2                 File number within BASIC(0-25
[0330] 0002          CZREAD EQU  2                 READ CODE
[0331] 0003          OFS    EQU  3                 Offset within record
[0332] 0003          CZWRIT EQU  3                 WRITE CODE
[0333] 0004          COD    EQU  4                 I/O code
[0334] 0004          CZREST EQU  4                 RESTORE/REWIND CODE
[0335] 0005          FLG    EQU  5                 I/O mode flag byte
[0336] 0005          CZLOAD EQU  5                 LOAD CODE
[0337] 0006          BUF    EQU  6                 Start of data buffer
[0338] 0006          CZSAVE EQU  6                 SAVE CODE
[0339] 0007          CZDELE EQU  7                 DELETE CODE
[0340] 0008          LEN    EQU  8                 Record length
[0341] 0008          CZSCR  EQU  8                 SCRATCH CODE
[0342] 0009          CNT    EQU  9                 Character count
[0343] 0009          CZSTAT EQU  9                 STATUS CODE
[0344] 000A          RNM    EQU  10                Record number
[0345] 000C          SCR    EQU  12                Screen base offset
[0346] 000D          NLEN   EQU  13                Length of file descriptor
[0347] 000E          PABLEN EQU  14                PAB LENGTH
[0348]               ***********************************************************
[0349]               *    BASIC TOKEN TABLE
[0350]               *      EQU  >80               spare token
[0351] 0081          ELSEZ  EQU  >81               ELSE
[0352] 0082          SSEPZ  EQU  >82               ::
[0353] 0083          TREMZ  EQU  >83               $
[0354] 0084          IFZ    EQU  >84               IF
[0355] 0085          GOZ    EQU  >85               GO
[0356] 0086          GOTOZ  EQU  >86               GOTO
[0357] 0087          GOSUBZ EQU  >87               GOSUB
[0358] 0088          RETURZ EQU  >88               RETURN
[0359] 0089          DEFZ   EQU  >89               DEF
[0360] 008A          DIMZ   EQU  >8A               DIM
[0361] 008B          ENDZ   EQU  >8B               END
[0362] 008C          FORZ   EQU  >8C               FOR
[0363] 008D          LETZ   EQU  >8D               LET
[0364] 008E          BREAKZ EQU  >8E               BREAK
[0365] 008F          UNBREZ EQU  >8F               UNBREAK
[0366] 0090          TRACEZ EQU  >90               TRACE
[0367] 0091          UNTRAZ EQU  >91               UNTRACE
[0368] 0092          INPUTZ EQU  >92               INPUT
[0369] 0093          DATAZ  EQU  >93               DATA
[0370] 0094          RESTOZ EQU  >94               RESTORE
[0371] 0095          RANDOZ EQU  >95               RANDOMIZE
[0372] 0096          NEXTZ  EQU  >96               NEXT
[0373] 0097          READZ  EQU  >97               READ
[0374] 0098          STOPZ  EQU  >98               STOP
[0375] 0099          DELETZ EQU  >99               DELETE
[0376] 009A          REMZ   EQU  >9A               REM
[0377] 009B          ONZ    EQU  >9B               ON
[0378] 009C          PRINTZ EQU  >9C               PRINT
[0379] 009D          CALLZ  EQU  >9D               CALL
[0380] 009E          OPTIOZ EQU  >9E               OPTION
[0381] 009F          OPENZ  EQU  >9F               OPEN
[0382] 00A0          CLOSEZ EQU  >A0               CLOSE
[0383] 00A1          SUBZ   EQU  >A1               SUB
[0384] 00A2          DISPLZ EQU  >A2               DISPLAY
[0385] 00A3          IMAGEZ EQU  >A3               IMAGE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0007 
EQUATES FLMGR-359
[0386] 00A4          ACCEPZ EQU  >A4               ACCEPT
[0387] 00A5          ERRORZ EQU  >A5               ERROR
[0388] 00A6          WARNZ  EQU  >A6               WARNING
[0389] 00A7          SUBXTZ EQU  >A7               SUBEXIT
[0390] 00A8          SUBNDZ EQU  >A8               SUBEND
[0391] 00A9          RUNZ   EQU  >A9               RUN
[0392] 00AA          LINPUZ EQU  >AA               LINPUT
[0393]               *      EQU  >AB               spare token (LIBRARY)
[0394]               *      EQU  >AC               spare token (REAL)
[0395]               *      EQU  >AD               spare token (INTEGER)
[0396]               *      EQU  >AE               spare token (SCRATCH)
[0397]               *      EQU  >AF               spare token
[0398] 00B0          THENZ  EQU  >B0               THEN
[0399] 00B1          TOZ    EQU  >B1               TO
[0400] 00B2          STEPZ  EQU  >B2               STEP
[0401] 00B3          COMMAZ EQU  >B3               ,
[0402] 00B4          SEMICZ EQU  >B4               ;
[0403] 00B5          COLONZ EQU  >B5               :
[0404] 00B6          RPARZ  EQU  >B6               )
[0405] 00B7          LPARZ  EQU  >B7               (
[0406] 00B8          CONCZ  EQU  >B8               &          (CONCATENATE)
[0407]               *      EQU  >B9               spare token
[0408] 00BA          ORZ    EQU  >BA               OR
[0409] 00BB          ANDZ   EQU  >BB               AND
[0410] 00BC          XORZ   EQU  >BC               XOR
[0411] 00BD          NOTZ   EQU  >BD               NOT
[0412] 00BE          EQUALZ EQU  >BE               =
[0413] 00BF          LESSZ  EQU  >BF               <
[0414] 00C0          GREATZ EQU  >C0               >
[0415] 00C1          PLUSZ  EQU  >C1               +
[0416] 00C2          MINUSZ EQU  >C2               -
[0417] 00C3          MULTZ  EQU  >C3               *
[0418] 00C4          DIVIZ  EQU  >C4               /
[0419] 00C5          CIRCUZ EQU  >C5               ^
[0420]               *      EQU  >C6               spare token
[0421] 00C7          STRINZ EQU  >C7               QUOTED STRING
[0422] 00C8          UNQSTZ EQU  >C8               UNQUOTED STRING
[0423] 00C8          NUMZ   EQU  >C8               ALSO NUMERICAL STRING
[0424] 00C8          NUMCOZ EQU  >C8               ALSO UNQUOTED STRING
[0425] 00C9          LNZ    EQU  >C9               LINE NUMBER CONSTANT
[0426]               *      EQU  >CA               spare token
[0427] 00CB          ABSZ   EQU  >CB               ABS
[0428] 00CC          ATNZ   EQU  >CC               ATN
[0429] 00CD          COSZ   EQU  >CD               COS
[0430] 00CE          EXPZZ  EQU  >CE               EXP
[0431] 00CF          INTZ   EQU  >CF               INT
[0432] 00D0          LOGZ   EQU  >D0               LOG
[0433] 00D1          SGNZZ  EQU  >D1               SGN
[0434] 00D2          SINZ   EQU  >D2               SIN
[0435] 00D3          SQRZ   EQU  >D3               SQR
[0436] 00D4          TANZ   EQU  >D4               TAN
[0437] 00D5          LENZ   EQU  >D5               LEN
[0438] 00D6          CHRZZ  EQU  >D6               CHR$
[0439] 00D7          RNDZ   EQU  >D7               RND
[0440] 00D8          SEGZZ  EQU  >D8               SEG$
[0441] 00D9          POSZ   EQU  >D9               POS
[0442] 00DA          VAL    EQU  >DA               VAL
[0443] 00DB          STRZZ  EQU  >DB               STR$
[0444] 00DC          ASCZ   EQU  >DC               ASC
[0445] 00DD          PIZ    EQU  >DD               PI
[0446] 00DE          RECZ   EQU  >DE               REC
[0447] 00DF          MAXZ   EQU  >DF               MAX
[0448] 00E0          MINZ   EQU  >E0               MIN
[0449] 00E1          RPTZZ  EQU  >E1               RPT$

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0008 
EQUATES FLMGR-359
[0450]               *      EQU  >E2               unused
[0451]               *      EQU  >E2               unused
[0452]               *      EQU  >E3               unused
[0453]               *      EQU  >E4               unused
[0454]               *      EQU  >E5               unused
[0455]               *      EQU  >E6               unused
[0456]               *      EQU  >E7               unused
[0457] 00E8          NUMERZ EQU  >E8               NUMERIC
[0458] 00E9          DIGITZ EQU  >E9               DIGIT
[0459] 00EA          UALPHZ EQU  >EA               UALPHA
[0460] 00EB          SIZEZ  EQU  >EB               SIZE
[0461] 00EC          ALLZ   EQU  >EC               ALL
[0462] 00ED          USINGZ EQU  >ED               USING
[0463] 00EE          BEEPZ  EQU  >EE               BEEP
[0464] 00EF          ERASEZ EQU  >EF               ERASE
[0465] 00F0          ATZ    EQU  >F0               AT
[0466] 00F1          BASEZ  EQU  >F1               BASE
[0467]               *      EQU  >F2               spare token (TEMPORARY)
[0468] 00F3          VARIAZ EQU  >F3               VARIABLE
[0469] 00F4          RELATZ EQU  >F4               RELATIVE
[0470] 00F5          INTERZ EQU  >F5               INTERNAL
[0471] 00F6          SEQUEZ EQU  >F6               SEQUENTIAL
[0472] 00F7          OUTPUZ EQU  >F7               OUTPUT
[0473] 00F8          UPDATZ EQU  >F8               UPDATE
[0474] 00F9          APPENZ EQU  >F9               APPEND
[0475] 00FA          FIXEDZ EQU  >FA               FIXED
[0476] 00FB          PERMAZ EQU  >FB               PERMANENT
[0477] 00FC          TABZ   EQU  >FC               TAB
[0478] 00FD          NUMBEZ EQU  >FD               #
[0479] 00FE          VALIDZ EQU  >FE               VALIDATE
[0480]               *      EQU  >FF               ILLEGAL VALUE
[0481]               ***********************************************************
[0482]                      TITL 'FLMGR-359'
[0483]               ***********************************************************
[0484]               *                        GROM HEADER
[0485]               ***********************************************************
[0486]               *    Branch table routines
[0487]               ***********************************************************
[0488] 8000 42,57           BR   DISPL1            DISPLAY routine
[0489] 8002 41,7C           BR   DELET             DELETE routine
[0490] 8004 42,66           BR   PRINT             PRINT routine
[0491] 8006 45,F0           BR   INPUT             INPUT routine (not yet impele
[0492] 8008 40,32           BR   OPEN              OPEN routine
[0493] 800A 41,96           BR   CLOSE             CLOSE routine
[0494] 800C 41,FC           BR   RESTOR            RESTORE routine
[0495] 800E 4B,3A           BR   READ              READ routine
[0496] 8010 53,08           BR   GETDAT            Get DATA from ERAM/VDP (not u
[0497] 8012 41,F4           BR   CLSALL            CLOSE ALL OPEN FILES subrouti
[0498] 8014 4D,B8           BR   SAVE              SAVE routine
[0499] 8016 4B,C4           BR   OLD               LOAD routine
[0500] 8018 50,68           BR   LIST              LIST routine
[0501] 801A 56,A5           BR   OUTREC            Output record routine
[0502] 801C 51,DE           BR   EOF               End of file routine
[0503] 801E 49,6B           BR   ACCEPT            ACCEPT routine
[0504] 8020 4B,96           BR   SRDATA            Search "DATAZ" routine
[0505] 8022 51,CA           BR   SUBREC            RECORD routine
[0506] 8024 55,AD           BR   CHKEND            Check EOS
[0507] 8026 4B,CA           BR   OLD1              A subroutine for LOAD
[0508] 8028 50,02           BR   MERGE             MERGE a program
[0509] 802A 51,79           BR   GRMLST            List a line out of ERAM
[0510] 802C 51,A4           BR   GRSUB2            Read 2 bytes of data from ERA
[0511] 802E 51,BC           BR   GRSUB3            Read 2 bytes of data from ERA
[0512]               *                             with resetting possible break
[0513] 8030 48,41           BR   LINPUT              LINPUT statement

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0009 
FLMGR-359
[0514]               ***********************************************************
[0515]               *               OPEN STATEMENT HANDLER
[0516]               * Handle the BASIC OPNE statement. A legal syntax can only
[0517]               * be something like
[0518]               *      OPEN #{exp}:{string-exp}[,{open-options}]
[0519]               * in which {open-option} is any of the following
[0520]               * DISPLAY, INPUT, VARIABLE, RELATIVE, INTERNAL, SEQUENTIAL,
[0521]               * OUTPUT, UPDATE, APPEND, FIXED or PERMANENT
[0522]               *
[0523]               * Each keyword can only be used once, which is being checke
[0524]               * with an OPTFLG-bit. For each specific option please refer
[0525]               * to the related routine.
[0526]               * Scanning stops as soon as no next field starting with a
[0527]               * comma can be found.
[0528]               * NOTE: After the actual DSR OPEN has been preformed, the
[0529]               *       length of the record, whether VARIABLE or FIXED,
[0530]               *       has to be non-zero. A zero length will cause an
[0531]               *       INCORRECT STATEMENT error.
[0532]               ***********************************************************
[0533] 8032 06,93,55 OPEN   CALL CHKFN             See if we specified any file
[0534] 8035 77,D7           BS   ERRFE             Definitely not... no # or #0
[0535] 8037 06,93,71        CALL CHKCON            Check and search given filenu
[0536] 803A 77,D7           BS   ERRFE             *** FILE NUMBER EXISTS ***
[0537]               * ERROR IF NOT STOPPED ON COLON
[0538] 803C 0F,7E           XML  SPEED             Must be at a
[0539] 803E 00              BYTE SYNCHK          *  colon or else
[0540] 803F B5              BYTE COLONZ          *   its an error
[0541] 8040 06,96,5A        CALL PARFN             Parse filename and create PAB
[0542] 8043 93,2C           DDEC @PGMPTR           Backup pgm pointer for next t
[0543] 8045 0F,79    OPTION XML  PGMCHR            Get next program character
[0544]               * Next field should start with a comma
[0545] 8047 D6,42,B3 OPTIZ0 CEQ  COMMAZ,@CHAT
[0546] 804A 41,0D           BR   CHECK
[0547]               * Enter HERE after comma exit in "SEQUENTIAL"
[0548] 804C 0F,79    OPTIZ1 XML  PGMCHR            Next token please...
[0549]               * Treat DISPLAY and INPUT as special cases
[0550] 804E D6,42,A2        CEQ  DISPLZ,@CHAT
[0551] 8051 60,EA           BS   OPTZ6
[0552] 8053 D6,42,92        CEQ  INPUTZ,@CHAT
[0553] 8056 60,F4           BS   OPTZ7
[0554] 8058 A6,42,F3        SUB  VARIAZ,@CHAT      Reduce keyword offset to 0
[0555] 805B CA,42,09        CHE  9,@CHAT           Keyword to high
[0556] 805E 61,06           BS   OPERR
[0557] 8060 8A,42           CASE @CHAT             JUST IN CASE
[0558] 8062 40,BE           BR   OPTZ01            Option VARIABLE
[0559] 8064 40,7C           BR   OPTZ02                   RELATIVE
[0560] 8066 40,E5           BR   OPTZ03                   INTERNAL
[0561] 8068 40,81           BR   OPTZ1                    SEQUENTIAL
[0562] 806A 40,A8           BR   OPTZ2                    OUTPUT
[0563] 806C 40,AD           BR   OPTZ3                    UPDATE
[0564] 806E 40,B7           BR   OPTZ4                    APPEND
[0565] 8070 40,C3           BR   OPTZ5                    FIXED
[0566]               *      BR   OPTZ0                    PERMANENT       <<<<<<
[0567]               * CASE 0 - "PERMANENT" ************************************
[0568]               *  Only check for multiple usage. Since PERMANENT is the
[0569]               *  default, we might as well ignore it...
[0570] 8072 DA,17,04 OPTZ0  CLOG >04,@OPTFLG
[0571] 8075 41,06           BR   OPERR
[0572] 8077 B6,17,04        OR   >04,@OPTFLG       Not used ... use now
[0573] 807A 40,45           BR   OPTION            Treat as simple default
[0574]               * CASE 2 - "RELATIVE" *************************************
[0575]               *  Select relative record file in PAB and fall through in
[0576]               *  SEQUENTIAL code for multiple usage check. Also handle
[0577]               *  initial file-size there.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0010 
FLMGR-359
[0578] 807C B6,E0,05 OPTZ02 OR   >01,V@FLG(@PABPTR) Indicate RELATIVE RECORD
       807F 04,01
[0579]               * CASE 4 - "SEQUENTIAL" ***********************************
[0580]               *  Checks for multiple usage. Remainder of syntax demads th
[0581]               *  we have something like:
[0582]               *                         [{numeric expression}],...
[0583]               *  In case only a comma is found, we use the default.
[0584]               *  Everything else has to be evaluated as a numeric
[0585]               *  expression, convertable to a 16-bit integer value.
[0586] 8081 DA,17,08 OPTZ1  CLOG >08,@OPTFLG
[0587] 8084 41,06           BR   OPERR
[0588] 8086 B6,17,08        OR   >08,@OPTFLG       First time usage, ok
[0589] 8089 0F,79           XML  PGMCHR            Check next token for default
[0590]               * Comma means default has been used
[0591] 808B D6,42,B3        CEQ  COMMAZ,@CHAT
[0592] 808E 60,4C           BS   OPTIZ1
[0593] 8090 06,95,AD        CALL CHKEND            Check for end of statement
[0594] 8093 61,0D           BS   CHECK
[0595] 8095 06,80,9F        CALL CHKPAR            Preform combined checking & p
[0596] 8098 BD,E0,0A        DST  @FAC,V@RNM(@PABPTR) Non-zero result
       809B 04,4A
[0597] 809D 40,47           BR   OPTIZ0            Scan other options
[0598]               * Parse and check a numeric argument in here....
[0599] 809F 0F,74    CHKPAR XML  PARSE             If not ... parse up to comma
[0600] 80A1 B3              BYTE COMMAZ
[0601] 80A2 06,93,5C        CALL CHKCNV            Check and convert to integer
[0602] 80A5 61,06           BS   OPERR             Oops..., someone made a mista
[0603] 80A7 00              RTN                    Return to caller
[0604]               * CASE 5 - "OUTPUT" ***************************************
[0605]               *  Select mode code "01" and check for multiple usage. Use
[0606]               *  MFLAG bit in OPTFLG for checking.
[0607] 80A8 B6,E0,05 OPTZ2  OR   >02,V@FLG(@PABPTR)  Mode code = 01
       80AB 04,02
[0608]               * CASE 6 - "UPDATE" ***************************************
[0609]               *  Default ... Check for multiple usage only...
[0610]               *  Test for previous usage of any mode setting
[0611] 80AD DA,17,01 OPTZ3  CLOG >01,@OPTFLG
[0612] 80B0 41,06           BR   OPERR
[0613] 80B2 B6,17,01        OR   >01,@OPTFLG       If not... set "MODE USED" bit
[0614] 80B5 40,45           BR   OPTION            Continue option scan
[0615]               * CASE 7 - "APPEND" ***************************************
[0616]               *  Mode code "11" indicates APPEND mode.
[0617] 80B7 B6,E0,05 OPTZ4  OR   >06,V@FLG(@PABPTR)  Mode code = 11
       80BA 04,06
[0618] 80BC 40,AD           BR   OPTZ3
[0619]               * CASE 1 - "VARIABLE" *************************************
[0620]               *  Change record type to VARIABLE and continue as FIXED
[0621] 80BE B6,E0,05 OPTZ01 OR   >10,V@FLG(@PABPTR)  Indicate variable length mo
       80C1 04,10
[0622]                
[0623]               * CASE 8 - "FIXED" ****************************************
[0624]               *  Fixed is default. Don't change anything, unless argument
[0625]               *  is given. In this case evaluate as numeric expression an
[0626]               *  check for 8-bit integer range...
[0627]               *  This routine is also used for VARIABLE !!!!!
[0628] 80C3 0F,79    OPTZ5  XML  PGMCHR            Get next character
[0629] 80C5 D6,42,B3        CEQ  COMMAZ,@CHAT      Could be some argument
[0630] 80C8 60,DB           BS   OPTZ55
[0631] 80CA 06,95,AD        CALL CHKEND            Could also be end of statemen
[0632] 80CD 60,DB           BS   OPTZ55            It is an EOS
[0633] 80CF 06,80,9F        CALL CHKPAR            Check & parse expression
[0634]               * Check for byte overflow (records can only be up to 255
[0635]               * bytes in length)
[0636] 80D2 8E,4A           CZ   @FAC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0011 
FLMGR-359
[0637] 80D4 41,06           BR   OPERR
[0638] 80D6 BC,E0,08        ST   @FAC1,V@LEN(@PABPTR) Select non-zero rec-size
       80D9 04,4B
[0639] 80DB DA,17,10 OPTZ55 CLOG >10,@OPTFLG
[0640] 80DE 41,06           BR   OPERR
[0641] 80E0 B6,17,10        OR   >10,@OPTFLG       Prevent to much usage of mode
[0642] 80E3 40,47           BR   OPTIZ0             Continue option scan
[0643]               * CASE 3 - "INTERNAL" *************************************
[0644]               *  Select INTERANL file type and continue in DIPLAY
[0645] 80E5 B6,E0,05 OPTZ03 OR   8,V@FLG(@PABPTR)  Select INTERNAL type
       80E8 04,08
[0646]               * CASE 9 - "DISPLAY" **************************************
[0647]               *  Default. Only check for multiple usage of either DISPLAY
[0648]               *  or INTERNAL...
[0649] 80EA DA,17,02 OPTZ6  CLOG >02,@OPTFLG
[0650] 80ED 41,06           BR   OPERR
[0651] 80EF B6,17,02        OR   >02,@OPTFLG       Else set "DISPLAY/INTERAL" fl
[0652] 80F2 40,45           BR   OPTION            Continue... DISPLAY is defaul
[0653]               * CASE 10 "INPUT" *****************************************
[0654]               *  Same as any other I/O type definition. Mode code "10" ..
[0655]               *  Continue in OPTZ3
[0656] 80F4 B6,E0,05 OPTZ7  OR   >04,V@FLG(@PABPTR) Mode code = 10
       80F7 04,04
[0657] 80F9 40,AD           BR   OPTZ3
[0658]               * CLRFRE deallocates previously alocated (parts of) PAB's a
[0659]               * return with an error message
[0660] 80FB 86,02    CLRFRE CLR  @MNUM             Undo any allocation
[0661] 80FD BC,03,E0        ST   V@OFS(@PABPTR),@MNUM+1  We need the length for
       8100 03,04
[0662]               *                                    that
[0663]               *      V@OFS(@PABPTR) Was set up in PARFN routine
[0664] 8102 A1,40,02        DADD @MNUM,@FREPTR     Update the first free world
[0665] 8105 00              RTN                    And return
[0666] 8106 06,80,FB OPERR  CALL CLRFRE            First undo the allocation
[0667] 8109 06,6A,84 ERRSYN CALL ERRZZ             Then give an error
[0668] 810C 03              BYTE 3                 * SYNTAX ERROR
[0669]               * Continue with CHECK to conplete the actual OPEN
[0670] 810D 06,95,AD CHECK  CALL CHKEND            Check EOS
[0671] 8110 41,06           BR   OPERR             Not EOS  : SYNTAX ERROR
[0672]               * If the user hasn't specified VARIABLE or FIXED, the
[0673]               * default specification depends on the file type.
[0674]               * Change current default (=VARIABLE) to FIXED for
[0675]               * RELATIVE files.
[0676] 8112 DA,E0,05        CLOG >01,V@FLG(@PABPTR) RELATIVE RECORD
       8115 04,01
[0677] 8117 61,27           BS   G8127
[0678] 8119 DA,E0,05        CLOG >10,V@FLG(@PABPTR) VARIABLE RECORD
       811C 04,10
[0679] 811E 61,25           BS   G8125
[0680] 8120 06,80,FB FILZZ  CALL CLRFRE            Undo the PAB allocation
[0681] 8123 57,D7           BR   ERRFE             FILE ERROR
[0682] 8125 41,31    G8125  BR   G8131             Sequential file, check rec. m
[0683] 8127 DA,17,10 G8127  CLOG >10,@OPTFLG       No definition yet
[0684] 812A 41,31           BR   G8131
[0685] 812C B6,E0,05        OR   >10,V@FLG(@PABPTR) Force VARIABLE mode
       812F 04,10
[0686] 8131 06,97,6B G8131  CALL CDSR              Call the DSR, return with err
[0687] 8134 57,94           BR   ERRZ2B             indication in COND...
[0688] 8136 87,E0,0A        DCLR V@RNM(@PABPTR)    Make sure we start with recor
       8139 04
[0689]               * Check for undefined record length. The record length for
[0690]               * any type might be defined by the DSR
[0691] 813A 8E,E0,08        CZ   V@LEN(@PABPTR)
       813D 04

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0012 
FLMGR-359
[0692] 813E 61,20           BS   FILZZ
[0693] 8140 BC,03,E0        ST   V@LEN(@PABPTR),@MNUM+1 Get record length
       8143 08,04
[0694] 8145 86,02           CLR  @MNUM             Create two byte result and
[0695] 8147 86,E0,03        CLR  V@OFS(@PABPTR)     allocate - remove offset for
       814A 04
[0696]               *                              later use
[0697] 814B BD,4A,02        DST  @MNUM,@FAC        - prepare for space claim
[0698]               * Check for special case : no PAB's yet
[0699] 814E 8F,3C           DCZ  @IOSTRT
[0700] 8150 41,57           BR   G8157
[0701] 8152 BD,3C,04        DST  @PABPTR,@IOSTRT   Simply enter the first pointe
[0702] 8155 41,69           BR   G8169
[0703] 8157 BD,0A,3C G8157  DST  @IOSTRT,@STADDR   Search for the end of the cha
[0704] 815A 8F,B0,0A G815A  DCZ  V*STADDR
[0705] 815D 61,65           BS   G8165
[0706] 815F BD,0A,B0        DST  V*STADDR,@STADDR  Keep on deferring
       8162 0A
[0707] 8163 41,5A           BR   G815A
[0708] 8165 BD,B0,0A G8165  DST  @PABPTR,V*STADDR  Update last chain link
       8168 04
[0709] 8169 BD,E0,06 G8169  DST  @PABPTR,V@BUF(@PABPTR) Set empty buffer first
       816C 04,04
[0710] 816E 0F,72           XML  MEMCHK            Check memory overflow & strin
[0711] 8170 77,C7           BS   ERRMEM            * MEMORY FULL
[0712] 8172 A5,40,02        DSUB @MNUM,@FREPTR     Compute buffer entry address
[0713] 8175 A5,E0,06        DSUB @MNUM,V@BUF(@PABPTR) Correct buffer address in
       8178 04,02
[0714] 817A 0F,75           XML  CONT              Return to the parser
[0715]               ***********************************************************
[0716]               *                    DELETE ROUTINE
[0717]               * Use file # 0 for this operation. Parse the file name
[0718]               * string-expression as usual, and delete the PAB before
[0719]               * actually calling the DSR.
[0720]               ***********************************************************
[0721] 817C 86,17    DELET  CLR  @FNUM             Create file #0 - non-existing
[0722] 817E 06,96,5A        CALL PARFN             Handle as normal PAB OPEN
[0723] 8181 06,95,AD        CALL CHKEND            Check EOS first
[0724] 8184 41,06           BR   OPERR             Not EOS : go undo PAB allocat
[0725]               *                              and print SYNTAX ERROR
[0726] 8186 86,02           CLR  @MNUM       *  Delete PAB again before calling
[0727] 8188 BC,03,E0        ST   V@OFS(@PABPTR),@MNUM+1  Create double byte PAB
       818B 03,04
[0728]                
[0729] 818D A1,40,02        DADD @MNUM,@FREPTR     Update free word pointer
[0730] 8190 06,97,5E        CALL IOCALL            Preform I/O call for actual d
[0731] 8193 07              BYTE CZDELE
[0732] 8194 0F,75           XML  CONT
[0733]               ***********************************************************
[0734]               *                    CLOSE ROUTINE
[0735]               * Syntax could be
[0736]               * CLOSE #{ num exp }  or CLOSE #{ num exp }:DELETE
[0737]               *
[0738]               * Possibly output pending records before closing or
[0739]               * deleting the file.
[0740]               ***********************************************************
[0741] 8196 06,93,55 CLOSE  CALL CHKFN             Check for "no #" / "#0" cases
[0742] 8199 77,D7           BS   ERRFE             Not for "CLOSE" you don't
[0743] 819B 06,93,71        CALL CHKCON            Check file number etc...
[0744] 819E 57,D7           BR   ERRFE             *** FILE NUMBER NOT IN SYSTEM
[0745] 81A0 06,93,90        CALL OUTEOF            Output pending records
[0746] 81A3 BE,E0,04        ST   CZCLOS,V@COD(@PABPTR) Default to CLOSE I/O code
       81A6 04,01
[0747] 81A8 D6,42,B5        CEQ  COLONZ,@CHAT      Check for ":DELETE" spec.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0013 
FLMGR-359
[0748] 81AB 41,B8           BR   G81B8
[0749] 81AD 0F,79           XML  PGMCHR            Request next input token
[0750] 81AF 0F,7E           XML  SPEED             Must be at a
[0751] 81B1 00              BYTE SYNCHK          *  "DELETE" else
[0752] 81B2 99              BYTE DELETZ          *   its an error
[0753] 81B3 BE,E0,04        ST   CZDELE,V@COD(@PABPTR) Change CLOSE to DELETE
       81B6 04,07
[0754] 81B8 06,95,AD G81B8  CALL CHKEND            EOS?
[0755] 81BB 41,09           BR   ERRSYN            NO:SYNTAX ERROR
[0756] 81BD 06,97,6B        CALL CDSR              Call DSR with whatever we hav
[0757] 81C0 41,C7           BR   CLOSZ1            Reset means error....
[0758] 81C2 06,93,A6        CALL DELPAB            Delete PAB and data-buffer
[0759] 81C5 0F,75           XML  CONT              Return to parser routine
[0760] 81C7 BD,5C,E0 CLOSZ1 DST  V@4(@PABPTR),@ARG Save error code for message
       81CA 04,04
[0761] 81CC 06,93,A6        CALL DELPAB            Now delete the PAB
[0762] 81CF BD,04,40        DST  @FREPTR,@PABPTR   Store error-code in free memo
[0763] 81D2 A7,04,00        DSUB 6,@PABPTR         Create standard size PAB
       81D5 06
[0764] 81D6 BD,E0,04        DST  @ARG,V@4(@PABPTR) Copy error-code
       81D9 04,5C
[0765] 81DB 57,BB           BR   ERRIO             Exit to error-routine
[0766]               ***********************************************************
[0767]               *                   CLOSE ALL ROUTINE
[0768]               * CLOSE all the existing PABs ... ignore errors
[0769]               *
[0770]               * NOTE: "CLSLBL" is used in the I/O error routine to
[0771]               *       determine if a warning should be given rather than
[0772]               *       an error.
[0773]               ***********************************************************
[0774] 81DD BD,04,B0 G81DD  DST  V*PABPTR,@PABPTR
       81E0 04
[0775] 81E1 8F,B0,04 CLSAZ0 DCZ  V*PABPTR          Find last PAB in chain
[0776] 81E4 41,DD           BR   G81DD
[0777] 81E6 06,93,90        CALL OUTEOF            Take care of pending records
[0778] 81E9 BE,E0,04 CLSLBL ST   CZCLOS,V@COD(@PABPTR) Select CLOSE code
       81EC 04,01
[0779] 81EE 06,97,6B        CALL CDSR              CLOSE to DSR routine
[0780] 81F1 06,93,A6        CALL DELPAB            Delete PAB - ignore CLOSE err
[0781] 81F4 BD,04,3C CLSALL DST  @IOSTRT,@PABPTR   Start at beginning of chain
[0782] 81F7 8F,3C           DCZ  @IOSTRT           Continue until done
[0783] 81F9 41,E1           BR   CLSAZ0
[0784] 81FB 00              RTN                    And return
[0785]               ***********************************************************
[0786]               *                   RESTORE ROUTINE
[0787]               * RESTORE can have any of four forms:
[0788]               *
[0789]               * RESTORE                     Restore to first DATA
[0790]               * RESTORE 20                  Restore DATA pointer
[0791]               * RESTORE #1                  Rewind file number 1
[0792]               * RESTORE #1, REC 2           Position file 1 at record 2
[0793]               ***********************************************************
[0794] 81FC 87,4A    RESTOR DCLR @FAC              Assume simple RESTORE
[0795] 81FE D6,42,FD        CEQ  NUMBEZ,@CHAT
[0796] 8201 42,1F           BR   OLDCD
[0797] 8203 06,93,55        CALL CHKFN             Check for #<filenumber>
[0798] 8206 8F,4A           DCZ  @FAC              Found equivalent of #0
[0799] 8208 62,27           BS   OLDCZ0
[0800] 820A 06,93,71        CALL CHKCON            Check and decode file #
[0801] 820D 57,D7           BR   ERRFE             Give error if file not there
[0802] 820F 06,93,90        CALL OUTEOF            Output pending record
[0803] 8212 87,E0,0A        DCLR V@RNM(@PABPTR)    Initialize to record 0
       8215 04
[0804] 8216 06,94,C2        CALL PARREC            Parse possible record clause

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0014 
FLMGR-359
[0805] 8219 06,97,5E        CALL IOCALL            Call DSR routine with
[0806] 821C 04              BYTE CZREST          *   RESTORE I/O code
[0807] 821D 0F,75           XML  CONT              Return if no error found
[0808]               * Following code is for handling RESTORE to line number
[0809]               * within program
[0810] 821F 06,95,AD OLDCD  CALL CHKEND            Check for start with end
[0811] 8222 62,27           BS   OLDCZ0            If we have anything else
[0812] 8224 06,A0,06        CALL LINE               in FAC (double)
[0813] 8227 D5,30,32 OLDCZ0 DCEQ @ENLN,@STLN
[0814] 822A 42,33           BR   G8233
[0815] 822C 06,6A,82 WRNNPP CALL WARNZZ            * NO PROGRAM PRESENT *
[0816] 822F 1D              BYTE 29
[0817] 8230 05,60,12        B    TOPL15            Go back to toplevel
[0818] 8233 BD,36,32 G8233  DST  @ENLN,@LNBUF      Start at beginning of program
[0819] 8236 A7,36,00        DSUB 3,@LNBUF          Backup for first line number
       8239 03
[0820]               * Check against given line number
[0821] 823A 06,91,BC OLDCZ1 CALL GRSUB3            Read 2 bytes of line ptr from
[0822]               *                              line # table which is in ERA
[0823] 823D 36              BYTE LNBUF           * Source address on ERAM/VDP
[0824]               *                             @EEE1: Destination addr on CP
[0825] 823E C5,4A,58        DCH  @EEE1,@FAC        Try to get something higher
[0826] 8241 42,4E           BR   G824E
[0827] 8243 D5,36,30        DCEQ @STLN,@LNBUF      Last line in program
[0828] 8246 77,D3           BS   ERRDAT
[0829] 8248 A7,36,00        DSUB 4,@LNBUF          Get next entry in line # tabl
       824B 04
[0830] 824C 42,3A           BR   OLDCZ1            Try again with next line
[0831] 824E A3,36,00 G824E  DADD 3,@LNBUF          Undo subtraction
       8251 03
[0832] 8252 06,A0,08        CALL DATAST            Setup pointer for READ
[0833] 8255 0F,75           XML  CONT              Continue PARSE
[0834]               ***********************************************************
[0835]               *                 DISPLAY ROUTINE
[0836]               * DISPLAY handles all random screen access stuff..
[0837]               * the AT-clause, and the BEEP, ERASE ALL and SIZE clause.
[0838]               ***********************************************************
[0839] 8257 06,94,EF DISPL1 CALL DISACC            Evaluate DISPLAY options
[0840] 825A 63,95           BS   EOLEX             EXIT directly on end-of-state
[0841]               * If anything is specified it has to be a colon
[0842] 825C 8E,04           CZ   @PABPTR           Nothing was specified
[0843] 825E 62,C4           BS   PRINZ1
[0844]               * At this point we MUST have a colon, or else we error off
[0845]               * (SYNTAX ERROR)
[0846] 8260 0F,7E           XML  SPEED             Check for a colon
[0847] 8262 00              BYTE SYNCHK          *  and continue
[0848] 8263 B5              BYTE COLONZ          *   it approved
[0849] 8264 42,C4           BR   PRINZ1            Continue with PRINT items
[0850]               ***********************************************************
[0851]               *                    PRINT ROUTINE
[0852]               * MAIN-HANDLER FOR ALL PRINT-FUNCTIONS
[0853]               ***********************************************************
[0854] 8266 06,97,3F PRINT  CALL INITKB            Initialize keyboard I/O
[0855] 8269 D6,42,FD        CEQ  NUMBEZ,@CHAT      Could still be anything
[0856] 826C 42,C4           BR   PRINZ1
[0857] 826E 06,93,55        CALL CHKFN             Check if default or open chan
[0858] 8271 8F,4A           DCZ  @FAC              Default intended
[0859] 8273 62,A5           BS   PRNZ10
[0860] 8275 06,93,71        CALL CHKCON            Check and convert expression
[0861] 8278 57,D7           BR   ERRFE             Error if PAB not in system
[0862]               * PRINT allowed in output, append or update modes
[0863]               *       Not allowed in input mode
[0864] 827A DA,E0,05        CLOG >04,V@FLG(@PABPTR)
       827D 04,04

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0015 
FLMGR-359
[0865] 827F 62,88           BS   G8288
[0866] 8281 DA,E0,05        CLOG >02,V@FLG(@PABPTR)
       8284 04,02
[0867] 8286 77,D7           BS   ERRFE
[0868] 8288 D6,E0,04 G8288  CEQ  CZREAD,V@COD(@PABPTR)
       828B 04,02
[0869] 828D 42,93           BR   G8293
[0870] 828F 86,E0,03        CLR  V@OFS(@PABPTR)    Unpend pending INPUTs
       8292 04
[0871] 8293 BE,E0,04 G8293  ST   CZWRIT,V@COD(@PABPTR) uncomplete PRINTs
       8296 04,03
[0872] 8298 06,96,F5        CALL PRINIT            Initialize some variables
[0873]               * Next character has to be either EOL, COMMA, or COLON
[0874] 829B 06,95,AD        CALL CHKEND
[0875] 829E 63,95           BS   EOLEX              exit on end of statement
[0876] 82A0 06,94,C2        CALL PARREC            Parse possible record clause
[0877] 82A3 62,B1           BS   PRINZ0            found "," but no REC clause
[0878] 82A5 06,95,AD PRNZ10 CALL CHKEND
[0879] 82A8 63,95           BS   EOLEX             Exit on end of statement for
[0880]               *                       "PRINT #0" or "PRINT file position"
[0881] 82AA D6,42,B3        CEQ  COMMAZ,@CHAT
[0882] 82AD 42,BE           BR   G82BE
[0883] 82AF 0F,79           XML  PGMCHR            Get next in line
[0884] 82B1 8E,04    PRINZ0 CZ   @PABPTR           For "PRINT #0"
[0885] 82B3 63,CF           BS   USING
[0886]               *         Interal type of file?
[0887] 82B5 DA,E0,05        CLOG >08,V@FLG(@PABPTR)
       82B8 04,08
[0888] 82BA 57,D7           BR   ERRFE
[0889] 82BC 43,CF           BR   USING             Execute USING clause
[0890] 82BE 0F,7E    G82BE  XML  SPEED             Must be at a
[0891] 82C0 00              BYTE SYNCHK          *   colon at this point
[0892] 82C1 B5              BYTE COLONZ          *     and error off on others
[0893] 82C2 42,C9           BR   CONPRT            Make it a short branched ELSE
[0894] 82C4 D6,42,ED PRINZ1 CEQ  USINGZ,@CHAT
[0895] 82C7 63,CF           BS   USING             End standard initialization
[0896]               * Test standard separators
[0897] 82C9 06,96,27 CONPRT CALL TSTSEP            Test separator character
[0898] 82CC D6,42,FC        CEQ  TABZ,@CHAT        Handle TABs
[0899] 82CF 63,2D           BS   PRTAB
[0900]               * At this point we've checked TAB and ; , :
[0901]               * The only remaining print items have to be expressions
[0902]               *  All expressions are being handled below.
[0903]               * If the result of the expression is a numeric, the string
[0904]               * is transformed into a string and printed. Strings are
[0905]               * printed "as is".
[0906]               *  The code for strings and converted numerics cannot be ma
[0907]               * common, since numerics may require an extra space behind
[0908]               * the item, depending upon the current position in the reco
[0909]               *  Either way, the string is chunked up into little pieces
[0910]               * it won't fit in an empty record.
[0911] 82D1 0F,74           XML  PARSE             Evaluate the expression
[0912] 82D3 B5              BYTE COLONZ
[0913]               * Special code for INTERNAL file handling
[0914]               *  Translate numeric datums into string format and indicate
[0915]               * length 8. Then check to see if the item fits within the
[0916]               * current record. If not, it is an error, since each item
[0917]               * has to fit.
[0918] 82D4 06,83,C5        CALL TSTINT            Test for internal files
[0919] 82D7 63,03           BS   OTHEZ1            Nope, something different
[0920] 82D9 D6,4C,65        CEQ  STRVAL,@FAC2      Change numerics
[0921] 82DC 62,EC           BS   G82EC
[0922] 82DE BE,56,08        ST   8,@FAC12          To string length 8
[0923] 82E1 35,00,08        MOVE 8,@FAC,@ARG       Save in ARG

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0016 
FLMGR-359
       82E4 5C,4A
[0924] 82E6 BE,55,5C        ST   ARG,@FAC11        And use this as source
[0925] 82E9 06,96,0B        CALL RSTRING           Reserve some string space
[0926] 82EC BC,5C,07 G82EC  ST   @RECLEN,@ARG      Compute remaining space to EO
[0927] 82EF A4,5C,06        SUB  @CCPPTR,@ARG       for space checking
[0928] 82F2 90,5C           INC  @ARG              Make it real space
[0929] 82F4 C8,51,5C        CHE  @ARG,@FAC7        Not enough!!!!!
[0930] 82F7 77,D7           BS   ERRFE
[0931]               * The = check includes length byte
[0932] 82F9 BC,B0,08        ST   @FAC7,V*CCPADR    Prestore string length
       82FC 51
[0933] 82FD 91,08           DINC @CCPADR           Update actual RAM address
[0934] 82FF 90,06           INC  @CCPPTR            and internal column pointer
[0935] 8301 43,08           BR   OTHEZ0
[0936] 8303 D6,4C,65 OTHEZ1 CEQ  STRVAL,@FAC2      Print the string result
[0937] 8306 43,0D           BR   G830D
[0938] 8308 06,97,0E OTHEZ0 CALL OSTRNG            Output the string to the reco
[0939] 830B 43,28           BR   CHKSEP
[0940] 830D 86,55    G830D  CLR  @FAC11            Select standard BASIC format
[0941] 830F 0F,73           XML  XCNS              Convert number to string
[0942] 8311 06,96,0B        CALL RSTRING           Reserve and copy string
[0943] 8314 06,97,0E        CALL OSTRNG            Output the string
[0944]               * Possibly add an extra space if we're not at the end of th
[0945]               * current record.
[0946] 8317 C8,07,06        CHE  @CCPPTR,@RECLEN   Enough space left
[0947] 831A 43,28           BR   CHKSEP
[0948] 831C BE,B0,08        ST   SPACE,V*CCPADR    Add trailing space
       831F 20
[0949] 8320 A0,B0,08        ADD  @DSRFLG,V*CCPADR  Take care of screen I/O
       8323 17
[0950] 8324 91,08           DINC @CCPADR           Update current column address
[0951] 8326 90,06           INC  @CCPPTR            and base 1 pointer
[0952] 8328 06,96,27 CHKSEP CALL TSTSEP            Check for legal delimiter
[0953] 832B 41,09           BR   ERRSYN            Illegal delimiter. SYNTAX ERR
[0954]               *                              Unconditional branch
[0955]               * PRTAB - Print TAB as part of PRINT command
[0956] 832D 06,83,C5 PRTAB  CALL TSTINT            Watch out for INTERAL file ty
[0957] 8330 57,D7           BR   ERRFE             They can't handle TABs
[0958] 8332 0F,79           XML  PGMCHR            Skip TAB keyword
[0959] 8334 D6,42,B7        CEQ  LPARZ,@CHAT
[0960] 8337 41,09           BR   ERRSYN
[0961] 8339 0F,74           XML  PARSE             Parse TAB expression
[0962] 833B B6              BYTE RPARZ
[0963] 833C 06,94,B8        CALL CNVDEF            Check and convert to integer
[0964] 833F BC,4C,07        ST   @RECLEN,@FAC2     Set modulo number
[0965] 8342 06,96,1A        CALL COMMOD            Compute remainder
[0966] 8345 C4,06,4B        CH   @FAC1,@CCPPTR     Position on next output recor
[0967] 8348 43,4F           BR   G834F
[0968] 834A 06,96,A5        CALL OUTREC            Output current record - no pe
[0969] 834D 63,28           BS   CHKSEP             react on SIZE block!!!
[0970] 834F D4,06,4B G834F  CEQ  @FAC1,@CCPPTR     Stay here
[0971] 8352 63,28           BS   CHKSEP
[0972] 8354 BC,03,4B        ST   @FAC1,@MNUM+1     Fill with spaces
[0973] 8357 0F,84           XML  IO                OK, go ahead... fill'r up
[0974] 8359 01              BYTE FILSPC
[0975] 835A 43,28           BR   CHKSEP            And check separator again
[0976]               * Comma is similar to TAB, except that it generates at leas
[0977]               * one space. The exact number of spaces generated depends
[0978]               * upon the current position within the record. If the next
[0979]               * fixed tab-position is outside the record, the record, the
[0980]               * current record is output and the column pointer is reset
[0981]               * to column 1 of the next record.
[0982] 835C BC,03,06 PRTCOM ST   @CCPPTR,@MNUM+1   Compute initial # of spaces
[0983] 835F 92,03           DEC  @MNUM+1           Decrecment for 0 origin

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0017 
FLMGR-359
[0984] 8361 86,02           CLR  @MNUM             Clear high byte of double
[0985] 8363 AE,02,0E        DIV  14,@MNUM          TABs are 14 spaces apart
[0986] 8366 90,02           INC  @MNUM             Compute next TAB-stop
[0987] 8368 AA,02,0E        MUL  14,@MNUM           and actual position
[0988] 836B C4,07,03        CH   @MNUM+1,@RECLEN   Within this record
[0989] 836E 43,77           BR   PRCOL
[0990] 8370 90,03           INC  @MNUM+1           Convert to real position
[0991] 8372 0F,84           XML  IO                Fill spaces to new location
[0992] 8374 01              BYTE FILSPC
[0993] 8375 43,7A           BR   PRSEM             Outside current record
[0994]               * The ":" (colon) separator is used to output the current
[0995]               * record, and proceed to position 1 of the next record.
[0996] 8377 06,96,A5 PRCOL  CALL OUTREC            Output the current record
[0997]               * The ";" (semi-colon) generates the null string. Since all
[0998]               * print items should be separated by a separator, this one
[0999]               * has been introduced to separate without moving to another
[1000]               * position. Notice that all separators join up here.
[1001] 837A 0F,79    PRSEM  XML  PGMCHR            Skip the separator
[1002] 837C 06,95,AD        CALL CHKEND            Exit on end of line
[1003] 837F 42,C9           BR   CONPRT            Continue if not end of line
[1004] 8381 8E,17    PRSMZ1 CZ   @DSRFLG           For screen output continue
[1005] 8383 63,A4           BS   PREXIT
[1006] 8385 DA,04,08        CLOG >08,@PABPTR       Check SIZE clause
[1007] 8388 63,A4           BS   PREXIT
[1008] 838A 06,96,A5        CALL OUTREC            Output current record (blank
[1009] 838D BC,06,09        ST   @CCPADR+1,@CCPPTR Compute correct value for CCP
[1010] 8390 A6,06,E1        SUB  >E1,@CCPPTR       Subtract current screen base
[1011] 8393 43,A4           BR   PREXIT             and exit form this command
[1012]               * End of line exit routine for PRINT statement
[1013] 8395 8E,17    EOLEX  CZ   @DSRFLG           I/O - remove blocks if
[1014] 8397 63,A1           BS   G83A1
[1015] 8399 DA,04,04        CLOG >04,@PABPTR        " AT" clause unused
[1016] 839C 43,A1           BR   G83A1
[1017] 839E B2,04,E7        AND  >E7,@PABPTR        remove flag 3 (SIZE used)
[1018] 83A1 06,96,A5 G83A1  CALL OUTREC            Output pending record
[1019]               * Continue here if record remains pending
[1020] 83A4 8E,17    PREXIT CZ   @DSRFLG           Regular file/device I/O
[1021] 83A6 43,B1           BR   G83B1
[1022] 83A8 92,06           DEC  @CCPPTR           Back to actual offset
[1023] 83AA BC,E0,03        ST   @CCPPTR,V@OFS(@PABPTR) Save for next statement
       83AD 04,06
[1024] 83AF 0F,75           XML  CONT              Continue with next statement
[1025]               *                              End external I/O handling
[1026]               * Reset of code is for internal I/O handling (VDP)
[1027] 83B1 DA,04,04 G83B1  CLOG >04,@PABPTR       Is not used
[1028] 83B4 43,BB           BR   G83BB
[1029] 83B6 BC,7F,06        ST   @CCPPTR,@XPT      Save current value of pointer
[1030] 83B9 94,7F           INCT @XPT              CCPPTR: 1-28
[1031] 83BB DA,04,02 G83BB  CLOG >02,@PABPTR       Used BEEP clause
[1032] 83BE 63,C3           BS   G83C3
[1033] 83C0 06,00,34        CALL TONE1             ---------- BEEP ------------
[1034] 83C3 0F,75    G83C3  XML  CONT              Continue in PARSE routine
[1035]               * TSTINT - test for INTERAL type files, set COND if file
[1036]               *          is NOT INTERNAL
[1037] 83C5 8E,17    TSTINT CZ   @DSRFLG           Couldn't possibly be INTERNAL
[1038] 83C7 53,8C           BR   RTC
[1039] 83C9 DA,E0,05        CLOG >08,V@FLG(@PABPTR) Set COND according to bit 3
       83CC 04,08
[1040] 83CE 01              RTNC                   Return without changing COND
[1041]               ********* PRINT / DISPLAY USING SECTION *******************
[1042]               * Arrive here after the keyword "USING" has been rejected.
[1043] 83CF 0F,7E    USING  XML  SPEED
[1044] 83D1 00              BYTE SYNCHK          * Get first character of format
[1045] 83D2 ED              BYTE USINGZ          *  after (double) checking USIN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0018 
FLMGR-359
[1046] 83D3 D6,42,C9        CEQ  LNZ,@CHAT         Pick up the line number
[1047] 83D6 44,30           BR   G8430
[1048] 83D8 0F,79           XML  PGMCHR            Get high address
[1049] 83DA BC,4A,42        ST   @CHAT,@FAC
[1050] 83DD 0F,79           XML  PGMCHR             and low address
[1051] 83DF BC,4B,42        ST   @CHAT,@FAC1
[1052] 83E2 0F,79           XML  PGMCHR              get next program character
[1053] 83E4 BD,4C,2E        DST  @EXTRAM,@FAC2        in SEETWO : EXTRAM value w
[1054]               *                                 changed
[1055] 83E7 0F,7E           XML  SPEED
[1056] 83E9 03              BYTE SEETWO          *  Find the line # in the progr
[1057] 83EA C1,4C,2E        DEX  @EXTRAM,@FAC2      result in SEETWO is in EXTRA
[1058]               *                               and restore EXTRAM value
[1059] 83ED 44,5E           BR   USNGZ1               has to match exactly
[1060] 83EF 95,4C           DINCT @FAC2            Move up to the pointer field
[1061] 83F1 BD,52,34        DST   @DATA,@FAC8      Save DATA pointer for READ fi
[1062] 83F4 06,91,A4        CALL GRSUB2            Read 2 bytes of data from ERA
[1063] 83F7 4C              BYTE FAC2           *  @FAC2 : Source address on ERA
[1064] 83F8 BD,34,58        DST  @EEE1,@DATA       @EEE1 : Destination addr. on
[1065]               *                              Put it in @DATA
[1066] 83FB BE,4C,A3        ST   IMAGEZ,@FAC2      Search for an IMAGE token
[1067] 83FE 06,8B,99        CALL SEARCH             at beginning of an statement
[1068] 8401 64,5E           BS   USNGZ1            Error if not found on this li
[1069] 8403 06,93,04        CALL GETGFL            Get first part of format stri
[1070] 8406 06,93,23        CALL CHKSTR            Prepare data for string assig
[1071] 8409 BD,0C,50        DST  @FAC6,@BYTES      Copy actual string length in
[1072] 840C BD,34,52        DST  @FAC8,@DATA       Restore original DATA pointer
[1073] 840F 06,92,CD        CALL CTSTR             Create a temporary string
[1074] 8412 8F,50           DCZ  @FAC6
[1075] 8414 64,2E           BS   G842E
[1076] 8416 8E,80,84        CZ   @RAMTOP           Data from RAM
[1077] 8419 44,23           BR   G8423
[1078] 841B 34,50,B0        MOVE @FAC6,V*TEMP5,V*SREF
       841E 1C,B0,66
[1079] 8421 44,2E           BR   G842E
[1080] 8423 BD,56,50 G8423  DST  @FAC6,@FFF1       FFF1 : byte count
[1081] 8426 BD,54,66        DST  @TEMP5,@DDD1      DDD1 : source address in ERAM
[1082] 8429 BD,58,1C        DST  @SREF,@EEE1       EEE1 : destination address on
[1083] 842C 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[1084] 842E 44,38    G842E  BR   G8438
[1085] 8430 0F,74    G8430  XML  PARSE             Parse up to the ending ":"
[1086] 8432 B5              BYTE COLONZ
[1087] 8433 D6,4C,65        CEQ  STRVAL,@FAC2      * IMAGE ERROR *
[1088] 8436 44,5E           BR   USNGZ1
[1089] 8438 D6,42,B5 G8438  CEQ  COLONZ,@CHAT      Probably no variable list
[1090] 843B 64,48           BS   G8448
[1091] 843D 06,95,AD        CALL CHKEND            We better check that through
[1092] 8440 41,09           BR   ERRSYN             something sneaky sneaked in
[1093] 8442 8E,51           CZ   @FAC7             End of line exit
[1094] 8444 63,95           BS   EOLEX
[1095] 8446 44,63           BR   G8463             Look for format item
[1096] 8448 8E,51    G8448  CZ   @FAC7             Exclude null strings
[1097] 844A 64,5E           BS   USNGZ1
[1098] 844C BD,5C,4E        DST  @FAC4,@ARG        Get start address for string
[1099] 844F BC,5E,51        ST   @FAC7,@ARG2       Get format string length
[1100] 8452 D6,B0,5C USNGZ0 CEQ  >23,V*ARG         Found no format item yet
       8455 23
[1101] 8456 64,60           BS   G8460
[1102] 8458 91,5C           DINC @ARG              Try next address
[1103] 845A 92,5E           DEC  @ARG2             Update address
[1104] 845C 44,52           BR   USNGZ0            Try up to the end of the stri
[1105] 845E 57,C3    USNGZ1 BR   ERRIM             * IMAGE ERROR
[1106]               * Now we're sure that we have at least one legal format ite
[1107]               * (anything with a "#" in it)

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0019 
FLMGR-359
[1108] 8460 BE,42,B3 G8460  ST   COMMAZ,@CHAT      Fake comma seperator for prin
[1109] 8463 0F,77    G8463  XML  VPUSH             Current string might be tempo
[1110] 8465 BD,0C,50        DST  @FAC6,@BYTES      Create a workstring for outpu
[1111] 8468 90,0D           INC  @BYTES+1          Create space for end of strin
[1112] 846A 0C              CARRY                  String would be too long
[1113] 846B 64,5E           BS   USNGZ1
[1114] 846D 0F,71           XML  GETSTR            Length whold equal format str
[1115] 846F BD,14,1C        DST  @SREF,@CURLIN     Create a temporary string
[1116] 8472 A1,1C,50        DADD @FAC6,@SREF       Compute last position in stri
[1117] 8475 86,B0,1C        CLR  V*SREF            Set end of string indicator
[1118] 8478 BD,4E,E0 USNGZ3 DST  V@4(@VSPTR),@FAC4 Update FAC4 area in case garb
       847B 04,6E
[1119] 847D 34,50,B0        MOVE @FAC6,V*FAC4,V*CURLIN Copy format
       8480 14,B0,4E
[1120] 8483 BD,4E,14        DST  @CURLIN,@FAC4     Complete preps for VPUSH
[1121] 8486 BF,4A,00        DST  >001C,@FAC        SREF = >001C
       8489 1C
[1122] 848A 91,50           DINC @FAC6             Include 0 in string length
[1123] 848C 0F,77           XML  VPUSH             Make the string temporary
[1124] 848E BD,14,E0        DST  V@4(@VSPTR),@CURLIN Update current line pointer
       8491 04,6E
[1125] 8493 D6,B0,14 USNGZ4 CEQ  >23,V*CURLIN      Try to locate the next format
       8496 23
[1126] 8497 64,C3           BS   G84C3
[1127] 8499 8E,B0,14        CZ   V*CURLIN          Not end of string yet
[1128] 849C 64,A2           BS   G84A2
[1129] 849E 91,14           DINC @CURLIN           Update pointer if not found
[1130] 84A0 44,93           BR   USNGZ4             and continue searching
[1131] 84A2 D6,42,B3 G84A2  CEQ  COMMAZ,@CHAT      Stop on last variable
[1132] 84A5 45,C3           BR   USNGZ9
[1133] 84A7 0F,78           XML  VPOP              Restore original workstring d
[1134] 84A9 BC,0C,51        ST   @FAC7,@BYTES      Pring the current format stri
[1135] 84AC 92,0C           DEC  @BYTES            Don't count the last "0"
[1136] 84AE BE,03,01        ST   1,@MNUM+1         Indicate direct output withou
[1137] 84B1 06,97,18        CALL CHKRZ0            Copy string to output record
[1138] 84B4 06,96,A5        CALL OUTREC            Also output current record
[1139]               * FAC still contains the right data, however it is easier j
[1140]               * to copy the original string again.
[1141] 84B7 BD,14,4E        DST  @FAC4,@CURLIN     Reconstruct CRULIN
[1142] 84BA 0F,78           XML  VPOP              Copy original string info
[1143] 84BC 0F,77           XML  VPUSH             Without actually removing it
[1144] 84BE A5,14,50        DSUB @FAC6,@CURLIN     Reconstruct start address
[1145] 84C1 44,78           BR   USNGZ3            Continue for the next variabl
[1146] 84C3 D5,14,E0 G84C3  DCEQ V@4(@VSPTR),@CURLIN Avoid "#" as count
       84C6 04,6E
[1147] 84C8 64,E9           BS   USNZ42
[1148] 84CA 93,14           DDEC @CURLIN           Backup to the sign
[1149] 84CC D6,B0,14        CEQ  >2E,V*CURLIN      Used ".#####"
       84CF 2E
[1150] 84D0 44,DB           BR   G84DB
[1151] 84D2 D5,14,E0        DCEQ V@4(@VSPTR),@CURLIN
       84D5 04,6E
[1152] 84D7 64,E9           BS   USNZ42
[1153] 84D9 93,14           DDEC @CURLIN           Avoid checking count bit
[1154] 84DB D6,B0,14 G84DB  CEQ  >2D,V*CURLIN      Check for minus
       84DE 2D
[1155] 84DF 64,E9           BS   USNZ42
[1156] 84E1 D6,B0,14        CEQ  >2B,V*CURLIN      Check for plus
       84E4 2B
[1157] 84E5 64,E9           BS   USNZ42
[1158] 84E7 91,14           DINC @CURLIN           It's neither, so we undo
[1159]               * Check for availability of variables
[1160] 84E9 D6,42,B3 USNZ42 CEQ  COMMAZ,@CHAT      Exit if no more pt item
[1161] 84EC 45,C3           BR   USNGZ9

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0020 
FLMGR-359
[1162] 84EE 0F,79           XML  PGMCHR            Get next expression
[1163] 84F0 A5,14,E0        DSUB V@4(@VSPTR),@CURLIN Make CURLIN offset for
       84F3 04,6E
[1164]               *                                garbage collection
[1165] 84F5 0F,74           XML  PARSE             Parse up to ";" or ","
[1166] 84F7 B4              BYTE SEMICZ
[1167] 84F8 A1,14,E0        DADD V@4(@VSPTR),@CURLIN Reconstruct new CLN after
       84FB 04,6E
[1168]               *                                garbage collection
[1169] 84FD 87,52           DCLR @FAC8             Start with clean sheet for co
[1170] 84FF 87,55           DCLR @FAC11
[1171] 8501 86,57           CLR  @FAC13
[1172] 8503 BD,0E,14        DST  @CURLIN,@VAR4     Now start checking process
[1173] 8506 D6,B0,14        CEQ  >2E,V*CURLIN
       8509 2E
[1174] 850A 65,33           BS   USNGZ5
[1175] 850C D6,B0,14        CEQ  >23,V*CURLIN      Has to be "+" or "-"
       850F 23
[1176] 8510 65,27           BS   G8527
[1177] 8512 D6,B0,14        CEQ  >2D,V*CURLIN
       8515 2D
[1178] 8516 45,1B           BR   G851B
[1179] 8518 B6,55,02        OR   >02,@FAC11        Set explict sign flag for CNS
[1180] 851B D6,B0,14 G851B  CEQ  >2B,V*CURLIN
       851E 2B
[1181] 851F 45,27           BR   G8527
[1182] 8521 B6,55,02        OR   >02,@FAC11        Set explict sign flag for CNS
[1183] 8524 B6,55,04        OR   >04,@FAC11        Set positive sign flag for CN
[1184] 8527 06,85,E5 G8527  CALL ACCNM             Accept first character plus "
[1185] 852A BC,56,53        ST   @FAC9,@FAC12      Set up FAC12 for CNS
[1186] 852D D6,B0,0E        CEQ  >2E,V*VAR4        Found decimal point
       8530 2E
[1187] 8531 45,40           BR   G8540
[1188] 8533 86,53    USNGZ5 CLR  @FAC9             Prepare for use as counter of
[1189]               *                              of # sign after decimal poin
[1190] 8535 06,85,E5        CALL ACCNM             Accept some more "#"'s
[1191] 8538 BC,57,53        ST   @FAC9,@FAC13      Set up FAC13 for CNS
[1192] 853B A0,53,56        ADD  @FAC12,@FAC9      FAC9 now contains the total n
[1193]               *                              of "#" sign, decimal point a
[1194]               *                              maybe a sign bit
[1195] 853E 92,53           DEC  @FAC9             Exclude the decimal point
[1196] 8540 D7,B0,0E G8540  DCEQ >5E5E,V*VAR4      Attempt to decode  ^^
       8543 5E,5E
[1197] 8545 45,64           BR   USNZ55
[1198] 8547 95,0E           DINCT @VAR4            Update address
[1199] 8549 D7,B0,0E        DCEQ  >5E5E,V*VAR4
       854C 5E,5E
[1200] 854E 45,62           BR   G8562
[1201] 8550 95,0E           DINCT @VAR4            Update address
[1202] 8552 B6,55,08        OR   >08,@FAC11        Set E-format bit for CNS
[1203] 8555 D6,B0,0E        CEQ  >5E,V*VAR4
       8558 5E
[1204] 8559 45,64           BR   USNZ55
[1205] 855B 91,0E           DINC @VAR4             Update end address
[1206] 855D B6,55,10        OR   >10,@FAC11        Set extended E-format bit for
[1207] 8560 45,64           BR   USNZ55
[1208] 8562 97,0E    G8562  DDECT @VAR4            Correct for previous errors
[1209]               * At this point, CURLIN is pointing at the first item of th
[1210]               * format, VAR4 is pointing at the character following the i
[1211] 8564 CA,4C,64 USNZ55 CHE  >64,@FAC2         Detected numerical argument
[1212] 8567 65,96           BS   G8596
[1213] 8569 DA,55,02        CLOG >02,@FAC11        Exclude the sign count
[1214] 856C 65,70           BS   G8570
[1215] 856E 92,53           DEC  @FAC9             FAC9 : Number of significant

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0021 
FLMGR-359
[1216] 8570 DA,55,08 G8570  CLOG >08,@FAC11        If E-format is used
[1217] 8573 65,7C           BS   G857C
[1218] 8575 CE,53,0A        CGT  >0A,@FAC9         More than 10 significant digi
[1219] 8578 77,C3           BS   ERRIM
[1220] 857A 45,81           BR   G8581
[1221] 857C CE,53,0E G857C  CGT  14,@FAC9          More than 14 significant digi
[1222] 857F 77,C3           BS   ERRIM
[1223] 8581 B6,55,01 G8581  OR   >01,@FAC11        Set fixed format output it fo
[1224] 8584 0F,73           XML  XCNS    1          Convert number to fixed form
[1225]               * FAC11 points to the beginning of the string after supress
[1226]               * leading 0's, FAC12 contains the length of the string
[1227] 8586 BC,57,55        ST   @FAC11,@FAC13     FAC13 now point to beginning
[1228]               *                              the string
[1229] 8589 86,55           CLR  @FAC11            Clear high byte
[1230] 858B 34,55,B0        MOVE @FAC11,*FAC13,V*CURLIN Copy the result string f
       858E 14,90,57
[1231]               *                                   temporary
[1232] 8591 BD,14,0E        DST  @VAR4,@CURLIN     Move pointer behind print fie
[1233] 8594 44,93           BR   USNGZ4            Continue after printing
[1234] 8596 BD,54,0E G8596  DST  @VAR4,@FAC10      Compute total length
[1235] 8599 A5,54,14        DSUB @CURLIN,@FAC10
[1236] 859C C4,51,55        CH   @FAC11,@FAC7      String exceeds limits
[1237] 859F 45,B1           BR   G85B1
[1238] 85A1 BE,00,2A        ST   >2A,@VAR0         Prepare a "*****.." string
[1239] 85A4 BC,B0,14 G85A4  ST   @VAR0,V*CURLIN    Fill the remainder of field
       85A7 00
[1240] 85A8 91,14           DINC @CURLIN           Up to the end
[1241] 85AA D5,14,0E USNZ67 DCEQ @VAR4,@CURLIN     Which is stored in VAR4
[1242] 85AD 45,A4           BR   G85A4
[1243] 85AF 44,93           BR   USNGZ4
[1244] 85B1 8F,50    G85B1  DCZ  @FAC6
[1245] 85B3 65,BE           BS   USNZ68
[1246] 85B5 34,50,B0        MOVE @FAC6,V*FAC4,V*CURLIN Copy result string
       85B8 14,B0,4E
[1247] 85BB A1,14,50        DADD @FAC6,@CURLIN     And update address in string
[1248] 85BE BE,00,20 USNZ68 ST   SPACE,@VAR0       Fill remainder with spaces
[1249] 85C1 45,AA           BR   USNZ67
[1250] 85C3 0F,78    USNGZ9 XML  VPOP              Temporary string back out
[1251] 85C5 BC,0C,15        ST   @CURLIN+1,@BYTES  Output up to the current
[1252]               *                              position
[1253] 85C8 A4,0C,4F        SUB  @FAC5,@BYTES      Create one byte result
[1254] 85CB 65,D3           BS   USNZ95            Avoid empty strings
[1255] 85CD BE,03,01        ST   1,@MNUM+1         Prevent skip if field too sma
[1256] 85D0 06,97,18        CALL CHKRZ0            Preform all nomal I/O stuff
[1257] 85D3 0F,78    USNZ95 XML  VPOP              Remove source format string
[1258] 85D5 06,95,AD        CALL CHKEND            Check for end of line exit
[1259] 85D8 63,95           BS   EOLEX             Take end of line exit
[1260] 85DA 0F,7E           XML  SPEED
[1261] 85DC 00              BYTE SYNCHK          * Then it HAS to be a ";"
[1262] 85DD B4              BYTE SEMICZ
[1263] 85DE 06,95,AD        CALL CHKEND            Now - must be EOS
[1264] 85E1 63,81           BS   PRSMZ1            Supressed end of record, make
[1265]               *                              it a pending record
[1266] 85E3 41,09           BR   ERRSYN            SYNTAX ERROR
[1267]               * Collect string of "#"'s
[1268] 85E5 90,53    ACCNM  INC  @FAC9             Update item count
[1269] 85E7 91,0E           DINC @VAR4              and item address
[1270] 85E9 D6,B0,0E        CEQ  >23,V*VAR4        Decode as many "#"'s as
       85EC 23
[1271]               *                              possible
[1272] 85ED 65,E5           BS   ACCNM
[1273] 85EF 00              RTN                    Return from duty
[1274]               ***********************************************************
[1275]               *                    INPUT ROUTINE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0022 
FLMGR-359
[1276]               * First check for file or screen I/O. If file I/O then chec
[1277]               * for pending output and print that. If screen I/O then
[1278]               * check for input prompt:
[1279]               * Next collect the INPUT variable list on the V-stack. Get
[1280]               * enough input form either file or keyboard, and compare
[1281]               * types with entries on V-stack. After verification and
[1282]               * approval, assign the values.
[1283]               ***********************************************************
[1284] 85F0 06,97,3F INPUT  CALL INITKB            Assume keyboard INPUT
[1285] 85F3 D6,42,FD        CEQ  NUMBEZ,@CHAT      Might be #0 or #1-255
[1286] 85F6 47,5A           BR   G875A
[1287] 85F8 06,93,55        CALL CHKFN             Check for default #0
[1288] 85FB 8F,4A           DCZ  @FAC              If luno #0
[1289] 85FD 46,0B           BR   G860B
[1290] 85FF BD,A3,AA        DST  @PGMPTR,V@INPUTP  Save PGMPTR for "try again"
       8602 2C
[1291] 8603 91,A3,AA        DINC V@INPUTP          Pass the ":" for the
[1292]               *                              "prompt" code handler
[1293]               *                              later, (using #0 will not
[1294]               *                              take care the prompt in
[1295]               *                              INPUT)
[1296] 8606 06,89,2D        CALL INPUZ2            #0 is equivalent to no #
[1297] 8609 47,68           BR   INPZ2
[1298] 860B 06,88,E8 G860B  CALL INSU1             Get info about file
[1299]               * INTERNAL files get special treatment
[1300] 860E DA,E0,05        CLOG >08,V@FLG(@PABPTR) INTERNAL file
       8611 04,08
[1301] 8613 66,AD           BS   G86AD
[1302] 8615 8E,E0,03        CZ   V@OFS(@PABPTR)    Fresh start
       8618 04
[1303] 8619 46,1E           BR   G861E
[1304] 861B 06,97,65 INTRZ0 CALL IOCLZ1            Get a new record through
[1305]               *                              the DSR
[1306] 861E BC,2B,E0 G861E  ST   V@OFS(@PABPTR),@VARA+1 Regain possible offset
       8621 03,04
[1307] 8623 86,2A           CLR  @VARA             Make that a two byte constant
[1308] 8625 BD,66,E0        DST  V@BUF(@PABPTR),@TEMP5 Get first address
       8628 06,04
[1309] 862A A1,66,2A        DADD @VARA,@TEMP5      Compute actual address
[1310]               *                              within record
[1311] 862D 06,97,E3 INTRZ1 CALL BUG01             Get the symbol table entry
[1312]               * Above call fixes bug, of the given variable
[1313] 8630 0F,77           XML  VPUSH             And save it on the stack
[1314] 8632 87,0C           DCLR @BYTES            Assume no data available
[1315] 8634 C8,2B,E0        CHE  V@CNT(@PABPTR),@VARA+1 Pick up data
       8637 09,04
[1316] 8639 66,43           BS   G8643
[1317] 863B BC,0D,B0        ST   V*TEMP5,@BYTES+1  Length byte first
       863E 66
[1318] 863F 91,66           DINC @TEMP5            Update both actual address
[1319] 8641 90,2B           INC  @VARA+1            and offset
[1320] 8643 D6,4C,65 G8643  CEQ  >65,@FAC2         Has to be string variable
[1321] 8646 46,50           BR   G8650
[1322] 8648 BD,50,0C        DST  @BYTES,@FAC6      Set length of string
[1323] 864B 06,92,DE        CALL CTMPST            Create temporary string
[1324] 864E 46,7E           BR   G867E
[1325] 8650 D6,0D,08 G8650  CEQ  >08,@BYTES+1      * FILE ERROR
[1326] 8653 57,D7           BR   ERRFE
[1327] 8655 34,0C,4A        MOVE @BYTES,V*TEMP5,@FAC  Copy value
       8658 B0,66
[1328] 865A 8F,4A           DCZ  @FAC              Watch out for non-scaled stuf
[1329] 865C 66,7C           BS   G867C
[1330] 865E BE,5C,51        ST   FAC7,@ARG         Test for legal numeric
[1331] 8661 C6,90,5C G8661  CH   99,*ARG           * FILE ERROR

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0023 
FLMGR-359
       8664 63
[1332] 8665 77,D7           BS   ERRFE
[1333] 8667 92,5C           DEC  @ARG              Next digit for test
[1334] 8669 D6,5C,4B        CEQ  FAC1,@ARG
[1335] 866C 46,61           BR   G8661
[1336] 866E BD,5C,4A        DST  @FAC,@ARG         Copy in ARG for some testing
[1337] 8671 81,5C           DABS @ARG              Be sure we're positive
[1338]               * If first byte after expon. byte=0 : incorrect
[1339]               * normalization has occured : FILE ERROR
[1340]               * Or >99 : illegal numeric  : FILE ERROR
[1341] 8673 92,5D           DEC  @ARG1             0 would cause underflow here
[1342] 8675 C6,5D,62        CH   98,@ARG1
[1343] 8678 77,D7           BS   ERRFE
[1344] 867A 46,7E           BR   G867E
[1345] 867C 87,4C    G867C  DCLR @FAC2             Be sure FAC2 = 0 (no strings)
[1346] 867E A1,66,0C G867E  DADD @BYTES,@TEMP5     Update address and
[1347] 8681 A0,2B,0D        ADD  @BYTES+1,@VARA+1   offset again
[1348] 8684 0F,7C           XML  ASSGNV            Assign value to variable
[1349] 8686 86,E0,03        CLR  V@OFS(@PABPTR)    Undo allocated offsets
       8689 04
[1350] 868A D6,42,B3        CEQ  COMMAZ,@CHAT
[1351] 868D 46,AB           BR   G86AB
[1352] 868F 0F,79           XML  PGMCHR            Get next text character
[1353] 8691 06,95,AD        CALL CHKEND            Check for end of statement
[1354] 8694 66,9F           BS   INTRZ2            OK, EOS is fine
[1355] 8696 C8,2B,E0        CHE  V@CNT(@PABPTR),@VARA+1
       8699 09,04
[1356] 869B 66,1B           BS   INTRZ0
[1357] 869D 46,2D           BR   INTRZ1            Still something left
[1358] 869F C8,2B,E0 INTRZ2 CHE  V@CNT(@PABPTR),@VARA+1
       86A2 09,04
[1359] 86A4 66,AB           BS   G86AB
[1360] 86A6 BC,E0,03        ST   @VARA+1,V@OFS(@PABPTR) Save value of offset
       86A9 04,2B
[1361] 86AB 0F,75    G86AB  XML  CONT              And CONTINUE
[1362] 86AD 06,92,8A G86AD  CALL GETVAR            Collect variable list on stac
[1363] 86B0 BD,14,0A        DST  @STADDR,@CURLIN   Save it in temp
[1364] 86B3 BF,0A,08        DST  CRNBUF,@RAMPTR    Initialize crunch buffer poin
       86B6 20
[1365] 86B7 86,07           CLR  @RECLEN           Initialize field counter
[1366] 86B9 BE,E0,04        ST   CZREAD,V@COD(@PABPTR) Select READ operation
       86BC 04,02
[1367] 86BE 8E,E0,03        CZ   V@OFS(@PABPTR)
       86C1 04
[1368] 86C2 46,E9           BR   INPZ31
[1369] 86C4 46,CC           BR   INPZ3             Adjust for used record usage
[1370] 86C6 BE,EF,FF G86C6  ST   COMMAZ,V@-1(@RAMPTR) Fake legal separator
       86C9 FF,0A,B3
[1371] 86CC 06,97,65 INPZ3  CALL IOCLZ1            Get next input record
[1372] 86CF 86,E0,03        CLR  V@OFS(@PABPTR)    Reset offset within record
       86D2 04
[1373] 86D3 06,88,27        CALL RECENT
[1374] 86D6 BC,2A,E0        ST   V@CNT(@PABPTR),@VARA Get record length
       86D9 09,04
[1375] 86DB 8E,2A    G86DB  CZ   @VARA
[1376] 86DD 66,E9           BS   INPZ31
[1377] 86DF A2,B0,20        ADD  OFFSET,V*VARW     Add video offset for normal
       86E2 60
[1378] 86E3 91,20           DINC @VARW             Screen-type crunch - proceed
[1379] 86E5 92,2A           DEC  @VARA              for entire record
[1380] 86E7 46,DB           BR   G86DB
[1381] 86E9 06,88,27 INPZ31 CALL RECENT            Compute actual record entry
[1382] 86EC BC,2B,E0        ST   V@CNT(@PABPTR),@VARA+1  Compute end of record
       86EF 09,04

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0024 
FLMGR-359
[1383] 86F1 86,2A           CLR  @VARA             Make that a double byte
[1384] 86F3 A1,2A,E0        DADD V@BUF(@PABPTR),@VARA  Add buffer start addr
       86F6 06,04
[1385] 86F8 93,2A           DDEC @VARA             Point to last position in rec
[1386] 86FA 86,11           CLR  @VAR6             Assume no values input
[1387] 86FC 0F,7F           XML  CRUNCH            Scan data fields as in DATA s
[1388] 86FE 01              BYTE 1               * Indicate input stmt crunch
[1389] 86FF 8F,22           DCZ  @ERRCOD           If some crunch error
[1390] 8701 57,CF           BR   ERRINP
[1391] 8703 90,11           INC  @VAR6             Get correct # of fields (one
[1392] 8705 A0,07,11        ADD  @VAR6,@RECLEN     Update # of fields up to now
[1393] 8708 C8,07,10        CHE  @VAR5,@RECLEN     OK, THAT'S ENOUGH!!!!
[1394] 870B 46,C6           BR   G86C6
[1395] 870D 97,2C           DDECT @PGMPTR          Backup program pointer
[1396] 870F 0F,79           XML  PGMCHR            Re-inspect last token before
[1397] 8711 06,88,27        CALL RECENT            Precompute record entry
[1398] 8714 86,E0,03        CLR  V@OFS(@PABPTR)    Assume no pending record
       8717 04
[1399] 8718 D6,42,B3        CEQ  COMMAZ,@CHAT      Make record pending
[1400] 871B 47,52           BR   G8752
[1401] 871D D4,07,10        CEQ  @VAR5,@RECLEN     Enough left pending
[1402] 8720 67,52           BS   G8752
[1403] 8722 A4,07,10        SUB  @VAR5,@RECLEN     Compute remaining # of fields
[1404] 8725 A4,11,07        SUB  @RECLEN,@VAR6     # of fields used in last reco
[1405] 8728 D6,B0,20 INPZ32 CEQ  >82,V*VARW        +OFFSET
       872B 82
[1406] 872C 47,3A           BR   G873A             Skip quoted strings
[1407] 872E 91,20    G872E  DINC @VARW
[1408] 8730 D6,B0,20        CEQ  >82,V*VARW        +OFFSET
       8733 82
[1409] 8734 47,2E           BR   G872E
[1410] 8736 91,20           DINC @VARW
[1411] 8738 47,28           BR   INPZ32            Search for Nth data item
[1412] 873A 91,20    G873A  DINC @VARW             Update pointer
[1413] 873C D6,EF,FF        CEQ  >8C,V@-1(@VARW) * ","+OFFSET = >8C
       873F FF,20,8C
[1414] 8742 47,3A           BR   G873A
[1415] 8744 92,11           DEC  @VAR6             Commas denote end of field
[1416] 8746 47,28           BR   INPZ32            Continue until done
[1417] 8748 A5,20,E0        DSUB V@BUF(@PABPTR),@VARW Compute current offset
       874B 06,04
[1418] 874D BC,E0,03        ST   @VARW+1,V@OFS(@PABPTR) Store for next round
       8750 04,21
[1419] 8752 BC,11,10 G8752  ST   @VAR5,@VAR6       Copy # of variables for check
[1420] 8755 BD,0A,14        DST  @CURLIN,@STADDR   Restore from temp
[1421] 8758 47,86           BR   G8786
[1422] 875A 06,97,3F G875A  CALL INITKB            Initialize some variables for
[1423] 875D BD,A3,AA        DST  @PGMPTR,V@INPUTP  Save for "try agian" case
       8760 2C
[1424] 8761 BD,A3,BC        DST  @CCPPTR,V@CPTEMP  Save CCPPTR, RECLEN for "try
       8764 06
[1425]               *                         Entry point for "try again" case
[1426] 8765 06,89,06 INPZ33 CALL INSUB1            Put out prompt
[1427] 8768 06,92,8A INPZ2  CALL GETVAR            Get variable list on V-stack
[1428] 876B 06,89,3B INPUZ3 CALL INSUB2            Read from the screen
[1429] 876E 86,11           CLR  @VAR6             Assume no values input
[1430] 8770 0F,7F           XML  CRUNCH            Crunch the input line
[1431] 8772 01              BYTE 1               * Indicate input stmt scan
[1432] 8773 BD,0A,14        DST  @CURLIN,@STADDR   Restore from temp
[1433] 8776 8F,22           DCZ  @ERRCOD           If got some crunch error
[1434] 8778 47,BB           BR   WRNINP
[1435] 877A 0F,83           XML  SCROLL            Scroll up after crunching
[1436] 877C BE,7F,03        ST   3,@XPT            Reset XPT too - pending recor
[1437] 877F 90,11           INC  @VAR6             # fields = # of commas + 1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0025 
FLMGR-359
[1438] 8781 D4,10,11        CEQ  @VAR6,@VAR5       # of variables wrong
[1439] 8784 47,BB           BR   WRNINP
[1440]               * Once we're here, all information should be availiable
[1441]               * After type verification for input and variables, push
[1442]               * all value entries on the V-stack.
[1443]               * VAR6 = VAR5 = number of variables
[1444] 8786 BD,14,34 G8786  DST  @DATA,@CURLIN     Save current DATA pointer
[1445] 8789 BF,34,08        DST  CRNBUF,@DATA      Get crunch entry
       878C 20
[1446] 878D BD,02,0E        DST  @VAR4,@MNUM       Get entry in V-stack before P
[1447] 8790 A3,02,00 INPUZ4 DADD 8,@MNUM           Point to first symbol table e
       8793 08
[1448] 8794 BD,06,B0        DST  V*MNUM,@CCPPTR    Get immedediate result
       8797 02
[1449] 8798 06,93,0C        CALL GETRAM            Get value descriptor from RAM
[1450] 879B DA,B0,06        CLOG >80,V*CCPPTR      Numerical value
       879E 80
[1451] 879F 47,CF           BR   G87CF
[1452] 87A1 06,92,EC        CALL CHKNUM            Check entered value against n
[1453] 87A4 47,B4           BR   INPUZ5            Found error
[1454] 87A6 8E,17           CZ   @DSRFLG           Do not check overflow in file
[1455]               *                              supply machine infinity with
[1456]               *                              appropriate sign and continu
[1457] 87A8 67,D4           BS   INPUZ6
[1458] 87AA 8E,A3,BA        CZ   V@CSNTP1          Watch out for overflow in scr
[1459] 87AD 67,D4           BS   INPUZ6
[1460] 87AF BD,34,14        DST  @CURLIN,@DATA     Restore DATA pointer
[1461] 87B2 47,BF           BR   WRZZ5             Ask for input re-enter
[1462] 87B4 8E,17    INPUZ5 CZ   @DSRFLG           FILE I/O IS FATAL
[1463] 87B6 77,CF           BS   ERRINP
[1464] 87B8 BD,34,14        DST  @CURLIN,@DATA     Restore DATA pointer on error
[1465] 87BB 06,6A,82 WRNINP CALL WARNZZ            Go here for simple warnings t
[1466] 87BE 20              BYTE 32              * INPUT ERROR - TRY AGAIN
[1467] 87BF 06,88,3A WRZZ5  CALL SCRZ              Scroll the screen and reset C
[1468] 87C2 BD,2C,A3        DST  V@INPUTP,@PGMPTR  Restore ptr to "prompt" if an
       87C5 AA
[1469] 87C6 BD,06,A3        DST  V@CPTEMP,@CCPPTR  Restore CCPPTR, RECLEN, for t
       87C9 BC
[1470] 87CA BD,6E,0E        DST  @VAR4,@VSPTR      Restore original stack ptr
[1471] 87CD 47,65           BR   INPZ33
[1472] 87CF 06,93,23 G87CF  CALL CHKSTR            Check string input
[1473] 87D2 67,B4           BS   INPUZ5            ERROR ... CHECK I/O TYPE
[1474] 87D4 06,93,0C INPUZ6 CALL GETRAM            Get separation character (RAM
[1475] 87D7 D6,01,B3        CEQ  COMMAZ,@VAR0+1
[1476] 87DA 67,E6           BS   G87E6
[1477] 87DC 92,11           DEC  @VAR6             Has to be end of data
[1478] 87DE 47,B4           BR   INPUZ5            If not ... ERROR
[1479] 87E0 8E,01           CZ   @VAR0+1
[1480] 87E2 47,B4           BR   INPUZ5
[1481] 87E4 47,EA           BR   G87EA
[1482] 87E6 92,11    G87E6  DEC  @VAR6             Count number of value entries
[1483] 87E8 47,90           BR   INPUZ4            Continue
[1484]               * Assign cycle - assign values to variables because it resc
[1485]               * the program line, this code can not be udes for inperativ
[1486]               * statements , since the crunch buffer get's destroyed on
[1487]               * input. The rescan is necessary because subscripts should
[1488]               * evaluated AFTER all previous values have been assigned. i
[1489]               *        INPUT I,A(I)      with values 2,3
[1490]               * Should assign value 3 to A(2) !!!!!!!!!
[1491]               * No error-checking is done here, since types are already
[1492]               * validated. We might get subscripts out of range though!!!
[1493] 87EA BF,34,08 G87EA  DST  CRNBUF,@DATA      Prepare for input rescan
       87ED 20
[1494] 87EE BD,2C,0A        DST  @STADDR,@PGMPTR   Restore token pointer for res

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0026 
FLMGR-359
[1495] 87F1 93,2C           DDEC @PGMPTR           Backup on token
[1496] 87F3 BD,6E,0E        DST  @VAR4,@VSPTR      Restore original stack pointe
[1497] 87F6 0F,79    INPZ65 XML  PGMCHR            Get next program characters
[1498] 87F8 06,95,AD        CALL CHKEND            Might have , before EOS
[1499] 87FB 68,22           BS   INPUZ7
[1500] 87FD 06,97,E3        CALL BUG01             Rescan variable name
[1501]               * Above call fixes bug.       Get correct entry for arrays
[1502] 8800 0F,77           XML  VPUSH             Save on stack for ASSGNV
[1503] 8802 06,93,0C        CALL GETRAM            Get first token of input valu
[1504] 8805 D6,4C,65        CEQ  STRVAL,@FAC2      Numerical case
[1505] 8808 68,0F           BS   G880F
[1506] 880A 06,92,EC        CALL CHKNUM            Check for numerical value
[1507] 880D 68,18           BS   INPZ67            COND should be set (valid num
[1508] 880F 06,93,23 G880F  CALL CHKSTR            Get the correct string value
[1509] 8812 BD,0C,50        DST  @FAC6,@BYTES      Length for temporary string
[1510] 8815 06,92,DE        CALL CTMPST            Create temporary string
[1511] 8818 0F,7C    INPZ67 XML  ASSGNV            Assign value to variable
[1512] 881A 06,93,0C        CALL GETRAM            Skip separator (already check
[1513] 881D 06,95,AD        CALL CHKEND            Check for end to statement
[1514] 8820 47,F6           BR   INPZ65            Found it
[1515] 8822 BD,34,14 INPUZ7 DST  @CURLIN,@DATA     Restore DATA pointer
[1516] 8825 0F,75           XML  CONT              Contiue in PARSE
[1517] 8827 BC,21,E0 RECENT ST   V@OFS(@PABPTR),@VARW+1  Get record offset
       882A 03,04
[1518] 882C 86,20           CLR  @VARW             Double byte value required
[1519] 882E A1,20,E0        DADD V@BUF(@PABPTR),@VARW   Got it
       8831 06,04
[1520] 8833 00              RTN                    AND NOW, THE END IS NEAR...
[1521] 8834 C7,08,02 CHKRM  DCH  SCRNBS+29,@CCPADR Not enough room for "?"
       8837 FD
[1522] 8838 48,40           BR   G8840
[1523] 883A 0F,83    SCRZ   XML  SCROLL            Scroll one line for "?"
[1524] 883C BF,08,02        DST  SCRNBS+2,@CCPADR   and update CCPADR accordingl
       883F E2
[1525] 8840 00       G8840  RTN
[1526]               ***********************************************************
[1527]               *                LINPUT ROUTINE
[1528]               * If file-I/O then
[1529]               *             Get file number and check it
[1530]               *             Internal file not allowed
[1531]               * End if
[1532]               * Get variable info
[1533]               * Must be string variable
[1534]               * If file I/O then
[1535]               *           If no-partial-record of REC clause included
[1536]               *           Read new record
[1537]               *     End if
[1538]               *     Set up copy pointers
[1539]               * Else
[1540]               *     Call readline to read from keyboard
[1541]               *     Copy to crunch buffer adjustin g for screen offset
[1542]               * End if
[1543]               * Get string of proper length
[1544]               * Move data into string
[1545]               * Assign string
[1546]               * Done.
[1547]               ***********************************************************
[1548] 8841 06,97,3F LINPUT CALL INITKB            Assume input from keyboard
[1549] 8844 D6,42,FD        CEQ  NUMBEZ,@CHAT      If "#" - then device
[1550] 8847 48,5C           BR   G885C
[1551] 8849 06,93,55        CALL CHKFN             Check for default = 0
[1552] 884C 8F,4A           DCZ  @FAC              #0 is assumed
[1553] 884E 68,5F           BS   LINP10
[1554] 8850 06,88,E8        CALL INSU1             Parse the device #

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0027 
FLMGR-359
[1555] 8853 DA,E0,05        CLOG >08,V@FLG(@PABPTR)
       8856 04,08
[1556] 8858 57,D7           BR   ERRFE
[1557] 885A 48,5F           BR   LINP10
[1558] 885C 06,89,06 G885C  CALL INSUB1            Handle possible prompt
[1559] 885F BD,0E,6E LINP10 DST  @VSPTR,@VAR4      Save original V-pointer
[1560]               *                              incase BREAK in READLN
[1561] 8862 06,97,E3        CALL BUG01             Get info about the symbol
[1562]               * Above call fixes bug.       Get value pointer and type
[1563] 8865 D6,4C,65        CEQ  STRVAL,@FAC2      Must be string
[1564] 8868 57,DF           BR   ERRMUV
[1565] 886A 0F,77           XML  VPUSH
[1566] 886C 8E,17           CZ   @DSRFLG           If device I/O
[1567] 886E 48,AF           BR   G88AF
[1568] 8870 8E,E0,03        CZ   V@OFS(@PABPTR)    If new record
       8873 04
[1569] 8874 48,7B           BR   G887B
[1570] 8876 06,97,65        CALL IOCLZ1            Read the record
[1571] 8879 48,93           BR   G8893
[1572] 887B BC,0C,E0 G887B  ST   V@CNT(@PABPTR),@BYTES Get length of record
       887E 09,04
[1573] 8880 BD,66,E0        DST  V@BUF(@PABPTR),@TEMP5 Get address of buffer
       8883 06,04
[1574] 8885 8E,0C    G8885  CZ   @BYTES            While characters in buffer
[1575] 8887 68,93           BS   G8893
[1576] 8889 A6,B0,66        SUB  OFFSET,V*TEMP5    Remove INPUT's offset
       888C 60
[1577] 888D 91,66           DINC @TEMP5            Increment pointer
[1578] 888F 92,0C           DEC  @BYTES            Decrement count
[1579] 8891 48,85           BR   G8885             Drop out directly when done
[1580] 8893 86,66    G8893  CLR  @TEMP5            Need a word value
[1581] 8895 BC,67,E0        ST   V@OFS(@PABPTR),@TEMP5+1  Restore value
       8898 03,04
[1582] 889A 86,0C           CLR  @BYTES            Need a word value
[1583] 889C BC,0D,E0        ST   V@CNT(@PABPTR),@BYTES+1  Get the length
       889F 09,04
[1584] 88A1 A5,0C,66        DSUB @TEMP5,@BYTES     Calcualte length
[1585] 88A4 A1,66,E0        DADD V@BUF(@PABPTR),@TEMP5  Current buffer address
       88A7 06,04
[1586] 88A9 86,E0,03        CLR  V@OFS(@PABPTR)    Read next record next time
       88AC 04
[1587] 88AD 48,E1           BR   G88E1             Else if keyboard input
[1588] 88AF 06,89,3B G88AF  CALL INSUB2            Clear line and call READLN
[1589] 88B2 87,0C           DCLR @BYTES            Initialize byte counter
[1590] 88B4 BD,66,0A        DST  @RAMPTR,@TEMP5    Initialize "crunch" pointer
[1591] 88B7 D6,B0,2A        CEQ  SPACE+OFFSET,V*VARA     If space
       88BA 80
[1592] 88BB 48,BF           BR   G88BF
[1593] 88BD 93,2A           DDEC @VARA             Don't include space on end
[1594] 88BF CD,20,2A G88BF  DCGT @VARA,@VARW       While not at end
[1595] 88C2 68,DC           BS   G88DC
[1596] 88C4 BC,00,B0        ST   V*VARW,@VAR0      Get the character
       88C7 20
[1597] 88C8 D6,00,7F        CEQ  EDGECH,@VAR0      If not at edge character
[1598] 88CB 68,D8           BS   G88D8
[1599] 88CD A6,00,60        SUB  OFFSET,@VAR0      Subtract screen offset
[1600] 88D0 BC,B0,0A        ST   @VAR0,V*RAMPTR    And put into crunch buffer
       88D3 00
[1601] 88D4 91,0C           DINC @BYTES            Count it
[1602] 88D6 91,0A           DINC @RAMPTR           And update "crunch" pointer
[1603] 88D8 91,20    G88D8  DINC @VARW             Update input pointer
[1604] 88DA 48,BF           BR   G88BF
[1605] 88DC 0F,83    G88DC  XML  SCROLL            Scroll the screen
[1606] 88DE BE,7F,03        ST   3,@XPT            Initialize x-pointer

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0028 
FLMGR-359
[1607] 88E1 06,92,DE G88E1  CALL CTMPST            Create temporary string
[1608] 88E4 0F,7C           XML  ASSGNV            Assign the value to it
[1609] 88E6 0F,75           XML  CONT              And continue execution
[1610]               * Get file number and info about the file
[1611] 88E8 06,93,71 INSU1  CALL CHKCON            Check & convert & search
[1612] 88EB 57,D7           BR   ERRFE             Give error if required
[1613]               * INPUT allowed for input and update modes
[1614] 88ED DA,E0,05        CLOG >02,V@FLG(@PABPTR)
       88F0 04,02
[1615] 88F2 57,D7           BR   ERRFE
[1616] 88F4 06,93,90        CALL OUTEOF            Output pending PRINT stuff
[1617] 88F7 BE,E0,04        ST   CZREAD,V@COD(@PABPTR)   Ensure read operation
       88FA 04,02
[1618] 88FC 06,94,C2        CALL PARREC            Parse REC clause
[1619] 88FF 0F,7E           XML  SPEED             Must be at a
[1620] 8901 00              BYTE SYNCHK          *  colon else
[1621] 8902 B5              BYTE COLONZ          *   its and error
[1622] 8903 86,17           CLR  @DSRFLG           Clear keyboard input flag
[1623] 8905 00              RTN
[1624]               * Parse and put out input prompt
[1625] 8906 BD,0A,2C INSUB1 DST  @PGMPTR,@STADDR   Save pointer for prompt check
[1626] 8909 93,0A           DDEC @STADDR           Backup to previous token
[1627]               *                              Go into a tight loop
[1628] 890B 06,95,BA G890B  CALL NXTCHR            Get next program character
[1629] 890E 69,27           BS   INPZ37            Detected end of statement
[1630] 8910 D6,42,B5        CEQ  COLONZ,@CHAT      Stop if we find a colon
[1631] 8913 49,0B           BR   G890B
[1632] 8915 BD,2C,0A        DST  @STADDR,@PGMPTR   Backup for actual prompt scan
[1633] 8918 0F,79           XML  PGMCHR            Jump into 1st char of prompt
[1634] 891A 0F,74           XML  PARSE             And try to decode string expr
[1635] 891C B5              BYTE COLONZ
[1636] 891D D6,4C,65        CEQ  STRVAL,@FAC2      Number prompt illegal
[1637] 8920 57,BF           BR   ERRSNM
[1638] 8922 06,97,0E        CALL OSTRNG            Output the given prompt
[1639] 8925 49,36           BR   INPZ39            Exit without prompt backup
[1640] 8927 BD,2C,0A INPZ37 DST  @STADDR,@PGMPTR   Backup to beginning of line
[1641] 892A BE,42,B5        ST   COLONZ,@CHAT      Fake prompt with ":"
[1642] 892D 06,88,34 INPUZ2 CALL CHKRM             Check for room for ?
[1643] 8930 BE,B0,08        ST   >9F,V*CCPADR      Display ?
       8933 9F
[1644] 8934 95,08           DINCT @CCPADR          Count it too
[1645] 8936 0F,7E    INPZ39 XML  SPEED             Must be at a
[1646] 8938 00              BYTE SYNCHK          *  colon else
[1647] 8939 B5              BYTE COLONZ          *   its an error
[1648] 893A 00              RTN
[1649]               * Issue 'BEEP' and call read line to read form screen
[1650] 893B 06,88,34 INSUB2 CALL CHKRM             Check for room for answer
[1651] 893E BD,20,08        DST  @CCPADR,@VARW     Copy current cursor position
[1652] 8941 BE,B0,08 G8941  ST   >80,V*CCPADR      Clear the remainder
       8944 80
[1653] 8945 91,08           DINC @CCPADR            of the current line
[1654] 8947 CB,08,02        DCHE >02FE,@CCPADR     Stop if we're there
       894A FE
[1655] 894B 49,41           BR   G8941
[1656] 894D BF,A2,FE        DST  >7F7F,V@>02FE     Replace edgechars
       8950 7F,7F
[1657] 8952 8E,80,CE        CZ   @PRTNFN           If previous tone finished
[1658] 8955 49,5A           BR   G895A
[1659] 8957 06,00,34        CALL TONE1             ---------- BEEP -------------
[1660] 895A C1,6E,0E G895A  DEX  @VAR4,@VSPTR      Don't destroy V-stack on BREA
[1661] 895D 06,6A,76        CALL READLN            Input a line from the keyboar
[1662] 8960 C1,6E,0E        DEX  @VAR4,@VSPTR      Restore V-stack pointer
[1663] 8963 BD,14,0A        DST  @STADDR,@CURLIN   Save in a temp
[1664] 8966 BF,0A,08        DST  CRNBUF,@RAMPTR    Init crunch buffer pointer

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0029 
FLMGR-359
       8969 20
[1665] 896A 00              RTN
[1666]               ***********************************************************
[1667]               *                   ACCEPT STATEMENT
[1668]               * Accept input anywhere on the screen. The total number of
[1669]               * input variables is limited to one. On an ACCEPT AT( , ),
[1670]               * the maximum number that can be accepted is up to the righ
[1671]               * margin!!!! If SIZE() is used, the maximum number is
[1672]               * limited to the given SIZE, or to the number of characters
[1673]               * remaining on the line, whichever is the lesser.
[1674]               ***********************************************************
[1675] 896B 86,A3,B7 ACCEPT CLR  V@ACCTRY          Clear "try again" flag
[1676] 896E 06,94,EF        CALL DISACC            Use common code for DISPLAY/A
[1677] 8971 61,09           BS   ERRSYN             COND set means end of statem
[1678] 8973 BE,63,FF        ST   >FF,@ARG7         Assume we don't have VALIDATE
[1679]               ************ VALIDATE OPTION HANDLING *********************
[1680] 8976 D6,42,FE        CEQ  VALIDZ,@CHAT      Detected VALIDATE option
[1681] 8979 49,FD           BR   G89FD
[1682] 897B 0F,79           XML  PGMCHR            Next character should start o
[1683] 897D D6,42,B7        CEQ  LPARZ,@CHAT       "* SYNTAX ERROR *"
[1684] 8980 41,09           BR   ERRSYN
[1685] 8982 B6,04,40        OR   >40,@PABPTR       Indicate usage of validate cl
[1686] 8985 BF,2A,00        DST  1,@VARA           Use VARA as length of option
       8988 01
[1687] 8989 87,20           DCLR @VARW             VARW= options used, VARW+1=#0
[1688]               *                              stack entries for strings
[1689] 898B 0F,79    G898B  XML  PGMCHR            Skip separator token
[1690] 898D CA,42,E8        CHE  NUMERZ,@CHAT      Could be valid option
[1691] 8990 49,AA           BR   G89AA
[1692] 8992 CA,42,EB        CHE  UALPHZ+1,@CHAT    It is ....
[1693] 8995 69,AA           BS   G89AA
[1694] 8997 BE,5C,01        ST   1,@ARG            Select bit 0 as number option
[1695] 899A A6,42,E8        SUB  NUMERZ,@CHAT      Create correct offset
[1696] 899D 69,A2           BS   SETVW             Skip the shift stat.
[1697] 899F E0,5C,42        SLL  @CHAT,@ARG        Then select whatever option w
[1698] 89A2 B4,20,5C SETVW  OR   @ARG,@VARW        Remember options in VARW
[1699]               *                              stack entries for strings
[1700] 89A5 0F,79           XML  PGMCHR            Get next token
[1701] 89A7 05,89,C4        B    VLIDZ0            Must use a long branch here
[1702] 89AA 0F,74    G89AA  XML  PARSE             Try to decode a string expres
[1703] 89AC B6              BYTE RPARZ
[1704] 89AD D6,4C,65        CEQ  STRVAL,@FAC2      String-number mismatch
[1705] 89B0 57,BF           BR   ERRSNM
[1706] 89B2 8E,51           CZ   @FAC7             Only count non-null strings
[1707] 89B4 69,C4           BS   VLIDZ0
[1708] 89B6 A0,2B,51        ADD  @FAC7,@VARA+1     Now watch out for overflow
[1709] 89B9 0C              CARRY                  Sting truncated
[1710] 89BA 49,C0           BR   G89C0
[1711] 89BC 06,6A,84        CALL ERRZZ             * STRING TRUNCATED ERROR *
[1712] 89BF 13              BYTE 19
[1713] 89C0 0F,77    G89C0  XML  VPUSH             Push the result for future re
[1714] 89C2 90,21           INC  @VARW+1           Count number of entries on st
[1715] 89C4 D6,42,B3 VLIDZ0 CEQ  COMMAZ,@CHAT      Evaluate all fields
[1716] 89C7 69,8B           BS   G898B
[1717] 89C9 0F,7E           XML  SPEED
[1718] 89CB 00              BYTE SYNCHK          * Check for ")" on end
[1719] 89CC B6              BYTE RPARZ           * If not, "* SYNTAX ERROR *"
[1720] 89CD 06,94,F2        CALL DISPZ1            Try to evaluate further optio
[1721] 89D0 61,09           BS   ERRSYN            Premature end of statement
[1722] 89D2 BD,0C,2A        DST  @VARA,@BYTES      Allocate string for character
[1723] 89D5 0F,71           XML  GETSTR
[1724] 89D7 BD,5C,1C        DST  @SREF,@ARG        Get start of allocated string
[1725] 89DA BC,B0,5C        ST   @VARW,V*ARG       Get start of allocated string
       89DD 20

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0030 
FLMGR-359
[1726] 89DE 91,5C           DINC @ARG              Leave room form standard opti
[1727] 89E0 8E,21    G89E0  CZ   @VARW+1           Copy all available informatio
[1728] 89E2 69,F3           BS   G89F3
[1729] 89E4 0F,78           XML  VPOP              Regain stack-entry
[1730] 89E6 34,50,B0        MOVE @FAC6,V*FAC4,V*ARG Copy string
       89E9 5C,B0,4E
[1731] 89EC A1,5C,50        DADD @FAC6,@ARG        Update destination address
[1732] 89EF 92,21           DEC  @VARW+1           Count # of stack entries
[1733] 89F1 49,E0           BR   G89E0
[1734] 89F3 BD,A3,B0 G89F3  DST  @SREF,V@VALIDP    Copy start address of string
       89F6 1C
[1735] 89F7 BD,A3,B2        DST  @VARA,V@VALIDL     and total string length
       89FA 2A
[1736] 89FB 86,63           CLR  @ARG7             Indicate VALIDATE usage of RE
[1737] 89FD BD,20,08 G89FD  DST  @CCPADR,@VARW     Save start address of the fie
[1738] 8A00 BD,2A,20        DST  @VARW,@VARA       Set default highest address u
[1739] 8A03 BD,5E,08        DST  @CCPADR,@ARG2     Select absolute highest usabl
[1740] 8A06 A3,5E,01        DADD 290,@ARG2         290=2+32*9 maximum of 254 cha
       8A09 22
[1741] 8A0A C6,2B,FC        CH   >FC,@VARA+1       Start at the end of line
[1742] 8A0D 4A,13           BR   G8A13
[1743] 8A0F A3,5E,00        DADD 4,@ARG2
       8A12 04
[1744] 8A13 8E,04    G8A13  CZ   @PABPTR           We used some options like AT,
[1745] 8A15 6A,66           BS   G8A66
[1746] 8A17 0F,7E           XML  SPEED
[1747] 8A19 00              BYTE SYNCHK          * Should always end on ":"
[1748] 8A1A B5              BYTE COLONZ
[1749] 8A1B DA,04,02        CLOG >02,@PABPTR       Used BEEP clause
[1750] 8A1E 6A,23           BS   G8A23
[1751] 8A20 06,00,34        CALL TONE1             Wake up the user
[1752] 8A23 DA,04,04 G8A23  CLOG >04,@PABPTR       Used AT option, SIZE!!!
[1753] 8A26 6A,35           BS   G8A35
[1754] 8A28 DA,04,08        CLOG >08,@PABPTR       Use defualt SIZE option
[1755] 8A2B 4A,33           BR   G8A33
[1756] 8A2D BE,05,1C        ST   VWIDTH,@PABPTR+1  Limit current record length
[1757] 8A30 06,95,DF        CALL SIZE1
[1758] 8A33 4A,47    G8A33  BR   ACCPZ1
[1759] 8A35 DA,04,08 G8A35  CLOG >08,@PABPTR       SIZE option used somewhere
[1760] 8A38 6A,66           BS   G8A66
[1761]               * We're sure now that SIZE has been used WITHOUT the AT
[1762]               * option, this means that we should set XPT to point behind
[1763]               * the SIZE field. This can be done by adding the record
[1764]               * length to the current screen base address and the line's
[1765]               * screen base address
[1766] 8A3A BC,7F,09        ST   @CCPADR+1,@XPT    Start of with current address
[1767] 8A3D A0,7F,07        ADD  @RECLEN,@XPT      Add in the current record len
[1768] 8A40 A6,7F,DF        SUB  >DF,@XPT          And subtract the lower base a
[1769]               *                             Also adjust for edge characte
[1770] 8A43 BC,A3,B8        ST   @XPT,V@SIZXPT     Save it for "try again" case
       8A46 7F
[1771]               *                              in WARNING, XPT gets changed
[1772] 8A47 BD,A3,B4 ACCPZ1 DST  @CCPADR,V@SIZCCP  Save for "try again" case
       8A4A 08
[1773] 8A4B BC,A3,B6        ST   @RECLEN,V@SIZREC  Save for "try again" case
       8A4E 07
[1774]               ***********************************************************
[1775]               * ENTRY POINT FOR "TRY AGAIN" CASE WHEN SIZE OR ACCEPT USED
[1776]               ***********************************************************
[1777] 8A4F DA,04,80 ACCPZ9 CLOG >80,@PABPTR       Blank current field
[1778] 8A52 4A,58           BR   G8A58
[1779] 8A54 BE,B0,08        ST   SPACE+OFFSET,V*CCPADR
       8A57 80
[1780] 8A58 91,08    G8A58  DINC @CCPADR           Update screen address

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0031 
FLMGR-359
[1781] 8A5A 92,07           DEC  @RECLEN           Reduce count, always at least
[1782] 8A5C 4A,4F           BR   ACCPZ9            Loop until at end of field
[1783] 8A5E 93,08           DDEC @CCPADR           Fix end of field for maximum
[1784] 8A60 BD,2A,08        DST  @CCPADR,@VARA     Set highest location availabl
[1785] 8A63 BD,5E,2A        DST  @VARA,@ARG2       Also highest location availab
[1786]               *                              OK all set to go
[1787] 8A66 D6,A3,B7 G8A66  CEQ  1,V@ACCTRY        Skip if in "try again"
       8A69 01
[1788] 8A6A 6A,74           BS   ACCPZ7
[1789] 8A6C BD,0E,6E        DST  @VSPTR,@VAR4      Save first entry in V-stack
[1790] 8A6F 06,97,E3        CALL BUG01             Collect the symbol designator
[1791]               * Above call fixes bug.       Take care of arrays too
[1792] 8A72 0F,77           XML  VPUSH             Save symbol table entry
[1793] 8A74 BD,A3,AC ACCPZ7 DST  @VARW,V@ACCVRW    Save for trying again case
       8A77 20
[1794] 8A78 BD,A3,AE        DST  @VARA,V@ACCVRA    Save for trying again case
       8A7B 2A
[1795]               ***********************************************************
[1796]               * ENTRY POINT FOR "TRY AGAIN" WHEN NEITHER SIZE OR ACCEPT I
[1797]               ***********************************************************
[1798]               * In case a CALL CLEAR or ERASE ALL or CALL HCHAR has just
[1799]               * processed, EDGE CHARS, are gone at the bottom line
[1800] 8A7C DA,04,0C ACCPZ5 CLOG >0C,@PABPTR       If AT/SIZE used, maximum fiel
[1801] 8A7F 4A,86           BR   AZ1                is line, so no need to worry
[1802]               *                              about it
[1803] 8A81 BF,A2,FE        DST  >7F7F,V@>02FE     Put the EDGE CHAR back
       8A84 7F,7F
[1804] 8A86 C1,0E,6E AZ1    DEX  @VSPTR,@VAR4      Don't destroy V-stack on BREA
[1805] 8A89 06,6A,86        CALL READL1            Ask for some input that can b
[1806]               *                             used
[1807] 8A8C C1,0E,6E        DEX  @VSPTR,@VAR4      Resote V-stack pointer
[1808]               * At this point, VARA contains the highest location used,
[1809]               * and VARW contains the string's start address
[1810] 8A8F D5,2A,20 ACCPZ2 DCEQ @VARW,@VARA       Only non-empty string
[1811] 8A92 6A,9E           BS   G8A9E
[1812] 8A94 93,2A           DDEC @VARA             Go to the next position
[1813] 8A96 D6,B0,2A        CEQ  SPACE+OFFSET,V*VARA
       8A99 80
[1814] 8A9A 6A,8F           BS   ACCPZ2
[1815] 8A9C 91,2A           DINC @VARA             Back to the last space
[1816] 8A9E 0F,78    G8A9E  XML  VPOP              Check the symbol designator i
[1817] 8AA0 0F,77           XML  VPUSH             a string or numeric variable
[1818] 8AA2 D6,4C,65        CEQ  >65,@FAC2         If numeric : empty string is
[1819] 8AA5 6A,B2           BS   G8AB2
[1820] 8AA7 D5,20,2A        DCEQ @VARA,@VARW       If an empty string was entere
[1821] 8AAA 4A,B2           BR   G8AB2
[1822] 8AAC 06,6A,82        CALL WARNZZ            *** INPUT ERROR ***
[1823] 8AAF 20              BYTE 32
[1824] 8AB0 4A,FC           BR   ACCPZ8
[1825] 8AB2 87,0C    G8AB2  DCLR @BYTES            Compute length of input strin
[1826] 8AB4 BD,1C,20        DST  @VARW,@SREF       Use SREF as temporary variabl
[1827] 8AB7 D5,1C,2A G8AB7  DCEQ @VARA,@SREF
[1828] 8ABA 6A,C8           BS   G8AC8
[1829] 8ABC D6,B0,1C        CEQ  EDGECH,V*SREF     Exclude edge character
       8ABF 7F
[1830] 8AC0 6A,C4           BS   G8AC4
[1831] 8AC2 91,0C           DINC @BYTES
[1832] 8AC4 91,1C    G8AC4  DINC @SREF             Decrement the counter
[1833] 8AC6 4A,B7           BR   G8AB7
[1834] 8AC8 06,92,D1 G8AC8  CALL CTSTR0            Create a temporary string
[1835] 8ACB D5,20,2A ACCPZ3 DCEQ @VARA,@VARW
[1836] 8ACE 6A,EB           BS   G8AEB
[1837] 8AD0 D6,B0,20        CEQ  EDGECH,V*VARW     Skip the edge character
       8AD3 7F

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0032 
FLMGR-359
[1838] 8AD4 4A,DC           BR   G8ADC
[1839] 8AD6 A3,20,00        DADD 4,@VARW
       8AD9 04
[1840] 8ADA 4A,CB           BR   ACCPZ3
[1841] 8ADC BC,B0,1C G8ADC  ST   V*VARW,V*SREF     Copy the string
       8ADF B0,20
[1842] 8AE1 A6,B0,1C        SUB  OFFSET,V*SREF     Subtract the screen offset
       8AE4 60
[1843] 8AE5 91,20           DINC @VARW             Update pointers
[1844] 8AE7 91,1C           DINC @SREF
[1845] 8AE9 4A,CB           BR   ACCPZ3            Result can't be 0
[1846] 8AEB D6,4C,65 G8AEB  CEQ  STRVAL,@FAC2      Numerical variable
[1847] 8AEE 6B,2A           BS   ACCPZ6
[1848] 8AF0 BE,4C,65        ST   STRVAL,@FAC2      Create temp string
[1849] 8AF3 06,A0,16        CALL VALCD             Use VAL code for translation
[1850] 8AF6 4B,2A           BR   ACCPZ6            No error - ok go on
[1851] 8AF8 06,6A,82 WRNSNM CALL WARNZZ            Error
[1852] 8AFB 07              BYTE 7               * STRING NUMBER MISMATCH
[1853] 8AFC DA,04,08 ACCPZ8 CLOG >08,@PABPTR       If SIZE is used
[1854] 8AFF 6B,0A           BS   G8B0A
[1855] 8B01 DA,04,04        CLOG >04,@PABPTR       Also AT is not used
[1856] 8B04 4B,0A           BR   G8B0A
[1857] 8B06 BC,7F,A3        ST   V@SIZXPT,@XPT     Restore XPT : in WARNING XPT
       8B09 B8
[1858] 8B0A BD,20,A3 G8B0A  DST  V@ACCVRW,@VARW    Restore @VARA, @VARW
       8B0D AC
[1859] 8B0E BD,2A,A3        DST  V@ACCVRA,@VARA
       8B11 AE
[1860] 8B12 BE,A3,B7        ST   1,V@ACCTRY        Set the "try again" flag
       8B15 01
[1861] 8B16 DA,04,08        CLOG >08,@PABPTR       If SIZE is not used
[1862] 8B19 4B,20           BR   G8B20
[1863]               * IF ACCEPT ALSO NOT USED. GOTO "TRY AGAIN" FORM HERE
[1864] 8B1B DA,04,04        CLOG >04,@PABPTR
[1865] 8B1E 6A,7C           BS   ACCPZ5
[1866]               * IF "EITHER SIZE OR ACCEPT IS USED" THEN
[1867] 8B20 BD,08,A3 G8B20  DST  V@SIZCCP,@CCPADR  Restore CCPADR
       8B23 B4
[1868] 8B24 BC,07,A3        ST   V@SIZREC,@RECLEN  Restore RECLEN
       8B27 B6
[1869] 8B28 4A,4F           BR   ACCPZ9            Go blanking the field and
[1870]               *                              "try again"
[1871] 8B2A 0F,7C    ACCPZ6 XML  ASSGNV            Should be ok now
[1872] 8B2C DA,04,0C        CLOG >0C,@PABPTR       Test usage of AT and/or SIZE
[1873] 8B2F 4B,36           BR   ACCPZ4            At least one of the two used
[1874] 8B31 0F,83           XML  SCROLL            Scroll the screen up
[1875] 8B33 BE,7F,03        ST   3,@XPT            And reset XPT
[1876] 8B36 0F,75    ACCPZ4 XML  CONT
[1877]               ***********************************************************
[1878]               *                  READ STATEMENT
[1879]               * Assign DATA values to variables in READ-list one at a
[1880]               * time. Possibly search for new DATA statements if the
[1881]               * current DATA statement has been used. Be careful with
[1882]               * null entries...!!!
[1883]               ***********************************************************
[1884] 8B38 0F,79    G8B38  XML  PGMCHR            Get character following ","
[1885] 8B3A 06,97,E3 READ   CALL BUG01             Get pointers and correct entr
[1886]               * Above call fixes bug.        also allow for array variabl
[1887] 8B3D 0F,77           XML  VPUSH             Push on Vstack for assignment
[1888] 8B3F 8E,34           CZ   @DATA             DATA ERROR
[1889] 8B41 77,D3           BS   ERRDAT
[1890] 8B43 06,93,04        CALL GETGFL            Get next data item (RAM/GROM)
[1891] 8B46 D6,4C,65        CEQ  STRVAL,@FAC2
[1892] 8B49 6B,6B           BS   G8B6B

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0033 
FLMGR-359
[1893] 8B4B D6,01,C8        CEQ  NUMZ,@VAR0+1      Not a numeric
[1894] 8B4E 57,BF           BR   ERRSNM
[1895]               *                              string-number mismatch error
[1896] 8B50 06,93,2F        CALL CHKSZ0            Build up string info
[1897] 8B53 91,50           DINC @FAC6             Force legal delimiter on end
[1898] 8B55 06,A0,02        CALL LITS05            Copy numeric into string spac
[1899] 8B58 BD,56,1C        DST  @SREF,@FAC12      Copy string start address
[1900] 8B5B A1,1C,50        DADD @FAC6,@SREF       Compute end address of string
[1901] 8B5E 93,1C           DDEC @SREF             Back up over delimiter
[1902] 8B60 06,A0,12        CALL CONVER            Convert string to number
[1903] 8B63 D5,A3,90        DCEQ @SREF,V@CSNTMP    WRONG!!!!!!!
       8B66 1C
[1904] 8B67 57,D3           BR   ERRDAT
[1905] 8B69 4B,73           BR   G8B73
[1906] 8B6B 06,93,23 G8B6B  CALL CHKSTR            Check string input
[1907] 8B6E 77,D3           BS   ERRDAT            Give error on error
[1908] 8B70 06,A0,02        CALL LITS05            Allocate string in string spa
[1909] 8B73 0F,7C    G8B73  XML  ASSGNV            Assign variable
[1910] 8B75 06,93,04        CALL GETGFL            Get next datum from DATA stmt
[1911] 8B78 D6,01,B3        CEQ  COMMAZ,@VAR0+1    Has to be an end of DATA
[1912] 8B7B 6B,8F           BS   G8B8F
[1913] 8B7D 8E,01           CZ   @VAR0+1           Check for end of data
[1914] 8B7F 57,D3           BR   ERRDAT
[1915] 8B81 97,36           DDECT @LNBUF           Pointer to line # of DATA stm
[1916] 8B83 86,34           CLR  @DATA             Assume the worst - no more DA
[1917] 8B85 D5,36,30        DCEQ @STLN,@LNBUF
[1918] 8B88 6B,8F           BS   G8B8F
[1919] 8B8A 93,36           DDEC @LNBUF            Next line's 1st token address
[1920] 8B8C 06,A0,08        CALL DATAST            Get next DATA statement
[1921] 8B8F D6,42,B3 G8B8F  CEQ  COMMAZ,@CHAT      Worry about junk in CONT
[1922] 8B92 6B,38           BS   G8B38
[1923] 8B94 0F,75           XML  CONT
[1924]               * SRDATA-Search for DATA statements (DATA statement must
[1925]               * be the only statement on one line)
[1926]               * SEARCH-also used for searching IMAGE statement.
[1927] 8B96 BE,4C,93 SRDATA ST   DATAZ,@FAC2       Search for a DATA token
[1928] 8B99 C1,2C,34 SEARCH DEX  @DATA,@PGMPTR     Exchange with normal PC
[1929] 8B9C C0,01,42        EX   @CHAT,@VAR0+1     Preserve current PGM characte
[1930] 8B9F 8E,44           CZ   @PRGFLG           If imperative statement
[1931] 8BA1 4B,B3           BR   G8BB3
[1932] 8BA3 8E,80,84        CZ   @RAMTOP           With ERAM : text itself in ER
[1933] 8BA6 6B,B3           BS   G8BB3
[1934] 8BA8 BE,80,89        ST   >FF,@RAMFLG       Fake RAMFLG in this case
       8BAB FF
[1935] 8BAC 0F,79           XML  PGMCHR            Get first character on the li
[1936] 8BAE 86,80,89        CLR  @RAMFLG           Restore it back
[1937] 8BB1 4B,B5           BR   SRDAZ1            Skip that PGMCHR
[1938] 8BB3 0F,79    G8BB3  XML  PGMCHR            Get first character on the li
[1939] 8BB5 D4,42,4C SRDAZ1 CEQ  @FAC2,@CHAT       Search for specific token
[1940] 8BB8 6B,BD           BS   SRDAZ0
[1941] 8BBA D4,00,00        CEQ  @VAR0,@VAR0       Set COND if no DATA found
[1942] 8BBD C1,2C,34 SRDAZ0 DEX  @DATA,@PGMPTR     Exchange won't affect the CON
[1943] 8BC0 C0,01,42        EX   @CHAT,@VAR0+1     Situation ok
[1944] 8BC3 01              RTNC                   Return to caller with COND
[1945]               ***********************************************************
[1946]               *                     OLD STATEMENT
[1947]               * A normal load:
[1948]               *   Get a program from an external device to VDP and
[1949]               *   reinitialize the program pointers. Also update the line
[1950]               *   pointer table, since the memory size of the machine on
[1951]               *   which the program was created doesn't have to be the
[1952]               *   same as on the current system!!!! Then check if ERAM
[1953]               *   existed, move it to ERAM if does exist (in relocated
[1954]               *   from)

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0034 
FLMGR-359
[1955]               * Load a sequential file:
[1956]               *   When program is bigger than 13.5K and ERAM exists,
[1957]               *   maximum-length record reads are preformed to read the
[1958]               *   file and each record is copied into the ERAM as it is
[1959]               *   read.
[1960]               ***********************************************************
[1961] 8BC4 06,8B,CA OLD    CALL OLD1              Make OLD1 a subroutine for LO
[1962] 8BC7 05,60,12        B    TOPL15            Go back to top level
[1963] 8BCA 06,92,35 OLD1   CALL GPNAME            Get program name & reinitiali
[1964] 8BCD 0F,79           XML  PGMCHR            Check for EOL
[1965] 8BCF BD,0A,04        DST  @PABPTR,@STADDR   Compute memory start address
[1966] 8BD2 A1,0A,E0        DADD V@NLEN-1(@PABPTR),@STADDR    Add PAB-name lengt
       8BD5 0C,04
[1967] 8BD7 A3,0A,00        DADD PABLEN-4,@STADDR              and PAB length
       8BDA 0A
[1968] 8BDB BD,E0,0A        DST  @HIVDP,V@RNM(@PABPTR)  Compute # of availiable
       8BDE 04,70
[1969] 8BE0 A5,E0,0A        DSUB @STADDR,V@RNM(@PABPTR)
       8BE3 04,0A
[1970] 8BE5 91,E0,0A        DINC V@RNM(@PABPTR)    Include current address
       8BE8 04
[1971] 8BE9 BD,E0,06        DST  @STADDR,V@BUF(@PABPTR) for copy start
       8BEC 04,0A
[1972] 8BEE BE,E0,04        ST   CZLOAD,V@COD(@PABPTR)   Select LOAD I/O code
       8BF1 04,05
[1973] 8BF3 06,97,6B        CALL CDSR              Call device service routine
[1974] 8BF6 4C,63           BR   OLDZ3             Not a program file, may be a
[1975]               *                              sequential file
[1976]               * STADDR still points to the info bytes
[1977] 8BF8 BD,02,E0        DST  V@2(@STADDR),@MNUM First test checksum
       8BFB 02,0A
[1978] 8BFD B9,02,E0        DXOR V@4(@STADDR),@MNUM  which is a simple XOR
       8C00 04,0A
[1979] 8C02 D5,B0,0A        DCEQ @MNUM,V*STADDR     Try PROTECTION option
       8C05 02
[1980] 8C06 6C,15           BS   G8C15
[1981] 8C08 83,02           DNEG @MNUM
[1982] 8C0A D5,B0,0A        DCEQ @MNUM,V*STADDR    No-ERROR
       8C0D 02
[1983] 8C0E 4D,2D           BR   OLDER
[1984] 8C10 B6,45,80        OR   >80,@FLAG         Yes, set LIST/EDIT PROTECTION
[1985] 8C13 4C,17           BR   G8C17
[1986] 8C15 86,45    G8C15  CLR  @FLAG             Otherwise clear protection
[1987] 8C17 BD,32,E0 G8C17  DST  V@2(@STADDR),@ENLN  Copy new ENLN,
       8C1A 02,0A
[1988] 8C1C BD,30,E0        DST  V@4(@STADDR),@STLN   STLN and
       8C1F 04,0A
[1989] 8C21 BD,A3,BC        DST  V@6(@STADDR),V@OLDTOP top of memory info
       8C24 E0,06,0A
[1990] 8C27 A3,0A,00        DADD 8,@STADDR         Point to program data
       8C2A 08
[1991] 8C2B BD,A3,BE        DST  @HIVDP,V@NEWTOP   Set up the new top
       8C2E 70
[1992] 8C2F 06,8D,36        CALL RELOCA            Relocate according to @>8370
[1993] 8C32 8E,80,84 OLDZ5  CZ   @RAMTOP           ERAM present?
[1994] 8C35 6D,32           BS   LRTOPZ
[1995]               *                             No, go back to toplevel
[1996]               *                             Yes, move from VDP to ERAM
[1997]               *                             (in relocated form)
[1998]               ************ Move to the ERAM from CPUBAS first ***********
[1999] 8C37 BD,00,70        DST  @HIVDP,@VAR0
[2000] 8C3A A5,00,30        DSUB @STLN,@VAR0
[2001] 8C3D 91,00           DINC @VAR0             # of bytes to move
[2002] 8C3F BD,4E,00        DST  @VAR0,@CCC        @CCC : Byte count for VGWITE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0035 
FLMGR-359
[2003] 8C42 BF,50,A0        DST  CPUBAS,@BBB       @BBB : Destination addr on ER
       8C45 40
[2004] 8C46 BD,0A,50        DST  @BBB,@STADDR      For later use as the base of
[2005]               *                              current program image in REL
[2006] 8C49 BD,4C,30        DST  @STLN,@AAA        @AAA : Source address on ERAM
[2007] 8C4C 0F,8A           XML  VGWITE            Move from VDP to ERAM
[2008] 8C4E BD,A3,BC        DST  @HIVDP,V@OLDTOP   Set up old memory top
       8C51 70
[2009] 8C52 BD,A3,BE        DST  @RAMTOP,V@NEWTOP  Set up new memory top
       8C55 80,84
[2010] 8C57 06,8D,36        CALL RELOCA            Relocate the program image
[2011] 8C5A BD,80,86 OLDZ7  DST  @STLN,@RAMFRE     Reset the RAMFRE on ERAM
       8C5D 30
[2012] 8C5E 93,80,86        DDEC @RAMFRE
[2013] 8C61 4D,32           BR   LRTOPZ            Go back to toplevel
[2014]               ***********************************************************
[2015]               * At this point : if ERAM not exist - ERROR off else open
[2016]               * sequential file to load program to ERAM through VDP RAM
[2017]               ***********************************************************
[2018] 8C63 8E,80,84 OLDZ3  CZ   @RAMTOP
[2019] 8C66 6D,2D           BS   OLDER
[2020]               * Set up PAB for OPEN
[2021]               * File type : Sequential file,
[2022]               * Mode of operation : Input
[2023]               * Date type : internal
[2024]               * Record type : Variable length records
[2025]               * Logical record length : 254 maximum
[2026] 8C68 31,00,09        MOVE 9,G@PAB3,V@4(@PABPTR) Build the PAB          <<
       8C6B E0,04,04
       8C6E 8D,24
[2027] 8C70 BD,4A,70        DST  @HIVDP,@FAC       Compute the data buffer addre
[2028] 8C73 A7,4A,00        DSUB 253,@FAC
       8C76 FD
[2029] 8C77 BD,4C,4A        DST  @FAC,@AAA         Save it for later use in VGWI
[2030] 8C7A BD,E0,06        DST  @FAC,V@BUF(@PABPTR)
       8C7D 04,4A
[2031] 8C7F 06,97,6B        CALL CDSR              Call the device service routi
[2032] 8C82 57,94           BR   ERRZ2B            Return with ERROR indication
[2033]               *                              in COND
[2034]               * Start to read in file
[2035] 8C84 06,97,5E        CALL IOCALL            Read in the first record
[2036] 8C87 02              BYTE CZREAD          *
[2037]               * Check the control information
[2038] 8C88 D6,E0,09        CEQ  10,V@CNT(@PABPTR) * 10 bytes contr info
       8C8B 04,0A
[2039] 8C8D 4D,2D           BR   OLDER
[2040]               * >ABCD is the flag set at SAVE time indicating a program f
[2041] 8C8F D7,B0,4A        DCEQ >ABCD,V*FAC
       8C92 AB,CD
[2042] 8C94 4D,2D           BR   OLDER
[2043] 8C96 95,4A           DINCT @FAC
[2044] 8C98 BD,30,B0        DST  V*FAC,@STLN       Copy the new STLN
       8C9B 4A
[2045] 8C9C 95,4A           DINCT @FAC
[2046] 8C9E BD,32,B0        DST  V*FAC,@ENLN       ENLN too
       8CA1 4A
[2047] 8CA2 BD,02,32        DST  @ENLN,@MNUM       Test checksum
[2048] 8CA5 B9,02,30        DXOR @STLN,@MNUM
[2049] 8CA8 95,4A           DINCT @FAC
[2050] 8CAA D5,B0,4A        DCEQ @MNUM,V*FAC       Try PROTECTION option
       8CAD 02
[2051] 8CAE 6C,BD           BS   G8CBD
[2052] 8CB0 83,02           DNEG @MNUM
[2053] 8CB2 D5,B0,4A        DCEQ @MNUM,V*FAC       No, ERROR

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0036 
FLMGR-359
       8CB5 02
[2054] 8CB6 4D,2D           BR   OLDER
[2055] 8CB8 B6,45,80        OR   >80,@FLAG         Yes, set LIST/EDIT PROTECTION
[2056] 8CBB 4C,BF           BR   G8CBF
[2057] 8CBD 86,45    G8CBD  CLR  @FLAG             Otherwise clear protection fl
[2058] 8CBF 95,4A    G8CBF  DINCT @FAC
[2059]               * Check is there enough memory in ERAM
[2060] 8CC1 BD,02,B0        DST  V*FAC,@MNUM       Get the old top of memory out
       8CC4 4A
[2061] 8CC5 BD,A3,BC        DST  @MNUM,V@OLDTOP    For later use in RELOCA
       8CC8 02
[2062] 8CC9 A5,02,30        DSUB @STLN,@MNUM
[2063] 8CCC 91,02           DINC @MNUM             Total # of bytes in program
[2064] 8CCE BD,08,02        DST  @MNUM,@CCC1       For later use as the byte cou
[2065] 8CD1 A3,02,A0        DADD CPUBAS,@MNUM      Add the total # of bytes to C
       8CD4 40
[2066]               * Check if enough memory in ERAM
[2067] 8CD5 0A              GT                     Greater than >FFFF case
[2068] 8CD6 6D,2D           BS   OLDER
[2069] 8CD8 C5,02,80        DCH  @RAMTOP,@MNUM     Greater than >DFFF case
       8CDB 84
[2070] 8CDC 6D,2D           BS   OLDER
[2071]               * Move to ERAM starting from CPUBAS first,
[2072]               * then relocate according the new top of memory in ERAM
[2073] 8CDE BF,50,A0 OLZZ   DST  CPUBAS,@BBB       @BBB : Destination addr in
       8CE1 40
[2074]               *                                    ERAM FOR VGWITE
[2075] 8CE2 BD,0A,50        DST  @BBB,@STADDR      For later use as base of the
[2076]               *                      current program image in ERAM RELOCA
[2077]               *      DST  HIVDP,@AAA        @AAA has been set up before
[2078]               *      DSUB 253,@AAA          For copy start on VDP RAM
[2079]               * @CCC1 : Total # of bytes to move to ERAM, set up above
[2080] 8CE5 06,97,5E        CALL IOCALL            Read in the second record
[2081] 8CE8 02              BYTE CZREAD
[2082]               * Read in the file and each record
[2083]               * Should be a full (maximum length 254) record at this time
[2084]               * because program supposed to be bigger than 13.5K
[2085] 8CE9 D6,E0,09 G8CE9  CEQ  254,V@CNT(@PABPTR)
       8CEC 04,FE
[2086] 8CEE 4D,2D           BR   OLDER
[2087] 8CF0 BF,4E,00        DST  254,@CCC          @CCC : # of bytes to move
       8CF3 FE
[2088] 8CF4 0F,8A           XML  VGWITE            Move data from VDP to ERAM
[2089] 8CF6 A3,50,00        DADD 254,@BBB          Update the destination addres
       8CF9 FE
[2090]               *                              on ERAM
[2091] 8CFA A7,08,00        DSUB 254,@CCC1         # of bytes left to move
       8CFD FE
[2092] 8CFE 6D,16           BS   OLDZ9             No more bytes to move
[2093] 8D00 06,97,5E        CALL IOCALL            Read in the file and each rec
[2094] 8D03 02              BYTE CZREAD          * Copied into ERAM as it is rea
[2095] 8D04 CB,08,00        DCHE 254,@CCC1         Leave the last record alone
       8D07 FE
[2096] 8D08 6C,E9           BS   G8CE9
[2097]               * The record length should be the same as the # of bytes le
[2098]               * to move at this time
[2099] 8D0A D4,E0,09        CEQ  @CCC1+1,V@CNT(@PABPTR)
       8D0D 04,09
[2100] 8D0F 4D,2D           BR   OLDER
[2101] 8D11 BD,4E,08        DST  @CCC1,@CCC        Set up byte count for the las
[2102] 8D14 0F,8A           XML  VGWITE            Move data from VDP to ERAM
[2103] 8D16 06,97,5E OLDZ9  CALL IOCALL            Close the file
[2104] 8D19 01              BYTE CZCLOS
[2105] 8D1A BD,A3,BE        DST  @RAMTOP,V@NEWTOP  New top of memory

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0037 
FLMGR-359
       8D1D 80,84
[2106]               * V@OLDTOP : old top of memory, set up above
[2107]               * @STADDR  : base of current program image in ERAM, set abo
[2108] 8D1F 06,8D,36        CALL RELOCA            Relocate the program
[2109] 8D22 4C,5A           BR   OLDZ7             Go to set the RAMFRE and back
[2110]               *                              toplevel
[2111] 8D24 00,1C,00 PAB3   BYTE >00,>1C,>00,>00,>FE,>00,>00,>00,OFFSET
       8D27 00,FE,00
       8D2A 00,00,60
[2112]               * OLD error exit code, don't kill machine
[2113] 8D2D 06,60,14 OLDER  CALL INITPG            Initialize program space
[2114] 8D30 57,97           BR   ERRZ2             And take error exit
[2115] 8D32 06,60,22 LRTOPZ CALL KILSYM            Release string space/symbol t
[2116] 8D35 00              RTN
[2117]               ***********************************************************
[2118]               * RELOCATE THE PROGRAM IMAGE ACCORDING TO THE NEW TOP OF
[2119]               * MEMORY:
[2120]               *         STLN         : old STLN
[2121]               *         ENLN         : old ENLN
[2122]               *         V@OLDTOP     : old top of memory
[2123]               *         V@NEWTOP     : new top of memory
[2124]               *         @STADDR      : current base for the old image
[2125]               ***********************************************************
[2126] 8D36 BD,A3,B4 RELOCA DST  @PABPTR,V@SIZCCP  Save in temp.
       8D39 04
[2127] 8D3A BD,02,A3        DST  V@OLDTOP,@MNUM    Get the old top of memory
       8D3D BC
[2128] 8D3E BD,04,A3        DST  V@NEWTOP,@PABPTR  Get the new top of memory
       8D41 BE
[2129] 8D42 A5,32,02        DSUB @MNUM,@ENLN       Compute ENLN relative to top
[2130] 8D45 A5,30,02        DSUB @MNUM,@STLN       Compute STLN relative to top
[2131] 8D48 A5,0A,30        DSUB @STLN,@STADDR     Highest memory address used
[2132] 8D4B 87,02           DCLR @MNUM             Total # of bytes to be moved
[2133] 8D4D A5,02,30        DSUB @STLN,@MNUM       STLN = -(# bytes -1)
[2134] 8D50 91,02           DINC @MNUM             Take care of that one
[2135] 8D52 A1,32,04        DADD @PABPTR,@ENLN     Compute new address of ENLN
[2136] 8D55 A1,30,04        DADD @PABPTR,@STLN      and STLN
[2137]               * @PABPTR : destination address, @STADDR : source address
[2138] 8D58 BD,5C,02        DST  @MNUM,@ARG        @ARG   : byte count
[2139] 8D5B BD,00,0A        DST  @STADDR,@VAR0     @VAR0  : source addr for MVDN
[2140] 8D5E BD,10,06        DST  @CCPPTR,@VAR5     Save in temp (CCPPTR, VARY2 E
[2141] 8D61 BD,06,04        DST  @PABPTR,@VARY2    @VARY2 : destination addr for
[2142] 8D64 D5,A3,BE        DCEQ @RAMTOP,V@NEWTOP  Relocate the program
       8D67 80,84
[2143] 8D69 4D,6F           BR   G8D6F              in ERAM
[2144] 8D6B 0F,88           XML  MVDN              Move from lower memory to hig
[2145]               *                              memory one byte at a time
[2146] 8D6D 4D,7E           BR   G8D7E
[2147] 8D6F 87,A3,B6 G8D6F  DCLR V@SIZREC          Clear a temporary variable
[2148] 8D72 C1,A3,B6        DEX  @RAMTOP,V@SIZREC  Save the RAMTOP, also fake as
       8D75 80,84
[2149]               *                         if ERAM not exist for MVDN in thi
[2150] 8D77 0F,88           XML  MVDN              Move in VDP
[2151] 8D79 C1,A3,B6        DEX  @RAMTOP,V@SIZREC  Restore RAMTOP
       8D7C 80,84
[2152] 8D7E BD,06,10 G8D7E  DST  @VAR5,@CCPPTR     Restore back
[2153]               * Update line # links according to new size
[2154] 8D81 BD,02,A3        DST  V@OLDTOP,@MNUM    Old memory top
       8D84 BC
[2155] 8D85 A5,02,A3        DSUB V@NEWTOP,@MNUM    Stop if sizes are same
       8D88 BE
[2156] 8D89 6D,B3           BS   RELOZ1
[2157] 8D8B BD,0A,30        DST  @STLN,@STADDR     Start relocation at STLN
[2158] 8D8E C9,32,0A OLDZ2  DCHE @STADDR,@ENLN      and continue up to ENLN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0038 
FLMGR-359
[2159] 8D91 4D,B3           BR   RELOZ1
[2160] 8D93 95,0A           DINCT @STADDR          Skip the line #
[2161] 8D95 D4,A3,BE        CEQ  @RAMTOP,V@NEWTOP  If in ERAM
       8D98 80,84
[2162] 8D9A 4D,AB           BR   G8DAB
[2163] 8D9C 06,91,A4        CALL GRSUB2            Read the link out
[2164] 8D9F 0A              BYTE STADDR
[2165] 8DA0 A5,58,02        DSUB @MNUM,@EEE1       Update
[2166] 8DA3 06,60,36        CALL GWSUB             Write it back
[2167] 8DA6 0A,58,02        BYTE >0A,>58,>02     * STADDR,EEE1,2
[2168] 8DA9 4D,AF           BR   G8DAF
[2169] 8DAB A5,B0,0A G8DAB  DSUB @MNUM,V*STADDR    Upadate the link
       8DAE 02
[2170] 8DAF 95,0A    G8DAF  DINCT @STADDR          Skip the link, next line #
[2171] 8DB1 4D,8E           BR   OLDZ2             And continue until done
[2172] 8DB3 BD,04,A3 RELOZ1 DST  V@SIZCCP,@PABPTR  Restore from temp
       8DB6 B4
[2173] 8DB7 00              RTN
[2174]               ***********************************************************
[2175]               *                    SAVE STATEMENT
[2176]               * SAVE "NAME", MERGE : Save in crunched form in program
[2177]               *  into a file one line at at time with the line number.
[2178]               *  File opened with sequential accessed, variable-length
[2179]               *  records (161 max), display type & output mode, move one
[2180]               *  line number and one in text to the crunch buffer then
[2181]               *  write to the file one line at a time.
[2182]               * A normal SAVE : When ERAM not exist or the size of the
[2183]               *  program and line number table in ERAM can fit in VDP
[2184]               *  (can be moved into VDP from ERAM once), then the save
[2185]               *  statement saves a program image to an external device,
[2186]               *  including all the information the system needs for
[2187]               *  rebuilding the program image on a machine with a
[2188]               *  different memory size, also included is a checksum for
[2189]               *  rudimentary error checking and for PROTECTION VIOLATION
[2190]               * A sequential SAVE : Maximum-length records are performed
[2191]               *  to write the file and each record is copied into the VDP
[2192]               *  from ERAM before it is written.
[2193]               ***********************************************************
[2194] 8DB8 DA,45,80 SAVE   CLOG >80,@FLAG         * PROTECTION VIOLATION
[2195] 8DBB 57,DB           BR   ERRPV
[2196] 8DBD 06,92,35        CALL GPNAME            This will also close all file
[2197]               * Check SAVE "NAME", MERGE or SAVE "NAME", PROTECTED first
[2198] 8DC0 86,A3,B9        CLR  V@SAPROT          Clear "PROTECTED" flag
[2199] 8DC3 0F,79           XML  PGMCHR
[2200] 8DC5 8E,42           CZ   @CHAT             EOL?
[2201] 8DC7 6E,2B           BS   SAZ1              Yes, no need to check any opt
[2202] 8DC9 D6,42,B3        CEQ  COMMAZ,@CHAT      Has to be a comma here
[2203] 8DCC 41,09           BR   ERRSYN
[2204] 8DCE D7,B0,2C        DCEQ >C805,V*PGMPTR    Unquoted string with length 5
       8DD1 C8,05
[2205]               *                              has to be MERGE at this time
[2206] 8DD3 4D,F4           BR   G8DF4
[2207] 8DD5 D7,E0,02        DCEQ >4D45,V@2(@PGMPTR) "ME" of MErge
       8DD8 2C,4D,45
[2208]               * RXB PATCH CODE OPTION ADDED IV254 FOR SAVE 2015 *********
[2209]               * SAVE "DSK#.FILENAME",MERGE ! SAVE MERGE FORMAT
[2210]               * SAVE "DSK#.FILENAME",IV254 ! SAVE IV254 PROGRAM FORMAT
[2211]               * SAVE "DSK#.FILENAME" ! NORMAL PROGRAM FORMAT OR IV254
[2212]               *       BR   ERRSYN             If not : SYNTAX ERROR
[2213] 8DDB 5F,7C           BR    CIV254            CHECK FOR IV254 OPTION
[2214] 8DDD D7,E0,04        DCEQ >5247,V@4(@PGMPTR) "RG" of meRGe
       8DE0 2C,52,47
[2215] 8DE3 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2216] 8DE5 D6,E0,06        CEQ  >45,V@6(@PGMPTR)   "E" of mergE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0039 
FLMGR-359
       8DE8 2C,45
[2217] 8DEA 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2218] 8DEC 8E,E0,07        CZ   V@7(@PGMPTR)      Check for EOL
       8DEF 2C
[2219] 8DF0 41,09           BR   ERRSYN            Not EOL : SYNTAX ERROR
[2220] 8DF2 4F,76           BR   SAVMG             Go to handle this option
[2221]               * Has to be PROTECTED option here, crunched as unquoted str
[2222] 8DF4 D7,B0,2C G8DF4  DCEQ >C809,V*PGMPTR    Unquoted string with length 9
       8DF7 C8,09
[2223]               *                              has to be PROTECTED
[2224] 8DF9 41,09           BR   ERRSYN
[2225] 8DFB D7,E0,02        DCEQ >5052,V@2(@PGMPTR) "PR" of PRotected
       8DFE 2C,50,52
[2226] 8E01 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2227] 8E03 D7,E0,04        DCEQ >4F54,V@4(@PGMPTR) "OT" of prOTected
       8E06 2C,4F,54
[2228] 8E09 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2229] 8E0B D7,E0,06        DCEQ >4543,V@6(@PGMPTR) "EC" of protECted
       8E0E 2C,45,43
[2230] 8E11 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2231] 8E13 D7,E0,08        DCEQ >5445,V@8(@PGMPTR) "TE",of protecTEd
       8E16 2C,54,45
[2232] 8E19 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2233] 8E1B D6,E0,0A        CEQ  >44,V@10(@PGMPTR)  "D" of protecteD
       8E1E 2C,44
[2234] 8E20 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2235] 8E22 8E,E0,0B        CZ   V@11(@PGMPTR)     Check EOL
       8E25 2C
[2236] 8E26 41,09           BR   ERRSYN
[2237] 8E28 90,A3,B9        INC  V@SAPROT
[2238]               ***********************************************************
[2239] 8E2B 8E,80,84 SAZ1   CZ   @RAMTOP           If ERAM NOT present then
[2240] 8E2E 4E,42           BR   G8E42
[2241]               ***** CLEAR THE BREAKPOINT IN VDP ALONE TO SPEED UP *******
[2242] 8E30 BD,52,30        DST  @STLN,@FAC8       End of line # buffer
[2243] 8E33 B2,B0,52 G8E33  AND  >7F,V*FAC8        Clear the breakpoint
       8E36 7F
[2244] 8E37 A3,52,00        DADD 4,@FAC8           Move to the next one
       8E3A 04
[2245] 8E3B C5,52,32        DCH  @ENLN,@FAC8       Until done
[2246] 8E3E 4E,33           BR   G8E33
[2247] 8E40 4E,69           BR   VSAVZ
[2248] 8E42 06,A0,20 G8E42  CALL UBSUB             Clear the breakpoint in ERAM
[2249] 8E45 BD,02,80        DST  @RAMTOP,@MNUM     Top of memory in ERAM
       8E48 84
[2250] 8E49 A5,02,30        DSUB @STLN,@MNUM
[2251] 8E4C 91,02           DINC @MNUM             # of bytes total in ERAM
[2252] 8E4E BD,00,70        DST  @HIVDP,@VAR0      Top of memory in VDP
[2253] 8E51 A5,00,02        DSUB @MNUM,@VAR0
[2254] 8E54 91,00           DINC @VAR0
[2255]               * Check is there enough memory in VDP to move the program
[2256]               *  text and line number table from ERAM to VDP
[2257] 8E56 0A              GT                  Not enough memory in VDP for sur
[2258] 8E57 4E,B7           BR   GSAVE
[2259] 8E59 BF,10,0A        DST  VRAMVS+64+256,@VAR5 * 64 bytes are for safety b
       8E5C 98
[2260]                
[2261]               * DSR routine give file error when loading a program which
[2262]               *  VDP maximum size and was saved from VDP to be a program
[2263]               *  on disk when ERAM not exist. In order to fix this proble
[2264]               *  restrict the program memory to be 256 bytes less then th
[2265]               *  real space in VDP when ERAM not exist.
[2266] 8E5D C9,00,10        DCHE @VAR5,@VAR0       Not enough memory in VDP, do
[2267]               *                              sequential file save

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0040 
FLMGR-359
[2268] 8E60 4E,B7           BR   GSAVE
[2269] 8E62 A7,10,00        DSUB 10,@VAR5        * 10 bytes for control informat
       8E65 0A
[2270] 8E66 06,8F,4A        CALL GVMOV             Enough memory in VDP, move it
[2271]               *                             over and do the normal save l
[2272]               **************** Without ERAM, or after GVMOV *************
[2273]               **************** do the normal save           *************
[2274] 8E69 BD,0A,40 VSAVZ  DST  @FREPTR,@STADDR   Store additional control info
[2275] 8E6C 93,0A           DDEC @STADDR           Back up some more for 2 byte
[2276] 8E6E BD,B0,0A        DST  @>8370,V*STADDR   First current top of memory
       8E71 70
[2277] 8E72 97,0A           DDECT @STADDR
[2278] 8E74 BD,B0,0A        DST  @STLN,V*STADDR    Then STLN
       8E77 30
[2279] 8E78 97,0A           DDECT @STADDR
[2280] 8E7A BD,B0,0A        DST  @ENLN,V*STADDR    Then ENLN
       8E7D 32
[2281] 8E7E 97,0A           DDECT @STADDR          Then
[2282] 8E80 BD,B0,0A        DST  @STLN,V*STADDR
       8E83 30
[2283] 8E84 B9,B0,0A        DXOR @ENLN,V*STADDR    STLN XORed with ENLN
       8E87 32
[2284] 8E88 D6,A3,B9        CEQ  1,V@SAPROT        Check is there PROTECTED opti
       8E8B 01
[2285] 8E8C 4E,91           BR   G8E91
[2286] 8E8E 83,B0,0A        DNEG V*STADDR          Negate the CHECKSUM to indica
[2287]               *                             LIST/EDIT protection
[2288] 8E91 BD,E0,06 G8E91  DST  @STADDR,V@BUF(@PABPTR)  Save start address in P
       8E94 04,0A
[2289] 8E96 93,0A           DDEC @STADDR
[2290] 8E98 BD,E0,0A        DST  @>8370,V@RNM(@PABPTR)   Compute # of bytes used
       8E9B 04,70
[2291] 8E9D A5,E0,0A        DSUB @STADDR,V@RNM(@PABPTR)   and store that in PAB
       8EA0 04,0A
[2292] 8EA2 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2293] 8EA5 6E,AD           BS   G8EAD
[2294] 8EA7 BD,30,0C        DST  @BBB1,@STLN       Restore the original STLN, EN
[2295] 8EAA BD,32,08        DST  @CCC1,@ENLN        which points to ERAM
[2296] 8EAD 06,97,5E G8EAD  CALL IOCALL            Call Device Service Routine f
[2297] 8EB0 06              BYTE CZSAVE          * SAVE operation
[2298] 8EB1 06,60,22 LRTOPL CALL KILSYM            Release string space/symbol t
[2299] 8EB4 05,60,12        B    TOPL15            Go back to toplevel
[2300]               ***********************************************************
[2301]               * Open the sequential file, set the PAB
[2302]               * File type             : sequential file
[2303]               * Mode of operation     : output
[2304]               * Data type             : internal
[2305]               * Record type           : variable length records
[2306]               * Logical record length : 254 maximum
[2307] 8EB7 31,00,09 GSAVE  MOVE 9,G@PAB3,V@4(@PABPTR) Build the PAB
       8EBA E0,04,04
       8EBD 8D,24
[2308] 8EBF 96,E0,05        DECT V@FLG(@PABPTR)    Put in the correct I/O mode :
       8EC2 04
[2309]               * Compute the data buffer address
[2310] 8EC3 BD,4A,70        DST  @>8370,@FAC
[2311] 8EC6 A7,4A,00        DSUB 253,@FAC
       8EC9 FD
[2312] 8ECA BD,E0,06        DST  @FAC,V@BUF(@PABPTR)
       8ECD 04,4A
[2313] 8ECF BD,58,4A        DST  @FAC,@EEE1     Save it for later use in GVWITE
[2314] 8ED2 06,97,6B        CALL CDSR           Call device service routine to o
[2315] 8ED5 57,94           BR   ERRZ2B         Return with ERROR indication in
[2316]               *                          Put 8 bytes control info at the

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0041 
FLMGR-359
[2317]               *                          beginning of the data buffer
[2318] 8ED7 BF,B0,4A        DST  >ABCD,V*FAC       >ABCD indentifies a program f
       8EDA AB,CD
[2319] 8EDC 95,4A           DINCT @FAC              when doing LOAD later
[2320] 8EDE BD,B0,4A        DST  @STLN,V*FAC       Save STLN in control info
       8EE1 30
[2321] 8EE2 95,4A           DINCT @FAC
[2322] 8EE4 BD,B0,4A        DST  @ENLN,V*FAC       ENLN too
       8EE7 32
[2323] 8EE8 95,4A           DINCT @FAC
[2324] 8EEA BD,B0,4A        DST  @STLN,V*FAC
       8EED 30
[2325] 8EEE B9,B0,4A        DXOR @ENLN,V*FAC       Save the checksum
       8EF1 32
[2326] 8EF2 D6,A3,B9        CEQ  1,V@SAPROT        Check is there PROTECTED opti
       8EF5 01
[2327] 8EF6 4E,FB           BR   G8EFB
[2328] 8EF8 83,B0,4A        DNEG V*FAC             Negate the CHECKSUM to indica
[2329]               *                              the LIST/EDIT protection
[2330] 8EFB 95,4A    G8EFB  DINCT @FAC
[2331] 8EFD BD,B0,4A        DST  @RAMTOP,V*FAC     Save the top of memory info
       8F00 80,84
[2332] 8F02 BE,E0,09        ST   10,V@CNT(@PABPTR) Set the caracter count in PAB
       8F05 04,0A
[2333] 8F07 06,97,5E        CALL IOCALL            Call device service routine
[2334] 8F0A 03              BYTE CZWRIT          * With I/O opcode : write, to s
[2335]               *                       the control info for the first reco
[2336]               * Now start to use maximum-length record to write the file
[2337]               * and each record is copied into the VDP from ERAM bofore i
[2338]               * is written
[2339] 8F0B BD,54,30        DST  @STLN,@DDD1       Starting address on ERAM
[2340]               *      DST  @>8370,@EEE1      @EEE1 has been set up before
[2341]               *      DST  253,@EEE1         Starting address of the data
[2342]               *                              buffer on VDP
[2343] 8F0E BD,08,80        DST  @RAMTOP,@CCC1
       8F11 84
[2344] 8F12 A5,08,30        DSUB @STLN,@CCC1
[2345] 8F15 91,08           DINC @CCC1
[2346] 8F17 BE,E0,09        ST   254,V@CNT(@PABPTR) Set the character count of P
       8F1A 04,FE
[2347] 8F1C BF,56,00 G8F1C  DST  254,@FFF1         @FFF1 byte count
       8F1F FE
[2348] 8F20 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[2349] 8F22 06,97,5E        CALL IOCALL            Call device service routine
[2350] 8F25 03              BYTE CZWRIT
[2351] 8F26 A3,54,00        DADD 254,@DDD1         Update the source addr on ERA
       8F29 FE
[2352] 8F2A A7,08,00        DSUB 254,@CCC1         # of bytes left to move
       8F2D FE
[2353] 8F2E 6F,44           BS   GSAV1             No more bytes to save
[2354] 8F30 CB,08,00        DCHE 254,@CCC1         Leave the last record alone
       8F33 FE
[2355] 8F34 6F,1C           BS   G8F1C
[2356]               * Move the last @CCC1 bytes from ERAM to VDP
[2357] 8F36 BD,56,08        DST  @CCC1,@FFF1       @FFF1 : Byte count
[2358] 8F39 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2359] 8F3B BC,E0,09        ST   @CCC1+1,V@CNT(@PABPTR) Update the character cou
       8F3E 04,09
[2360]               *                                   in PAB
[2361] 8F40 06,97,5E        CALL IOCALL            Call device service routine
[2362] 8F43 03              BYTE CZWRIT
[2363] 8F44 06,97,5E GSAV1  CALL IOCALL
[2364] 8F47 01              BYTE CZCLOS          * Close the file
[2365] 8F48 4E,B1           BR   LRTOPL            Continue

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0042 
FLMGR-359
[2366]               ***********************************************************
[2367]               * Move the program text & line # table to VDP, and relocate
[2368] 8F4A BD,0C,30 GVMOV  DST  @STLN,@BBB1       Save STLN, ENLN for later use
[2369] 8F4D BD,08,32        DST  @ENLN,@CCC1
[2370] 8F50 BD,54,30        DST  @STLN,@DDD1       Source addr on ERAM
[2371] 8F53 BD,58,10        DST  @VAR5,@EEE1       Destination addr on VDP
[2372] 8F56 BD,0A,58        DST  @EEE1,@STADDR     Use later for RELOCA
[2373] 8F59 BD,56,80        DST  @RAMTOP,@FFF1
       8F5C 84
[2374] 8F5D A5,56,30        DSUB @STLN,@FFF1       # of bytes to move
[2375] 8F60 91,56           DINC @FFF1             @FFF1 : byte count for GVWITE
[2376] 8F62 0F,8B           XML  GVWITE            Move from ERAM to VDP
[2377] 8F64 BD,A3,BC        DST  @RAMTOP,V@OLDTOP  Set up @RAMTOP for old top
       8F67 80,84
[2378]               *                             of memory
[2379] 8F69 BD,A3,BE        DST  @>8370,V@NEWTOP   Set up @>8370 for new top
       8F6C 70
[2380]               *                             of memory
[2381] 8F6D 06,8D,36        CALL RELOCA            Relocate the program
[2382] 8F70 BD,40,30        DST  @STLN,@FREPTR     Set up @FREPTR
[2383] 8F73 93,40           DDEC @FREPTR
[2384] 8F75 00              RTN
[2385]               ***********************************************************
[2386]               * Save the crunched form of a program into a file.
[2387]               * Move the line number and text to the crunch buffer, then
[2388]               * write to the file one line at a time.
[2389]               ***********************************************************
[2390]               * Open the file with:
[2391]               *  I/O opcode            : OPEN
[2392]               *  File type             : SEQUENTIAL file
[2393]               *  Mode of operation     : OUTPUT
[2394]               *  Data type             : DISPLAY type data
[2395]               *  Record type           : VARIABLE LENGTH records
[2396]               *  Data buffer address   : Crunch buffer address
[2397]               *  Logical record length : 163 (length of curnch buffer + 2
[2398]               *                                bytes for line #) maximum
[2399] 8F76 31,00,09 SAVMG  MOVE 9,G@PAB1,V@4(@PABPTR) Build PAB
       8F79 E0,04,04
       8F7C 8F,F9
[2400] 8F7E 06,97,65        CALL IOCLZ1         Call the DSR routine to open fil
[2401] 8F81 BD,50,32        DST  @ENLN,@FAC6    Start from the first line #
[2402] 8F84 A7,50,00        DSUB 3,@FAC6        @FAC6 now points to the 1st line
       8F87 03
[2403]               *                          Write to the file from crunch bu
[2404]               *                           one line at a time
[2405] 8F88 86,00    G8F88  CLR  @VAR0             Make it a two byte later
[2406] 8F8A 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2407] 8F8D 6F,B6           BS   G8FB6
[2408] 8F8F BD,54,50        DST  @FAC6,@DDD1       Write the 4 bytes (line # and
[2409]               *                              line pointer) from ERAM to
[2410]               *                              crunch buffer
[2411]               *                             @DDD1 : Source address on ERA
[2412] 8F92 BF,58,08        DST  CRNBUF,@EEE1      @EEE1 : Destination address
       8F95 20
[2413]               *                                      on VDP
[2414] 8F96 BF,56,00        DST  4,@FFF1           @FFF1 : byte count
       8F99 04
[2415] 8F9A 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2416] 8F9C BD,54,A8        DST  V@CRNBUF+2,@DDD1  Line pointer now points to
       8F9F 22
[2417]               *                              length byte
[2418] 8FA0 93,54           DDEC @DDD1             Get the length of this line
[2419]               *                             @DDD1 : Source address on ERA
[2420] 8FA2 91,56           DINC @FFF1             @FFF1 : Byte count, coming ba

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0043 
FLMGR-359
[2421]               *                                     from GVWITE above, =0
[2422] 8FA4 0F,8C           XML  GREAD1            Read the length byte from ERA
[2423] 8FA6 BC,01,58        ST   @EEE1,@VAR0+1     @EEE1 : Destination addr on C
[2424] 8FA9 BF,58,08        DST  CRNBUF+2,@EEE1    Write the text from ERAM to 3
       8FAC 22
[2425]               *                             byte of crunch buffer
[2426]               *                             @EEE1 : Destination addr on V
[2427]               *                             @DDD1 : Source addr on ERAM
[2428] 8FAD 91,54           DINC @DDD1             Back to point to the text
[2429] 8FAF BD,56,00        DST  @VAR0,@FFF1       @FFF1 : Byte count
[2430] 8FB2 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2431] 8FB4 4F,CD           BR   G8FCD             ERAM not exist : line # table
[2432]               *                              and text in VDP
[2433] 8FB6 BD,A8,20 G8FB6  DST  V*FAC6,V@CRNBUF   PUT THE LINE # IN
       8FB9 B0,50
[2434] 8FBB BD,4C,E0        DST  V@2(@FAC6),@FAC2  Get the line pointer out
       8FBE 02,50
[2435] 8FC0 93,4C           DDEC @FAC2             Line pointer now points to th
[2436]               *                              length byte
[2437] 8FC2 BC,01,B0        ST   V*FAC2,@VAR0+1    Get the length out
       8FC5 4C
[2438]               * Move the text into the crunch buffer
[2439] 8FC6 34,00,A8        MOVE @VAR0,V@1(@FAC2),V@CRNBUF+2
       8FC9 22,E0,01
       8FCC 4C
[2440] 8FCD B2,A8,20 G8FCD  AND  >7F,V@CRNBUF      Reset possible breakpoint
       8FD0 7F
[2441] 8FD1 95,00           DINCT @VAR0    * Total length=text length+line # len
[2442] 8FD3 BC,E0,09        ST   @VAR0+1,V@CNT(@PABPTR) Store in the cahracter c
       8FD6 04,01
[2443] 8FD8 06,97,5E        CALL IOCALL            Call the device service routi
[2444] 8FDB 03              BYTE CZWRIT          * Write
[2445] 8FDC A7,50,00        DSUB 4,@FAC6           Go to the next line #
       8FDF 04
[2446] 8FE0 C9,50,30        DCHE @STLN,@FAC6       Finish moving all
[2447] 8FE3 6F,88           BS   G8F88
[2448] 8FE5 BF,A8,20        DST  >FFFF,V@CRNBUF    Set up a EOF for the last rec
       8FE8 FF,FF
[2449] 8FEA BE,E0,09        ST   2,V@CNT(@PABPTR)  Only write this 2 bytes
       8FED 04,02
[2450] 8FEF 06,97,5E        CALL IOCALL            Call the device service routi
[2451] 8FF2 03              BYTE CZWRIT          * Write
[2452] 8FF3 06,97,5E        CALL IOCALL            Call the device service routi
[2453] 8FF6 01              BYTE CZCLOS          * Close the file
[2454] 8FF7 4E,B1           BR   LRTOPL            Go back to top level
[2455] 8FF9 00,12,08 PAB1   BYTE >00,>12,>08,>20,>A3,>00,>00,>00,>60
       8FFC 20,A3,00
       8FFF 00,00,60
[2456]               *           >0820 = CRNBUF
[2457]               *           >A3   = 163
[2458]               *           >60   = OFFSET
[2459]               ***********************************************************
[2460]               *                   MERGE ROUTINE
[2461]               * MERGE load a file which is in crunched program form into
[2462]               * the CRNBUF one record (one in) at a time then take the
[2463]               * line # out in FAC, text length into @CHAT, and edit it
[2464]               * into the program. Identify EOF by the last record which
[2465]               * is set up at SAVE time.
[2466]               ***********************************************************
[2467] 9002 06,92,35 MERGE  CALL GPNAME            Close all file, set up PAB
[2468] 9005 DA,45,80        CLOG >80,@FLAG         Check PROTECTION VIOLATION
[2469] 9008 57,DB           BR   ERRPV
[2470]               * To fix the bug #06 in MERGE
[2471] 900A 0F,79           XML  PGMCHR            Check EOL

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0044 
FLMGR-359
[2472] 900C 8E,42           CZ   @CHAT
[2473] 900E 41,09           BR   ERRSYN            Not EOL : SYNTAX ERROR
[2474]               * Open the file with
[2475]               *  I/O opcode            : OPEN
[2476]               *  File type             : SEQUENTIAL file
[2477]               *  Mode of operation     : INPUT
[2478]               *  Data type             : DISPLAY type data
[2479]               *  Record type           : VARIABLE LENGTH records
[2480]               *  Data buffer address   : crunch address
[2481]               *  Logical record length : 163 maximum
[2482] 9010 31,00,09        MOVE 9,G@PAB1,V@4(@PABPTR)  Set up PAB
       9013 E0,04,04
       9016 8F,F9
[2483] 9018 94,E0,05        INCT V@FLG(@PABPTR)    Put in correct I/O mode : >14
       901B 04
[2484] 901C 06,97,65        CALL IOCLZ1            Call the device service routi
[2485]               *                              to open the file
[2486] 901F 06,97,5E        CALL IOCALL            Call the device service routi
[2487] 9022 02              BYTE CZREAD          *  to read
[2488] 9023 D7,A8,20        DCEQ >FFFF,V@CRNBUF    If 1st rec is EOF
       9026 FF,FF
[2489] 9028 77,94           BS   ERRZ2B
[2490] 902A 87,80,D6 G902A  DCLR @>83D6            Read in one line and edit it
[2491]               *                              program
[2492] 902D BC,42,E0        ST   V@CNT(@PABPTR),@CHAT Length of this record
       9030 09,04
[2493] 9032 96,42           DECT @CHAT             Text length = total length-2
[2494]               *                                          (line # length)
[2495]               *                              Put it in @CHAT for EDITLN
[2496] 9034 BD,4A,A8        DST  V@CRNBUF,@FAC     Put the line # in @FAC for ED
       9037 20
[2497] 9038 86,56           CLR  @FAC12            Make it a double byte
[2498] 903A BC,57,42        ST   @CHAT,@FAC13
[2499]               * Move the text up 2 bytes
[2500] 903D 34,56,A8        MOVE @FAC12,V@CRNBUF+2,V@CRNBUF
       9040 20,A8,22
[2501] 9043 BD,A3,9E        DST  @PABPTR,V@MRGPAB  SAVE PAB POINTER
       9046 04
[2502] 9047 06,60,32        CALL EDITLN            EDIT IT TO THE PROGRAM
[2503] 904A 87,04           DCLR @PABPTR           Clear temporary PAB pointer
[2504] 904C C1,04,A3        DEX  V@MRGPAB,@PABPTR  Restore old PAB pointer
       904F 9E
[2505] 9050 06,97,5E        CALL IOCALL            CALL THE DEVICE SERVICE ROUTI
[2506] 9053 02              BYTE CZREAD          *  read another record or anoth
[2507]               *                              line
[2508] 9054 D7,A8,20        DCEQ >FFFF,V@CRNBUF    End of EOF
       9057 FF,FF
[2509] 9059 50,2A           BR   G902A
[2510]               * Double check EOF record
[2511] 905B D6,E0,09 MERGZ1 CEQ  2,V@CNT(@PABPTR)  I/O ERROR
       905E 04,02
[2512] 9060 57,94           BR   ERRZ2B
[2513] 9062 06,97,5E        CALL IOCALL            Call the device service routi
[2514] 9065 01              BYTE CZCLOS          *  close the file
[2515] 9066 4E,B1           BR   LRTOPL            Go back to top level
[2516]               ***********************************************************
[2517]               *                  LIST ROUTINE
[2518]               * List lists a readable copy of the current program imnage
[2519]               * to the specified device. In case no device is specified,
[2520]               * the listing is copied to the screen.
[2521]               *  This routine uses the fact that ERRZZ returns to the
[2522]               * caller if the call has been issued in EDIT which will
[2523]               * reinitiate the variable stuff.
[2524]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0045 
FLMGR-359
[2525] 9068 DA,45,80 LIST   CLOG >80,@FLAG         PROTECTION VILOATION ERROR  <
[2526] 906B 57,DB           BR   ERRPV                                         <
[2527] 906D 87,14           DCLR @CURLIN           Create some kind of control <
[2528] 906F 87,0E           DCLR @CURINC            for defaults               <
[2529] 9071 BE,08,2D        ST   MINUS,@VARC       Select "-" as separator     <
[2530]               * GKXB GKLIST label
[2531] 9074 06,7A,06        CALL GTLIST            GKXB pick up length
[2532]               * If either CURLIN or CURINC is non-zero, use it
[2533]               * For zero values replace the default (ENLN-3, STLN)
[2534] 9077 8F,14           DCZ  @CURLIN
[2535] 9079 50,94           BR   G9094
[2536] 907B BD,54,32        DST  @ENLN,@DDD1       Get the first lines line #
[2537] 907E A7,54,00        DSUB 3,@DDD1           DDD1 : Source address on ERAM
       9081 03
[2538] 9082 06,91,BC        CALL GRSUB3            Read the line # from ERAM/VDP
[2539] 9085 54              BYTE DDD1            * @DDD1 : Source address on ERA
[2540]               *                             Reset possible breakpoint too
[2541] 9086 BD,14,58        DST @EEE1,@CURLIN      Use standard default
[2542] 9089 8F,0E           DCZ @CURINC
[2543] 908B 50,94           BR  G9094
[2544] 908D 06,91,BC LISTZ0 CALL GRSUB3            Read last line # from ERAM/VD
[2545] 9090 30              BYTE STLN           *  @STLN : Source address on ERA
[2546]               *                             Reset possible breakpoint too
[2547] 9091 BD,0E,58        DST  @EEE1,@CURINC     @EEE1 : Destination address o
[2548]               *                             Also default for end line
[2549]               * Now first evaluate what we've got in CURLIN
[2550] 9094 8F,0E    G9094  DCZ  @CURINC           Check for combination xxx-
[2551] 9096 50,A6           BR   G90A6
[2552] 9098 93,20    G9098  DDEC @VARW             Backup to the separation mark
[2553] 909A D6,B0,20        CEQ  SPACE+OFFSET,V*VARW
       909D 80
[2554] 909E 70,98           BS   G9098
[2555] 90A0 D6,B0,20        CEQ  MINUS+OFFSET,V*VARW Select last
       90A3 8D
[2556] 90A4 70,8D           BS   LISTZ0
[2557] 90A6 C9,0E,14 G90A6  DCHE @CURLIN,@CURINC   If something like LIST 15-11
[2558] 90A9 70,AE           BS   G90AE
[2559] 90AB BD,0E,14        DST  @CURLIN,@CURINC   Replace byt LIST 15-15
[2560] 90AE BD,4A,14 G90AE  DST  @CURLIN,@FAC      Prepare for line # search
[2561] 90B1 0F,7E           XML  SPEED             Search the line number table
[2562] 90B3 03              BYTE SEETWO
[2563] 90B4 BD,14,2E        DST  @EXTRAM,@CURLIN   Get first real line # in CURL
[2564] 90B7 BD,4A,0E        DST  @CURINC,@FAC
[2565] 90BA 0F,7E           XML  SPEED
[2566] 90BC 03              BYTE SEETWO          * Evaluate second line #
[2567] 90BD 06,91,BC        CALL GRSUB3            Read 2 bytes of data from ERA
[2568] 90C0 2E              BYTE EXTRAM          * @EXTRAM : Source addr on ERAM
[2569]               *                             Reset possible breakpoint too
[2570] 90C1 C5,58,0E        DCH  @CURINC,@EEE1
[2571] 90C4 50,CA           BR   G90CA
[2572] 90C6 A3,2E,00        DADD 4,@EXTRAM         Else take next lower line
       90C9 04
[2573] 90CA BD,0E,2E G90CA  DST  @EXTRAM,@CURINC   Which could be equal to CURLI
[2574] 90CD BD,2E,14        DST  @CURLIN,@EXTRAM   For use below by LIST
[2575] 90D0 93,2C           DDEC @PGMPTR           Backup to last CHAT
[2576] 90D2 0F,79           XML  PGMCHR            Retrieve last CHAT
[2577] 90D4 8E,42           CZ   @CHAT             Device name available
[2578] 90D6 71,32           BS   G9132
[2579] 90D8 06,81,F4        CALL CLSALL            Close all files that are open
[2580] 90DB BF,6E,09        DST  VRAMVS,@VSPTR     Re-initialize the V-stack
       90DE 58
[2581] 90DF BD,24,6E        DST  @VSPTR,@STVSPT    And it's base
[2582] 90E2 0F,79           XML  PGMCHR            Get name length in CHAT
[2583] 90E4 BF,04,09        DST  VRAMVS+16,@PABPTR Get entrypoint in PAB

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0046 
FLMGR-359
       90E7 68
[2584] 90E8 86,17           CLR  @DSRFLG           Indicate device I/O
[2585] 90EA 31,00,09        MOVE 9,G@PAB,V@4(@PABPTR)
       90ED E0,04,04
       90F0 91,70
[2586] 90F2 BF,08,09        DST  VRAMVS+16+NLEN,@CCPADR Select start address
       90F5 75
[2587]               *                                   for copy
[2588]               * GKXB GTLENGTH label
[2589] 90F6 06,97,ED        CALL GTLENG            GKXB Set length in PAB
[2590] 90F9 90,4C           INC  @FAC2             Plus length byte
[2591] 90FB BC,B0,08 LISTZ1 ST   @CHAT,V*CCPADR    Copy the bytes one by one
       90FE 42
[2592] 90FF 0F,79           XML  PGMCHR            Get next character
[2593] 9101 91,08           DINC @CCPADR           CCPADR ends up with highest a
[2594] 9103 92,4C           DEC  @FAC2             Count total # of characters
[2595] 9105 50,FB           BR   LISTZ1
[2596] 9107 06,97,65        CALL IOCLZ1            Preform OPEN on DSR
[2597] 910A 86,4A           CLR  @FAC              Create double byte PAB length
[2598] 910C BC,07,E0        ST   V@LEN(@PABPTR),@RECLEN Get record length
       910F 08,04
[2599] 9111 BC,4B,07        ST   @RECLEN,@FAC1     Get highest address used
[2600] 9114 A1,4A,08        DADD @CCPADR,@FAC      Compute record length
[2601] 9117 BD,E0,06        DST  @CCPADR,V@BUF(@PABPTR) Store it
       911A 04,08
[2602] 911C 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2603] 911F 71,28           BS   G9128
[2604] 9121 C5,4A,70        DCH  @>8370,@FAC       Compare with top of
[2605]               *                    VDP : if higher then 'not enough room'
[2606] 9124 77,BB           BS   ERRIO
[2607] 9126 51,2D           BR   G912D
[2608] 9128 C5,4A,30 G9128  DCH  @STLN,@FAC        Not enough room
[2609] 912B 77,BB           BS   ERRIO
[2610] 912D BE,06,01 G912D  ST   1,@CCPPTR         Clear first line in output
[2611] 9130 51,38           BR   G9138
[2612] 9132 BE,7F,1F G9132  ST   VWIDTH+3,@XPT     For common code usage
[2613] 9135 06,97,3F        CALL INITKB            Reset current record length
[2614] 9138 8E,80,84 G9138  CZ   @RAMTOP           If ERAM exist then
[2615] 913B 71,40           BS   G9140
[2616] 913D 06,91,79        CALL GRMLST            Fake it : move each line to t
[2617]               *                              CRUNCH buffer form ERAM
[2618] 9140 06,6A,74 G9140  CALL LLIST             List the current line
[2619] 9143 03              SCAN                   Test for a break key
[2620] 9144 51,4E           BR   LISTZ3            No key
[2621] 9146 D6,75,02        CEQ  BREAK,@RKEY
[2622] 9149 71,5F           BS   LISTZ4
[2623] 914B 03       LISTZ5 SCAN
[2624] 914C 51,4B           BR   LISTZ5
[2625] 914E 8E,80,84 LISTZ3 CZ   @RAMTOP           If ERAM exists
[2626] 9151 71,56           BS   G9156
[2627] 9153 BD,2E,58        DST  @FAC14,@EXTRAM    Restore the @EXTRAM
[2628] 9156 A7,2E,00 G9156  DSUB 4,@EXTRAM         Pointer to next line
       9159 04
[2629] 915A C5,0E,2E        DCH  @EXTRAM,@CURINC   Display all lines in range
[2630] 915D 51,38           BR   G9138
[2631] 915F 8E,17    LISTZ4 CZ   @DSRFLG           Device I/O -> output last rec
[2632] 9161 51,6D           BR   G916D
[2633] 9163 06,96,A5        CALL OUTREC            Output the last record
[2634] 9166 06,97,5E        CALL IOCALL            Close the device properly
[2635] 9169 01              BYTE CZCLOS
[2636] 916A 05,60,1A        B    TOPL10
[2637] 916D 05,60,12 G916D  B    TOPL15            Restart the variable too
[2638]               * PAB image used in LIST function
[2639] 9170 00,12,00 PAB    BYTE 0,>12,0,0,0,0,0,0,OFFSET

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0047 
FLMGR-359
       9173 00,00,00
       9176 00,00,60
[2640]               * Move each line in ERAM to CRNBUF area, put line number in
[2641]               * (CRNBUF), put CRNBUF+4 in (CRNBUF+2) which is the line
[2642]               * pointer field, put the text itself from ERAM to (CRNBUF+4
[2643]               * before call LLIST, trick it by moving CRNBUF to @EXTRAM
[2644] 9179 06,91,BC GRMLST CALL GRSUB3            Get line # from ERAM(use GREA
[2645] 917C 2E              BYTE EXTRAM          * @EXTRAM : Source address on E
[2646]               *                             Reset possible breakpoint too
[2647] 917D BD,A8,20        DST  @EEE1,V@CRNBUF    Put it in CRNBUF
       9180 58
[2648] 9181 BF,A8,22        DST  CRNBUF+4,V@CRNBUF+2 Put CRNBUF+4 into
       9184 08,24
[2649]               *                              the line pointer field
[2650] 9186 95,54           DINCT @DDD1            Get the pointer to the text
[2651]               *                              from GRAM
[2652] 9188 06,91,AA        CALL GRSUB4            Read the line pointer in (use
[2653]               *                              GREAD1)
[2654] 918B 93,58           DDEC @EEE1             Get the ptr to the length byt
[2655] 918D 06,91,A4        CALL GRSUB2            Read th length from ERAM, use
[2656] 9190 58              BYTE EEE1           *   GREAD1, @EEE1 : Source addre
[2657]               *                               on ERAM
[2658] 9191 BC,57,58        ST   @EEE1,@FFF1+1     Use the length as byte count
[2659]               *                             to move the text from ERAM to
[2660]               *                             VDP CRNBUF+4 area
[2661] 9194 BF,58,08        DST  CRNBUF+4,@EEE1    EEE1 : Destination address on
       9197 24
[2662] 9198 91,54           DINC @DDD1             DDD1 : Source address on ERAM
[2663] 919A 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[2664] 919C BD,58,2E        DST  @EXTRAM,@FAC14    Save for later use
[2665] 919F BF,2E,08        DST  CRNBUF,@EXTRAM    Fake it
       91A2 20
[2666] 91A3 00              RTN
[2667]               * SUBROUTINE TO READ 2 BYTES OF DATA FROM ERAM OR VDP WITH
[2668]               * THE OPTION TO RESET THE POSSIBLE BREAKPOINT
[2669] 91A4 88,56    GRSUB2 FETCH @FFF1            Fetch the source address on
[2670] 91A6 BD,54,90        DST  *FFF1,@DDD1        ERAM or VDP
       91A9 56
[2671]                
[2672]               *                             @DDD1 : Source addr  on ERAM
[2673]               *                             or VDP
[2674] 91AA 8E,80,84 GRSUB4 CZ   @RAMTOP           If ERAM exists
[2675] 91AD 71,B7           BS   G91B7
[2676] 91AF BF,56,00        DST  2,@FFF1           @FFF1 : Byte count
       91B2 02
[2677] 91B3 0F,8C           XML  GREAD1            Read data from ERAM to CPU
[2678] 91B5 51,BB           BR   G91BB
[2679] 91B7 BD,58,B0 G91B7  DST  V*DDD1,@EEE1      Read data from VDP to CPU
       91BA 54
[2680] 91BB 00       G91BB  RTN
[2681] 91BC 88,56    GRSUB3 FETCH @FFF1            Fetch the source addr on ERAM
[2682] 91BE BD,54,90        DST  *FFF1,@DDD1        or VDP
       91C1 56
[2683]               *                             @DDD1 : Source addr on ERAM/V
[2684] 91C2 06,91,AA        CALL GRSUB4            Do the actual read
[2685] 91C5 B3,58,7F        DAND >7FFF,@EEE1       Reset possible breakpoint
       91C8 FF
[2686] 91C9 00              RTN
[2687]               *********** REC ROUTINE ***********************************
[2688]               * REC(X) returns the current record to which file X is
[2689]               *  positioned.
[2690] 91CA BD,5C,04 SUBREC DST  @PABPTR,@ARG      Save the current PAB & set ne
[2691] 91CD 06,92,1E        CALL SUBEOF            Try to find the correct PAB
[2692] 91D0 C1,5C,04        DEX  @PABPTR,@ARG      @ARG : new PAB

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0048 
FLMGR-359
[2693]               *                             @PABPTR : restore current PAB
[2694] 91D3 52,12           BR   EOFZ2             Didn't find the corresponding
[2695] 91D5 BD,4A,E0        DST  V@RNM(@ARG),@FAC  Obtain integer record number
       91D8 0A,5C
[2696] 91DA 0F,80           XML  CIF               Convert integer to floating
[2697] 91DC 0F,75           XML  CONT               and continue
[2698]               ***********************************************************
[2699]               *                         EOF ROUTINE
[2700]               * EOF(X) returns status codes on file X. The meaning of the
[2701]               * result codes is:
[2702]               *           -1  Physical End Of File
[2703]               *            0  Not at End Of File yet
[2704]               *            1  Logical End Of File
[2705]               ***********************************************************
[2706] 91DE BD,5C,04 EOF    DST  @PABPTR,@ARG      Save the current PAB and set
[2707]               *                              the new one in SUBEOF
[2708] 91E1 06,92,1E        CALL SUBEOF            Try to find the PAB somewhere
[2709] 91E4 57,D7           BR   ERRFE             Can't file
[2710] 91E6 BE,5E,09        ST   CZSTAT,@ARG2      Select status code without
[2711] 91E9 C0,E0,04        EX   @ARG2,V@COD(@PABPTR) destorying original code
       91EC 04,5E
[2712] 91EE 06,97,65        CALL IOCLZ1            Get the info from DSR
[2713] 91F1 C1,04,5C        DEX  @ARG,@PABPTR      Restore original PAB and orig
[2714] 91F4 BC,E0,04        ST   @ARG2,V@COD(@ARG)  I/O code
       91F7 5C,5E
[2715] 91F9 BC,5E,E0        ST   V@SCR(@ARG),@ARG2 And pick up STATUS
       91FC 0C,5C
[2716] 91FE 31,00,08        MOVE 8,G@FLOAT1,@FAC   Get floating 1
       9201 4A,92,16
[2717] 9204 DA,5E,03        CLOG 3,@ARG2           Test EOF bits
[2718] 9207 72,12           BS   EOFZ2             No EOF indication
[2719] 9209 DA,5E,02        CLOG 2,@ARG2           Physical EOF
[2720] 920C 72,10           BS   G9210
[2721] 920E 83,4A           DNEG @FAC              Make result -1
[2722] 9210 0F,75    G9210  XML  CONT
[2723] 9212 87,4A    EOFZ2  DCLR @FAC              Create result 0
[2724] 9214 0F,75           XML  CONT
[2725] 9216 40,01,00 FLOAT1 BYTE >40,1,0,0,0,0,0,0   * Floating point -1
       9219 00,00,00
       921C 00,00
[2726] 921E D6,42,B7 SUBEOF CEQ  LPARZ,@CHAT       * SYNTAX ERROR
[2727] 9221 41,09           BR   ERRSYN
[2728] 9223 0F,74           XML  PARSE             Parse up to the matching ")"
[2729] 9225 FF              BYTE >FF
[2730] 9226 06,93,5C        CALL CHKCNV            Convert and search for PAB
[2731] 9229 77,CB           BS   ERRBV             Avoid 0's and negatives bad v
[2732] 922B BC,62,17        ST   @DSRFLG,@ARG6     @DSRFLG got changed in CHKCON
[2733] 922E 06,93,71        CALL CHKCON            Check and search tiven filenu
[2734] 9231 BC,17,62        ST   @ARG6,@DSRFLG     @DSRFLG to changed CHKCON
[2735] 9234 01              RTNC                   Condition set : file # exists
[2736]               ***********************************************************
[2737]               *      LOAD / SAVE / MERGE UTILITY ROUTINE
[2738]               * GPNAME gets program name from OLD and SAVE
[2739]               * Can also be used for future implementation of REPLACE
[2740]               * statement. Also gives valuable contribution to updating
[2741]               * of program pointers (VSPTR, STVSPT, FLAG, etc...) and
[2742]               * creation of LOAD/SAVE PAB
[2743]               ***********************************************************
[2744] 9235 B2,45,80 GPNAME AND  >80,@FLAG         Avoid returns from ERRZZ rout
[2745] 9238 D6,42,C7        CEQ  STRINZ,@CHAT
[2746] 923B 72,42           BS   G9242
[2747] 923D D6,42,C8        CEQ  NUMZ,@CHAT        * SYNTAX ERROR
[2748] 9240 41,09           BR   ERRSYN
[2749] 9242 06,81,F4 G9242  CALL CLSALL            First close all open files

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0049 
FLMGR-359
[2750] 9245 06,60,22        CALL KILSYM            Kill the symbol table
[2751] 9248 BF,04,09        DST  VRAMVS+8,@PABPTR  Create PAB as low as possible
       924B 60
[2752] 924C 86,B0,04        CLR  V*PABPTR          Clear PAB with ripple-move
[2753] 924F 35,00,09        MOVE PABLEN-5,V*PABPTR,V@1(@PABPTR)
       9252 E0,01,04
       9255 B0,04
[2754] 9257 0F,79           XML  PGMCHR            Get length of file-specificat
[2755] 9259 A7,04,00        DSUB 4,@PABPTR         Make it a regular PAB
       925C 04
[2756] 925D BC,E0,0D        ST   @CHAT,V@NLEN(@PABPTR) Copy name length to PAB
       9260 04,42
[2757] 9262 BD,0A,E0        DST  V@NLEN-1(@PABPTR),@STADDR Avoid problems(bugs!)
       9265 0C,04
[2758] 9267 8E,80,89        CZ   @RAMFLG           If ERAM not exist or imperati
[2759] 926A 52,75           BR   G9275
[2760] 926C 34,0A,E0        MOVE @STADDR,V*PGMPTR,V@NLEN+1(@PABPTR)
       926F 0E,04,B0
       9272 2C
[2761] 9273 52,84           BR   G9284
[2762] 9275 BD,56,0A G9275  DST  @STADDR,@FFF1     @FFF1 : Byte count
[2763] 9278 BD,54,2C        DST  @PGMPTR,@DDD1     Source address on ERAM
[2764] 927B BD,58,04        DST  @PABPTR,@EEE1
[2765] 927E A3,58,00        DADD NLEN+1,@EEE1      Destination address on VDP
       9281 0E
[2766] 9282 0F,8B           XML  GVWITE            Write from ERAM to VDP
[2767] 9284 A1,2C,0A G9284  DADD @STADDR,@PGMPTR   Skip the string
[2768]               * OLD and SAVE can only be imperative
[2769] 9287 86,34           CLR  @DATA             Clear DATA line
[2770] 9289 00              RTN                    That's all folks
[2771]               ***********************************************************
[2772]               *           READ / INPUT UTILITY ROUTINES
[2773]               ***********************************************************
[2774] 928A BD,0A,2C GETVAR DST  @PGMPTR,@STADDR   Save token pointer to first c
[2775] 928D 86,10           CLR  @VAR5             Clear # of parsed variables
[2776] 928F BD,0E,6E        DST  @VSPTR,@VAR4      Save first entry in V-stack
[2777]               * Start parse cycle for IMPUT statement
[2778] 9292 CA,42,80 GETVZ0 CHE  >80,@CHAT         Make sure of varialbe name
[2779] 9295 61,09           BS   ERRSYN
[2780] 9297 0F,7A           XML  SYM               Get correct symbol table entr
[2781] 9299 86,11           CLR  @VAR6             Start with zero paren nesting
[2782] 929B D6,42,B7 GETVZ1 CEQ  LPARZ,@CHAT       Increment counter for "("
[2783] 929E 52,A2           BR   G92A2
[2784] 92A0 90,11           INC  @VAR6
[2785] 92A2 8E,11    G92A2  CZ   @VAR6             Watch out for final balance
[2786] 92A4 72,B6           BS   G92B6
[2787] 92A6 06,95,AD        CALL CHKEND            Check for unbalenced parenthe
[2788] 92A9 61,09           BS   ERRSYN            Somebody forgot something!!!!
[2789] 92AB D6,42,B6        CEQ  RPARZ,@CHAT       Decrement for ")"
[2790] 92AE 52,B2           BR   G92B2
[2791] 92B0 92,11           DEC  @VAR6
[2792] 92B2 0F,79    G92B2  XML  PGMCHR            Get character following last
[2793] 92B4 52,9B           BR   GETVZ1
[2794] 92B6 0F,77    G92B6  XML  VPUSH             Push entry to V-stack
[2795] 92B8 90,10           INC  @VAR5             Count all pushed variables
[2796] 92BA 06,95,AD        CALL CHKEND            Next should either be EOS or
[2797] 92BD 72,CC           BS   GETVZ2            Found it EOS!!!!
[2798] 92BF 0F,7E           XML  SPEED             Must be at a
[2799] 92C1 00              BYTE SYNCHK          *  comma else
[2800] 92C2 B3              BYTE COMMAZ          *   its an error
[2801] 92C3 06,95,AD        CALL CHKEND            Check for end of statement
[2802] 92C6 52,92           BR   GETVZ0            Haven't found it yet
[2803] 92C8 8E,17           CZ   @DSRFLG           Error for keyboard I/O
[2804] 92CA 41,09           BR   ERRSYN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0050 
FLMGR-359
[2805] 92CC 00       GETVZ2 RTN
[2806]               * Create a temporary string in memory. BYTES contains the l
[2807] 92CD BF,4C,65 CTSTR  DST  >6500,@FAC2       Indicate string in FAC
       92D0 00
[2808] 92D1 BD,50,0C CTSTR0 DST  @BYTES,@FAC6      Copy string length in FAC6
[2809] 92D4 0F,71           XML  GETSTR            Reserve the string
[2810] 92D6 BD,4E,1C        DST  @SREF,@FAC4       Copy start address of string
[2811] 92D9 BF,4A,00        DST  >001C,@FAC        And indicate temp. string >00
       92DC 1C
[2812] 92DD 00              RTN
[2813]               * Create a temporary string from TEMP5. Length is given
[2814]               * in BYTES.
[2815] 92DE 06,92,CD CTMPST CALL CTSTR             Create the temporary string
[2816] 92E1 8E,51           CZ   @FAC7
[2817] 92E3 72,EB           BS   G92EB
[2818] 92E5 34,0C,B0        MOVE @BYTES,V*TEMP5,V*SREF
       92E8 1C,B0,66
[2819] 92EB 00       G92EB  RTN                    Non-empty
[2820]               * CHKNUM - Check for numeric argument
[2821] 92EC D6,01,C8 CHKNUM CEQ  NUMZ,@VAR0+1
[2822] 92EF 53,03           BR   G9303
[2823] 92F1 06,93,0C        CALL GETRAM            Get string length
[2824] 92F4 BD,56,34        DST  @DATA,@FAC12      Store entry for conversion
[2825] 92F7 86,00           CLR  @VAR0             Prepare for double action
[2826] 92F9 A1,34,00        DADD @VAR0,@DATA       Get end of data field
[2827] 92FC 06,A0,12        CALL CONVER            Convert data to FAC #
[2828]               * Conversion should also end at end of field
[2829] 92FF D5,A3,90        DCEQ @DATA,V@CSNTMP    Set COND according to equalit
       9302 34
[2830] 9303 01       G9303  RTNC                   Back to caller
[2831] 9304 BC,4D,80 GETGFL ST   @RAMTOP,@FAC3     Select target memory
       9307 84
[2832] 9308 8E,4D    GETDAT CZ   @FAC3             Get everything from RAM
[2833] 930A 53,14           BR   G9314
[2834] 930C BC,01,B0 GETRAM ST   V*DATA,@VAR0+1    Get data in VAR0+1
       930F 34
[2835] 9310 86,4D           CLR  @FAC3             Be sure FAC3 = 0 !!!!
[2836] 9312 53,20           BR   G9320
[2837] 9314 BF,56,00 G9314  DST  1,@FFF1           FFF1 : byte count
       9317 01
[2838] 9318 BD,54,34        DST  @DATA,@DDD1       DDD1 : source addr on ERAM
[2839] 931B 0F,8C           XML  GREAD1            Read data from ERAM
[2840] 931D BC,01,58        ST   @EEE1,@VAR0+1     EEE1 : Destination addr on CP
[2841] 9320 91,34    G9320  DINC @DATA             Go to next datum for next tim
[2842] 9322 00              RTN
[2843] 9323 87,50    CHKSTR DCLR @FAC6             Assume we'll have an empty st
[2844] 9325 D6,01,C7        CEQ  STRINZ,@VAR0+1
[2845] 9328 73,2F           BS   CHKSZ0
[2846] 932A D6,01,C8        CEQ  NUMZ,@VAR0+1      See ............
[2847] 932D 53,3E           BR   EMPSTR
[2848] 932F 06,93,08 CHKSZ0 CALL GETDAT            Next datum is length byte
[2849] 9332 86,50           CLR  @FAC6             Be sure high byte = 0 !!!!
[2850] 9334 BC,51,01        ST   @VAR0+1,@FAC7     Prepare FAC for string assign
[2851] 9337 BD,66,34        DST  @DATA,@TEMP5      Save string addr for assignme
[2852] 933A A1,34,50        DADD @FAC6,@DATA       Update DATA for end of field
[2853] 933D 00              RTN
[2854]               * Empty strings are handled below
[2855] 933E D6,01,B3 EMPSTR CEQ  COMMAZ,@VAR0+1
[2856] 9341 73,48           BS   G9348
[2857] 9343 06,93,4B        CALL DATEND            Check for end of data stateme
[2858] 9346 53,8C           BR   RTC               Return with COND if not EOS
[2859] 9348 93,34    G9348  DDEC @DATA             Backup data pointer for empti
[2860] 934A 00              RTN
[2861] 934B C0,42,01 DATEND EX   @VAR0+1,@CHAT

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0051 
FLMGR-359
[2862] 934E 06,95,AD        CALL CHKEND            Check for EOS (=EOL or "::")
[2863] 9351 C0,42,01        EX   @VAR0+1,@CHAT     Restore original situation
[2864] 9354 01              RTNC
[2865]               ***********************************************************
[2866]               *           OPEN / CLOSE / RESTORE UTILITY ROUTNE
[2867]               * CHKFN - Check for token = "#" and collect and check
[2868]               * filenumber. Also convert filenumber to (two byte) integer
[2869]               * and check for range 0<x<256
[2870]               ***********************************************************
[2871] 9355 0F,7E    CHKFN  XML  SPEED             Must be at a
[2872] 9357 00              BYTE SYNCHK         *   '#' else
[2873] 9358 FD              BYTE NUMBEZ         *    its an error
[2874] 9359 0F,74           XML  PARSE             Parse argument up to ":"
[2875] 935B B5              BYTE COLONZ
[2876]               * Code to check for negative or zero result in floating poi
[2877]               * accumilator. If not... convert to integer and return two
[2878]               * byte integer in FAC
[2879] 935C D6,4C,65 CHKCNV CEQ  STRVAL,@FAC2      String/number mismatch
[2880] 935F 77,BF           BS   ERRSNM
[2881] 9361 86,54           CLR  @FAC10            Clear error-code byte
[2882] 9363 0F,12           XML  CFI               Convert to two byte integer
[2883] 9365 8E,54           CZ   @FAC10            BAD VALUE ERROR
[2884] 9367 57,CB           BR   ERRBV
[2885] 9369 DA,4A,80        CLOG >80,@FAC          Negative result
[2886] 936C 53,8C           BR   RTC
[2887] 936E 8F,4A           DCZ  @FAC              And return with COND set/rese
[2888] 9370 01              RTNC
[2889] 9371 BC,17,4B CHKCON ST   @FAC1,@FNUM       Move result into FNUM
[2890]               * Check for high byte not zero (>0255)
[2891] 9374 8E,4A           CZ   @FAC              Bad value error
[2892] 9376 57,CB           BR   ERRBV
[2893]               * Search routine - Search for a given file number in the
[2894]               * chain of allocated PABs.
[2895]               * IOSTRT contains the start of the PAB - chain
[2896] 9378 BD,04,3C        DST  @IOSTRT,@PABPTR   Get first link in the chain
[2897]               * Check for last PAB in the chain and exit if found
[2898] 937B 8F,04    CHKFZ1 DCZ  @PABPTR           Check if file # is correct
[2899] 937D 73,8F           BS   G938F
[2900] 937F D4,E0,02        CEQ  @FNUM,V@FIL(@PABPTR)
       9382 04,17
[2901] 9384 73,8C           BS   RTC
[2902] 9386 BD,04,B0        DST  V*PABPTR,@PABPTR  Try the next PAB
       9389 04
[2903] 938A 53,7B           BR   CHKFZ1
[2904] 938C D4,00,00 RTC    CEQ  @>8300,@>8300     Force COND to "SET"
[2905] 938F 01       G938F  RTNC                   Exit with no COND change
[2906]               ***********************************************************
[2907]               * OUTEOF outputs the last record if this record is
[2908]               * non-empty, and if the PAB is open for non-imput mode
[2909]               * (UPDATE, APPEND or OUTPUT).
[2910]               ***********************************************************
[2911] 9390 86,17    OUTEOF CLR  @DSRFLG
[2912] 9392 D6,E0,04        CEQ  CZWRIT,V@COD(@PABPTR) Non-input mode
       9395 04,03
[2913] 9397 53,A5           BR   G93A5
[2914] 9399 8E,E0,03        CZ   V@OFS(@PABPTR)    Non-empty record
       939C 04
[2915] 939D 73,A5           BS   G93A5
[2916] 939F 06,96,F5        CALL PRINIT            Initiate for output
[2917] 93A2 06,96,A5        CALL OUTREC            Output and remove pending con
[2918] 93A5 00       G93A5  RTN                    Return to whoever called
[2919]               ***********************************************************
[2920]               * DELPAB routine - delete a given PAB from chain under the
[2921]               * assumption that the PAB exists

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0052 
FLMGR-359
[2922]               ***********************************************************
[2923]               * First compute start and end address for block move
[2924] 93A6 BD,0A,E0 DELPAB DST  V@BUF(@PABPTR),@STADDR Get lowest used address
       93A9 06,04
[2925] 93AB 93,0A           DDEC @STADDR           Make that an addr following P
[2926] 93AD 86,08           CLR  @CCPADR           Get highest addr in CCPADR (2
[2927] 93AF BC,09,E0        ST   V@NLEN(@PABPTR),@CCPADR+1 complete the two byte
       93B2 0D,04
[2928] 93B4 A2,09,0D        ADD  PABLEN-1,@CCPADR+1 Add PAB length-1
[2929] 93B7 A1,08,04        DADD @PABPTR,@CCPADR   Compute actual addr within RA
[2930] 93BA D5,3C,04        DCEQ @PABPTR,@IOSTRT   Watch out for first PAB
[2931] 93BD 73,E6           BS   G93E6
[2932] 93BF BD,02,3C        DST  @IOSTRT,@MNUM     Figure out where link to PAB
[2933] 93C2 D5,B0,02 G93C2  DCEQ @PABPTR,V*MNUM    Continue while not found
       93C5 04
[2934] 93C6 73,CE           BS   G93CE
[2935] 93C8 BD,02,B0        DST  V*MNUM,@MNUM      Defer to next link in chain
       93CB 02
[2936] 93CC 53,C2           BR   G93C2             Short end for code-savings
[2937] 93CE BD,B0,02 G93CE  DST  V*PABPTR,V*MNUM   Copy link over deleted PAB
       93D1 B0,04
[2938] 93D3 8F,B0,02        DCZ  V*MNUM            Adjust link only if not done
[2939] 93D6 73,E0           BS   G93E0
[2940] 93D8 A1,B0,02        DADD @CCPADR,V*MNUM    Add deleted # of bytes for
       93DB 08
[2941] 93DC A5,B0,02        DSUB @STADDR,V*MNUM     link correction
       93DF 0A
[2942] 93E0 BD,04,B0 G93E0  DST  V*MNUM,@PABPTR    Get new PABPTR
       93E3 02
[2943] 93E4 53,F7           BR   G93F7
[2944] 93E6 BD,3C,B0 G93E6  DST  V*PABPTR,@IOSTRT  Update first link
       93E9 04
[2945] 93EA 8F,3C           DCZ  @IOSTRT           Only adjust if not last link
[2946] 93EC 73,F4           BS   G93F4
[2947] 93EE A1,3C,08        DADD @CCPADR,@IOSTRT   Add deleted # of bytes
[2948] 93F1 A5,3C,0A        DSUB @STADDR,@IOSTRT
[2949] 93F4 BD,04,3C G93F4  DST  @IOSTRT,@PABPTR   Get new PABPTR
[2950]               * Move the bytes below the deleted block up in memory. This
[2951]               * includes both variables and PABs
[2952] 93F7 BD,02,0A G93F7  DST  @STADDR,@MNUM     Get # of bytes to move
[2953] 93FA A5,02,40        DSUB @FREPTR,@MNUM
[2954] 93FD BD,06,08        DST  @CCPADR,@CCPPTR   Save destination address
[2955] 9400 8F,02    G9400  DCZ  @MNUM
[2956] 9402 74,11           BS   G9411
[2957] 9404 BC,B0,08        ST   V*STADDR,V*CCPADR Move byte by byte
       9407 B0,0A
[2958] 9409 93,0A           DDEC @STADDR           Update source
[2959] 940B 93,08           DDEC @CCPADR            and destination pointers
[2960] 940D 93,02           DDEC @MNUM             Also update counter value
[2961] 940F 54,00           BR   G9400
[2962] 9411 A5,08,0A G9411  DSUB @STADDR,@CCPADR   Compute # of bytes of old PAB
[2963] 9414 8F,04           DCZ  @PABPTR           Avoid trouble with last PAB
[2964] 9416 74,31           BS   G9431
[2965] 9418 8F,B0,04 G9418  DCZ  V*PABPTR          Ad infinitum (or fundum)
[2966] 941B 74,2C           BS   G942C
[2967] 941D A1,B0,04        DADD @CCPADR,V*PABPTR  Adjust link to next PAB
       9420 08
[2968] 9421 A1,E0,06        DADD @CCPADR,V@BUF(@PABPTR) Update the buffer link
       9424 04,08
[2969] 9426 BD,04,B0        DST  V*PABPTR,@PABPTR  Get next link in chain
       9429 04
[2970] 942A 54,18           BR   G9418
[2971] 942C A1,E0,06 G942C  DADD @CCPADR,V@BUF(@PABPTR) Update buffer link
       942F 04,08

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0053 
FLMGR-359
[2972]               * Adjust symbol table links
[2973] 9431 8F,3E    G9431  DCZ  @SYMTAB
[2974] 9433 74,B4           BS   G94B4
[2975] 9435 D1,3E,06        DCGE @CCPPTR,@SYMTAB   Only update lower links
[2976] 9438 74,B4           BS   G94B4
[2977] 943A A1,3E,08        DADD @CCPADR,@SYMTAB   Get symbol table pointer back
[2978] 943D BD,04,3E        DST  @SYMTAB,@PABPTR   Get pointer for update
[2979] 9440 8E,80,84 DELPZ1 CZ   @RAMTOP
[2980] 9443 54,4C           BR   DELPZ2
[2981] 9445 D1,E0,04        DCGE @STLN,V@4(@PABPTR) If imperative
       9448 04,30
[2982] 944A 74,51           BS   G9451
[2983] 944C A1,E0,04 DELPZ2 DADD @CCPADR,V@4(@PABPTR) Adjust name pointer
       944F 04,08
[2984] 9451 D2,B0,04 G9451  CGE  0,V*PABPTR        If string-fix breakpoints
       9454 00
[2985] 9455 74,9B           BS   G949B
[2986] 9457 BE,4A,07        ST   >07,@FAC          Mask to get # of dims
[2987] 945A B0,4A,B0        AND  V*PABPTR,@FAC     Get # of dims
       945D 04
[2988] 945E BD,4C,04        DST  @PABPTR,@FAC2     Pointer to 1st dim max
[2989] 9461 A3,4C,00        DADD 6,@FAC2            or string pointer
       9464 06
[2990] 9465 BF,50,00        DST  1,@FAC6           Number of pointers to change
       9468 01
[2991] 9469 86,4E           CLR  @FAC4             For 2 byte use of option base
[2992] 946B 8E,4A    G946B  CZ   @FAC              While more dimendions
[2993] 946D 74,83           BS   G9483
[2994] 946F BE,4F,01        ST   1,@FAC5           Assume option base 0
[2995] 9472 A4,4F,43        SUB  @BASE,@FAC5       But correct if base 1
[2996] 9475 A1,4E,B0        DADD V*FAC2,@FAC4      Get dim maximum
       9478 4C
[2997] 9479 A9,4E,50        DMUL @FAC6,@FAC4       Multiply it in
[2998] 947C 92,4A           DEC  @FAC              Next dim
[2999] 947E 95,4C           DINCT @FAC2
[3000] 9480 05,94,6B        B    G946B
[3001]               * FAC2 now points at the 1st string pointer
[3002]               * FAC6 contains the # of pointers that need to be changed
[3003] 9483 8F,50    G9483  DCZ  @FAC6             While pointers to cheange
[3004] 9485 74,9B           BS   G949B
[3005] 9487 BD,4A,B0        DST  V*FAC2,@FAC       Get pointer to string
       948A 4C
[3006] 948B 8F,4A           DCZ  @FAC              If sting is non-null
[3007] 948D 74,95           BS   G9495
[3008] 948F BD,EF,FF        DST  @FAC2,V@-3(@FAC)  Fix backpointer
       9492 FD,4A,4C
[3009] 9495 95,4C    G9495  DINCT @FAC2            Point to next pointer
[3010] 9497 93,50           DDEC @FAC6             One less pointer to change
[3011] 9499 54,83           BR   G9483
[3012] 949B 8F,E0,02 G949B  DCZ  V@2(@PABPTR)
       949E 04
[3013] 949F 74,B4           BS   G94B4
[3014] 94A1 D1,E0,02        DCGE @CCPPTR,V@2(@PABPTR)
       94A4 04,06
[3015] 94A6 74,B4           BS   G94B4
[3016] 94A8 A1,E0,02        DADD @CCPADR,V@2(@PABPTR) Adjust next value link
       94AB 04,08
[3017] 94AD BD,04,E0        DST  V@2(@PABPTR),@PABPTR Next entry
       94B0 02,04
[3018] 94B2 54,40           BR   DELPZ1
[3019] 94B4 A1,40,08 G94B4  DADD @CCPADR,@FREPTR   Update free word pointer
[3020] 94B7 00              RTN
[3021]               ***********************************************************
[3022]               * CNVDEF - Convert to 2 byte integer and default to 1 on

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0054 
FLMGR-359
[3023]               *          negative or 0 ....
[3024]               ***********************************************************
[3025] 94B8 06,93,5C CNVDEF CALL CHKCNV            Check and convert
[3026] 94BB 54,C1           BR   CNVDZ0
[3027] 94BD BF,4A,00        DST  1,@FAC            Default to 1 or minus and 0
       94C0 01
[3028] 94C1 00       CNVDZ0 RTN                    And return without COND set
[3029]               ***********************************************************
[3030]               * PARREC parses a possible REC clause in INPUT, PRINT or
[3031]               * RESTORE. In case a comma is detected without a REC clause
[3032]               * following it, the COND is set upon return. In case a REC
[3033]               * clause is specified for a file opened for SEQUENTIAL
[3034]               * access, a * FILE ERROR is given.
[3035]               ***********************************************************
[3036] 94C2 D6,42,B3 PARREC CEQ  COMMAZ,@CHAT      Only check if we have a ","
[3037] 94C5 54,EE           BR   G94EE
[3038] 94C7 0F,79           XML  PGMCHR            Check next token for REC
[3039] 94C9 D6,42,DE        CEQ  RECZ,@CHAT        May be USING clause
[3040] 94CC 53,8C           BR   RTC
[3041] 94CE DA,E0,05        CLOG 1,V@FLG(@PABPTR)
       94D1 04,01
[3042] 94D3 77,D7           BS   ERRFE
[3043] 94D5 0F,79           XML  PGMCHR            Get first character of expres
[3044] 94D7 06,93,90        CALL OUTEOF            Output possible pending outpu
[3045] 94DA 86,E0,03        CLR  V@OFS(@PABPTR)    Clear record offset
       94DD 04
[3046] 94DE 0F,74           XML  PARSE             Translate the expression in R
[3047] 94E0 B5              BYTE COLONZ
[3048] 94E1 06,93,5C        CALL CHKCNV            Check numeric and convert to
[3049] 94E4 D2,4A,00        CGE  0,@FAC             2 byte integer, Bad Value
[3050] 94E7 57,CB           BR   ERRBV
[3051] 94E9 BD,E0,0A        DST  @FAC,V@RNM(@PABPTR) Store actual record number
       94EC 04,4A
[3052] 94EE 00       G94EE  RTN
[3053]               ***********************************************************
[3054]               *              DISPLAY / ACCEPT UTILITIES
[3055]               ***********************************************************
[3056] 94EF 06,97,3F DISACC CALL INITKB            PABPTR is used as flag (no DS
[3057] 94F2 D6,42,EF DISPZ1 CEQ  ERASEZ,@CHAT      Check for ERASE ALL
[3058] 94F5 55,18           BR   G9518
[3059] 94F7 DA,04,01        CLOG 1,@PABPTR          already used once
[3060] 94FA 41,09           BR   ERRSYN
[3061] 94FC 0F,79           XML  PGMCHR            Check next token for ALL
[3062] 94FE 0F,7E           XML  SPEED
[3063] 9500 00              BYTE SYNCHK          *  has to be ALL
[3064] 9501 EC              BYTE ALLZ
[3065] 9502 07,80           ALL  BKGD+OFFSET       Clear screen to background co
[3066] 9504 BE,7F,03        ST   3,@XPT            Reset pending output pointer
[3067] 9507 DA,04,04        CLOG 4,@PABPTR         Didn't use AT yet
[3068] 950A 55,13           BR   G9513
[3069] 950C BE,06,01        ST   1,@CCPPTR         Reset column pointer
[3070] 950F BF,08,02        DST  SCRNBS+2,@CCPADR   and screen base address
       9512 E2
[3071] 9513 B6,04,01 G9513  OR   1,@PABPTR         Set "ERASE USED" flag
[3072] 9516 54,F2           BR   DISPZ1            Try next token
[3073] 9518 D6,42,EE G9518  CEQ  BEEPZ,@CHAT        delay action for BEEP
[3074] 951B 55,29           BR   G9529
[3075] 951D DA,04,02        CLOG 2,@PABPTR         Use it only once
[3076] 9520 41,09           BR   ERRSYN
[3077] 9522 B6,04,02        OR   2,@PABPTR         No syntax error detected here
[3078] 9525 0F,79           XML  PGMCHR            Evaluate next token
[3079] 9527 54,F2           BR   DISPZ1            Get set for second pass
[3080] 9529 D6,42,F0 G9529  CEQ  ATZ,@CHAT         Generate "AT" clause
[3081] 952C 55,71           BR   G9571

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0055 
FLMGR-359
[3082] 952E DA,04,04        CLOG 4,@PABPTR         Second usage not
[3083] 9531 41,09           BR   ERRSYN
[3084] 9533 0F,79           XML  PGMCHR             allowed....
[3085] 9535 0F,7E           XML  SPEED
[3086] 9537 00              BYTE SYNCHK          * Skip left parenthesis
[3087] 9538 B7              BYTE LPARZ
[3088] 9539 0F,74           XML  PARSE             Now parse any expression
[3089] 953B B3              BYTE COMMAZ
[3090] 953C 0F,7E           XML  SPEED
[3091] 953E 00              BYTE SYNCHK          * Check for "," and skip it
[3092] 953F B3              BYTE COMMAZ
[3093] 9540 06,94,B8        CALL CNVDEF            Convert to 2 byte numeric
[3094] 9543 BE,4C,18        ST   24,@FAC2          Convert modulo 24 (# screen l
[3095] 9546 06,96,1A        CALL COMMOD            Compute remainder
[3096] 9549 92,4B           DEC  @FAC1             Convert back to 0 (range was
[3097] 954B AA,4B,20        MUL  32,@FAC1          Convert to line base address
[3098] 954E BD,08,4B        DST  @FAC1,@CCPADR     And repalce CCPADR
[3099] 9551 0F,74           XML  PARSE             Parse column expression
[3100] 9553 B6              BYTE RPARZ
[3101] 9554 0F,7E           XML  SPEED
[3102] 9556 00              BYTE SYNCHK          * Check for ")" at end
[3103] 9557 B6              BYTE RPARZ
[3104] 9558 06,94,B8        CALL CNVDEF            Again convert to two byte int
[3105] 955B BE,4C,1C        ST   VWIDTH,@FAC2      Convert modulo video width
[3106] 955E 06,96,1A        CALL COMMOD            Compute remainder
[3107] 9561 BC,06,4B        ST   @FAC1,@CCPPTR     Select current column
[3108] 9564 A1,08,4A        DADD @FAC,@CCPADR      Compute full address
[3109] 9567 91,08           DINC @CCPADR           Adjust for column 0 (offset-1
[3110] 9569 B6,04,04        OR   4,@PABPTR         Set "AT-CLAUSE" used flag
[3111] 956C B6,04,20        OR   32,@PABPTR        Set "NON-STANDARD SCREEN ADDR
[3112] 956F 54,F2           BR   DISPZ1            Continue for next item
[3113] 9571 D6,42,EB G9571  CEQ  SIZEZ,@CHAT       "SIZE" clause
[3114] 9574 55,A0           BR   G95A0
[3115] 9576 DA,04,08        CLOG 8,@PABPTR         Only use once
[3116] 9579 41,09           BR   ERRSYN
[3117] 957B 0F,79           XML  PGMCHR            Get character following the S
[3118] 957D D6,42,B7        CEQ  LPARZ,@CHAT        has to open "("
[3119] 9580 41,09           BR   ERRSYN
[3120] 9582 0F,74           XML  PARSE             And close again ")"
[3121] 9584 FE              BYTE VALIDZ
[3122] 9585 D2,4A,00        CGE  0,@FAC            Change to positive argument
[3123] 9588 75,8F           BS   G958F
[3124] 958A 83,4A           DNEG @FAC              For ACCEPT statement with siz
[3125] 958C B6,04,80        OR   >80,@PABPTR        indicate in highest bit
[3126] 958F 06,93,5C G958F  CALL CHKCNV
[3127] 9592 77,CB           BS   ERRBV             * BAD VALUE
[3128] 9594 8E,4A           CZ   @FAC              Also for args >255 (less then
[3129] 9596 57,CB           BR   ERRBV
[3130] 9598 BC,05,4B        ST   @FAC1,@PABPTR+1   Copy to PABPTR (always used)
[3131] 959B B6,04,08        OR   8,@PABPTR         Prevent further use
[3132] 959E 54,F2           BR   DISPZ1             and go on
[3133] 95A0 D6,42,FE G95A0  CEQ  VALIDZ,@CHAT      Exclude VALIDATE option
[3134] 95A3 75,B9           BS   G95B9
[3135]               * Start evaluating ERASE clause here
[3136] 95A5 DA,04,08        CLOG 8,@PABPTR
[3137] 95A8 75,AD           BS   CHKEND
[3138] 95AA 06,95,DF        CALL SIZE1             Evaluate field defined in SIZ
[3139]               * If it's no DISPLAY keyword ( AT, SIZE, BEEP or USING) it
[3140]               * has to be a print separator or colon ":"
[3141]               * If anything is specified is has to be a colon or end of
[3142]               * line... for end-of-line output current record
[3143]               * Check for end of statement
[3144] 95AD DA,42,80 CHKEND CLOG >80,@CHAT
[3145] 95B0 75,B7           BS   G95B7

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0056 
FLMGR-359
[3146] 95B2 CA,42,84        CHE  TREMZ+1,@CHAT
[3147] 95B5 53,8C           BR   RTC
[3148] 95B7 8E,42    G95B7  CZ   @CHAT             Set COND according to CHAT
[3149] 95B9 01       G95B9  RTNC
[3150]               ***********************************************************
[3151]               * NXTCHR - Get next program character - skip all strings,
[3152]               *          numerics and line references...
[3153]               ***********************************************************
[3154] 95BA 06,95,AD NXTCHR CALL CHKEND            Check for end of statements
[3155] 95BD 73,8C           BS   RTC               Avoid end of statement
[3156] 95BF D6,42,C7        CEQ  STRINZ,@CHAT      Skip all strings
[3157] 95C2 75,C9           BS   NXTCZ0
[3158] 95C4 D6,42,C8        CEQ  NUMZ,@CHAT         and numerics/unquoted string
[3159] 95C7 55,D5           BR   G95D5
[3160] 95C9 0F,79    NXTCZ0 XML  PGMCHR            Get string length
[3161] 95CB BC,4B,42        ST   @CHAT,@FAC1       Make that a double please...
[3162] 95CE 86,4A           CLR  @FAC              Hic.... Oops, sorry
[3163] 95D0 A1,2C,4A        DADD @FAC,@PGMPTR      Back to the serious stuff
[3164] 95D3 55,DC           BR   G95DC
[3165] 95D5 D6,42,C9 G95D5  CEQ  LNZ,@CHAT         Line # = skip 2 tokens
[3166] 95D8 55,DC           BR   G95DC
[3167] 95DA 95,2C           DINCT @PGMPTR          <----------- That's the skip
[3168] 95DC 0F,79    G95DC  XML   PGMCHR           Get the next token
[3169] 95DE 00              RTN
[3170]               ***********************************************************
[3171]               *                 PRINT / DISPLAY UTILITES
[3172]               * Use the parameters specified in SIZE for further
[3173]               * evaluation of the limited field length
[3174]               ***********************************************************
[3175] 95DF DA,04,04 SIZE1  CLOG 4,@PABPTR         Not "AT" clause used
[3176] 95E2 55,FC           BR   G95FC
[3177] 95E4 D6,06,01        CEQ  1,@CCPPTR         Might have to print current
[3178] 95E7 75,FC           BS   G95FC
[3179] 95E9 BC,4A,06        ST   @CCPPTR,@FAC      Compute final position after
[3180] 95EC A0,4A,05        ADD  @PABPTR+1,@FAC     in FAC and compare with reco
[3181] 95EF 92,4A           DEC  @FAC
[3182] 95F1 C4,4A,07        CH   @RECLEN,@FAC      Size clause too long
[3183] 95F4 55,FC           BR   G95FC
[3184]               * We can't get here for AT( , ) output, since right margin
[3185]               * limited there
[3186] 95F6 06,96,A5        CALL OUTREC            Advance to next line
[3187] 95F9 06,96,CC        CALL SCRO              Scroll the screeen
[3188] 95FC A4,07,06 G95FC  SUB  @CCPPTR,@RECLEN   Limit field size to available
[3189] 95FF 90,07           INC  @RECLEN            space... including current p
[3190] 9601 C4,07,05        CH   @PABPTR+1,@RECLEN
[3191] 9604 56,C8           BR   INITZ1
[3192] 9606 BC,07,05        ST   @PABPTR+1,@RECLEN Only accept if available
[3193] 9609 56,C8           BR   INITZ1            Reinitialize CCPPTR
[3194]               * Copy (converted) numerical datum in string
[3195] 960B BC,0D,56 RSTRING ST  @FAC12,@BYTES+1   Get actual string length
[3196] 960E 86,0C           CLR  @BYTES            Create double byte value
[3197] 9610 06,92,CD        CALL CTSTR             Create a temporary string
[3198] 9613 34,0C,B0        MOVE @BYTES,*FAC11,V*SREF Copy value string
       9616 1C,90,55
[3199] 9619 00              RTN
[3200]               * COMMOD - Compute FAC module FAC2
[3201] 961A AC,4A,4C COMMOD DIV  @FAC2,@FAC        Compute remainder
[3202] 961D 8E,4B           CZ   @FAC1             Avoid zero remainders
[3203] 961F 56,24           BR   G9624
[3204] 9621 BC,4B,4C        ST   @FAC2,@FAC1       Assume maximum remainder
[3205] 9624 86,4A    G9624  CLR  @FAC              Clear upper byte
[3206] 9626 00              RTN
[3207]               * TSTSEP tests for separator in print and branches to the
[3208]               * correct evaluation routine.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0057 
FLMGR-359
[3209]               * If no separator is found, simple return.
[3210]               * Test case end of line
[3211] 9627 06,95,AD TSTSEP CALL CHKEND
[3212] 962A 56,31           BR   TSTSZ0
[3213] 962C BF,90,73        DST  EOLEX,*SUBSTK     Replace return address with E
       962F 83,95
[3214] 9631 CA,42,B3 TSTSZ0 CHE  COMMAZ,@CHAT
[3215] 9634 56,59           BR   TSTSZ1
[3216] 9636 C6,42,B5        CH   COLONZ,@CHAT
[3217] 9639 76,59           BS   TSTSZ1
[3218] 963B BF,90,73        DST  PRSEM,*SUBSTK     Expect it to be a ";"
       963E 83,7A
[3219] 9640 06,83,C5        CALL TSTINT            Test for INTERNAL files
[3220] 9643 56,59           BR   TSTSZ1            Treat all separators as ";"
[3221] 9645 D6,42,B3        CEQ  COMMAZ,@CHAT
[3222] 9648 56,4F           BR   G964F
[3223] 964A BF,90,73        DST  PRTCOM,*SUBSTK
       964D 83,5C
[3224] 964F D6,42,B5 G964F  CEQ  COLONZ,@CHAT
[3225] 9652 56,59           BR   TSTSZ1
[3226] 9654 BF,90,73        DST  PRCOL,*SUBSTK
       9657 83,77
[3227] 9659 00       TSTSZ1 RTN
[3228]               * PARFN - Parse string expression and create PAB automatica
[3229]               *         continue in CSTRIN for copy string to PAB
[3230]               * Exit on non-string values
[3231]               *
[3232]               * First evaluate string expression
[3233] 965A 0F,74    PARFN  XML  PARSE             Parse up to next comma    <<<
[3234] 965C B3              BYTE COMMAZ          *                           <<<
[3235] 965D D6,4C,65        CEQ  STRVAL,@FAC2      Check for "STRING"        <<<
[3236] 9660 57,BF           BR   ERRSNM
[3237] 9662 BD,02,50        DST  @FAC6,@MNUM       Copy length byte in MNUM
[3238] 9665 A2,03,0E        ADD  PABLEN,@MNUM+1    Account for PAB length+contro
[3239] 9668 0F,77           XML  VPUSH             Save start of string somewher
[3240] 966A BD,4A,02        DST  @MNUM,@FAC        Setup for MEMCHK - check for
[3241] 966D 0F,72           XML  MEMCHK             memory overflow
[3242] 966F 77,C7           BS   ERRMEM            * MEMORY FULL
[3243] 9671 0F,78           XML  VPOP              Restore all FAC information a
[3244] 9673 A5,40,02        DSUB @MNUM,@FREPTR     Update free word pointer
[3245] 9676 BD,04,40        DST  @FREPTR,@PABPTR   Assign PAB entry address
[3246] 9679 91,04           DINC @PABPTR           Correct for byte within PAB
[3247] 967B 86,B0,04        CLR  V*PABPTR          Clear PAB plus control info
[3248] 967E 35,00,0D        MOVE PABLEN-1,V*PABPTR,V@1(@PABPTR)  Ripple byte
       9681 E0,01,04
       9684 B0,04
[3249] 9686 BC,E0,03        ST   @MNUM+1,V@OFS(@PABPTR) Save length of PAB
       9689 04,03
[3250] 968B BC,02,51        ST   @FAC7,@MNUM       Compute # of bytes in name
[3251] 968E BC,E0,0D        ST   @FAC7,V@NLEN(@PABPTR) Store name length
       9691 04,51
[3252] 9693 BC,E0,02        ST   @FNUM,V@FIL(@PABPTR) Copy file number in PAB
       9696 04,17
[3253] 9698 BD,08,04        DST  @PABPTR,@CCPADR   Get start addr for string des
[3254] 969B A3,08,00        DADD NLEN+1,@CCPADR    Add offset to actual start ad
       969E 0E
[3255]               * TRICKY - OPTFLG also results offset added in CSTRIN
[3256] 969F 86,17           CLR  @OPTFLG           Clear all option flags
[3257] 96A1 0F,84           XML  IO                CSTRIN I/O UTILITY
[3258] 96A3 02              BYTE CSTRIN
[3259] 96A4 00              RTN
[3260]               ***********************************************************
[3261]               *                      OUTREC
[3262]               * OUTREC and INITRC are used to output a record to either

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0058 
FLMGR-359
[3263]               * screen or external I/O devices, and to initiate pointers
[3264]               * for further I/O.
[3265]               ***********************************************************
[3266] 96A5 BC,03,07 OUTREC ST   @RECLEN,@MNUM+1   Compute number of characters
[3267] 96A8 90,03           INC  @MNUM+1            positions we should fill
[3268] 96AA 8E,17           CZ   @DSRFLG           Screen I/O
[3269] 96AC 76,D3           BS   G96D3
[3270] 96AE 0F,84           XML  IO                Fill the remainder of the rec
[3271] 96B0 01              BYTE FILSPC          *  with appropriate fillers
[3272] 96B1 DA,04,08        CLOG 8,@PABPTR           block output on size
[3273] 96B4 53,8C           BR   RTC
[3274] 96B6 DA,04,04        CLOG 4,@PABPTR         "AT CLAUSE USED"
[3275] 96B9 76,CC           BS   SCRO
[3276]               * Next test for xing the end of screen
[3277] 96BB A3,08,00        DADD 4,@CCPADR
       96BE 04
[3278] 96BF CA,08,03        CHE  3,@CCPADR
[3279] 96C2 56,C8           BR   INITZ1
[3280] 96C4 BF,08,00        DST  2,@CCPADR         Restart at upper left hand
       96C7 02
[3281]               *                              corner of screen
[3282] 96C8 BE,06,01 INITZ1 ST   1,@CCPPTR         Reset current column pointer
[3283] 96CB 00              RTN
[3284] 96CC 0F,83    SCRO   XML  SCROLL            Scroll the screen one line
[3285] 96CE BE,06,01        ST   1,@CCPPTR         Reinitialize CCPPTR
[3286] 96D1 57,54           BR   INTKB0             and reinitialize
[3287]               * This is also entry for last record output
[3288] 96D3 DA,E0,05 G96D3  CLOG >10,V@FLG(@PABPTR) FIXED records
       96D6 04,10
[3289] 96D8 56,E2           BR   G96E2
[3290] 96DA BC,03,07        ST   @RECLEN,@MNUM+1   Ready for space filling
[3291] 96DD 90,03           INC  @MNUM+1           Move to first position outsid
[3292]               *                              record
[3293] 96DF 0F,84           XML  IO                And do it up to end of record
[3294] 96E1 01              BYTE FILSPC
[3295] 96E2 92,06    G96E2  DEC  @CCPPTR           Update last character positio
[3296] 96E4 BC,E0,09        ST   @CCPPTR,V@CNT(@PABPTR) Store # of characters
       96E7 04,06
[3297] 96E9 86,E0,03        CLR  V@OFS(@PABPTR)    Undo pending record offsets
       96EC 04
[3298] 96ED 06,97,5E        CALL IOCALL            Call DSR
[3299] 96F0 03              BYTE CZWRIT          *  for WRITE mode
[3300] 96F1 86,09           CLR  @CCPADR+1         Get address at buffer start
[3301] 96F3 57,01           BR   PRZZ0
[3302]               * PRINIT initializes the variable CCPADR, CCPPTR, RECLEN an
[3303]               * DSRFLG, for a given PABPTR.
[3304] 96F5 86,17    PRINIT CLR  @DSRFLG           Indicate external I/O in DSRF
[3305] 96F7 BC,07,E0        ST   V@LEN(@PABPTR),@RECLEN  Pick up record length
       96FA 08,04
[3306] 96FC BC,09,E0        ST   V@OFS(@PABPTR),@CCPADR+1 Get offset in record
       96FF 03,04
[3307] 9701 BC,06,09 PRZZ0  ST   @CCPADR+1,@CCPPTR  Compute columnar position
[3308] 9704 90,06           INC  @CCPPTR           And convert from offset
[3309] 9706 86,08           CLR  @CCPADR           Clear upper byte
[3310] 9708 A1,08,E0        DADD V@BUF(@PABPTR),@CCPADR Compute actual address
       970B 06,04
[3311] 970D 00              RTN
[3312]               ***********************************************************
[3313]               * OSTRNG - Copy the value of the string expression to the
[3314]               *          screen.
[3315]               ***********************************************************
[3316] 970E BC,0C,51 OSTRNG ST   @FAC7,@BYTES      Pick up the string length
[3317] 9711 8E,0C    G9711  CZ   @BYTES            Output as many records as req
[3318] 9713 77,3E           BS   G973E

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0059 
FLMGR-359
[3319]               * CHKREC check available space in current record.
[3320]               * If the string to be output is too long, it is chuncked up
[3321]               * into digestable pieces. If the current record is partly
[3322]               * filled up, it is output before any chuncking is done.
[3323] 9715 BC,03,06 CHKREC ST   @CCPPTR,@MNUM+1   Use MNUM for current offset i
[3324] 9718 BC,02,07 CHKRZ0 ST   @RECLEN,@MNUM     Compute remaining area
[3325] 971B A4,02,06        SUB  @CCPPTR,@MNUM      between column and end
[3326] 971E 90,02           INC  @MNUM             Also count current column
[3327] 9720 C8,02,0C        CHE  @BYTES,@MNUM      Won't fit in current record
[3328] 9723 77,30           BS   G9730
[3329] 9725 D6,03,01        CEQ  1,@MNUM+1         Unused record
[3330] 9728 77,33           BS   CHKRZ1
[3331] 972A 06,96,A5        CALL OUTREC            Output whatever we have
[3332] 972D 57,15           BR   CHKREC            And try again
[3333] 972F 00              RTN
[3334] 9730 BC,02,0C G9730  ST   @BYTES,@MNUM      Use actual count if fit
[3335] 9733 A4,0C,02 CHKRZ1 SUB  @MNUM,@BYTES      Update remaining chars count
[3336] 9736 A0,06,02        ADD  @MNUM,@CCPPTR     Also new column pointer
[3337] 9739 0F,84           XML  IO                Copy string to output
[3338] 973B 02              BYTE CSTRIN
[3339] 973C 57,11           BR   G9711             Continue as long as needed
[3340] 973E 00       G973E  RTN
[3341]               ***********************************************************
[3342]               * INITKB - Initialize the variable needed for keyboard outp
[3343]               ***********************************************************
[3344] 973F 86,04    INITKB CLR  @PABPTR           Don't use any DISPLAY options
[3345] 9741 BE,17,60        ST   OFFSET,@DSRFLG    Load for correction of screen
[3346] 9744 BE,06,01        ST   1,@CCPPTR         Assume un-initialized XPT
[3347] 9747 C6,7F,02        CH   2,@XPT            * Patch for un-initialized XP
[3348] 974A 57,51           BR   G9751
[3349] 974C BC,06,7F        ST   @XPT,@CCPPTR      Initialize CCPPTR
[3350] 974F 96,06           DECT @CCPPTR           Correct for incorrect XPT off
[3351] 9751 BE,07,1C G9751  ST   VWIDTH,@RECLEN    Get video screen width
[3352] 9754 BC,09,06 INTKB0 ST   @CCPPTR,@CCPADR+1 Initialize screen address
[3353] 9757 86,08           CLR  @CCPADR           Clear upper byte CCPADR
[3354] 9759 A3,08,02        DADD SCRNBS+1,@CCPADR  Add start-addr plus comenstat
       975C E1
[3355] 975D 00              RTN
[3356] 975E 88,56    IOCALL FETCH @FAC12           I/O code to FAC12 (BUG!!!)
[3357] 9760 BC,E0,04        ST   @FAC12,V@COD(@PABPTR) Pick up the I/O code
       9763 04,56
[3358] 9765 06,97,6B IOCLZ1 CALL CDSR              Call the DSR routine
[3359] 9768 57,97           BR   ERRZ2             Give I/O error on error
[3360] 976A 00              RTN                    Or else return
[3361]               * DSR CALL ROUTINE - NORMAL ENTRY
[3362] 976B BE,E0,0C CDSR   ST   OFFSET,V@SCR(@PABPTR)   Always set screen offse
       976E 04,60
[3363] 9770 35,00,1E        MOVE 30,@FAC,V@VROAZ   Save FAC area
       9773 A3,C0,4A
[3364] 9776 BD,56,04        DST  @PABPTR,@FAC12    Get PAB pointer in FAC
[3365] 9779 A3,56,00        DADD NLEN,@FAC12       Get PAB pointer in FAC
       977C 0D
[3366] 977D B2,E0,05        AND  >1F,V@FLG(@PABPTR) Clear error bits for ON ERRO
       9780 04,1F
[3367]               *                       time, I/O process can still be
[3368]               *                        continued
[3369] 9782 06,00,10        CALL CALDSR            Call actual DSR link routine
[3370] 9785 08              BYTE 8
[3371] 9786 35,00,1E        MOVE 30,V@VROAZ,@FAC
       9789 4A,A3,C0
[3372]               * MOVE does not affect status
[3373] 978C 77,93           BS   CDSRZ0            ERROR = ERROR = ERROR
[3374] 978E DA,E0,05        CLOG >E0,V@FLG(@PABPTR) Set COND if no error
       9791 04,E0

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0060 
FLMGR-359
[3375] 9793 01       CDSRZ0 RTNC
[3376]               * ERROR MESSAGES
[3377] 9794 06,80,FB ERRZ2B CALL CLRFRE            Undo allocation of PAB
[3378]               * First check is it error coming from AUTOLD
[3379]               * If it is then do not print the error messege and
[3380]               *  go back to TOPL02
[3381] 9797 31,00,02 ERRZ2  MOVE 2,G@TOPL02,V@AUTTMP
       979A A3,94,60
       979D 30
[3382] 979E D5,80,8A        DCEQ V@AUTTMP,@RSTK+2
       97A1 A3,94
[3383] 97A3 57,A9           BR   G97A9
[3384] 97A5 BE,73,8A        ST   RSTK+2,@SUBSTK
[3385] 97A8 00              RTN
[3386]               ***********************************************************
[3387]               * Next code is to avoid recursion of errors in CLSALL
[3388]               * routine. If this entry is taken from CLSALL, the stack
[3389]               * will contain CLSLBL as a retrun address in the third leve
[3390]               ***********************************************************
[3391] 97A9 A6,73,04 G97A9  SUB  4,@SUBSTK
[3392] 97AC D7,90,73        DCEQ CLSLBL,*SUBSTK
       97AF 81,E9
[3393] 97B1 57,B8           BR   G97B8
[3394] 97B3 06,6A,82 WRNIO  CALL WARNZZ            Give warning to the user
[3395] 97B6 23              BYTE 35                * I/O ERROR but warning
[3396] 97B7 00              RTN                    And return to close routine
[3397] 97B8 A2,73,04 G97B8  ADD  4,@SUBSTK         Back up two levels for OLD/SA
[3398] 97BB 06,6A,84 ERRIO  CALL ERRZZ
[3399] 97BE 24              BYTE 36                * I/O ERROR
[3400]               * ERROR messages called in this file
[3401] 97BF 06,6A,84 ERRSNM CALL ERRZZ
[3402] 97C2 07              BYTE 7                 * STRING-NUMBER MISMATCH
[3403] 97C3 06,6A,84 ERRIM  CALL ERRZZ
[3404] 97C6 0A              BYTE 10                * IMAGE ERROR
[3405] 97C7 06,6A,84 ERRMEM CALL ERRZZ
[3406] 97CA 0B              BYTE 11                * MEMORY FULL
[3407] 97CB 06,6A,84 ERRBV  CALL ERRZZ
[3408] 97CE 1E              BYTE 30                * BAD VALUE
[3409] 97CF 06,6A,84 ERRINP CALL ERRZZ
[3410] 97D2 20              BYTE 32                * INPUT ERROR
[3411] 97D3 06,6A,84 ERRDAT CALL ERRZZ
[3412] 97D6 21              BYTE 33                * DATA ERROR
[3413] 97D7 06,6A,84 ERRFE  CALL ERRZZ
[3414] 97DA 22              BYTE 34                * FILE ERROR
[3415] 97DB 06,6A,84 ERRPV  CALL ERRZZ
[3416] 97DE 27              BYTE 39                * PROTECTION VIOLATION
[3417] 97DF 06,6A,84 ERRMUV CALL ERRZZ
[3418] 97E2 09              BYTE 9                 * IMPROPERLY USED NAME
[3419]               * Other errors called in file
[3420]               * ERRSYN    * SYNTAX ERROR                        BYTE  3
[3421]               * ERRST     * STRING TRUNCATED ERROR              BYTE 19
[3422]               * WRNNPP    * NO PROGRAM PRESENT                  BYTE 29
[3423]               * WRNINP    * INPUT ERROR            (WARNING)    BYTE 32
[3424]               * ERRIO     * I/O ERROR                           BYTE 36
[3425]               * WRNIO     * I/O ERROR              (WARNING)    BYTE 36
[3426]               * WRNSNM    * STRING NO. MISMATCH    (WARNING)    BYTE  7
[3427]               ***********************************************************
[3428]               * The following section has been added to fix bugs in INPUT
[3429]               * ACCEPT, and LINPUT statements.
[3430]               ***********************************************************
[3431] 97E3 CA,42,80 BUG01  CHE  >80,@CHAT         Make sure of variable name
[3432] 97E6 61,09           BS   ERRSYN
[3433] 97E8 0F,7A           XML  SYM               Get the information of the
[3434] 97EA 0F,7B           XML  SMB                variable.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0061 
FLMGR-359
[3435] 97EC 00              RTN
[3436]               ***********************************************************
[3437]               * GKXB CODE HERE
[3438] 97ED BC,4C,42 GTLENG ST   @CHAT,@FAC+2      Moved from LIST routine
[3439] 97F0 BC,E0,08        ST   @XSTLN,V@8(@PABPTR) Store length
       97F3 04,64
[3440] 97F5 00              RTN                       and return
[3441]               ***********************************************************
[3442]                       AORG >1800
[3443]               ***********************************************************
[3444] 9800 20,5A,24 ALCEND  DATA >205A,>24F4,>4000,>AA55
       9803 F4,40,00
       9806 AA,55
[3445] 9808 20,38,20         DATA >2038,>2096,>2038,>217E
       980B 96,20,38
       980E 21,7E
[3446] 9810 20,38,21         DATA >2038,>21E2,>2038,>234C
       9813 E2,20,38
       9816 23,4C
[3447] 9818 20,38,24         DATA >2038,>2432,>2038,>246E
       981B 32,20,38
       981E 24,6E
[3448] 9820 20,38,24         DATA >2038,>2484,>2038,>2490
       9823 84,20,38
       9826 24,90
[3449] 9828 20,38,24         DATA >2038,>249E,>2038,>24AA
       982B 9E,20,38
       982E 24,AA
[3450] 9830 20,38,24         DATA >2038,>24B8,>2038,>2090
       9833 B8,20,38
       9836 20,90
[3451] 9838 00,00,00         DATA >0000,>0000,>0000,>0000
       983B 00,00,00
       983E 00,00
[3452] 9840 00,00,00         DATA >0000,>0000,>0000,>0000
       9843 00,00,00
       9846 00,00
[3453] 9848 00,00,00         DATA >0000,>0000,>0000,>0000
       984B 00,00,00
       984E 00,00
[3454] 9850 00,00,00         DATA >0000,>0000,>0000,>0000
       9853 00,00,00
       9856 00,00
[3455] 9858 65,20,C0         DATA >6520,>C060,>2004,>0281
       985B 60,20,04
       985E 02,81
[3456] 9860 40,00,13         DATA >4000,>130E,>C001,>0202
       9863 0E,C0,01
       9866 02,02
[3457] 9868 83,4A,8C         DATA >834A,>8CB0,>1606,>8CB0
       986B B0,16,06
       986E 8C,B0
[3458] 9870 16,04,8C         DATA >1604,>8CB0,>1602,>C030
       9873 B0,16,02
       9876 C0,30
[3459] 9878 04,50,02         DATA >0450,>0221,>0008,>10EF
       987B 21,00,08
       987E 10,EF
[3460] 9880 02,00,25         DATA >0200,>2500,>C800,>8322
       9883 00,C8,00
       9886 83,22
[3461] 9888 02,E0,83         DATA >02E0,>83E0,>0460,>00CE
       988B E0,04,60
       988E 00,CE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0062 
FLMGR-359
[3462] 9890 C8,1D,83         DATA >C81D,>8322,>10F9,>C01D
       9893 22,10,F9
       9896 C0,1D
[3463] 9898 C0,6D,00         DATA >C06D,>0002,>06A0,>20DC
       989B 02,06,A0
       989E 20,DC
[3464] 98A0 C0,C1,06         DATA >C0C1,>0603,>0223,>8300
       98A3 03,02,23
       98A6 83,00
[3465] 98A8 D0,D3,13         DATA >D0D3,>1361,>0983,>0643
       98AB 61,09,83
       98AE 06,43
[3466] 98B0 16,12,C0         DATA >1612,>C000,>165C,>C0C5
       98B3 00,16,5C
       98B6 C0,C5
[3467] 98B8 05,C3,06         DATA >05C3,>06A0,>2406,>1653
       98BB A0,24,06
       98BE 16,53
[3468] 98C0 05,C3,06         DATA >05C3,>06A0,>23CA,>0204
       98C3 A0,23,CA
       98C6 02,04
[3469] 98C8 83,4A,02         DATA >834A,>0202,>0008,>DC74
       98CB 02,00,08
       98CE DC,74
[3470] 98D0 06,02,15         DATA >0602,>15FD,>0380,>06A0
       98D3 FD,03,80
       98D6 06,A0
[3471] 98D8 20,F8,10         DATA >20F8,>10F5,>C041,>1347
       98DB F5,C0,41
       98DE 13,47
[3472] 98E0 0A,81,90         DATA >0A81,>9060,>8312,>1143
       98E3 60,83,12
       98E6 11,43
[3473] 98E8 09,81,C1         DATA >0981,>C141,>0A35,>0225
       98EB 41,0A,35
       98EE 02,25
[3474] 98F0 00,08,A1         DATA >0008,>A160,>8310,>045B
       98F3 60,83,10
       98F6 04,5B
[3475] 98F8 C2,4B,06         DATA >C24B,>0643,>1634,>C0C5
       98FB 43,16,34
       98FE C0,C5
[3476] 9900 06,A0,23         DATA >06A0,>23CA,>C0C1,>06A0
       9903 CA,C0,C1
       9906 06,A0
[3477] 9908 24,06,11         DATA >2406,>112D,>06A0,>211C
       990B 2D,06,A0
       990E 21,1C
[3478] 9910 06,A0,23         DATA >06A0,>23CA,>6004,>0A30
       9913 CA,60,04
       9916 0A,30
[3479] 9918 A0,40,04         DATA >A040,>0459,>C28B,>0A51
       991B 59,C2,8B
       991E 0A,51
[3480] 9920 09,D1,C2         DATA >09D1,>C201,>D120,>8343
       9923 01,D1,20
       9926 83,43
[3481] 9928 09,84,13         DATA >0984,>1303,>0600,>1123
       992B 03,06,00
       992E 11,23
[3482] 9930 05,80,02         DATA >0580,>0206,>0001,>C0C5
       9933 06,00,01
       9936 C0,C5
[3483] 9938 02,23,00         DATA >0223,>0004,>06A0,>23CA

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0063 
FLMGR-359
       993B 04,06,A0
       993E 23,CA
[3484] 9940 C0,C1,06         DATA >C0C1,>0643,>05C3,>06A0
       9943 43,05,C3
       9946 06,A0
[3485] 9948 23,CA,05         DATA >23CA,>0581,>6044,>3981
       994B 81,60,44
       994E 39,81
[3486] 9950 C1,86,16         DATA >C186,>1611,>C187,>0608
       9953 11,C1,87
       9956 06,08
[3487] 9958 15,F5,06         DATA >15F5,>0606,>A184,>8180
       995B 06,A1,84
       995E 81,80
[3488] 9960 15,0A,05         DATA >150A,>05C3,>045A,>0200
       9963 C3,04,5A
       9966 02,00
[3489] 9968 07,00,04         DATA >0700,>0460,>2084,>0200
       996B 60,20,84
       996E 02,00
[3490] 9970 1C,00,04         DATA >1C00,>0460,>2084,>0200
       9973 60,20,84
       9976 02,00
[3491] 9978 14,00,04         DATA >1400,>0460,>2084,>C01D
       997B 60,20,84
       997E C0,1D
[3492] 9980 C0,6D,00         DATA >C06D,>0002,>06A0,>20DC
       9983 02,06,A0
       9986 20,DC
[3493] 9988 C0,C1,06         DATA >C0C1,>0603,>0223,>8300
       998B 03,02,23
       998E 83,00
[3494] 9990 D0,D3,09         DATA >D0D3,>0983,>160E,>C000
       9993 83,16,0E
       9996 C0,00
[3495] 9998 16,22,02         DATA >1622,>0202,>0008,>0204
       999B 02,00,08
       999E 02,04
[3496] 99A0 83,4A,C0         DATA >834A,>C0C5,>06A0,>23CA
       99A3 C5,06,A0
       99A6 23,CA
[3497] 99A8 CD,01,05         DATA >CD01,>05C3,>0642,>15FA
       99AB C3,06,42
       99AE 15,FA
[3498] 99B0 03,80,06         DATA >0380,>0643,>160F,>C000
       99B3 43,16,0F
       99B6 C0,00
[3499] 99B8 16,12,C0         DATA >1612,>C0C5,>05C3,>06A0
       99BB C5,05,C3
       99BE 06,A0
[3500] 99C0 24,06,16         DATA >2406,>160B,>05C3,>06A0
       99C3 0B,05,C3
       99C6 06,A0
[3501] 99C8 23,CA,C1         DATA >23CA,>C101,>0201,>834A
       99CB 01,02,01
       99CE 83,4A
[3502] 99D0 04,60,20         DATA >0460,>20CA,>06A0,>20F8
       99D3 CA,06,A0
       99D6 20,F8
[3503] 99D8 10,F8,04         DATA >10F8,>0460,>2166,>0460
       99DB 60,21,66
       99DE 04,60
[3504] 99E0 21,6E,C8         DATA >216E,>C81D,>2038,>C82D
       99E3 1D,20,38

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0064 
FLMGR-359
       99E6 C8,2D
[3505] 99E8 00,02,83         DATA >0002,>83E2,>C82D,>0004
       99EB E2,C8,2D
       99EE 00,04
[3506] 99F0 20,44,02         DATA >2044,>02E0,>83E0,>C80B
       99F3 E0,83,E0
       99F6 C8,0B
[3507] 99F8 20,40,C0         DATA >2040,>C020,>2044,>06A0
       99FB 20,20,44
       99FE 06,A0
[3508] 9A00 20,DC,C0         DATA >20DC,>C0C1,>0603,>0223
       9A03 C1,06,03
       9A06 02,23
[3509] 9A08 83,00,D0         DATA >8300,>D0D3,>0983,>0603
       9A0B D3,09,83
       9A0E 06,03
[3510] 9A10 13,32,06         DATA >1332,>0643,>164A,>C2A0
       9A13 43,16,4A
       9A16 C2,A0
[3511] 9A18 20,38,16         DATA >2038,>162D,>C0C5,>05C3
       9A1B 2D,C0,C5
       9A1E 05,C3
[3512] 9A20 06,A0,24         DATA >06A0,>2406,>9801,>2058
       9A23 06,98,01
       9A26 20,58
[3513] 9A28 16,20,02         DATA >1620,>0206,>0008,>0204
       9A2B 06,00,08
       9A2E 02,04
[3514] 9A30 83,4A,C0         DATA >834A,>C0C5,>06A0,>23CA
       9A33 C5,06,A0
       9A36 23,CA
[3515] 9A38 CD,01,05         DATA >CD01,>05C3,>0646,>15FA
       9A3B C3,06,46
       9A3E 15,FA
[3516] 9A40 06,A0,22         DATA >06A0,>22DA,>0225,>0004
       9A43 DA,02,25
       9A46 00,04
[3517] 9A48 C1,05,C0         DATA >C105,>C046,>06A0,>23E6
       9A4B 46,06,A0
       9A4E 23,E6
[3518] 9A50 05,C4,D0         DATA >05C4,>D050,>0981,>06A0
       9A53 50,09,81
       9A56 06,A0
[3519] 9A58 23,E6,C2         DATA >23E6,>C2E0,>2040,>C820
       9A5B E0,20,40
       9A5E C8,20
[3520] 9A60 20,3E,83         DATA >203E,>830C,>02E0,>2038
       9A63 0C,02,E0
       9A66 20,38
[3521] 9A68 03,80,02         DATA >0380,>0200,>0700,>C2E0
       9A6B 00,07,00
       9A6E C2,E0
[3522] 9A70 20,40,04         DATA >2040,>0460,>2084,>0200
       9A73 60,20,84
       9A76 02,00
[3523] 9A78 1C,00,04         DATA >1C00,>0460,>226E,>C08B
       9A7B 60,22,6E
       9A7E C0,8B
[3524] 9A80 06,43,16         DATA >0643,>16F3,>C0C5,>06A0
       9A83 F3,C0,C5
       9A86 06,A0
[3525] 9A88 23,CA,C0         DATA >23CA,>C0C1,>06A0,>2406
       9A8B C1,06,A0
       9A8E 24,06

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0065 
FLMGR-359
[3526] 9A90 11,02,04         DATA >1102,>0460,>226A,>C020
       9A93 60,22,6A
       9A96 C0,20
[3527] 9A98 20,38,06         DATA >2038,>06A0,>211C,>6004
       9A9B A0,21,1C
       9A9E 60,04
[3528] 9AA0 0A,10,A0         DATA >0A10,>A0C0,>06A0,>23CA
       9AA3 C0,06,A0
       9AA6 23,CA
[3529] 9AA8 04,52,06         DATA >0452,>06A0,>227E,>0206
       9AAB A0,22,7E
       9AAE 02,06
[3530] 9AB0 83,4A,CD         DATA >834A,>CD83,>DDA0,>2058
       9AB3 83,DD,A0
       9AB6 20,58
[3531] 9AB8 DD,84,CD         DATA >DD84,>CD81,>C0C1,>1602
       9ABB 81,C0,C1
       9ABE 16,02
[3532] 9AC0 04,D6,10         DATA >04D6,>1005,>0603,>06A0
       9AC3 05,06,03
       9AC6 06,A0
[3533] 9AC8 24,06,09         DATA >2406,>0981,>C581,>C020
       9ACB 81,C5,81
       9ACE C0,20
[3534] 9AD0 20,44,06         DATA >2044,>06A0,>22DA,>0460
       9AD3 A0,22,DA
       9AD6 04,60
[3535] 9AD8 22,5A,C8         DATA >225A,>C80B,>203A,>C805
       9ADB 0B,20,3A
       9ADE C8,05
[3536] 9AE0 20,3C,C2         DATA >203C,>C2E0,>601E,>069B
       9AE3 E0,60,1E
       9AE6 06,9B
[3537] 9AE8 C0,20,20         DATA >C020,>2044,>C160,>203C
       9AEB 44,C1,60
       9AEE 20,3C
[3538] 9AF0 D1,90,09         DATA >D190,>0986,>C820,>830C
       9AF3 86,C8,20
       9AF6 83,0C
[3539] 9AF8 20,3E,C8         DATA >203E,>C806,>830C,>C806
       9AFB 06,83,0C
       9AFE C8,06
[3540] 9B00 83,50,C2         DATA >8350,>C2E0,>6012,>069B
       9B03 E0,60,12
       9B06 06,9B
[3541] 9B08 C0,20,20         DATA >C020,>2044,>0206,>834A
       9B0B 44,02,06
       9B0E 83,4A
[3542] 9B10 02,04,00         DATA >0204,>001C,>CD84,>DDA0
       9B13 1C,CD,84
       9B16 DD,A0
[3543] 9B18 20,58,DD         DATA >2058,>DD84,>C5A0,>831C
       9B1B 84,C5,A0
       9B1E 83,1C
[3544] 9B20 C0,A0,83         DATA >C0A0,>830C,>1309,>C116
       9B23 0C,13,09
       9B26 C1,16
[3545] 9B28 C0,C0,05         DATA >C0C0,>0583,>D073,>06A0
       9B2B 83,D0,73
       9B2E 06,A0
[3546] 9B30 24,1A,05         DATA >241A,>0584,>0602,>15FA
       9B33 84,06,02
       9B36 15,FA
[3547] 9B38 C2,E0,60         DATA >C2E0,>6028,>069B,>C020

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0066 
FLMGR-359
       9B3B 28,06,9B
       9B3E C0,20
[3548] 9B40 20,44,C1         DATA >2044,>C160,>203C,>C2E0
       9B43 60,20,3C
       9B46 C2,E0
[3549] 9B48 20,3A,04         DATA >203A,>045B,>C01D,>C06D
       9B4B 5B,C0,1D
       9B4E C0,6D
[3550] 9B50 00,02,06         DATA >0002,>06A0,>20DC,>C0C1
       9B53 A0,20,DC
       9B56 C0,C1
[3551] 9B58 06,03,02         DATA >0603,>0223,>8300,>D0D3
       9B5B 23,83,00
       9B5E D0,D3
[3552] 9B60 09,83,06         DATA >0983,>0603,>1302,>0643
       9B63 03,13,02
       9B66 06,43
[3553] 9B68 16,23,C0         DATA >1623,>C000,>1628,>C02D
       9B6B 00,16,28
       9B6E C0,2D
[3554] 9B70 00,04,C0         DATA >0004,>C0C5,>05C3,>06A0
       9B73 C5,05,C3
       9B76 06,A0
[3555] 9B78 24,06,98         DATA >2406,>9801,>2058,>161D
       9B7B 01,20,58
       9B7E 16,1D
[3556] 9B80 05,C3,06         DATA >05C3,>06A0,>23CA,>C041
       9B83 A0,23,CA
       9B86 C0,41
[3557] 9B88 13,07,C1         DATA >1307,>C181,>0601,>C0C1
       9B8B 81,06,01
       9B8E C0,C1
[3558] 9B90 06,A0,24         DATA >06A0,>2406,>9050,>1A15
       9B93 06,90,50
       9B96 1A,15
[3559] 9B98 DC,01,13         DATA >DC01,>1309,>C0C6,>0981
       9B9B 09,C0,C6
       9B9E 09,81
[3560] 9BA0 C1,41,06         DATA >C141,>06A0,>2406,>DC01
       9BA3 A0,24,06
       9BA6 DC,01
[3561] 9BA8 05,83,06         DATA >0583,>0605,>15FA,>0380
       9BAB 05,15,FA
       9BAE 03,80
[3562] 9BB0 06,A0,22         DATA >06A0,>227E,>C02D,>0004
       9BB3 7E,C0,2D
       9BB6 00,04
[3563] 9BB8 10,E6,04         DATA >10E6,>0460,>2166,>0460
       9BBB 60,21,66
       9BBE 04,60
[3564] 9BC0 21,6E,02         DATA >216E,>0200,>1300,>0460
       9BC3 00,13,00
       9BC6 04,60
[3565] 9BC8 20,84,06         DATA >2084,>06C3,>D803,>8C02
       9BCB C3,D8,03
       9BCE 8C,02
[3566] 9BD0 06,C3,D8         DATA >06C3,>D803,>8C02,>1000
       9BD3 03,8C,02
       9BD6 10,00
[3567] 9BD8 D0,60,88         DATA >D060,>8800,>06C1,>D060
       9BDB 00,06,C1
       9BDE D0,60
[3568] 9BE0 88,00,06         DATA >8800,>06C1,>045B,>06C4
       9BE3 C1,04,5B

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0067 
FLMGR-359
       9BE6 06,C4
[3569] 9BE8 D8,04,8C         DATA >D804,>8C02,>06C4,>0264
       9BEB 02,06,C4
       9BEE 02,64
[3570] 9BF0 40,00,D8         DATA >4000,>D804,>8C02,>1000
       9BF3 04,8C,02
       9BF6 10,00
[3571] 9BF8 D8,01,8C         DATA >D801,>8C00,>06C1,>D801
       9BFB 00,06,C1
       9BFE D8,01
[3572] 9C00 8C,00,06         DATA >8C00,>06C1,>045B,>06C3
       9C03 C1,04,5B
       9C06 06,C3
[3573] 9C08 D8,03,8C         DATA >D803,>8C02,>06C3,>D803
       9C0B 02,06,C3
       9C0E D8,03
[3574] 9C10 8C,02,10         DATA >8C02,>1000,>D060,>8800
       9C13 00,D0,60
       9C16 88,00
[3575] 9C18 04,5B,06         DATA >045B,>06C4,>D804,>8C02
       9C1B C4,D8,04
       9C1E 8C,02
[3576] 9C20 06,C4,02         DATA >06C4,>0264,>4000,>D804
       9C23 64,40,00
       9C26 D8,04
[3577] 9C28 8C,02,10         DATA >8C02,>1000,>D801,>8C00
       9C2B 00,D8,01
       9C2E 8C,00
[3578] 9C30 04,5B,C8         DATA >045B,>C83E,>83E2,>02E0
       9C33 3E,83,E2
       9C36 02,E0
[3579] 9C38 83,E0,C8         DATA >83E0,>C80B,>204E,>C081
       9C3B 0B,20,4E
       9C3E C0,81
[3580] 9C40 02,81,00         DATA >0281,>0040,>1B0A,>C0A1
       9C43 40,1B,0A
       9C46 C0,A1
[3581] 9C48 60,10,02         DATA >6010,>0281,>0004,>1605
       9C4B 81,00,04
       9C4E 16,05
[3582] 9C50 C0,A2,00         DATA >C0A2,>0002,>0692,>2466
       9C53 02,06,92
       9C56 24,66
[3583] 9C58 10,01,06         DATA >1001,>0692,>02E0,>2038
       9C5B 92,02,E0
       9C5E 20,38
[3584] 9C60 C8,0B,83         DATA >C80B,>83F6,>0380,>0200
       9C63 F6,03,80
       9C66 02,00
[3585] 9C68 0B,00,04         DATA >0B00,>0460,>2084,>02E0
       9C6B 60,20,84
       9C6E 02,E0
[3586] 9C70 83,E0,C8         DATA >83E0,>C80B,>204E,>06A0
       9C73 0B,20,4E
       9C76 06,A0
[3587] 9C78 00,0E,02         DATA >000E,>02E0,>2038,>C80B
       9C7B E0,20,38
       9C7E C8,0B
[3588] 9C80 83,F6,03         DATA >83F6,>0380,>06A0,>24CA
       9C83 80,06,A0
       9C86 24,CA
[3589] 9C88 D8,2D,00         DATA >D82D,>0002,>8C00,>0380
       9C8B 02,8C,00
       9C8E 03,80

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0068 
FLMGR-359
[3590] 9C90 06,A0,24         DATA >06A0,>24CA,>D831,>8C00
       9C93 CA,D8,31
       9C96 8C,00
[3591] 9C98 06,02,16         DATA >0602,>16FC,>0380,>06A0
       9C9B FC,03,80
       9C9E 06,A0
[3592] 9CA0 24,D0,DB         DATA >24D0,>DB60,>8800,>0002
       9CA3 60,88,00
       9CA6 00,02
[3593] 9CA8 03,80,06         DATA >0380,>06A0,>24D0,>DC60
       9CAB A0,24,D0
       9CAE DC,60
[3594] 9CB0 88,00,06         DATA >8800,>0602,>16FC,>0380
       9CB3 02,16,FC
       9CB6 03,80
[3595] 9CB8 C0,5D,D8         DATA >C05D,>D82D,>0001,>8C02
       9CBB 2D,00,01
       9CBE 8C,02
[3596] 9CC0 02,61,80         DATA >0261,>8000,>D801,>8C02
       9CC3 00,D8,01
       9CC6 8C,02
[3597] 9CC8 03,80,02         DATA >0380,>0201,>4000,>1001
       9CCB 01,40,00
       9CCE 10,01
[3598] 9CD0 04,C1,C0         DATA >04C1,>C09D,>D820,>203D
       9CD3 9D,D8,20
       9CD6 20,3D
[3599] 9CD8 8C,02,E0         DATA >8C02,>E081,>D802,>8C02
       9CDB 81,D8,02
       9CDE 8C,02
[3600] 9CE0 C0,6D,00         DATA >C06D,>0002,>C0AD,>0004
       9CE3 02,C0,AD
       9CE6 00,04
[3601] 9CE8 04,5B            DATA >045B
[3602]               ***********************************************************
[3603] 9CEA 10,10,10 CHARS  BYTE >10,>10,>10,>10,>10,>00,>10    * ! 33
       9CED 10,10,00
       9CF0 10
[3604] 9CF1 50,50,50        BYTE >50,>50,>50,>00,>00,>00,>00    * " 34
       9CF4 00,00,00
       9CF7 00
[3605] 9CF8 50,50,F8        BYTE >50,>50,>F8,>50,>F8,>50,>50    * # 35
       9CFB 50,F8,50
       9CFE 50
[3606] 9CFF 20,78,A0        BYTE >20,>78,>A0,>70,>28,>F0,>20    * $ 36
       9D02 70,28,F0
       9D05 20
[3607] 9D06 C0,C8,10        BYTE >C0,>C8,>10,>20,>40,>98,>18    * % 37
       9D09 20,40,98
       9D0C 18
[3608] 9D0D 40,A0,A0        BYTE >40,>A0,>A0,>40,>A8,>90,>68    * & 38
       9D10 40,A8,90
       9D13 68
[3609] 9D14 C0,40,80        BYTE >C0,>40,>80,>00,>00,>00,>00    * ' 39
       9D17 00,00,00
       9D1A 00
[3610] 9D1B 08,10,20        BYTE >08,>10,>20,>20,>20,>10,>08    * ( 40
       9D1E 20,20,10
       9D21 08
[3611] 9D22 10,08,04        BYTE >10,>08,>04,>04,>04,>08,>10    * ) 41
       9D25 04,04,08
       9D28 10
[3612] 9D29 00,28,10        BYTE >00,>28,>10,>7C,>10,>28,>00    * * 42  
       9D2C 7C,10,28

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0069 
FLMGR-359
       9D2F 00
[3613] 9D30 00,10,10        BYTE >00,>10,>10,>7C,>10,>10,>00    * + 43
       9D33 7C,10,10
       9D36 00
[3614] 9D37 00,00,00        BYTE >00,>00,>00,>00,>60,>20,>40    * , 44
       9D3A 00,60,20
       9D3D 40
[3615] 9D3E 00,00,00        BYTE >00,>00,>00,>F8,>00,>00,>00    * - 45
       9D41 F8,00,00
       9D44 00
[3616] 9D45 00,00,00        BYTE >00,>00,>00,>00,>00,>60,>60    * . 46
       9D48 00,00,60
       9D4B 60
[3617] 9D4C 00,08,10        BYTE >00,>08,>10,>20,>40,>80,>00    * / 47
       9D4F 20,40,80
       9D52 00
[3618] 9D53 70,88,98        BYTE >70,>88,>98,>A8,>C8,>88,>70    * 0 48
       9D56 A8,C8,88
       9D59 70
[3619] 9D5A 20,60,20        BYTE >20,>60,>20,>20,>20,>20,>70    * 1 49
       9D5D 20,20,20
       9D60 70
[3620] 9D61 70,88,08        BYTE >70,>88,>08,>30,>40,>80,>F8    * 2 50
       9D64 30,40,80
       9D67 F8
[3621] 9D68 70,88,08        BYTE >70,>88,>08,>30,>08,>88,>70    * 3 51
       9D6B 30,08,88
       9D6E 70
[3622] 9D6F 10,30,50        BYTE >10,>30,>50,>90,>F8,>10,>10    * 4 52
       9D72 90,F8,10
       9D75 10
[3623] 9D76 F0,80,80        BYTE >F0,>80,>80,>F0,>08,>88,>70    * 5 53
       9D79 F0,08,88
       9D7C 70
[3624] 9D7D 70,80,80        BYTE >70,>80,>80,>F0,>88,>88,>70    * 6 54
       9D80 F0,88,88
       9D83 70
[3625] 9D84 F8,08,10        BYTE >F8,>08,>10,>20,>40,>40,>40    * 7 55
       9D87 20,40,40
       9D8A 40
[3626] 9D8B 70,88,88        BYTE >70,>88,>88,>70,>88,>88,>70    * 8 56
       9D8E 70,88,88
       9D91 70
[3627] 9D92 70,88,88        BYTE >70,>88,>88,>78,>08,>88,>70    * 9 57
       9D95 78,08,88
       9D98 70
[3628] 9D99 00,60,60        BYTE >00,>60,>60,>00,>60,>60,>00    * : 58
       9D9C 00,60,60
       9D9F 00
[3629] 9DA0 00,60,60        BYTE >00,>60,>60,>00,>60,>20,>40    * ; 59
       9DA3 00,60,20
       9DA6 40
[3630] 9DA7 08,10,20        BYTE >08,>10,>20,>40,>20,>10,>08    * < 60
       9DAA 40,20,10
       9DAD 08
[3631] 9DAE 00,7C,00        BYTE >00,>7C,>00,>00,>7C,>00,>00    * = 61
       9DB1 00,7C,00
       9DB4 00
[3632] 9DB5 20,10,08        BYTE >20,>10,>08,>04,>08,>10,>20    * > 62
       9DB8 04,08,10
       9DBB 20
[3633] 9DBC 70,88,10        BYTE >70,>88,>10,>20,>20,>00,>20    * ? 63
       9DBF 20,20,00
       9DC2 20

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0070 
FLMGR-359
[3634] 9DC3 38,44,5C        BYTE >38,>44,>5C,>54,>5C,>40,>38    * @ 64
       9DC6 54,5C,40
       9DC9 38
[3635] 9DCA 70,88,88        BYTE >70,>88,>88,>F8,>88,>88,>88    * A 65
       9DCD F8,88,88
       9DD0 88
[3636] 9DD1 F0,48,48        BYTE >F0,>48,>48,>70,>48,>48,>F0    * B 66
       9DD4 70,48,48
       9DD7 F0
[3637] 9DD8 70,88,80        BYTE >70,>88,>80,>80,>80,>88,>70    * C 67
       9DDB 80,80,88
       9DDE 70
[3638] 9DDF F0,48,48        BYTE >F0,>48,>48,>48,>48,>48,>F0    * D 68
       9DE2 48,48,48
       9DE5 F0
[3639] 9DE6 F8,80,80        BYTE >F8,>80,>80,>F0,>80,>80,>F8    * E 69
       9DE9 F0,80,80
       9DEC F8
[3640] 9DED F8,80,80        BYTE >F8,>80,>80,>F0,>80,>80,>80    * F 70
       9DF0 F0,80,80
       9DF3 80
[3641] 9DF4 70,88,80        BYTE >70,>88,>80,>80,>98,>88,>78    * G 71
       9DF7 80,98,88
       9DFA 78
[3642] 9DFB 88,88,88        BYTE >88,>88,>88,>F8,>88,>88,>88    * H 72
       9DFE F8,88,88
       9E01 88
[3643] 9E02 F8,20,20        BYTE >F8,>20,>20,>20,>20,>20,>F8    * I 73
       9E05 20,20,20
       9E08 F8
[3644] 9E09 08,08,08        BYTE >08,>08,>08,>08,>08,>88,>70    * J 74
       9E0C 08,08,88
       9E0F 70
[3645] 9E10 88,90,A0        BYTE >88,>90,>A0,>C0,>A0,>90,>88    * K 75
       9E13 C0,A0,90
       9E16 88
[3646] 9E17 80,80,80        BYTE >80,>80,>80,>80,>80,>80,>F8    * L 76
       9E1A 80,80,80
       9E1D F8
[3647] 9E1E 88,D8,A8        BYTE >88,>D8,>A8,>A8,>88,>88,>88    * M 77
       9E21 A8,88,88
       9E24 88
[3648] 9E25 88,88,C8        BYTE >88,>88,>C8,>A8,>98,>88,>88    * N 78
       9E28 A8,98,88
       9E2B 88
[3649] 9E2C 70,88,88        BYTE >70,>88,>88,>88,>88,>88,>70    * O 79
       9E2F 88,88,88
       9E32 70
[3650] 9E33 F0,88,88        BYTE >F0,>88,>88,>88,>F0,>80,>80    * P 80
       9E36 88,F0,80
       9E39 80
[3651] 9E3A 70,88,88        BYTE >70,>88,>88,>88,>A8,>90,>68    * Q 81
       9E3D 88,A8,90
       9E40 68
[3652] 9E41 F0,88,88        BYTE >F0,>88,>88,>F0,>A0,>90,>88    * R 82
       9E44 F0,A0,90
       9E47 88
[3653] 9E48 70,88,80        BYTE >70,>88,>80,>70,>08,>88,>70    * S 83
       9E4B 70,08,88
       9E4E 70
[3654] 9E4F F8,20,20        BYTE >F8,>20,>20,>20,>20,>20,>20    * T 84
       9E52 20,20,20
       9E55 20
[3655] 9E56 44,44,44        BYTE >44,>44,>44,>44,>44,>44,>38    * U 85

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0071 
FLMGR-359
       9E59 44,44,44
       9E5C 38
[3656] 9E5D 44,44,44        BYTE >44,>44,>44,>28,>28,>10,>10    * V 86
       9E60 28,28,10
       9E63 10
[3657] 9E64 88,88,88        BYTE >88,>88,>88,>88,>A8,>A8,>50    * W 87
       9E67 88,A8,A8
       9E6A 50
[3658] 9E6B 88,88,50        BYTE >88,>88,>50,>20,>50,>88,>88    * X 88
       9E6E 20,50,88
       9E71 88
[3659] 9E72 88,88,88        BYTE >88,>88,>88,>50,>20,>20,>20    * Y 89
       9E75 50,20,20
       9E78 20
[3660] 9E79 F8,08,10        BYTE >F8,>08,>10,>20,>40,>80,>F8    * Z 90          
       9E7C 20,40,80
       9E7F F8
[3661] 9E80 78,40,40        BYTE >78,>40,>40,>40,>40,>40,>78    * [ 91
       9E83 40,40,40
       9E86 78
[3662] 9E87 00,80,40        BYTE >00,>80,>40,>20,>10,>08,>00    * \ 92
       9E8A 20,10,08
       9E8D 00
[3663] 9E8E F0,10,10        BYTE >F0,>10,>10,>10,>10,>10,>F0    * ] 93
       9E91 10,10,10
       9E94 F0
[3664] 9E95 20,50,88        BYTE >20,>50,>88,>00,>00,>00,>00    * ^ 94
       9E98 00,00,00
       9E9B 00
[3665] 9E9C 00,00,00        BYTE >00,>00,>00,>00,>00,>00,>FF    * _ 95
       9E9F 00,00,00
       9EA2 FF
[3666] 9EA3 18,10,08        BYTE >18,>10,>08,>00,>00,>00,>00    * ` 96
       9EA6 00,00,00
       9EA9 00
[3667] 9EAA 00,00,60        BYTE >00,>00,>60,>10,>70,>90,>68    * a 97
       9EAD 10,70,90
       9EB0 68
[3668] 9EB1 00,40,40        BYTE >00,>40,>40,>70,>48,>48,>B0    * b 98
       9EB4 70,48,48
       9EB7 B0
[3669] 9EB8 00,00,60        BYTE >00,>00,>60,>90,>80,>90,>60    * c 99
       9EBB 90,80,90
       9EBE 60
[3670] 9EBF 00,10,10        BYTE >00,>10,>10,>70,>90,>90,>68    * d 100
       9EC2 70,90,90
       9EC5 68
[3671] 9EC6 00,00,60        BYTE >00,>00,>60,>90,>E0,>80,>70    * e 101
       9EC9 90,E0,80
       9ECC 70
[3672] 9ECD 00,30,40        BYTE >00,>30,>40,>E0,>40,>40,>40    * f 102
       9ED0 E0,40,40
       9ED3 40
[3673] 9ED4 00,00,70        BYTE >00,>00,>70,>90,>70,>10,>60    * g 103
       9ED7 90,70,10
       9EDA 60
[3674] 9EDB 00,80,80        BYTE >00,>80,>80,>E0,>90,>90,>90    * h 104
       9EDE E0,90,90
       9EE1 90
[3675] 9EE2 00,20,00        BYTE >00,>20,>00,>20,>20,>20,>70    * i 105
       9EE5 20,20,20
       9EE8 70
[3676] 9EE9 00,10,10        BYTE >00,>10,>10,>10,>10,>90,>60    * j 106
       9EEC 10,10,90

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0072 
FLMGR-359
       9EEF 60
[3677] 9EF0 00,80,90        BYTE >00,>80,>90,>A0,>C0,>A0,>90    * k 107
       9EF3 A0,C0,A0
       9EF6 90
[3678] 9EF7 00,60,20        BYTE >00,>60,>20,>20,>20,>20,>70    * l 108
       9EFA 20,20,20
       9EFD 70
[3679] 9EFE 00,00,D0        BYTE >00,>00,>D0,>A8,>A8,>A8,>A8    * m 109
       9F01 A8,A8,A8
       9F04 A8
[3680] 9F05 00,00,B0        BYTE >00,>00,>B0,>48,>48,>48,>48    * n 110
       9F08 48,48,48
       9F0B 48
[3681] 9F0C 00,00,60        BYTE >00,>00,>60,>90,>90,>90,>60    * o 111
       9F0F 90,90,90
       9F12 60
[3682] 9F13 00,F0,48        BYTE >00,>F0,>48,>48,>70,>40,>40    * p 112
       9F16 48,70,40
       9F19 40
[3683] 9F1A 00,78,90        BYTE >00,>78,>90,>90,>70,>10,>10    * q 113
       9F1D 90,70,10
       9F20 10
[3684] 9F21 00,00,B0        BYTE >00,>00,>B0,>C8,>80,>80,>80    * r 114
       9F24 C8,80,80
       9F27 80
[3685] 9F28 00,00,70        BYTE >00,>00,>70,>80,>70,>08,>F0    * s 115
       9F2B 80,70,08
       9F2E F0
[3686] 9F2F 00,40,E0        BYTE >00,>40,>E0,>40,>40,>50,>20    * t 116
       9F32 40,40,50
       9F35 20
[3687] 9F36 00,00,90        BYTE >00,>00,>90,>90,>90,>90,>68    * u 117
       9F39 90,90,90
       9F3C 68
[3688] 9F3D 00,00,88        BYTE >00,>00,>88,>88,>88,>50,>20    * v 118
       9F40 88,88,50
       9F43 20
[3689] 9F44 00,00,88        BYTE >00,>00,>88,>88,>A8,>A8,>50    * w 119
       9F47 88,A8,A8
       9F4A 50
[3690] 9F4B 00,00,88        BYTE >00,>00,>88,>50,>20,>50,>88    * x 120
       9F4E 50,20,50
       9F51 88
[3691] 9F52 00,00,48        BYTE >00,>00,>48,>48,>38,>08,>70    * y 121
       9F55 48,38,08
       9F58 70
[3692] 9F59 00,00,F8        BYTE >00,>00,>F8,>10,>20,>40,>F8    * z 122
       9F5C 10,20,40
       9F5F F8
[3693] 9F60 18,20,20        BYTE >18,>20,>20,>40,>20,>20,>18    * { 123
       9F63 40,20,20
       9F66 18
[3694] 9F67 20,20,20        BYTE >20,>20,>20,>00,>20,>20,>20    * | 124
       9F6A 00,20,20
       9F6D 20
[3695] 9F6E C0,20,20        BYTE >C0,>20,>20,>10,>20,>20,>C0    * } 125
       9F71 10,20,20
       9F74 C0
[3696] 9F75 00,00,40        BYTE >00,>00,>40,>A8,>10,>00,>00    * ~ 126
       9F78 A8,10,00
       9F7B 00
[3697]               ***********************************************************
[3698] 9F7C D7,E0,02 CIV254 DCEQ >4956,V@2(@PGMPTR) * IV?
       9F7F 2C,49,56

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0073 
FLMGR-359
[3699] 9F82 41,09           BR   ERRSYN
[3700] 9F84 D7,E0,04        DCEQ >3235,V@4(@PGMPTR) * 25?
       9F87 2C,32,35
[3701] 9F8A 41,09           BR   ERRSYN
[3702] 9F8C D6,E0,06        CEQ  >34,V@6(@PGMPTR)   * 4?
       9F8F 2C,34
[3703] 9F91 41,09           BR   ERRSYN
[3704] 9F93 8E,80,84        CZ   @RAMTOP
[3705] 9F96 6E,2B           BS   SAZ1       
[3706] 9F98 CB,80,86        DCHE >FEE7,@RAMFRE      * MINIMUM SIZE TO SAVE IV254
       9F9B FE,E7
[3707] 9F9D 6E,2B           BS   SAZ1               * PROGRAM FORMAT
[3708] 9F9F 4E,B7           BR   GSAVE              * IV254 FORMAT
[3709]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0074 
FLMGR-359
Symbol Table #1 (New,alpha)  
834C AAA        8302 AAA1       00CB ABSZ       896B ACCEPT     00A4 ACCEPZ     
85E5 ACCNM      8A47 ACCPZ1     8A8F ACCPZ2     8ACB ACCPZ3     8B36 ACCPZ4     
8A7C ACCPZ5     8B2A ACCPZ6     8A74 ACCPZ7     8AFC ACCPZ8     8A4F ACCPZ9     
03B7 ACCTRY     8302 ACCUM      03AE ACCVRA     03AC ACCVRW     9800 ALCEND     
00EC ALLZ       00BB ANDZ       00F9 APPENZ     835D ARG1       8367 ARG11      
836B ARG15      836C ARG16      835E ARG2       835F ARG3       8360 ARG4       
8361 ARG5       8362 ARG6       8363 ARG7       8364 ARG8       A00A ASC        
00DC ASCZ       007C ASSGNV     00CC ATNZ       0022 ATNZZ      00F0 ATZ        
602E AUTO1      0394 AUTTMP     8A86 AZ1        0008 BACK       8343 BASE       
00F1 BASEZ      8350 BBB        830C BBB1       00EE BEEPZ      0020 BKGD       
0002 BREAK      008E BREAKZ     0006 BUF        038E BUFEND     8346 BUFLEV     
038C BUFSRT     97E3 BUG01      830C BYTES      0010 CALDSR     830A CALIST     
009D CALLZ      834E CCC        8308 CCC1       8308 CCPADD     8308 CCPADR     
8306 CCPPTR     976B CDSR       9793 CDSRZ0     0012 CFI        0018 CHAR2Z     
004A CHAR3Z     9CEA CHARS      8342 CHAT       810D CHECK      935C CHKCNV     
9371 CHKCON     95AD CHKEND     9355 CHKFN      937B CHKFZ1     92EC CHKNUM     
809F CHKPAR     9715 CHKREC     8834 CHKRM      9718 CHKRZ0     9733 CHKRZ1     
8328 CHKSEP     9323 CHKSTR     932F CHKSZ0     000D CHRTN      00D6 CHRZZ      
830E CHSAV      0080 CIF        00C5 CIRCUZ     9F7C CIV254     8196 CLOSE      
00A0 CLOSEZ     81C7 CLOSZ1     80FB CLRFRE     0007 CLRLN      81F4 CLSALL     
81E1 CLSAZ0     81E9 CLSLBL     0009 CNT        94B8 CNVDEF     94C1 CNVDZ0     
0004 COD        00B5 COLONZ     002C COMMA      00B3 COMMAZ     961A COMMOD     
0070 COMPCT     00B8 CONCZ      03BB CONFLG     82C9 CONPRT     0075 CONT       
0081 CONTIN     A012 CONVER     00CD COSZ       03BC CPTEMP     A040 CPUBAS     
0820 CRNBUF     08BE CRNEND     007F CRUNCH     0390 CSNTMP     03BA CSNTP1     
0002 CSTRIN     92DE CTMPST     92CD CTSTR      92D1 CTSTR0     830E CURINC     
8314 CURLIN     007E CURSOR     0001 CZCLOS     0007 CZDELE     0005 CZLOAD     
0000 CZOPEN     0002 CZREAD     0004 CZREST     0006 CZSAVE     0008 CZSCR      
0009 CZSTAT     0003 CZWRIT     8334 DATA       A008 DATAST     0093 DATAZ      
934B DATEND     8354 DDD1       0089 DEFZ       817C DELET      0099 DELETZ     
A010 DELINK     93A6 DELPAB     9440 DELPZ1     944C DELPZ2     0087 DELREP     
8306 DFLTLM     00E9 DIGITZ     008A DIMZ       94EF DISACC     8257 DISPL1     
00A2 DISPLZ     94F2 DISPZ1     00C4 DIVIZ      0003 DLETE      0024 DOLLAR     
000A DOWN       8317 DSRFLG     000A DWNARR     007F EDGECH     6032 EDITLN     
76F7 EDTZ00     76EB EDTZZ0     8350 EEE        8358 EEE1       0081 ELSEZ      
933E EMPSTR     02FE ENDSCR     008B ENDZ       8332 ENLN       91DE EOF        
9212 EOFZ2      8395 EOLEX      00BE EQUALZ     00EF ERASEZ     837C ERCODE     
97CB ERRBV      8322 ERRCOD     97D3 ERRDAT     97D7 ERRFE      97C3 ERRIM      
97CF ERRINP     97BB ERRIO      038A ERRLN      97C7 ERRMEM     97DF ERRMUV     
00A5 ERRORZ     97DB ERRPV      97BF ERRSNM     8109 ERRSYN     CD77 ERRTAB     
6A84 ERRZ       9797 ERRZ2      9794 ERRZ2B     6A84 ERRZZ      A004 EXEC       
A00C EXEC1      A00E EXEC6D     8376 EXPZ       00CE EXPZZ      832E EXTRAM     
834B FAC1       8354 FAC10      8355 FAC11      8356 FAC12      8357 FAC13      
8358 FAC14      8359 FAC15      835A FAC16      835B FAC17      834C FAC2       
834D FAC3       834E FAC4       834F FAC5       8350 FAC6       8351 FAC7       
8352 FAC8       8353 FAC9       834E FFF        8356 FFF1       0002 FIL        
0001 FILSPC     8120 FILZZ      00FA FIXEDZ     8345 FLAG       0005 FLG        
9216 FLOAT1     8317 FNUM       8317 FORNET     0009 FORW       008C FORZ       
8340 FREPTR     8125 G8125      8127 G8127      8131 G8131      8157 G8157      
815A G815A      8165 G8165      8169 G8169      81B8 G81B8      81DD G81DD      
8233 G8233      824E G824E      8288 G8288      8293 G8293      82BE G82BE      
82EC G82EC      830D G830D      834F G834F      83A1 G83A1      83B1 G83B1      
83BB G83BB      83C3 G83C3      8423 G8423      842E G842E      8430 G8430      
8438 G8438      8448 G8448      8460 G8460      8463 G8463      84A2 G84A2      
84C3 G84C3      84DB G84DB      851B G851B      8527 G8527      8540 G8540      
8562 G8562      8570 G8570      857C G857C      8581 G8581      8596 G8596      
85A4 G85A4      85B1 G85B1      860B G860B      861E G861E      8643 G8643      
8650 G8650      8661 G8661      867C G867C      867E G867E      86AB G86AB      
86AD G86AD      86C6 G86C6      86DB G86DB      872E G872E      873A G873A      
8752 G8752      875A G875A      8786 G8786      87CF G87CF      87E6 G87E6      
87EA G87EA      880F G880F      8840 G8840      885C G885C      887B G887B      
8885 G8885      8893 G8893      88AF G88AF      88BF G88BF      88D8 G88D8      
88DC G88DC      88E1 G88E1      890B G890B      8941 G8941      895A G895A      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0075 
FLMGR-359
898B G898B      89AA G89AA      89C0 G89C0      89E0 G89E0      89F3 G89F3      
89FD G89FD      8A13 G8A13      8A23 G8A23      8A33 G8A33      8A35 G8A35      
8A58 G8A58      8A66 G8A66      8A9E G8A9E      8AB2 G8AB2      8AB7 G8AB7      
8AC4 G8AC4      8AC8 G8AC8      8ADC G8ADC      8AEB G8AEB      8B0A G8B0A      
8B20 G8B20      8B38 G8B38      8B6B G8B6B      8B73 G8B73      8B8F G8B8F      
8BB3 G8BB3      8C15 G8C15      8C17 G8C17      8CBD G8CBD      8CBF G8CBF      
8CE9 G8CE9      8D6F G8D6F      8D7E G8D7E      8DAB G8DAB      8DAF G8DAF      
8DF4 G8DF4      8E33 G8E33      8E42 G8E42      8E91 G8E91      8EAD G8EAD      
8EFB G8EFB      8F1C G8F1C      8F88 G8F88      8FB6 G8FB6      8FCD G8FCD      
902A G902A      9094 G9094      9098 G9098      90A6 G90A6      90AE G90AE      
90CA G90CA      9128 G9128      912D G912D      9132 G9132      9138 G9138      
9140 G9140      9156 G9156      916D G916D      91B7 G91B7      91BB G91BB      
9210 G9210      9242 G9242      9275 G9275      9284 G9284      92A2 G92A2      
92B2 G92B2      92B6 G92B6      92EB G92EB      9303 G9303      9314 G9314      
9320 G9320      9348 G9348      938F G938F      93A5 G93A5      93C2 G93C2      
93CE G93CE      93E0 G93E0      93E6 G93E6      93F4 G93F4      93F7 G93F7      
9400 G9400      9411 G9411      9418 G9418      942C G942C      9431 G9431      
9451 G9451      946B G946B      9483 G9483      9495 G9495      949B G949B      
94B4 G94B4      94EE G94EE      9513 G9513      9518 G9518      9529 G9529      
9571 G9571      958F G958F      95A0 G95A0      95B7 G95B7      95B9 G95B9      
95D5 G95D5      95DC G95DC      95FC G95FC      9624 G9624      964F G964F      
96D3 G96D3      96E2 G96E2      9711 G9711      9730 G9730      973E G973E      
9751 G9751      97A9 G97A9      97B8 G97B8      008E GDTECT     9308 GETDAT     
9304 GETGFL     930C GETRAM     0071 GETSTR     928A GETVAR     9292 GETVZ0     
929B GETVZ1     92CC GETVZ2     0087 GOSUBZ     0086 GOTOZ      0085 GOZ        
9235 GPNAME     0085 GREAD      008C GREAD1     00C0 GREATZ     9179 GRMLST     
91A4 GRSUB2     91BC GRSUB3     91AA GRSUB4     8F44 GSAV1      8EB7 GSAVE      
97ED GTLENG     7A06 GTLIST     8F4A GVMOV      008B GVWITE     0086 GWRITE     
6036 GWSUB      8370 HIVDP      0084 IFZ        00A3 IMAGEZ     973F INITKB     
6014 INITPG     96C8 INITZ1     85F0 INPUT      03AA INPUTP     0092 INPUTZ     
892D INPUZ2     876B INPUZ3     8790 INPUZ4     87B4 INPUZ5     87D4 INPUZ6     
8822 INPUZ7     8768 INPZ2      86CC INPZ3      86E9 INPZ31     8728 INPZ32     
8765 INPZ33     8927 INPZ37     8936 INPZ39     87F6 INPZ65     8818 INPZ67     
0004 INSRT      88E8 INSU1      8906 INSUB1     893B INSUB2     00F5 INTERZ     
9754 INTKB0     8338 INTRIN     A018 INTRND     861B INTRZ0     862D INTRZ1     
869F INTRZ2     00CF INTZ       0084 IO         975E IOCALL     9765 IOCLZ1     
833C IOSTRT     8374 KEYBD      CB00 KEYTAB     6022 KILSYM     0008 LEN        
00D5 LENZ       00BF LESSZ      008D LETZ       A006 LINE       A026 LINK1      
885F LINP10     8841 LINPUT     00AA LINPUZ     8312 LINUM      9068 LIST       
0002 LISTZ      908D LISTZ0     90FB LISTZ1     914E LISTZ3     915F LISTZ4     
914B LISTZ5     A002 LITS05     6A74 LLIST      8336 LNBUF      00C9 LNZ        
0371 LODFLG     00D0 LOGZ       00B7 LPARZ      8EB1 LRTOPL     8D32 LRTOPZ     
8348 LSUBP      00DF MAXZ       0072 MEMCHK     9002 MERGE      0008 MERGEZ     
905B MERGZ1     002D MINUS      00C2 MINUSZ     00E0 MINZ       8302 MNUM       
837A MOTION     039E MRGPAB     6053 MSGTA      00C3 MULTZ      0088 MVDN       
0089 MVUP       6038 MZMSG      03BE NEWTOP     0096 NEXTZ      000D NLEN       
02E2 NLNADD     8314 NMLEN      830C NMPTR      0374 NOTONE     00BD NOTZ       
8328 NUDTAB     00FD NUMBEZ     0000 NUMBR      00C8 NUMCOZ     00E8 NUMERZ     
00C8 NUMZ       95BA NXTCHR     95C9 NXTCZ0     0060 OFFSET     0003 OFS        
8BC4 OLD        8BCA OLD1       821F OLDCD      8227 OLDCZ0     823A OLDCZ1     
8D2D OLDER      03BC OLDTOP     0005 OLDZ       8D8E OLDZ2      8C63 OLDZ3      
8C32 OLDZ5      8C5A OLDZ7      8D16 OLDZ9      8CDE OLZZ       009B ONZ        
8032 OPEN       009F OPENZ      8106 OPERR      8317 OPTFLG     8045 OPTION     
009E OPTIOZ     8047 OPTIZ0     804C OPTIZ1     8072 OPTZ0      80BE OPTZ01     
807C OPTZ02     80E5 OPTZ03     8081 OPTZ1      80A8 OPTZ2      80AD OPTZ3      
80B7 OPTZ4      80C3 OPTZ5      80DB OPTZ55     80EA OPTZ6      80F4 OPTZ7      
00BA ORZ        970E OSTRNG     8308 OTHEZ0     8303 OTHEZ1     9390 OUTEOF     
00F7 OUTPUZ     96A5 OUTREC     9170 PAB        8FF9 PAB1       8D24 PAB3       
000E PABLEN     8304 PABPTR     965A PARFN      94C2 PARREC     0074 PARSE      
00FB PERMAZ     0079 PGMCHR     832C PGMPTR     00DD PIZ        00C1 PLUSZ      
00D9 POSZ       8377 PRCOL      83A4 PREXIT     8344 PRGFLG     96F5 PRINIT     
8266 PRINT      009C PRINTZ     82B1 PRINZ0     82C4 PRINZ1     82A5 PRNZ10     
837A PRSEM      8381 PRSMZ1     832D PRTAB      835C PRTCOM     83CE PRTNFN     
9701 PRZZ0      03B7 PSCFG      0022 QUOTE      8389 RAMFLG     8386 RAMFRE     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0076 
FLMGR-359
830A RAMPTR     8384 RAMTOP     8378 RANDOM     0095 RANDOZ     8B3A READ       
6A86 READL1     6A76 READLN     0097 READZ      0006 RECALL     08C0 RECBUF     
8827 RECENT     8307 RECLEN     00DE RECZ       00F4 RELATZ     8D36 RELOCA     
8DB3 RELOZ1     009A REMZ       0006 RESEQZ     81FC RESTOR     0094 RESTOZ     
CF68 RETNOS     0088 RETURZ     8375 RKEY       00D7 RNDZ       000A RNM        
00B6 RPARZ      00E1 RPTZZ      8388 RSTK       960B RSTRING    938C RTC        
8326 RTNG       00A9 RUNZ       03B9 SAPROT     8DB8 SAVE       0388 SAVEVP     
0007 SAVEZ      7795 SAVLIN     8F76 SAVMG      8E2B SAZ1       0384 SBUFLV     
007D SCHSYM     008F SCNSMT     000C SCR        02E0 SCRNBS     96CC SCRO       
0083 SCROLL     883A SCRZ       8B99 SEARCH     0003 SEETWO     00D8 SEGZZ      
00B4 SEMICZ     00F6 SEQUEZ     89A2 SETVW      0386 SEXTRM     0398 SFLAG      
00D1 SGNZZ      00D2 SINZ       03B4 SIZCCP     95DF SIZE1      00EB SIZEZ      
03B6 SIZREC     03B8 SIZXPT     0396 SLSUBP     007B SMB        831E SMTSRT     
0020 SPACE      007E SPEED      0382 SPGMPT     00D3 SQRZ       A014 SQUISH     
8B96 SRDATA     8BBD SRDAZ0     8BB5 SRDAZ1     831C SREF       0082 SSEPZ      
039A SSTEMP     039C SSTMP2     8372 STACK      830A STADDR     0372 START      
00B2 STEPZ      83BD STKMAX     83AF STKMIN     8330 STLN       0098 STOPZ      
8302 STPT       831A STREND     00C7 STRINZ     8318 STRSP      0065 STRVAL     
00DB STRZZ      8324 STVSPT     921E SUBEOF     00A8 SUBNDZ     91CA SUBREC     
833A SUBTAB     00A7 SUBXTZ     00A1 SUBZ       007A SYM        0376 SYMBOL     
833E SYMTAB     0000 SYNCHK     0392 TABSAV     00FC TABZ       00D4 TANZ       
8366 TEMP5      00B0 THENZ      8379 TIMER      0034 TONE1      0036 TONE2      
6030 TOPL02     601A TOPL10     6012 TOPL15     8310 TOPSTK     00B1 TOZ        
CE1F TRACBK     0090 TRACEZ     0083 TREMZ      83C5 TSTINT     9627 TSTSEP     
9631 TSTSZ0     9659 TSTSZ1     00EA UALPHZ     A020 UBSUB      008F UNBREZ     
00C8 UNQSTZ     0091 UNTRAZ     000B UPARR      00F8 UPDATZ     000B UPMV       
83CF USING      00ED USINGZ     8452 USNGZ0     845E USNGZ1     8478 USNGZ3     
8493 USNGZ4     8533 USNGZ5     85C3 USNGZ9     84E9 USNZ42     8564 USNZ55     
85AA USNZ67     85BE USNZ68     85D3 USNZ95     00DA VAL        A016 VALCD      
03B2 VALIDL     03B0 VALIDP     00FE VALIDZ     8300 VAR0       830E VAR4       
8310 VAR5       8311 VAR6       8316 VAR9       832A VARA       8308 VARC       
00F3 VARIAZ     8301 VARV       8320 VARW       8304 VARY       8306 VARY2      
837B VDPSTS     008A VGWITE     89C4 VLIDZ0     0078 VPOP       0077 VPUSH      
0958 VRAMVS     03C0 VROAZ      8E69 VSAVZ      001C VWIDTH     00A6 WARNZ      
6A82 WARNZZ     87BB WRNINP     97B3 WRNIO      822C WRNNPP     8AF8 WRNSNM     
87BF WRZZ5      0073 XCNS       8316 XFLAG      00BC XORZ       8364 XSTLN      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0077 
FLMGR-359
Symbol Table #2 (New,value)  
0000 CZOPEN     0000 NUMBR      0000 SYNCHK     0001 CZCLOS     0001 FILSPC     
0002 BREAK      0002 CSTRIN     0002 CZREAD     0002 FIL        0002 LISTZ      
0003 CZWRIT     0003 DLETE      0003 OFS        0003 SEETWO     0004 COD        
0004 CZREST     0004 INSRT      0005 CZLOAD     0005 FLG        0005 OLDZ       
0006 BUF        0006 CZSAVE     0006 RECALL     0006 RESEQZ     0007 CLRLN      
0007 CZDELE     0007 SAVEZ      0008 BACK       0008 CZSCR      0008 LEN        
0008 MERGEZ     0009 CNT        0009 CZSTAT     0009 FORW       000A DOWN       
000A DWNARR     000A RNM        000B UPARR      000B UPMV       000C SCR        
000D CHRTN      000D NLEN       000E PABLEN     0010 CALDSR     0012 CFI        
0018 CHAR2Z     001C VWIDTH     0020 BKGD       0020 SPACE      0022 ATNZZ      
0022 QUOTE      0024 DOLLAR     002C COMMA      002D MINUS      0034 TONE1      
0036 TONE2      004A CHAR3Z     0060 OFFSET     0065 STRVAL     0070 COMPCT     
0071 GETSTR     0072 MEMCHK     0073 XCNS       0074 PARSE      0075 CONT       
0077 VPUSH      0078 VPOP       0079 PGMCHR     007A SYM        007B SMB        
007C ASSGNV     007D SCHSYM     007E CURSOR     007E SPEED      007F CRUNCH     
007F EDGECH     0080 CIF        0081 CONTIN     0081 ELSEZ      0082 SSEPZ      
0083 SCROLL     0083 TREMZ      0084 IFZ        0084 IO         0085 GOZ        
0085 GREAD      0086 GOTOZ      0086 GWRITE     0087 DELREP     0087 GOSUBZ     
0088 MVDN       0088 RETURZ     0089 DEFZ       0089 MVUP       008A DIMZ       
008A VGWITE     008B ENDZ       008B GVWITE     008C FORZ       008C GREAD1     
008D LETZ       008E BREAKZ     008E GDTECT     008F SCNSMT     008F UNBREZ     
0090 TRACEZ     0091 UNTRAZ     0092 INPUTZ     0093 DATAZ      0094 RESTOZ     
0095 RANDOZ     0096 NEXTZ      0097 READZ      0098 STOPZ      0099 DELETZ     
009A REMZ       009B ONZ        009C PRINTZ     009D CALLZ      009E OPTIOZ     
009F OPENZ      00A0 CLOSEZ     00A1 SUBZ       00A2 DISPLZ     00A3 IMAGEZ     
00A4 ACCEPZ     00A5 ERRORZ     00A6 WARNZ      00A7 SUBXTZ     00A8 SUBNDZ     
00A9 RUNZ       00AA LINPUZ     00B0 THENZ      00B1 TOZ        00B2 STEPZ      
00B3 COMMAZ     00B4 SEMICZ     00B5 COLONZ     00B6 RPARZ      00B7 LPARZ      
00B8 CONCZ      00BA ORZ        00BB ANDZ       00BC XORZ       00BD NOTZ       
00BE EQUALZ     00BF LESSZ      00C0 GREATZ     00C1 PLUSZ      00C2 MINUSZ     
00C3 MULTZ      00C4 DIVIZ      00C5 CIRCUZ     00C7 STRINZ     00C8 NUMCOZ     
00C8 NUMZ       00C8 UNQSTZ     00C9 LNZ        00CB ABSZ       00CC ATNZ       
00CD COSZ       00CE EXPZZ      00CF INTZ       00D0 LOGZ       00D1 SGNZZ      
00D2 SINZ       00D3 SQRZ       00D4 TANZ       00D5 LENZ       00D6 CHRZZ      
00D7 RNDZ       00D8 SEGZZ      00D9 POSZ       00DA VAL        00DB STRZZ      
00DC ASCZ       00DD PIZ        00DE RECZ       00DF MAXZ       00E0 MINZ       
00E1 RPTZZ      00E8 NUMERZ     00E9 DIGITZ     00EA UALPHZ     00EB SIZEZ      
00EC ALLZ       00ED USINGZ     00EE BEEPZ      00EF ERASEZ     00F0 ATZ        
00F1 BASEZ      00F3 VARIAZ     00F4 RELATZ     00F5 INTERZ     00F6 SEQUEZ     
00F7 OUTPUZ     00F8 UPDATZ     00F9 APPENZ     00FA FIXEDZ     00FB PERMAZ     
00FC TABZ       00FD NUMBEZ     00FE VALIDZ     02E0 SCRNBS     02E2 NLNADD     
02FE ENDSCR     0371 LODFLG     0372 START      0374 NOTONE     0376 SYMBOL     
0382 SPGMPT     0384 SBUFLV     0386 SEXTRM     0388 SAVEVP     038A ERRLN      
038C BUFSRT     038E BUFEND     0390 CSNTMP     0392 TABSAV     0394 AUTTMP     
0396 SLSUBP     0398 SFLAG      039A SSTEMP     039C SSTMP2     039E MRGPAB     
03AA INPUTP     03AC ACCVRW     03AE ACCVRA     03B0 VALIDP     03B2 VALIDL     
03B4 SIZCCP     03B6 SIZREC     03B7 ACCTRY     03B7 PSCFG      03B8 SIZXPT     
03B9 SAPROT     03BA CSNTP1     03BB CONFLG     03BC CPTEMP     03BC OLDTOP     
03BE NEWTOP     03C0 VROAZ      0820 CRNBUF     08BE CRNEND     08C0 RECBUF     
0958 VRAMVS     6012 TOPL15     6014 INITPG     601A TOPL10     6022 KILSYM     
602E AUTO1      6030 TOPL02     6032 EDITLN     6036 GWSUB      6038 MZMSG      
6053 MSGTA      6A74 LLIST      6A76 READLN     6A82 WARNZZ     6A84 ERRZ       
6A84 ERRZZ      6A86 READL1     76EB EDTZZ0     76F7 EDTZ00     7795 SAVLIN     
7A06 GTLIST     8032 OPEN       8045 OPTION     8047 OPTIZ0     804C OPTIZ1     
8072 OPTZ0      807C OPTZ02     8081 OPTZ1      809F CHKPAR     80A8 OPTZ2      
80AD OPTZ3      80B7 OPTZ4      80BE OPTZ01     80C3 OPTZ5      80DB OPTZ55     
80E5 OPTZ03     80EA OPTZ6      80F4 OPTZ7      80FB CLRFRE     8106 OPERR      
8109 ERRSYN     810D CHECK      8120 FILZZ      8125 G8125      8127 G8127      
8131 G8131      8157 G8157      815A G815A      8165 G8165      8169 G8169      
817C DELET      8196 CLOSE      81B8 G81B8      81C7 CLOSZ1     81DD G81DD      
81E1 CLSAZ0     81E9 CLSLBL     81F4 CLSALL     81FC RESTOR     821F OLDCD      
8227 OLDCZ0     822C WRNNPP     8233 G8233      823A OLDCZ1     824E G824E      
8257 DISPL1     8266 PRINT      8288 G8288      8293 G8293      82A5 PRNZ10     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0078 
FLMGR-359
82B1 PRINZ0     82BE G82BE      82C4 PRINZ1     82C9 CONPRT     82EC G82EC      
8300 VAR0       8301 VARV       8302 AAA1       8302 ACCUM      8302 MNUM       
8302 STPT       8303 OTHEZ1     8304 PABPTR     8304 VARY       8306 CCPPTR     
8306 DFLTLM     8306 VARY2      8307 RECLEN     8308 CCC1       8308 CCPADD     
8308 CCPADR     8308 OTHEZ0     8308 VARC       830A CALIST     830A RAMPTR     
830A STADDR     830C BBB1       830C BYTES      830C NMPTR      830D G830D      
830E CHSAV      830E CURINC     830E VAR4       8310 TOPSTK     8310 VAR5       
8311 VAR6       8312 LINUM      8314 CURLIN     8314 NMLEN      8316 VAR9       
8316 XFLAG      8317 DSRFLG     8317 FNUM       8317 FORNET     8317 OPTFLG     
8318 STRSP      831A STREND     831C SREF       831E SMTSRT     8320 VARW       
8322 ERRCOD     8324 STVSPT     8326 RTNG       8328 CHKSEP     8328 NUDTAB     
832A VARA       832C PGMPTR     832D PRTAB      832E EXTRAM     8330 STLN       
8332 ENLN       8334 DATA       8336 LNBUF      8338 INTRIN     833A SUBTAB     
833C IOSTRT     833E SYMTAB     8340 FREPTR     8342 CHAT       8343 BASE       
8344 PRGFLG     8345 FLAG       8346 BUFLEV     8348 LSUBP      834B FAC1       
834C AAA        834C FAC2       834D FAC3       834E CCC        834E FAC4       
834E FFF        834F FAC5       834F G834F      8350 BBB        8350 EEE        
8350 FAC6       8351 FAC7       8352 FAC8       8353 FAC9       8354 DDD1       
8354 FAC10      8355 FAC11      8356 FAC12      8356 FFF1       8357 FAC13      
8358 EEE1       8358 FAC14      8359 FAC15      835A FAC16      835B FAC17      
835C PRTCOM     835D ARG1       835E ARG2       835F ARG3       8360 ARG4       
8361 ARG5       8362 ARG6       8363 ARG7       8364 ARG8       8364 XSTLN      
8366 TEMP5      8367 ARG11      836B ARG15      836C ARG16      8370 HIVDP      
8372 STACK      8374 KEYBD      8375 RKEY       8376 EXPZ       8377 PRCOL      
8378 RANDOM     8379 TIMER      837A MOTION     837A PRSEM      837B VDPSTS     
837C ERCODE     8381 PRSMZ1     8384 RAMTOP     8386 RAMFRE     8388 RSTK       
8389 RAMFLG     8395 EOLEX      83A1 G83A1      83A4 PREXIT     83AF STKMIN     
83B1 G83B1      83BB G83BB      83BD STKMAX     83C3 G83C3      83C5 TSTINT     
83CE PRTNFN     83CF USING      8423 G8423      842E G842E      8430 G8430      
8438 G8438      8448 G8448      8452 USNGZ0     845E USNGZ1     8460 G8460      
8463 G8463      8478 USNGZ3     8493 USNGZ4     84A2 G84A2      84C3 G84C3      
84DB G84DB      84E9 USNZ42     851B G851B      8527 G8527      8533 USNGZ5     
8540 G8540      8562 G8562      8564 USNZ55     8570 G8570      857C G857C      
8581 G8581      8596 G8596      85A4 G85A4      85AA USNZ67     85B1 G85B1      
85BE USNZ68     85C3 USNGZ9     85D3 USNZ95     85E5 ACCNM      85F0 INPUT      
860B G860B      861B INTRZ0     861E G861E      862D INTRZ1     8643 G8643      
8650 G8650      8661 G8661      867C G867C      867E G867E      869F INTRZ2     
86AB G86AB      86AD G86AD      86C6 G86C6      86CC INPZ3      86DB G86DB      
86E9 INPZ31     8728 INPZ32     872E G872E      873A G873A      8752 G8752      
875A G875A      8765 INPZ33     8768 INPZ2      876B INPUZ3     8786 G8786      
8790 INPUZ4     87B4 INPUZ5     87BB WRNINP     87BF WRZZ5      87CF G87CF      
87D4 INPUZ6     87E6 G87E6      87EA G87EA      87F6 INPZ65     880F G880F      
8818 INPZ67     8822 INPUZ7     8827 RECENT     8834 CHKRM      883A SCRZ       
8840 G8840      8841 LINPUT     885C G885C      885F LINP10     887B G887B      
8885 G8885      8893 G8893      88AF G88AF      88BF G88BF      88D8 G88D8      
88DC G88DC      88E1 G88E1      88E8 INSU1      8906 INSUB1     890B G890B      
8927 INPZ37     892D INPUZ2     8936 INPZ39     893B INSUB2     8941 G8941      
895A G895A      896B ACCEPT     898B G898B      89A2 SETVW      89AA G89AA      
89C0 G89C0      89C4 VLIDZ0     89E0 G89E0      89F3 G89F3      89FD G89FD      
8A13 G8A13      8A23 G8A23      8A33 G8A33      8A35 G8A35      8A47 ACCPZ1     
8A4F ACCPZ9     8A58 G8A58      8A66 G8A66      8A74 ACCPZ7     8A7C ACCPZ5     
8A86 AZ1        8A8F ACCPZ2     8A9E G8A9E      8AB2 G8AB2      8AB7 G8AB7      
8AC4 G8AC4      8AC8 G8AC8      8ACB ACCPZ3     8ADC G8ADC      8AEB G8AEB      
8AF8 WRNSNM     8AFC ACCPZ8     8B0A G8B0A      8B20 G8B20      8B2A ACCPZ6     
8B36 ACCPZ4     8B38 G8B38      8B3A READ       8B6B G8B6B      8B73 G8B73      
8B8F G8B8F      8B96 SRDATA     8B99 SEARCH     8BB3 G8BB3      8BB5 SRDAZ1     
8BBD SRDAZ0     8BC4 OLD        8BCA OLD1       8C15 G8C15      8C17 G8C17      
8C32 OLDZ5      8C5A OLDZ7      8C63 OLDZ3      8CBD G8CBD      8CBF G8CBF      
8CDE OLZZ       8CE9 G8CE9      8D16 OLDZ9      8D24 PAB3       8D2D OLDER      
8D32 LRTOPZ     8D36 RELOCA     8D6F G8D6F      8D7E G8D7E      8D8E OLDZ2      
8DAB G8DAB      8DAF G8DAF      8DB3 RELOZ1     8DB8 SAVE       8DF4 G8DF4      
8E2B SAZ1       8E33 G8E33      8E42 G8E42      8E69 VSAVZ      8E91 G8E91      
8EAD G8EAD      8EB1 LRTOPL     8EB7 GSAVE      8EFB G8EFB      8F1C G8F1C      
8F44 GSAV1      8F4A GVMOV      8F76 SAVMG      8F88 G8F88      8FB6 G8FB6      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0079 
FLMGR-359
8FCD G8FCD      8FF9 PAB1       9002 MERGE      902A G902A      905B MERGZ1     
9068 LIST       908D LISTZ0     9094 G9094      9098 G9098      90A6 G90A6      
90AE G90AE      90CA G90CA      90FB LISTZ1     9128 G9128      912D G912D      
9132 G9132      9138 G9138      9140 G9140      914B LISTZ5     914E LISTZ3     
9156 G9156      915F LISTZ4     916D G916D      9170 PAB        9179 GRMLST     
91A4 GRSUB2     91AA GRSUB4     91B7 G91B7      91BB G91BB      91BC GRSUB3     
91CA SUBREC     91DE EOF        9210 G9210      9212 EOFZ2      9216 FLOAT1     
921E SUBEOF     9235 GPNAME     9242 G9242      9275 G9275      9284 G9284      
928A GETVAR     9292 GETVZ0     929B GETVZ1     92A2 G92A2      92B2 G92B2      
92B6 G92B6      92CC GETVZ2     92CD CTSTR      92D1 CTSTR0     92DE CTMPST     
92EB G92EB      92EC CHKNUM     9303 G9303      9304 GETGFL     9308 GETDAT     
930C GETRAM     9314 G9314      9320 G9320      9323 CHKSTR     932F CHKSZ0     
933E EMPSTR     9348 G9348      934B DATEND     9355 CHKFN      935C CHKCNV     
9371 CHKCON     937B CHKFZ1     938C RTC        938F G938F      9390 OUTEOF     
93A5 G93A5      93A6 DELPAB     93C2 G93C2      93CE G93CE      93E0 G93E0      
93E6 G93E6      93F4 G93F4      93F7 G93F7      9400 G9400      9411 G9411      
9418 G9418      942C G942C      9431 G9431      9440 DELPZ1     944C DELPZ2     
9451 G9451      946B G946B      9483 G9483      9495 G9495      949B G949B      
94B4 G94B4      94B8 CNVDEF     94C1 CNVDZ0     94C2 PARREC     94EE G94EE      
94EF DISACC     94F2 DISPZ1     9513 G9513      9518 G9518      9529 G9529      
9571 G9571      958F G958F      95A0 G95A0      95AD CHKEND     95B7 G95B7      
95B9 G95B9      95BA NXTCHR     95C9 NXTCZ0     95D5 G95D5      95DC G95DC      
95DF SIZE1      95FC G95FC      960B RSTRING    961A COMMOD     9624 G9624      
9627 TSTSEP     9631 TSTSZ0     964F G964F      9659 TSTSZ1     965A PARFN      
96A5 OUTREC     96C8 INITZ1     96CC SCRO       96D3 G96D3      96E2 G96E2      
96F5 PRINIT     9701 PRZZ0      970E OSTRNG     9711 G9711      9715 CHKREC     
9718 CHKRZ0     9730 G9730      9733 CHKRZ1     973E G973E      973F INITKB     
9751 G9751      9754 INTKB0     975E IOCALL     9765 IOCLZ1     976B CDSR       
9793 CDSRZ0     9794 ERRZ2B     9797 ERRZ2      97A9 G97A9      97B3 WRNIO      
97B8 G97B8      97BB ERRIO      97BF ERRSNM     97C3 ERRIM      97C7 ERRMEM     
97CB ERRBV      97CF ERRINP     97D3 ERRDAT     97D7 ERRFE      97DB ERRPV      
97DF ERRMUV     97E3 BUG01      97ED GTLENG     9800 ALCEND     9CEA CHARS      
9F7C CIV254     A002 LITS05     A004 EXEC       A006 LINE       A008 DATAST     
A00A ASC        A00C EXEC1      A00E EXEC6D     A010 DELINK     A012 CONVER     
A014 SQUISH     A016 VALCD      A018 INTRND     A020 UBSUB      A026 LINK1      
A040 CPUBAS     CB00 KEYTAB     CD77 ERRTAB     CE1F TRACBK     CF68 RETNOS     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0080 
FLMGR-359
Symbol Table #4 (Def,alpha)  
0034 ACCTON     835C ARG        0032 ATN        0036 BADTON     003B BITREV     
0012 CFI        0014 CNS        002C COS        0010 CSN        8372 DATSTK     
0001 DIVZER     0003 ERRIOV     0006 ERRLOG     0005 ERRNIP     0002 ERRSNN     
0004 ERRSQR     0028 EXP        834A FAC        0006 FADD       000A FCOMP      
0009 FDIV       0008 FMUL       836C FPERAD     0007 FSUB       0038 GETSPACE   
0022 INT        0010 LINK       0018 LOCASE     002A LOG        8370 MEMSIZ     
003D NAMLNK     8300 PAD        0024 PWR        0012 RETURN     000B SADD       
000F SCOMP      000E SDIV       8375 SGN        002E SIN        000D SMUL       
8400 SOUND      0026 SQR        000C SSUB       837C STATUS     0016 STCASE     
8373 SUBSTK     0030 TAN        0007 TRIGER     004A UPCASE     836E VSPTR      
0001 WRNOV      837F XPT        837E YPT        

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0081 
FLMGR-359
Symbol Table #8 (Def,value)  
0001 DIVZER     0001 WRNOV      0002 ERRSNN     0003 ERRIOV     0004 ERRSQR     
0005 ERRNIP     0006 ERRLOG     0006 FADD       0007 FSUB       0007 TRIGER     
0008 FMUL       0009 FDIV       000A FCOMP      000B SADD       000C SSUB       
000D SMUL       000E SDIV       000F SCOMP      0010 CSN        0010 LINK       
0012 CFI        0012 RETURN     0014 CNS        0016 STCASE     0018 LOCASE     
0022 INT        0024 PWR        0026 SQR        0028 EXP        002A LOG        
002C COS        002E SIN        0030 TAN        0032 ATN        0034 ACCTON     
0036 BADTON     0038 GETSPACE   003B BITREV     003D NAMLNK     004A UPCASE     
8300 PAD        834A FAC        835C ARG        836C FPERAD     836E VSPTR      
8370 MEMSIZ     8372 DATSTK     8373 SUBSTK     8375 SGN        837C STATUS     
837E YPT        837F XPT        8400 SOUND      
